const $1L = { hi: 0, lo: 1 };
const $0L = { hi: 0, lo: 0 };
const $_22L = { hi: -1, lo: -22 };
const $22L = { hi: 0, lo: 22 };
const $37L = { hi: 0, lo: 37 };
const $1000000000000000000L = { hi: 232830643, lo: -1486618624 };
const $10L = { hi: 0, lo: 10 };
const $100L = { hi: 0, lo: 100 };
const $1000L = { hi: 0, lo: 1000 };
const $10000L = { hi: 0, lo: 10000 };
const $100000L = { hi: 0, lo: 100000 };
const $1000000L = { hi: 0, lo: 1000000 };
const $10000000L = { hi: 0, lo: 10000000 };
const $100000000L = { hi: 0, lo: 100000000 };
const $1000000000L = { hi: 0, lo: 1000000000 };
const $10000000000L = { hi: 2, lo: 1410065408 };
const $100000000000L = { hi: 23, lo: 1215752192 };
const $1000000000000L = { hi: 232, lo: -727379968 };
const $10000000000000L = { hi: 2328, lo: 1316134912 };
const $100000000000000L = { hi: 23283, lo: 276447232 };
const $1000000000000000L = { hi: 232830, lo: -1530494976 };
const $_1L = { hi: -1, lo: -1 };
const $_4503599627370496L = { hi: -1048576, lo: 0 };
const $9221120237041090561L = { hi: 2146959360, lo: 1 };
const $9218868437227405312L = { hi: 2146435072, lo: 0 };
const $2L = { hi: 0, lo: 2 };
class $PanicError extends Error {}
function $panic() {
  throw new $PanicError();
}
const Option$None$0$ = { $tag: 0 };
function Option$Some$0$(param0) {
  this._0 = param0;
}
Option$Some$0$.prototype.$tag = 1;
function $compare_int(a, b) {
  return (a >= b) - (a <= b);
}
const $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$1$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$1$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$1$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$1$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$1$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$1$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$1$.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$1$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$1$.prototype.$tag = 4;
function $bound_check(arr, index) {
  if (index < 0 || index >= arr.length) throw new Error("Index out of bounds");
}
function $make_array_len_and_init(a, b) {
  const arr = new Array(a);
  for (let i = 0; i < a; i++) {
    arr[i] = b;
  }
  return arr;
}
function Result$Err$2$(param0) {
  this._0 = param0;
}
Result$Err$2$.prototype.$tag = 0;
function Result$Ok$2$(param0) {
  this._0 = param0;
}
Result$Ok$2$.prototype.$tag = 1;
function Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError.prototype.$tag = 8;
function Error$moonbitlang$47$core$47$json$46$JsonDecodeError$46$JsonDecodeError(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$core$47$json$46$JsonDecodeError$46$JsonDecodeError.prototype.$tag = 7;
function Error$rami3l$47$cmark$47$cmark$46$FolderError$46$FolderError(param0) {
  this._0 = param0;
}
Error$rami3l$47$cmark$47$cmark$46$FolderError$46$FolderError.prototype.$tag = 6;
function Error$rami3l$47$js$45$ffi$47$js$46$Error_$46$Error_(param0) {
  this._0 = param0;
}
Error$rami3l$47$js$45$ffi$47$js$46$Error_$46$Error_.prototype.$tag = 5;
function Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidChar(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidChar.prototype.$tag = 4;
const Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof = { $tag: 3 };
function Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidNumber(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidNumber.prototype.$tag = 2;
function Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidIdentEscape(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidIdentEscape.prototype.$tag = 1;
function Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure.prototype.$tag = 0;
function Result$Err$3$(param0) {
  this._0 = param0;
}
Result$Err$3$.prototype.$tag = 0;
function Result$Ok$3$(param0) {
  this._0 = param0;
}
Result$Ok$3$.prototype.$tag = 1;
function Result$Err$4$(param0) {
  this._0 = param0;
}
Result$Err$4$.prototype.$tag = 0;
function Result$Ok$4$(param0) {
  this._0 = param0;
}
Result$Ok$4$.prototype.$tag = 1;
function Result$Err$5$(param0) {
  this._0 = param0;
}
Result$Err$5$.prototype.$tag = 0;
function Result$Ok$5$(param0) {
  this._0 = param0;
}
Result$Ok$5$.prototype.$tag = 1;
function Result$Err$6$(param0) {
  this._0 = param0;
}
Result$Err$6$.prototype.$tag = 0;
function Result$Ok$6$(param0) {
  this._0 = param0;
}
Result$Ok$6$.prototype.$tag = 1;
function Result$Err$7$(param0) {
  this._0 = param0;
}
Result$Err$7$.prototype.$tag = 0;
function Result$Ok$7$(param0) {
  this._0 = param0;
}
Result$Ok$7$.prototype.$tag = 1;
function Result$Err$8$(param0) {
  this._0 = param0;
}
Result$Err$8$.prototype.$tag = 0;
function Result$Ok$8$(param0) {
  this._0 = param0;
}
Result$Ok$8$.prototype.$tag = 1;
function Result$Err$9$(param0) {
  this._0 = param0;
}
Result$Err$9$.prototype.$tag = 0;
function Result$Ok$9$(param0) {
  this._0 = param0;
}
Result$Ok$9$.prototype.$tag = 1;
function Result$Err$10$(param0) {
  this._0 = param0;
}
Result$Err$10$.prototype.$tag = 0;
function Result$Ok$10$(param0) {
  this._0 = param0;
}
Result$Ok$10$.prototype.$tag = 1;
function Result$Err$11$(param0) {
  this._0 = param0;
}
Result$Err$11$.prototype.$tag = 0;
function Result$Ok$11$(param0) {
  this._0 = param0;
}
Result$Ok$11$.prototype.$tag = 1;
function Result$Err$12$(param0) {
  this._0 = param0;
}
Result$Err$12$.prototype.$tag = 0;
function Result$Ok$12$(param0) {
  this._0 = param0;
}
Result$Ok$12$.prototype.$tag = 1;
function Result$Err$13$(param0) {
  this._0 = param0;
}
Result$Err$13$.prototype.$tag = 0;
function Result$Ok$13$(param0) {
  this._0 = param0;
}
Result$Ok$13$.prototype.$tag = 1;
function Result$Err$14$(param0) {
  this._0 = param0;
}
Result$Err$14$.prototype.$tag = 0;
function Result$Ok$14$(param0) {
  this._0 = param0;
}
Result$Ok$14$.prototype.$tag = 1;
function Result$Err$15$(param0) {
  this._0 = param0;
}
Result$Err$15$.prototype.$tag = 0;
function Result$Ok$15$(param0) {
  this._0 = param0;
}
Result$Ok$15$.prototype.$tag = 1;
function Result$Err$16$(param0) {
  this._0 = param0;
}
Result$Err$16$.prototype.$tag = 0;
function Result$Ok$16$(param0) {
  this._0 = param0;
}
Result$Ok$16$.prototype.$tag = 1;
function Result$Err$17$(param0) {
  this._0 = param0;
}
Result$Err$17$.prototype.$tag = 0;
function Result$Ok$17$(param0) {
  this._0 = param0;
}
Result$Ok$17$.prototype.$tag = 1;
function Result$Err$18$(param0) {
  this._0 = param0;
}
Result$Err$18$.prototype.$tag = 0;
function Result$Ok$18$(param0) {
  this._0 = param0;
}
Result$Ok$18$.prototype.$tag = 1;
function Result$Err$19$(param0) {
  this._0 = param0;
}
Result$Err$19$.prototype.$tag = 0;
function Result$Ok$19$(param0) {
  this._0 = param0;
}
Result$Ok$19$.prototype.$tag = 1;
function Result$Err$20$(param0) {
  this._0 = param0;
}
Result$Err$20$.prototype.$tag = 0;
function Result$Ok$20$(param0) {
  this._0 = param0;
}
Result$Ok$20$.prototype.$tag = 1;
function Result$Err$21$(param0) {
  this._0 = param0;
}
Result$Err$21$.prototype.$tag = 0;
function Result$Ok$21$(param0) {
  this._0 = param0;
}
Result$Ok$21$.prototype.$tag = 1;
function Result$Err$22$(param0) {
  this._0 = param0;
}
Result$Err$22$.prototype.$tag = 0;
function Result$Ok$22$(param0) {
  this._0 = param0;
}
Result$Ok$22$.prototype.$tag = 1;
function Result$Err$23$(param0) {
  this._0 = param0;
}
Result$Err$23$.prototype.$tag = 0;
function Result$Ok$23$(param0) {
  this._0 = param0;
}
Result$Ok$23$.prototype.$tag = 1;
function Result$Err$24$(param0) {
  this._0 = param0;
}
Result$Err$24$.prototype.$tag = 0;
function Result$Ok$24$(param0) {
  this._0 = param0;
}
Result$Ok$24$.prototype.$tag = 1;
function Result$Err$25$(param0) {
  this._0 = param0;
}
Result$Err$25$.prototype.$tag = 0;
function Result$Ok$25$(param0) {
  this._0 = param0;
}
Result$Ok$25$.prototype.$tag = 1;
function Result$Err$26$(param0) {
  this._0 = param0;
}
Result$Err$26$.prototype.$tag = 0;
function Result$Ok$26$(param0) {
  this._0 = param0;
}
Result$Ok$26$.prototype.$tag = 1;
function Result$Err$27$(param0) {
  this._0 = param0;
}
Result$Err$27$.prototype.$tag = 0;
function Result$Ok$27$(param0) {
  this._0 = param0;
}
Result$Ok$27$.prototype.$tag = 1;
function Result$Err$28$(param0) {
  this._0 = param0;
}
Result$Err$28$.prototype.$tag = 0;
function Result$Ok$28$(param0) {
  this._0 = param0;
}
Result$Ok$28$.prototype.$tag = 1;
function Result$Err$29$(param0) {
  this._0 = param0;
}
Result$Err$29$.prototype.$tag = 0;
function Result$Ok$29$(param0) {
  this._0 = param0;
}
Result$Ok$29$.prototype.$tag = 1;
function Result$Err$30$(param0) {
  this._0 = param0;
}
Result$Err$30$.prototype.$tag = 0;
function Result$Ok$30$(param0) {
  this._0 = param0;
}
Result$Ok$30$.prototype.$tag = 1;
function Result$Err$31$(param0) {
  this._0 = param0;
}
Result$Err$31$.prototype.$tag = 0;
function Result$Ok$31$(param0) {
  this._0 = param0;
}
Result$Ok$31$.prototype.$tag = 1;
function Result$Err$32$(param0) {
  this._0 = param0;
}
Result$Err$32$.prototype.$tag = 0;
function Result$Ok$32$(param0) {
  this._0 = param0;
}
Result$Ok$32$.prototype.$tag = 1;
const moonbitlang$core$builtin$$JSArray$push = (arr, val) => { arr.push(val); };
const Option$None$33$ = { $tag: 0 };
function Option$Some$33$(param0) {
  this._0 = param0;
}
Option$Some$33$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$34$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$34$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$34$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$34$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$34$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$34$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$34$.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$34$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$34$.prototype.$tag = 4;
const $64$moonbitlang$47$core$47$builtin$46$Json$Null = { $tag: 0 };
const $64$moonbitlang$47$core$47$builtin$46$Json$True = { $tag: 1 };
const $64$moonbitlang$47$core$47$builtin$46$Json$False = { $tag: 2 };
function $64$moonbitlang$47$core$47$builtin$46$Json$Number(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$Number.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$Json$String(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$String.prototype.$tag = 4;
function $64$moonbitlang$47$core$47$builtin$46$Json$Array(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$Array.prototype.$tag = 5;
function $64$moonbitlang$47$core$47$builtin$46$Json$Object(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$Object.prototype.$tag = 6;
const moonbitlang$core$builtin$$JSArray$pop = (arr) => arr.pop();
const moonbitlang$core$builtin$$JSArray$splice = (arr, idx, cnt) => arr.splice(idx, cnt);
const moonbitlang$core$builtin$$MyInt64$convert_to_double_u = (a) => (a.hi >>> 0) * 4294967296.0 + (a.lo >>> 0);
const moonbitlang$core$builtin$$MyInt64$reinterpret_as_double = function f(a) {
  let view = f._view;
  if (view === undefined) {
    view = f._view = new DataView(new ArrayBuffer(8));
  }
  view.setUint32(0, a.hi);
  view.setUint32(4, a.lo);
  return view.getFloat64(0);
};
const moonbitlang$core$builtin$$get_int64_wasm_helper = function f() {
  if (f._exports) return f._exports;
  return f._exports = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
};
const moonbitlang$core$builtin$$MyInt64$compare = (a, b) => {
  const ahi = a.hi;
  const bhi = b.hi;
  if (ahi < bhi) {
    return -1;
  }
  if (ahi > bhi) {
    return 1;
  }
  const alo = a.lo >>> 0;
  const blo = b.lo >>> 0;
  if (alo < blo) {
    return -1;
  }
  if (alo > blo) {
    return 1;
  }
  return 0;
};
const moonbitlang$core$builtin$$MyInt64$compare_u = (a, b) => {
  const ahi = a.hi >>> 0;
  const bhi = b.hi >>> 0;
  if (ahi < bhi) {
    return -1;
  }
  if (ahi > bhi) {
    return 1;
  }
  const alo = a.lo >>> 0;
  const blo = b.lo >>> 0;
  if (alo < blo) {
    return -1;
  }
  if (alo > blo) {
    return 1;
  }
  return 0;
};
function Result$Err$35$(param0) {
  this._0 = param0;
}
Result$Err$35$.prototype.$tag = 0;
function Result$Ok$35$(param0) {
  this._0 = param0;
}
Result$Ok$35$.prototype.$tag = 1;
function Result$Err$36$(param0) {
  this._0 = param0;
}
Result$Err$36$.prototype.$tag = 0;
function Result$Ok$36$(param0) {
  this._0 = param0;
}
Result$Ok$36$.prototype.$tag = 1;
function Result$Err$37$(param0) {
  this._0 = param0;
}
Result$Err$37$.prototype.$tag = 0;
function Result$Ok$37$(param0) {
  this._0 = param0;
}
Result$Ok$37$.prototype.$tag = 1;
function Result$Err$38$(param0) {
  this._0 = param0;
}
Result$Err$38$.prototype.$tag = 0;
function Result$Ok$38$(param0) {
  this._0 = param0;
}
Result$Ok$38$.prototype.$tag = 1;
function Result$Err$39$(param0) {
  this._0 = param0;
}
Result$Err$39$.prototype.$tag = 0;
function Result$Ok$39$(param0) {
  this._0 = param0;
}
Result$Ok$39$.prototype.$tag = 1;
function Result$Err$40$(param0) {
  this._0 = param0;
}
Result$Err$40$.prototype.$tag = 0;
function Result$Ok$40$(param0) {
  this._0 = param0;
}
Result$Ok$40$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$json$46$Token$Null = { $tag: 0 };
const $64$moonbitlang$47$core$47$json$46$Token$True = { $tag: 1 };
const $64$moonbitlang$47$core$47$json$46$Token$False = { $tag: 2 };
function $64$moonbitlang$47$core$47$json$46$Token$Number(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$json$46$Token$Number.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$json$46$Token$String(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$json$46$Token$String.prototype.$tag = 4;
const $64$moonbitlang$47$core$47$json$46$Token$LBrace = { $tag: 5 };
const $64$moonbitlang$47$core$47$json$46$Token$RBrace = { $tag: 6 };
const $64$moonbitlang$47$core$47$json$46$Token$LBracket = { $tag: 7 };
const $64$moonbitlang$47$core$47$json$46$Token$RBracket = { $tag: 8 };
const $64$moonbitlang$47$core$47$json$46$Token$Comma = { $tag: 9 };
const $64$moonbitlang$47$core$47$json$46$JsonPath$Root = { $tag: 0 };
function $64$moonbitlang$47$core$47$json$46$JsonPath$Key(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$json$46$JsonPath$Key.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$json$46$JsonPath$Index(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$json$46$JsonPath$Index.prototype.$tag = 2;
function Result$Err$41$(param0) {
  this._0 = param0;
}
Result$Err$41$.prototype.$tag = 0;
function Result$Ok$41$(param0) {
  this._0 = param0;
}
Result$Ok$41$.prototype.$tag = 1;
function Result$Err$42$(param0) {
  this._0 = param0;
}
Result$Err$42$.prototype.$tag = 0;
function Result$Ok$42$(param0) {
  this._0 = param0;
}
Result$Ok$42$.prototype.$tag = 1;
function Result$Err$43$(param0) {
  this._0 = param0;
}
Result$Err$43$.prototype.$tag = 0;
function Result$Ok$43$(param0) {
  this._0 = param0;
}
Result$Ok$43$.prototype.$tag = 1;
function Result$Err$44$(param0) {
  this._0 = param0;
}
Result$Err$44$.prototype.$tag = 0;
function Result$Ok$44$(param0) {
  this._0 = param0;
}
Result$Ok$44$.prototype.$tag = 1;
function Result$Err$45$(param0) {
  this._0 = param0;
}
Result$Err$45$.prototype.$tag = 0;
function Result$Ok$45$(param0) {
  this._0 = param0;
}
Result$Ok$45$.prototype.$tag = 1;
function Result$Err$46$(param0) {
  this._0 = param0;
}
Result$Err$46$.prototype.$tag = 0;
function Result$Ok$46$(param0) {
  this._0 = param0;
}
Result$Ok$46$.prototype.$tag = 1;
function Result$Err$47$(param0) {
  this._0 = param0;
}
Result$Err$47$.prototype.$tag = 0;
function Result$Ok$47$(param0) {
  this._0 = param0;
}
Result$Ok$47$.prototype.$tag = 1;
function Result$Err$48$(param0) {
  this._0 = param0;
}
Result$Err$48$.prototype.$tag = 0;
function Result$Ok$48$(param0) {
  this._0 = param0;
}
Result$Ok$48$.prototype.$tag = 1;
function Result$Err$49$(param0) {
  this._0 = param0;
}
Result$Err$49$.prototype.$tag = 0;
function Result$Ok$49$(param0) {
  this._0 = param0;
}
Result$Ok$49$.prototype.$tag = 1;
function Result$Err$50$(param0) {
  this._0 = param0;
}
Result$Err$50$.prototype.$tag = 0;
function Result$Ok$50$(param0) {
  this._0 = param0;
}
Result$Ok$50$.prototype.$tag = 1;
function Result$Err$51$(param0) {
  this._0 = param0;
}
Result$Err$51$.prototype.$tag = 0;
function Result$Ok$51$(param0) {
  this._0 = param0;
}
Result$Ok$51$.prototype.$tag = 1;
const $65536L = { hi: 0, lo: 65536 };
function Result$Err$52$(param0) {
  this._0 = param0;
}
Result$Err$52$.prototype.$tag = 0;
function Result$Ok$52$(param0) {
  this._0 = param0;
}
Result$Ok$52$.prototype.$tag = 1;
const Option$None$53$ = { $tag: 0 };
function Option$Some$53$(param0) {
  this._0 = param0;
}
Option$Some$53$.prototype.$tag = 1;
function Result$Err$54$(param0) {
  this._0 = param0;
}
Result$Err$54$.prototype.$tag = 0;
function Result$Ok$54$(param0) {
  this._0 = param0;
}
Result$Ok$54$.prototype.$tag = 1;
const $9223372036854775807L = { hi: 2147483647, lo: -1 };
const $16L = { hi: 0, lo: 16 };
const $_9223372036854775808L = { hi: -2147483648, lo: 0 };
const $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$55$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$55$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$55$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$56$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$56$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$56$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$57$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$57$(param0, param1, param2, param3, param4) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
}
$64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$57$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$58$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$60$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$60$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$60$.prototype.$tag = 1;
const $64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Http = { $tag: 0 };
const $64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Https = { $tag: 1 };
function $64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Other(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Other.prototype.$tag = 2;
function Result$Err$61$(param0) {
  this._0 = param0;
}
Result$Err$61$.prototype.$tag = 0;
function Result$Ok$61$(param0) {
  this._0 = param0;
}
Result$Ok$61$.prototype.$tag = 1;
const rami3l$js$45$ffi$js$$Value$undefined = () => undefined;
const rami3l$js$45$ffi$js$$Value$is_null = (n) => Object.is(n, null);
const Option$None$62$ = { $tag: 0 };
function Option$Some$62$(param0) {
  this._0 = param0;
}
Option$Some$62$.prototype.$tag = 1;
const Option$None$63$ = { $tag: 0 };
function Option$Some$63$(param0) {
  this._0 = param0;
}
Option$Some$63$.prototype.$tag = 1;
const Option$None$64$ = { $tag: 0 };
function Option$Some$64$(param0) {
  this._0 = param0;
}
Option$Some$64$.prototype.$tag = 1;
const Option$None$65$ = { $tag: 0 };
function Option$Some$65$(param0) {
  this._0 = param0;
}
Option$Some$65$.prototype.$tag = 1;
const Option$None$66$ = { $tag: 0 };
function Option$Some$66$(param0) {
  this._0 = param0;
}
Option$Some$66$.prototype.$tag = 1;
const Option$None$67$ = { $tag: 0 };
function Option$Some$67$(param0) {
  this._0 = param0;
}
Option$Some$67$.prototype.$tag = 1;
const Option$None$68$ = { $tag: 0 };
function Option$Some$68$(param0) {
  this._0 = param0;
}
Option$Some$68$.prototype.$tag = 1;
const Option$None$69$ = { $tag: 0 };
function Option$Some$69$(param0) {
  this._0 = param0;
}
Option$Some$69$.prototype.$tag = 1;
const rami3l$js$45$ffi$js$$Value$is_undefined = (n) => Object.is(n, undefined);
const rami3l$js$45$ffi$js$$Value$to_string = (self) => self.toString();
const rami3l$js$45$ffi$js$$Promise$wait_ffi = (self, on_ok, on_err) => self.then((t) => on_ok(t), (e) => on_err(e));
const rami3l$js$45$ffi$js$$Error_$cause_ffi = (self) => self.cause;
const Option$None$70$ = { $tag: 0 };
function Option$Some$70$(param0) {
  this._0 = param0;
}
Option$Some$70$.prototype.$tag = 1;
const Yoorkin$rabbit$45$tea$dom$$document = () => document;
const Yoorkin$rabbit$45$tea$dom$$Document$get_element_by_id = (doc,id) => doc.getElementById(id);
const Yoorkin$rabbit$45$tea$dom$$Document$create_element = (doc,tag) => doc.createElement(tag);
const Yoorkin$rabbit$45$tea$dom$$Document$create_text_node = (doc,str) => doc.createTextNode(str);
const Yoorkin$rabbit$45$tea$dom$$Node$to_element = (x) => x.nodeType===1 ? x : null;
const Yoorkin$rabbit$45$tea$dom$$Node$to_event_target = (x) => x;
const Yoorkin$rabbit$45$tea$dom$$Element$to_node = (x) => x;
const Yoorkin$rabbit$45$tea$dom$$EventTarget$to_node = (x) => x instanceof Node ? x : null;
const Yoorkin$rabbit$45$tea$dom$$EventTarget$add_event_listener = (target, type, listener) => target.addEventListener(type, listener);
const Yoorkin$rabbit$45$tea$dom$$EventTarget$remove_event_listener = (target, type, listener) => target.removeEventListener(type, listener);
const Yoorkin$rabbit$45$tea$dom$$Element$to_html_element = (x) => x instanceof HTMLElement ? x : null;
const Yoorkin$rabbit$45$tea$dom$$Element$append_children = (self, child) => self.append(child);
const Yoorkin$rabbit$45$tea$dom$$Element$set_attribute = (self,attr,value) => self.setAttribute(attr, value);
const Yoorkin$rabbit$45$tea$dom$$Element$remove_attribute = (self,attr) => self.removeAttribute(attr);
const Yoorkin$rabbit$45$tea$dom$$Element$set_property = (self,prop,value) => self[prop] = value;
const Yoorkin$rabbit$45$tea$dom$$Element$remove_property = (self,prop) => delete self[prop];
const Yoorkin$rabbit$45$tea$dom$$Element$get_property = (self,prop) => self[prop];
const Yoorkin$rabbit$45$tea$dom$$Element$scroll_into_view = (self) => self.scrollIntoView();
const Yoorkin$rabbit$45$tea$dom$$Element$set_inner_html = (self,html) => self.innerHTML = html;
const Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_input_element = (x) => x instanceof HTMLInputElement ? x : null;
const Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_select_element = (x) => x instanceof HTMLSelectElement ? x : null;
const Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_dialog_element = (x) => x instanceof HTMLDialogElement ? x : null;
const Yoorkin$rabbit$45$tea$dom$$HTMLElement$set_style = (self,key,value) => self.style[key] = value;
const Yoorkin$rabbit$45$tea$dom$$HTMLElement$remove_style = (self,key) => self.style[key] = '';
const Yoorkin$rabbit$45$tea$dom$$HTMLInputElement$value = (self) => self.value;
const Yoorkin$rabbit$45$tea$dom$$HTMLSelectElement$value = (self) => self.value;
const Yoorkin$rabbit$45$tea$dom$$HTMLDialogElement$return_value = (self) => self.returnValue;
const Yoorkin$rabbit$45$tea$dom$$HTMLDialogElement$close = (self,returnValue) => self.close(returnValue);
const Yoorkin$rabbit$45$tea$dom$$HTMLDialogElement$show = (self) => self.show();
const Yoorkin$rabbit$45$tea$dom$$HTMLDialogElement$show_modal = (self) => self.showModal();
const Yoorkin$rabbit$45$tea$dom$$Window$load_url = (self,url) => { self.location.href = url; };
const Yoorkin$rabbit$45$tea$dom$$Window$push_url = (self,url) => { self.history.pushState(null, '', url); };
const Yoorkin$rabbit$45$tea$dom$$Window$current_url = (self) => { return self.location.href; };
const Yoorkin$rabbit$45$tea$dom$$window = () => window;
const Yoorkin$rabbit$45$tea$dom$$Window$to_event_target = (x) => x;
const Yoorkin$rabbit$45$tea$dom$$Window$navigator = (self) => self.navigator;
const Yoorkin$rabbit$45$tea$dom$$Clipboard$write_text = (self,text) => self.writeText(text);
const Yoorkin$rabbit$45$tea$dom$$Navigator$clipboard = (self) => self.clipboard;
const Yoorkin$rabbit$45$tea$dom$$Event$target = (self) => self.target;
const Yoorkin$rabbit$45$tea$dom$$Event$to_ui_event = (x) => x instanceof UIEvent ? x : null;
const Yoorkin$rabbit$45$tea$dom$$Event$prevent_default = (self) => self.preventDefault();
const Yoorkin$rabbit$45$tea$dom$$Event$stop_propagation = (self) => self.stopPropagation();
const Yoorkin$rabbit$45$tea$dom$$UIEvent$to_mouse_event = (e) => e instanceof MouseEvent ? e : null;
const Yoorkin$rabbit$45$tea$dom$$Node$append_child = (p,c) => p.appendChild(c);
const Yoorkin$rabbit$45$tea$dom$$Node$remove_child = (p,c) => p.removeChild(c);
const Yoorkin$rabbit$45$tea$dom$$Node$replace_child = (p,n,o) => p.replaceChild(n,o);
const Yoorkin$rabbit$45$tea$dom$$Node$insert_before = (p,value,before) => p.insertBefore(value,before);
const Yoorkin$rabbit$45$tea$dom$$Node$nth_child = (x,i) => { 
   const r = x.childNodes[i]; 
   if (r === undefined) throw new Error(`nth_child: index ${i} out of bounds, length=${x.childNodes.length}`);
   return r;
 };
const Yoorkin$rabbit$45$tea$dom$$Node$count_child = (x) => x.childNodes.length;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Normal$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Normal$71$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$71$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Custom$71$(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Custom$71$.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$71$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrStyle$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrStyle$71$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$71$.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$71$.prototype.$tag = 3;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$71$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$71$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$ExternalNode$71$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$ExternalNode$71$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$71$.prototype.$tag = 2;
const $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Nothing$71$ = { $tag: 3 };
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$72$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$72$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$ExternalNode$72$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$ExternalNode$72$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$72$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$72$.prototype.$tag = 2;
const $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Nothing$72$ = { $tag: 3 };
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$73$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$73$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$ExternalNode$73$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$ExternalNode$73$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$73$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$73$.prototype.$tag = 2;
const $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Nothing$73$ = { $tag: 3 };
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$72$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$72$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrStyle$72$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrStyle$72$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$72$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$72$.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$72$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$72$.prototype.$tag = 3;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$73$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$73$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrStyle$73$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrStyle$73$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$73$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$73$.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$73$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$73$.prototype.$tag = 3;
function $64$Yoorkin$47$rabbit$45$tea$47$url$46$UrlRequest$Internal(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$url$46$UrlRequest$Internal.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$url$46$UrlRequest$External(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$url$46$UrlRequest$External.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrRemove$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrRemove$71$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrAdd$71$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrAdd$71$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleAdd$71$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleAdd$71$.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleRemove$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleRemove$71$.prototype.$tag = 3;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyAdd$71$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyAdd$71$.prototype.$tag = 4;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyRemove$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyRemove$71$.prototype.$tag = 5;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$EventRemove$71$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$EventRemove$71$.prototype.$tag = 6;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$EventAdd$71$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$EventAdd$71$.prototype.$tag = 7;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Drop$71$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Drop$71$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Remove$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Remove$71$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Replace$71$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Replace$71$.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$InsertBefore$71$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$InsertBefore$71$.prototype.$tag = 3;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Append$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Append$71$.prototype.$tag = 4;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Update$71$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Update$71$.prototype.$tag = 5;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateNode$71$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateNode$71$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateText$71$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateText$71$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Normal$73$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Normal$73$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$73$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$73$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Custom$73$(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Custom$73$.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Normal$72$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Normal$72$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$72$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$72$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Custom$72$(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Custom$72$.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Boolean(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Boolean.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Integer(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Integer.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Floating(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Floating.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$String(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$String.prototype.$tag = 3;
function Result$Err$74$(param0) {
  this._0 = param0;
}
Result$Err$74$.prototype.$tag = 0;
function Result$Ok$74$(param0) {
  this._0 = param0;
}
Result$Ok$74$.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark_base$46$NextLineResult$ThisLine(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark_base$46$NextLineResult$ThisLine.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark_base$46$NextLineResult$NextLine(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark_base$46$NextLineResult$NextLine.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark_base$46$LineType$AtxHeadingLine(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$rami3l$47$cmark$47$cmark_base$46$LineType$AtxHeadingLine.prototype.$tag = 0;
const $64$rami3l$47$cmark$47$cmark_base$46$LineType$BlankLine = { $tag: 1 };
const $64$rami3l$47$cmark$47$cmark_base$46$LineType$BlockQuoteLine = { $tag: 2 };
function $64$rami3l$47$cmark$47$cmark_base$46$LineType$FencedCodeBlockLine(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$rami3l$47$cmark$47$cmark_base$46$LineType$FencedCodeBlockLine.prototype.$tag = 3;
function $64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine.prototype.$tag = 4;
const $64$rami3l$47$cmark$47$cmark_base$46$LineType$IndentedCodeBlockLine = { $tag: 5 };
function $64$rami3l$47$cmark$47$cmark_base$46$LineType$ListMarkerLine(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark_base$46$LineType$ListMarkerLine.prototype.$tag = 6;
const $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine = { $tag: 7 };
function $64$rami3l$47$cmark$47$cmark_base$46$LineType$SetextUnderlineLine(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark_base$46$LineType$SetextUnderlineLine.prototype.$tag = 8;
function $64$rami3l$47$cmark$47$cmark_base$46$LineType$ThematicBreakLine(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark_base$46$LineType$ThematicBreakLine.prototype.$tag = 9;
function $64$rami3l$47$cmark$47$cmark_base$46$LineType$ExtTableRow(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark_base$46$LineType$ExtTableRow.prototype.$tag = 10;
function $64$rami3l$47$cmark$47$cmark_base$46$LineType$ExtFootnoteLabel(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$rami3l$47$cmark$47$cmark_base$46$LineType$ExtFootnoteLabel.prototype.$tag = 11;
const $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch = { $tag: 12 };
function $64$rami3l$47$cmark$47$cmark_base$46$FencedCodeBlockContinue$Close(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark_base$46$FencedCodeBlockContinue$Close.prototype.$tag = 0;
const $64$rami3l$47$cmark$47$cmark_base$46$FencedCodeBlockContinue$Code = { $tag: 1 };
function $64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndStr(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndStr.prototype.$tag = 0;
const $64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndCond1 = { $tag: 1 };
const $64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndBlank = { $tag: 2 };
const $64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndBlank7 = { $tag: 3 };
function $64$rami3l$47$cmark$47$cmark_base$46$ListType$Unordered(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark_base$46$ListType$Unordered.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark_base$46$ListType$Ordered(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark_base$46$ListType$Ordered.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$Block$BlankLine(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$BlankLine.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$Block$BlockQuote(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$BlockQuote.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$Block$Blocks(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$Blocks.prototype.$tag = 2;
function $64$rami3l$47$cmark$47$cmark$46$Block$CodeBlock(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$CodeBlock.prototype.$tag = 3;
function $64$rami3l$47$cmark$47$cmark$46$Block$Heading(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$Heading.prototype.$tag = 4;
function $64$rami3l$47$cmark$47$cmark$46$Block$HtmlBlock(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$HtmlBlock.prototype.$tag = 5;
function $64$rami3l$47$cmark$47$cmark$46$Block$LinkRefDefinition(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$LinkRefDefinition.prototype.$tag = 6;
function $64$rami3l$47$cmark$47$cmark$46$Block$List(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$List.prototype.$tag = 7;
function $64$rami3l$47$cmark$47$cmark$46$Block$Paragraph(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$Paragraph.prototype.$tag = 8;
function $64$rami3l$47$cmark$47$cmark$46$Block$ThematicBreak(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$ThematicBreak.prototype.$tag = 9;
function $64$rami3l$47$cmark$47$cmark$46$Block$ExtMathBlock(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$ExtMathBlock.prototype.$tag = 10;
function $64$rami3l$47$cmark$47$cmark$46$Block$ExtTable(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$ExtTable.prototype.$tag = 11;
function $64$rami3l$47$cmark$47$cmark$46$Block$ExtFootnoteDefinition(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Block$ExtFootnoteDefinition.prototype.$tag = 12;
function $64$rami3l$47$cmark$47$cmark$46$LabelDef$LinkDef(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$LabelDef$LinkDef.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$LabelDef$FootnoteDef(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$LabelDef$FootnoteDef.prototype.$tag = 1;
const Option$None$75$ = { $tag: 0 };
function Option$Some$75$(param0) {
  this._0 = param0;
}
Option$Some$75$.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$Closer$Backticks(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Closer$Backticks.prototype.$tag = 0;
const $64$rami3l$47$cmark$47$cmark$46$Closer$RightBrack = { $tag: 1 };
const $64$rami3l$47$cmark$47$cmark$46$Closer$RightParen = { $tag: 2 };
function $64$rami3l$47$cmark$47$cmark$46$Closer$EmphasisMarks(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Closer$EmphasisMarks.prototype.$tag = 3;
const $64$rami3l$47$cmark$47$cmark$46$Closer$StrikethroughMarks = { $tag: 4 };
function $64$rami3l$47$cmark$47$cmark$46$Closer$MathSpanMarks(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Closer$MathSpanMarks.prototype.$tag = 5;
function $64$rami3l$47$cmark$47$cmark$46$Token$AutolinkOrHtmlStart(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Token$AutolinkOrHtmlStart.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$Token$Backticks(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Token$Backticks.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$Token$EmphasisMarks(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Token$EmphasisMarks.prototype.$tag = 2;
function $64$rami3l$47$cmark$47$cmark$46$Token$Inline(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Token$Inline.prototype.$tag = 3;
function $64$rami3l$47$cmark$47$cmark$46$Token$LinkStart(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Token$LinkStart.prototype.$tag = 4;
function $64$rami3l$47$cmark$47$cmark$46$Token$Newline(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Token$Newline.prototype.$tag = 5;
function $64$rami3l$47$cmark$47$cmark$46$Token$RightBrack(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Token$RightBrack.prototype.$tag = 6;
function $64$rami3l$47$cmark$47$cmark$46$Token$RightParen(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Token$RightParen.prototype.$tag = 7;
function $64$rami3l$47$cmark$47$cmark$46$Token$StrikethroughMarks(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Token$StrikethroughMarks.prototype.$tag = 8;
function $64$rami3l$47$cmark$47$cmark$46$Token$MathSpanMarks(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Token$MathSpanMarks.prototype.$tag = 9;
function $64$rami3l$47$cmark$47$cmark$46$Inline$Autolink(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$Autolink.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$Inline$Break(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$Break.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$Inline$CodeSpan(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$CodeSpan.prototype.$tag = 2;
function $64$rami3l$47$cmark$47$cmark$46$Inline$Emphasis(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$Emphasis.prototype.$tag = 3;
function $64$rami3l$47$cmark$47$cmark$46$Inline$Image(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$Image.prototype.$tag = 4;
function $64$rami3l$47$cmark$47$cmark$46$Inline$Inlines(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$Inlines.prototype.$tag = 5;
function $64$rami3l$47$cmark$47$cmark$46$Inline$Link(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$Link.prototype.$tag = 6;
function $64$rami3l$47$cmark$47$cmark$46$Inline$RawHtml(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$RawHtml.prototype.$tag = 7;
function $64$rami3l$47$cmark$47$cmark$46$Inline$StrongEmphasis(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$StrongEmphasis.prototype.$tag = 8;
function $64$rami3l$47$cmark$47$cmark$46$Inline$Text(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$Text.prototype.$tag = 9;
function $64$rami3l$47$cmark$47$cmark$46$Inline$ExtStrikethrough(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$ExtStrikethrough.prototype.$tag = 10;
function $64$rami3l$47$cmark$47$cmark$46$Inline$ExtMathSpan(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Inline$ExtMathSpan.prototype.$tag = 11;
function $64$rami3l$47$cmark$47$cmark$46$LabelContext$Def(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark$46$LabelContext$Def.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$LabelContext$Ref(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$rami3l$47$cmark$47$cmark$46$LabelContext$Ref.prototype.$tag = 1;
const Option$None$76$ = { $tag: 0 };
function Option$Some$76$(param0) {
  this._0 = param0;
}
Option$Some$76$.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$ReferenceKind$Inline(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$ReferenceKind$Inline.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$ReferenceKind$Ref(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$rami3l$47$cmark$47$cmark$46$ReferenceKind$Ref.prototype.$tag = 1;
const Option$None$77$ = { $tag: 0 };
function Option$Some$77$(param0) {
  this._0 = param0;
}
Option$Some$77$.prototype.$tag = 1;
function Result$Err$78$(param0) {
  this._0 = param0;
}
Result$Err$78$.prototype.$tag = 0;
function Result$Ok$78$(param0) {
  this._0 = param0;
}
Result$Ok$78$.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$StartColResult$Col(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark$46$StartColResult$Col.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$StartColResult$Start(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark$46$StartColResult$Start.prototype.$tag = 1;
function Result$Err$79$(param0) {
  this._0 = param0;
}
Result$Err$79$.prototype.$tag = 0;
function Result$Ok$79$(param0) {
  this._0 = param0;
}
Result$Ok$79$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$80$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$80$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$80$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$80$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$80$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$80$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$80$.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$80$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$80$.prototype.$tag = 4;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlockQuote(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlockQuote.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlankLine(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlankLine.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock.prototype.$tag = 2;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$Heading(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$Heading.prototype.$tag = 3;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$HtmlBlock(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$HtmlBlock.prototype.$tag = 4;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$List(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$List.prototype.$tag = 5;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$LinkRefDef(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$LinkRefDef.prototype.$tag = 6;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$Paragraph(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$Paragraph.prototype.$tag = 7;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ThematicBreak(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$ThematicBreak.prototype.$tag = 8;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtTable(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtTable.prototype.$tag = 9;
function $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtFootnote(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtFootnote.prototype.$tag = 10;
function $64$rami3l$47$cmark$47$cmark$46$Heading$Atx(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Heading$Atx.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$Heading$Setext(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$Heading$Setext.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Indented(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Indented.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Fenced(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Fenced.prototype.$tag = 1;
const Option$None$81$ = { $tag: 0 };
function Option$Some$81$(param0) {
  this._0 = param0;
}
Option$Some$81$.prototype.$tag = 1;
const $64$rami3l$47$cmark$47$cmark$46$CodeBlockLayout$Indented = { $tag: 0 };
function $64$rami3l$47$cmark$47$cmark$46$CodeBlockLayout$Fenced(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$CodeBlockLayout$Fenced.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$BlockHeadingLayout$Atx(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$BlockHeadingLayout$Atx.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$BlockHeadingLayout$Setext(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$BlockHeadingLayout$Setext.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$BlockHeadingId$Auto(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$BlockHeadingId$Auto.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$BlockHeadingId$Id(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$BlockHeadingId$Id.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$TableRow$Header(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$TableRow$Header.prototype.$tag = 0;
function $64$rami3l$47$cmark$47$cmark$46$TableRow$Sep(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$TableRow$Sep.prototype.$tag = 1;
function $64$rami3l$47$cmark$47$cmark$46$TableRow$Data(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$TableRow$Data.prototype.$tag = 2;
const $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart = { $tag: 0 };
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexSpace(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexSpace.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexIdent(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexIdent.prototype.$tag = 2;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexQual(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexQual.prototype.$tag = 3;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexQualIdent(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexQualIdent.prototype.$tag = 4;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexOp(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexOp.prototype.$tag = 5;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexString(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexString.prototype.$tag = 6;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexChar(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexChar.prototype.$tag = 7;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexMultiString(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexMultiString.prototype.$tag = 8;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexNumber(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexNumber.prototype.$tag = 9;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexLinkHref(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexLinkHref.prototype.$tag = 10;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexLinkContent(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexLinkContent.prototype.$tag = 11;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexComment(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexComment.prototype.$tag = 12;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Unknown(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Unknown.prototype.$tag = 0;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Keyword(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Keyword.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Symbol(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Symbol.prototype.$tag = 2;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Link(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Link.prototype.$tag = 3;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$UIdent(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$UIdent.prototype.$tag = 4;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$LIdent(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$LIdent.prototype.$tag = 5;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$QualIdent(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$QualIdent.prototype.$tag = 6;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$StringLit(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$StringLit.prototype.$tag = 7;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$CharLit(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$CharLit.prototype.$tag = 8;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Number(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Number.prototype.$tag = 9;
const $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Newline = { $tag: 10 };
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Space(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Space.prototype.$tag = 11;
function $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Comment(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Comment.prototype.$tag = 12;
function $64$rami3l$47$cmark$47$cmark$46$FolderResult$Fold$82$(param0) {
  this._0 = param0;
}
$64$rami3l$47$cmark$47$cmark$46$FolderResult$Fold$82$.prototype.$tag = 1;
const Yoorkin$rabbit$45$tea$http$$js_request = (url,method,contentType,body,hasBody,succeed,failed) => {
   var config = { method: method, headers: { 'Content-Type': contentType } }; 
   if (hasBody) { config.body = body };
   console.log("Requesting: ",url,config);
   fetch(url, config)
     .then(response => response.text())
     .then(json => succeed(json))
     .catch(error => {
       console.log(error);
       failed(error.toString())
     })
 };
function Result$Err$83$(param0) {
  this._0 = param0;
}
Result$Err$83$.prototype.$tag = 0;
function Result$Ok$83$(param0) {
  this._0 = param0;
}
Result$Ok$83$.prototype.$tag = 1;
function Result$Err$84$(param0) {
  this._0 = param0;
}
Result$Err$84$.prototype.$tag = 0;
function Result$Ok$84$(param0) {
  this._0 = param0;
}
Result$Ok$84$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$http$46$Body$Json(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$http$46$Body$Json.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$http$46$Body$Text(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$http$46$Body$Text.prototype.$tag = 1;
const $64$Yoorkin$47$rabbit$45$tea$47$http$46$Body$Empty = { $tag: 2 };
const moonbitlang$mooncakes$page$home$$compare_date = function compareDate(date1_str, date2_str) {
  const date1 = new Date(date1_str);
  const date2 = new Date(date2_str);
  if (date1 > date2) return -1;
  if (date1 < date2) return 1;
  return 0;
};
const Option$None$85$ = { $tag: 0 };
function Option$Some$85$(param0) {
  this._0 = param0;
}
Option$Some$85$.prototype.$tag = 1;
function Result$Err$86$(param0) {
  this._0 = param0;
}
Result$Err$86$.prototype.$tag = 0;
function Result$Ok$86$(param0) {
  this._0 = param0;
}
Result$Ok$86$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$87$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$87$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Text$87$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Text$87$.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$page$47$home$46$Msg$GotModuleIndices(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$home$46$Msg$GotModuleIndices.prototype.$tag = 0;
function $64$moonbitlang$47$mooncakes$47$page$47$home$46$Msg$FilterChanged(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$home$46$Msg$FilterChanged.prototype.$tag = 1;
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$88$ = { $tag: 0 };
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Failed$88$ = { $tag: 1 };
function $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$88$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$46$Status$Success$88$.prototype.$tag = 2;
const moonbitlang$mooncakes$page$home$$get_relative_time = function getRelativeTime(dateString) {
  const date = new Date(dateString);
  const now = new Date();
  const diff = now - date;
  const rtf = new Intl.RelativeTimeFormat("en", { numeric: "auto" });
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  const months = Math.floor(days / 30);
  const years = Math.floor(days / 365);
  if (years > 0) return rtf.format(-years, "year");
  if (months > 0) return rtf.format(-months, "month");
  if (days > 0) return rtf.format(-days, "day");
  if (hours > 0) return rtf.format(-hours, "hour");
  if (minutes > 0) return rtf.format(-minutes, "minute");
  return rtf.format(-seconds, "second");
};
const Option$None$89$ = { $tag: 0 };
function Option$Some$89$(param0) {
  this._0 = param0;
}
Option$Some$89$.prototype.$tag = 1;
const Option$None$90$ = { $tag: 0 };
function Option$Some$90$(param0) {
  this._0 = param0;
}
Option$Some$90$.prototype.$tag = 1;
function $64$CAIMEOX$47$lazy$46$LazyPrim$Thunk$91$(param0) {
  this._0 = param0;
}
$64$CAIMEOX$47$lazy$46$LazyPrim$Thunk$91$.prototype.$tag = 0;
function $64$CAIMEOX$47$lazy$46$LazyPrim$Value$91$(param0) {
  this._0 = param0;
}
$64$CAIMEOX$47$lazy$46$LazyPrim$Value$91$.prototype.$tag = 1;
function $36$Yoorkin$47$rabbit$45$tea$47$clipboard$46$copy$46$lambda$46$lambda$47$37$46$State$_try$47$15$72$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$36$Yoorkin$47$rabbit$45$tea$47$clipboard$46$copy$46$lambda$46$lambda$47$37$46$State$_try$47$15$72$.prototype.$tag = 0;
function $36$Yoorkin$47$rabbit$45$tea$47$clipboard$46$copy$46$lambda$46$lambda$47$37$46$State$State_1$72$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$36$Yoorkin$47$rabbit$45$tea$47$clipboard$46$copy$46$lambda$46$lambda$47$37$46$State$State_1$72$.prototype.$tag = 1;
function Result$Err$92$(param0) {
  this._0 = param0;
}
Result$Err$92$.prototype.$tag = 0;
function Result$Ok$92$(param0) {
  this._0 = param0;
}
Result$Ok$92$.prototype.$tag = 1;
function Result$Err$93$(param0) {
  this._0 = param0;
}
Result$Err$93$.prototype.$tag = 0;
function Result$Ok$93$(param0) {
  this._0 = param0;
}
Result$Ok$93$.prototype.$tag = 1;
function Result$Err$94$(param0) {
  this._0 = param0;
}
Result$Err$94$.prototype.$tag = 0;
function Result$Ok$94$(param0) {
  this._0 = param0;
}
Result$Ok$94$.prototype.$tag = 1;
function Result$Err$95$(param0) {
  this._0 = param0;
}
Result$Err$95$.prototype.$tag = 0;
function Result$Ok$95$(param0) {
  this._0 = param0;
}
Result$Ok$95$.prototype.$tag = 1;
function Result$Err$96$(param0) {
  this._0 = param0;
}
Result$Err$96$.prototype.$tag = 0;
function Result$Ok$96$(param0) {
  this._0 = param0;
}
Result$Ok$96$.prototype.$tag = 1;
function Result$Err$97$(param0) {
  this._0 = param0;
}
Result$Err$97$.prototype.$tag = 0;
function Result$Ok$97$(param0) {
  this._0 = param0;
}
Result$Ok$97$.prototype.$tag = 1;
function Result$Err$98$(param0) {
  this._0 = param0;
}
Result$Err$98$.prototype.$tag = 0;
function Result$Ok$98$(param0) {
  this._0 = param0;
}
Result$Ok$98$.prototype.$tag = 1;
function Result$Err$99$(param0) {
  this._0 = param0;
}
Result$Err$99$.prototype.$tag = 0;
function Result$Ok$99$(param0) {
  this._0 = param0;
}
Result$Ok$99$.prototype.$tag = 1;
function Result$Err$100$(param0) {
  this._0 = param0;
}
Result$Err$100$.prototype.$tag = 0;
function Result$Ok$100$(param0) {
  this._0 = param0;
}
Result$Ok$100$.prototype.$tag = 1;
function Result$Err$101$(param0) {
  this._0 = param0;
}
Result$Err$101$.prototype.$tag = 0;
function Result$Ok$101$(param0) {
  this._0 = param0;
}
Result$Ok$101$.prototype.$tag = 1;
function Result$Err$102$(param0) {
  this._0 = param0;
}
Result$Err$102$.prototype.$tag = 0;
function Result$Ok$102$(param0) {
  this._0 = param0;
}
Result$Ok$102$.prototype.$tag = 1;
function Result$Err$103$(param0) {
  this._0 = param0;
}
Result$Err$103$.prototype.$tag = 0;
function Result$Ok$103$(param0) {
  this._0 = param0;
}
Result$Ok$103$.prototype.$tag = 1;
function Result$Err$104$(param0) {
  this._0 = param0;
}
Result$Err$104$.prototype.$tag = 0;
function Result$Ok$104$(param0) {
  this._0 = param0;
}
Result$Ok$104$.prototype.$tag = 1;
function Result$Err$105$(param0) {
  this._0 = param0;
}
Result$Err$105$.prototype.$tag = 0;
function Result$Ok$105$(param0) {
  this._0 = param0;
}
Result$Ok$105$.prototype.$tag = 1;
function Result$Err$106$(param0) {
  this._0 = param0;
}
Result$Err$106$.prototype.$tag = 0;
function Result$Ok$106$(param0) {
  this._0 = param0;
}
Result$Ok$106$.prototype.$tag = 1;
function Result$Err$107$(param0) {
  this._0 = param0;
}
Result$Err$107$.prototype.$tag = 0;
function Result$Ok$107$(param0) {
  this._0 = param0;
}
Result$Ok$107$.prototype.$tag = 1;
function Result$Err$108$(param0) {
  this._0 = param0;
}
Result$Err$108$.prototype.$tag = 0;
function Result$Ok$108$(param0) {
  this._0 = param0;
}
Result$Ok$108$.prototype.$tag = 1;
function Result$Err$109$(param0) {
  this._0 = param0;
}
Result$Err$109$.prototype.$tag = 0;
function Result$Ok$109$(param0) {
  this._0 = param0;
}
Result$Ok$109$.prototype.$tag = 1;
function Result$Err$110$(param0) {
  this._0 = param0;
}
Result$Err$110$.prototype.$tag = 0;
function Result$Ok$110$(param0) {
  this._0 = param0;
}
Result$Ok$110$.prototype.$tag = 1;
function Result$Err$111$(param0) {
  this._0 = param0;
}
Result$Err$111$.prototype.$tag = 0;
function Result$Ok$111$(param0) {
  this._0 = param0;
}
Result$Ok$111$.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ResourceKind$Package(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$ResourceKind$Package.prototype.$tag = 0;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ResourceKind$Module(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$ResourceKind$Module.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ResourceKind$RootPackage(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$ResourceKind$RootPackage.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$112$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$112$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Text$112$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Text$112$.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleDocDetail(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleDocDetail.prototype.$tag = 0;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$DocModeChanged(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$DocModeChanged.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotResource(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotResource.prototype.$tag = 2;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotModuleIndex(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotModuleIndex.prototype.$tag = 3;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotPackageData(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotPackageData.prototype.$tag = 4;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$SidebarTabClicked(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$SidebarTabClicked.prototype.$tag = 5;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleSidebarItem(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleSidebarItem.prototype.$tag = 6;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ClickSidebarItem(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ClickSidebarItem.prototype.$tag = 7;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleSearchPanel(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleSearchPanel.prototype.$tag = 8;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$SearchFilterChanged(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$SearchFilterChanged.prototype.$tag = 9;
const $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleSidebarFab = { $tag: 10 };
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$CopyInstallCommand(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$CopyInstallCommand.prototype.$tag = 11;
const $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$CopyInstallSuccess = { $tag: 12 };
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$113$ = { $tag: 0 };
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Failed$113$ = { $tag: 1 };
function $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$113$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$46$Status$Success$113$.prototype.$tag = 2;
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$114$ = { $tag: 0 };
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Failed$114$ = { $tag: 1 };
function $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$114$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$46$Status$Success$114$.prototype.$tag = 2;
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$115$ = { $tag: 0 };
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Failed$115$ = { $tag: 1 };
function $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$115$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$46$Status$Success$115$.prototype.$tag = 2;
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$116$ = { $tag: 0 };
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Failed$116$ = { $tag: 1 };
function $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$116$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$46$Status$Success$116$.prototype.$tag = 2;
const $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$117$ = { $tag: 0 };
function $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$117$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$util$46$Status$Success$117$.prototype.$tag = 2;
function Result$Err$118$(param0) {
  this._0 = param0;
}
Result$Err$118$.prototype.$tag = 0;
function Result$Ok$118$(param0) {
  this._0 = param0;
}
Result$Ok$118$.prototype.$tag = 1;
function Result$Err$119$(param0) {
  this._0 = param0;
}
Result$Err$119$.prototype.$tag = 0;
function Result$Ok$119$(param0) {
  this._0 = param0;
}
Result$Ok$119$.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$Constr(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$Constr.prototype.$tag = 0;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$Arrow(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$Arrow.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$Param(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$Param.prototype.$tag = 2;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$TypePath(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$TypePath.prototype.$tag = 3;
function Result$Err$120$(param0) {
  this._0 = param0;
}
Result$Err$120$.prototype.$tag = 0;
function Result$Ok$120$(param0) {
  this._0 = param0;
}
Result$Ok$120$.prototype.$tag = 1;
function Result$Err$121$(param0) {
  this._0 = param0;
}
Result$Err$121$.prototype.$tag = 0;
function Result$Ok$121$(param0) {
  this._0 = param0;
}
Result$Ok$121$.prototype.$tag = 1;
function Result$Err$122$(param0) {
  this._0 = param0;
}
Result$Err$122$.prototype.$tag = 0;
function Result$Ok$122$(param0) {
  this._0 = param0;
}
Result$Ok$122$.prototype.$tag = 1;
function Result$Err$123$(param0) {
  this._0 = param0;
}
Result$Err$123$.prototype.$tag = 0;
function Result$Ok$123$(param0) {
  this._0 = param0;
}
Result$Ok$123$.prototype.$tag = 1;
function Result$Err$124$(param0) {
  this._0 = param0;
}
Result$Err$124$.prototype.$tag = 0;
function Result$Ok$124$(param0) {
  this._0 = param0;
}
Result$Ok$124$.prototype.$tag = 1;
function Result$Err$125$(param0) {
  this._0 = param0;
}
Result$Err$125$.prototype.$tag = 0;
function Result$Ok$125$(param0) {
  this._0 = param0;
}
Result$Ok$125$.prototype.$tag = 1;
function Result$Err$126$(param0) {
  this._0 = param0;
}
Result$Err$126$.prototype.$tag = 0;
function Result$Ok$126$(param0) {
  this._0 = param0;
}
Result$Ok$126$.prototype.$tag = 1;
function Result$Err$127$(param0) {
  this._0 = param0;
}
Result$Err$127$.prototype.$tag = 0;
function Result$Ok$127$(param0) {
  this._0 = param0;
}
Result$Ok$127$.prototype.$tag = 1;
function Result$Err$128$(param0) {
  this._0 = param0;
}
Result$Err$128$.prototype.$tag = 0;
function Result$Ok$128$(param0) {
  this._0 = param0;
}
Result$Ok$128$.prototype.$tag = 1;
function Result$Err$129$(param0) {
  this._0 = param0;
}
Result$Err$129$.prototype.$tag = 0;
function Result$Ok$129$(param0) {
  this._0 = param0;
}
Result$Ok$129$.prototype.$tag = 1;
function Result$Err$130$(param0) {
  this._0 = param0;
}
Result$Err$130$.prototype.$tag = 0;
function Result$Ok$130$(param0) {
  this._0 = param0;
}
Result$Ok$130$.prototype.$tag = 1;
function Result$Err$131$(param0) {
  this._0 = param0;
}
Result$Err$131$.prototype.$tag = 0;
function Result$Ok$131$(param0) {
  this._0 = param0;
}
Result$Ok$131$.prototype.$tag = 1;
function Result$Err$132$(param0) {
  this._0 = param0;
}
Result$Err$132$.prototype.$tag = 0;
function Result$Ok$132$(param0) {
  this._0 = param0;
}
Result$Ok$132$.prototype.$tag = 1;
function Result$Err$133$(param0) {
  this._0 = param0;
}
Result$Err$133$.prototype.$tag = 0;
function Result$Ok$133$(param0) {
  this._0 = param0;
}
Result$Ok$133$.prototype.$tag = 1;
function Result$Err$134$(param0) {
  this._0 = param0;
}
Result$Err$134$.prototype.$tag = 0;
function Result$Ok$134$(param0) {
  this._0 = param0;
}
Result$Ok$134$.prototype.$tag = 1;
function Result$Err$135$(param0) {
  this._0 = param0;
}
Result$Err$135$.prototype.$tag = 0;
function Result$Ok$135$(param0) {
  this._0 = param0;
}
Result$Ok$135$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$136$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$136$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$136$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$136$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$136$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$136$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$136$.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$136$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$136$.prototype.$tag = 4;
function $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Item$55$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Item$55$.prototype.$tag = 0;
function $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Node$55$(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Node$55$.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Package(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Package.prototype.$tag = 0;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol.prototype.$tag = 1;
function $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Section(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Section.prototype.$tag = 2;
function $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$137$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$137$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Text$137$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Text$137$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$138$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$138$.prototype.$tag = 0;
function $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Text$138$(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Text$138$.prototype.$tag = 1;
function $64$Yoorkin$47$rabbit$45$tea$47$clipboard$46$Item$Text(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$rabbit$45$tea$47$clipboard$46$Item$Text.prototype.$tag = 0;
function Model$Home(param0) {
  this._0 = param0;
}
Model$Home.prototype.$tag = 0;
function Model$Docs(param0) {
  this._0 = param0;
}
Model$Docs.prototype.$tag = 1;
const Model$NotFound = { $tag: 2 };
const Model$Redirect = { $tag: 3 };
function Msg$GotHomeMsg(param0) {
  this._0 = param0;
}
Msg$GotHomeMsg.prototype.$tag = 0;
function Msg$GotDocsMsg(param0) {
  this._0 = param0;
}
Msg$GotDocsMsg.prototype.$tag = 1;
function Msg$LinkClicked(param0) {
  this._0 = param0;
}
Msg$LinkClicked.prototype.$tag = 2;
function Msg$UrlChanged(param0) {
  this._0 = param0;
}
Msg$UrlChanged.prototype.$tag = 3;
function Error$$to_string(_e) {
  switch (_e.$tag) {
    case 5: {
      return moonbitlang$core$builtin$$Show$to_string$0$(_e);
    }
    case 0: {
      return moonbitlang$core$builtin$$Show$to_string$1$(_e);
    }
    case 2: {
      return moonbitlang$core$builtin$$Show$to_string$2$(_e);
    }
    case 3: {
      return moonbitlang$core$builtin$$Show$to_string$2$(_e);
    }
    case 7: {
      return moonbitlang$core$builtin$$Show$to_string$3$(_e);
    }
    case 1: {
      return moonbitlang$core$builtin$$Show$to_string$2$(_e);
    }
    case 4: {
      return moonbitlang$core$builtin$$Show$to_string$2$(_e);
    }
    case 8: {
      return moonbitlang$core$builtin$$Show$to_string$4$(_e);
    }
    default: {
      return moonbitlang$core$builtin$$Show$to_string$5$(_e);
    }
  }
}
const moonbitlang$core$strconv$$double_info = { mantissa_bits: 52, exponent_bits: 11, bias: -1023 };
const moonbitlang$core$strconv$$min_exponent_fast_path = $_22L;
const moonbitlang$core$strconv$$max_exponent_fast_path = $22L;
const moonbitlang$core$strconv$$max_exponent_disguised_fast_path = $37L;
const moonbitlang$core$strconv$$syntax_err_str = "invalid syntax";
const moonbitlang$core$strconv$$min_19digit_int = $1000000000000000000L;
const moonbitlang$core$strconv$$parse_scientific$46$exp_num$124$48 = $0L;
const moonbitlang$core$strconv$$parse_number$46$exp_number$124$29 = $0L;
const moonbitlang$core$strconv$$powtab = [1, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36, 39, 43, 46, 49, 53, 56, 59];
const moonbitlang$core$strconv$$range_err_str = "value out of range";
const moonbitlang$core$strconv$$left_shift_cheats = [{ _0: 0, _1: "" }, { _0: 1, _1: "5" }, { _0: 1, _1: "25" }, { _0: 1, _1: "125" }, { _0: 2, _1: "625" }, { _0: 2, _1: "3125" }, { _0: 2, _1: "15625" }, { _0: 3, _1: "78125" }, { _0: 3, _1: "390625" }, { _0: 3, _1: "1953125" }, { _0: 4, _1: "9765625" }, { _0: 4, _1: "48828125" }, { _0: 4, _1: "244140625" }, { _0: 4, _1: "1220703125" }, { _0: 5, _1: "6103515625" }, { _0: 5, _1: "30517578125" }, { _0: 5, _1: "152587890625" }, { _0: 6, _1: "762939453125" }, { _0: 6, _1: "3814697265625" }, { _0: 6, _1: "19073486328125" }, { _0: 7, _1: "95367431640625" }, { _0: 7, _1: "476837158203125" }, { _0: 7, _1: "2384185791015625" }, { _0: 7, _1: "11920928955078125" }, { _0: 8, _1: "59604644775390625" }, { _0: 8, _1: "298023223876953125" }, { _0: 8, _1: "1490116119384765625" }, { _0: 9, _1: "7450580596923828125" }, { _0: 9, _1: "37252902984619140625" }, { _0: 9, _1: "186264514923095703125" }, { _0: 10, _1: "931322574615478515625" }, { _0: 10, _1: "4656612873077392578125" }, { _0: 10, _1: "23283064365386962890625" }, { _0: 10, _1: "116415321826934814453125" }, { _0: 11, _1: "582076609134674072265625" }, { _0: 11, _1: "2910383045673370361328125" }, { _0: 11, _1: "14551915228366851806640625" }, { _0: 12, _1: "72759576141834259033203125" }, { _0: 12, _1: "363797880709171295166015625" }, { _0: 12, _1: "1818989403545856475830078125" }, { _0: 13, _1: "9094947017729282379150390625" }, { _0: 13, _1: "45474735088646411895751953125" }, { _0: 13, _1: "227373675443232059478759765625" }, { _0: 13, _1: "1136868377216160297393798828125" }, { _0: 14, _1: "5684341886080801486968994140625" }, { _0: 14, _1: "28421709430404007434844970703125" }, { _0: 14, _1: "142108547152020037174224853515625" }, { _0: 15, _1: "710542735760100185871124267578125" }, { _0: 15, _1: "3552713678800500929355621337890625" }, { _0: 15, _1: "17763568394002504646778106689453125" }, { _0: 16, _1: "88817841970012523233890533447265625" }, { _0: 16, _1: "444089209850062616169452667236328125" }, { _0: 16, _1: "2220446049250313080847263336181640625" }, { _0: 16, _1: "11102230246251565404236316680908203125" }, { _0: 17, _1: "55511151231257827021181583404541015625" }, { _0: 17, _1: "277555756156289135105907917022705078125" }, { _0: 17, _1: "1387778780781445675529539585113525390625" }, { _0: 18, _1: "6938893903907228377647697925567626953125" }, { _0: 18, _1: "34694469519536141888238489627838134765625" }, { _0: 18, _1: "173472347597680709441192448139190673828125" }, { _0: 19, _1: "867361737988403547205962240695953369140625" }];
const moonbitlang$core$strconv$$int_pow10 = [$1L, $10L, $100L, $1000L, $10000L, $100000L, $1000000L, $10000000L, $100000000L, $1000000000L, $10000000000L, $100000000000L, $1000000000000L, $10000000000000L, $100000000000000L, $1000000000000000L];
const moonbitlang$core$strconv$$table = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20, 1e+21, 1e+22, 0, 0, 0, 0, 0, 0, 0, 0, 0];
const moonbitlang$core$strconv$$base_err_str = "invalid base";
const moonbitlang$core$uint64$$max_value = $_1L;
const Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$320 = "://";
const Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$305 = "?";
const Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$302 = "";
const Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$289 = "#";
const Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$274 = "/";
const Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$256 = ":";
const Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$233 = "#";
const rami3l$cmark$char$$rep = 65533;
const rami3l$cmark$cmark_base$$html_block_start_5$46$sub$124$452 = "CDATA[";
const rami3l$cmark$cmark_base$$line_pos_none = { _0: -1, _1: -1 };
const rami3l$cmark$cmark_base$$file_path_none = "-";
const moonbitlang$mooncakes$util$highlight$$parse$46$42$bind$124$225 = "/";
const moonbitlang$mooncakes$config$$icon_close = "/close.svg";
const moonbitlang$mooncakes$config$$ok = "/ok.svg";
const moonbitlang$mooncakes$config$$clipboard = "/clipboard.svg";
const moonbitlang$mooncakes$config$$tag = "/tag.svg";
const moonbitlang$mooncakes$config$$user = "/user.svg";
const moonbitlang$mooncakes$config$$license = "/license.svg";
const moonbitlang$mooncakes$config$$repo = "/repo.svg";
const moonbitlang$mooncakes$config$$terminal = "/terminal.svg";
const moonbitlang$mooncakes$config$$deps = "/deps.svg";
const moonbitlang$mooncakes$config$$dead_rabbit = "         --  --\n       /  //  / __--------_\n      /  //  /_/            \\\n   ---      -                \\ __\n  / X        /        ____   /   )\n  *_________/__/_____/______/ `--";
const moonbitlang$mooncakes$view$$footer$46$class$124$44 = "hover:text-mooncake2 transition-colors";
const moonbitlang$mooncakes$page$home$$resource = "[\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"A-23187\",\n      \"name\": \"encoding\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"hex\",\n        \"base64\",\n        \"base32\"\n      ],\n      \"createdAt\": \"2024-11-02T14:16:05.008219+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Bemly\",\n      \"name\": \"cstdio-ffi\",\n      \"description\": \"standard C library I/O FFI binding. \\n对C标准库中stdio的绑定\",\n      \"version\": \"0.0.0\",\n      \"keywords\": [\n        \"native\",\n        \"stdio\",\n        \"ffi\",\n        \"c\"\n      ],\n      \"createdAt\": \"2025-04-30T18:19:59.459837+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"CAIMEOX\",\n      \"name\": \"feat-moon\",\n      \"description\": \"Functional enumeration of algebraic types\",\n      \"version\": \"0.2.0\",\n      \"keywords\": [\n        \"generation\",\n        \"functional enumeration\"\n      ],\n      \"createdAt\": \"2024-07-29T01:36:00.892562+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"CAIMEOX\",\n      \"name\": \"list\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"list\"\n      ],\n      \"createdAt\": \"2024-01-23T12:41:53.819691+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"CAIMEOX\",\n      \"name\": \"quickcheck\",\n      \"description\": \"Automatic testing of MoonBit programs\",\n      \"version\": \"0.6.9\",\n      \"keywords\": [\n        \"property-based-testing\",\n        \"quickcheck\"\n      ],\n      \"createdAt\": \"2024-11-18T02:37:53.419876+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"CAIMEOX\",\n      \"name\": \"t\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-01-23T08:59:05.933896+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Erolaffy\",\n      \"name\": \"easy-io\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"easy-io\"\n      ],\n      \"createdAt\": \"2025-01-20T08:19:21.115336+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"FreeFoots\",\n      \"name\": \"mooncake_hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-11T13:46:58.824725+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Guest0x0\",\n      \"name\": \"HAMT\",\n      \"description\": \"\",\n      \"version\": \"0.2.1\",\n      \"keywords\": [],\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Guest0x0\",\n      \"name\": \"dregex\",\n      \"description\": \"\",\n      \"version\": \"0.2.5\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-01-31T07:26:46.522026+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Howardzhangdqs\",\n      \"name\": \"md5\",\n      \"description\": \"MD5 的 MoonBit 实现\",\n      \"version\": \"0.9.3\",\n      \"keywords\": [\n        \"md5\"\n      ],\n      \"createdAt\": \"2024-06-25T03:36:16.940117+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"KCN-judu\",\n      \"name\": \"calculus-numerical\",\n      \"description\": \"A numerical calculus library, a part of LunaFlow.\",\n      \"version\": \"0.2.1-alpha-6\",\n      \"keywords\": [\n        \"calculus\",\n        \"numerical-methods\",\n        \"math\"\n      ],\n      \"createdAt\": \"2025-02-15T05:53:28.532241+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Kaida-Amethyst\",\n      \"name\": \"moonbit-math\",\n      \"description\": \"High-precision Math library\",\n      \"version\": \"0.1.14\",\n      \"keywords\": [\n        \"math\",\n        \"numeric\"\n      ],\n      \"createdAt\": \"2025-02-07T08:08:01.448933+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Lalenture\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-09T10:11:48.924022+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Lampese\",\n      \"name\": \"moondata\",\n      \"description\": \"\",\n      \"version\": \"0.2.8\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-09T03:55:37.532021+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Lampese\",\n      \"name\": \"moondata2\",\n      \"description\": \"\",\n      \"version\": \"0.0.2\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-17T08:51:01.790820+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"NerdyLee\",\n      \"name\": \"newcake_ls\",\n      \"description\": \"find the maximum value in a list\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"find_max_num\"\n      ],\n      \"createdAt\": \"2025-03-12T08:04:22.103151+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"PerfectPan\",\n      \"name\": \"base64\",\n      \"description\": \"base64 encode/decode library\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"base64\"\n      ],\n      \"createdAt\": \"2024-04-07T10:12:53.449671+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"PingGuoMiaoMiao\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-11T13:22:26.718149+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"TheWaWaR\",\n      \"name\": \"lunar\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-22T15:39:08.708082+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"TianZaiShuiZhong\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-11T11:14:26.125831+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Yoorkin\",\n      \"name\": \"format\",\n      \"description\": \"simple printf utils\",\n      \"version\": \"0.1.5\",\n      \"keywords\": [\n        \"format\",\n        \"utils\"\n      ],\n      \"createdAt\": \"2024-07-30T09:45:49.046658+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Yoorkin\",\n      \"name\": \"hashtbl\",\n      \"description\": \"\",\n      \"version\": \"0.1.2\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2024-09-04T03:16:18.533001+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Yoorkin\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [\n        \"utils\",\n        \"array\",\n        \"hello MoonBit\"\n      ],\n      \"createdAt\": \"2024-02-04T09:07:20.617611+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Yoorkin\",\n      \"name\": \"example\",\n      \"description\": \"functional style List for MoonBit\",\n      \"version\": \"0.1.4\",\n      \"keywords\": [\n        \"list\",\n        \"data structure\",\n        \"utility\"\n      ],\n      \"createdAt\": \"2024-01-26T07:51:20.491181+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Young-Flash\",\n      \"name\": \"test\",\n      \"description\": \"\",\n      \"version\": \"0.2.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2024-08-23T10:32:04.970519+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Young-Flash\",\n      \"name\": \"test_ignore\",\n      \"description\": \"\",\n      \"version\": \"0.2.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2024-08-23T10:31:48.481588+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Young-Flash\",\n      \"name\": \"test_publish\",\n      \"description\": \"\",\n      \"version\": \"0.2.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2024-08-23T10:31:08.636269+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"Yu-zh\",\n      \"name\": \"termbit\",\n      \"description\": \"A terminal manipulation library written in MoonBit\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"console\",\n        \"terminal\",\n        \"color\",\n        \"cursor\",\n        \"tui\"\n      ],\n      \"createdAt\": \"2025-04-09T03:33:08.950856+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"YumeCross\",\n      \"name\": \"schema\",\n      \"description\": \"Json Schema validation for MoonBit.\",\n      \"version\": \"0.4.3\",\n      \"keywords\": [\n        \"json\",\n        \"schema\"\n      ],\n      \"createdAt\": \"2024-11-03T04:15:53.128825+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"bob\",\n      \"name\": \"aegis\",\n      \"description\": \"AEGIS cipher implementation in Moonbit\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"crypto\",\n        \"aead\",\n        \"aegis\",\n        \"encryption\"\n      ],\n      \"createdAt\": \"2024-05-17T06:57:16.599651+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"bobzhang\",\n      \"name\": \"testa\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"bobzhang\",\n      \"name\": \"testb\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"bzy-debug\",\n      \"name\": \"cowsay\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"bzy-debug\",\n      \"name\": \"cowsay_lib\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"bzy-debug\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.20240510+81e045f4e\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-05-10T02:59:53.015764+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"eczn\",\n      \"name\": \"eczn-utils\",\n      \"description\": \"\",\n      \"version\": \"0.2.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-05-01T18:51:02.119094+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"enjoecn\",\n      \"name\": \"easy\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-06-25T04:39:31.476831+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"enjoecn\",\n      \"name\": \"gb\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-07-19T07:34:06.699464+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"fantix\",\n      \"name\": \"mmhttp\",\n      \"description\": \"MoonBit 的 HTTP 工具包\",\n      \"version\": \"0.3.0\",\n      \"keywords\": [\n        \"http\",\n        \"parser\"\n      ],\n      \"createdAt\": \"2024-06-01T23:39:50.432192+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"fantix\",\n      \"name\": \"muts\",\n      \"description\": \"非函数式的常用数据结构合集\",\n      \"version\": \"0.5.4\",\n      \"keywords\": [\n        \"mutable\",\n        \"data structure\"\n      ],\n      \"createdAt\": \"2024-03-29T14:33:33.340850+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"five-nuts\",\n      \"name\": \"coreutils\",\n      \"description\": \"\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-11-16T11:05:35.555323+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"gmlewis\",\n      \"name\": \"json\",\n      \"description\": \"simple json parser\",\n      \"version\": \"0.15.0\",\n      \"keywords\": [\n        \"json\"\n      ],\n      \"createdAt\": \"2024-07-15T16:00:16.688896+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"gmlewis\",\n      \"name\": \"jsonutil\",\n      \"description\": \"DEPRECATED AND ARCHIVED - USE STANDARD LIBRARY INSTEAD\",\n      \"version\": \"0.24.0\",\n      \"keywords\": [\n        \"json\"\n      ],\n      \"createdAt\": \"2024-08-20T13:23:23.993256+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"gmlewis\",\n      \"name\": \"modus\",\n      \"description\": \"Experimental Modus SDK for the MoonBit programming language.\",\n      \"version\": \"0.16.5\",\n      \"keywords\": [\n        \"modus\",\n        \"moonbit\",\n        \"sdk\"\n      ],\n      \"createdAt\": \"2025-01-18T01:23:10.174077+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"hackwaly\",\n      \"name\": \"common\",\n      \"description\": \"\",\n      \"version\": \"0.1.24\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-03-08T02:22:28.618759+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"hackwaly\",\n      \"name\": \"moonyacc\",\n      \"description\": \"\",\n      \"version\": \"0.3.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-12-23T17:39:47.402951+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"hzqdf\",\n      \"name\": \"aoko\",\n      \"description\": \"A MoonBit extension library.\",\n      \"version\": \"0.0.20250321\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-21T01:22:25.420758+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"illusory0x0\",\n      \"name\": \"qpainter\",\n      \"description\": \"Moonbit FFI Bindings for Qt's QPainter\",\n      \"version\": \"0.3.1\",\n      \"keywords\": [\n        \"Qt6\",\n        \"Qt\",\n        \"GUI\",\n        \"QPainter\",\n        \"canvas\",\n        \"native\",\n        \"FFI\",\n        \"C++ FFI\"\n      ],\n      \"createdAt\": \"2025-04-29T00:02:42.107432+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"jedisct1\",\n      \"name\": \"aegis\",\n      \"description\": \"AEGIS cipher implementation in Moonbit\",\n      \"version\": \"0.2.1\",\n      \"keywords\": [\n        \"crypto\",\n        \"aead\",\n        \"aegis\",\n        \"encryption\"\n      ],\n      \"createdAt\": \"2024-09-05T11:54:20.988088+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"jumpping\",\n      \"name\": \"baby\",\n      \"description\": \"Ordered set based on balanced binary tree\",\n      \"version\": \"0.2.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-11-27T08:53:04.763310+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"kesmeey\",\n      \"name\": \"tools\",\n      \"description\": \"A utility library similar to Hutool in Java.\",\n      \"version\": \"0.1.9\",\n      \"keywords\": [\n        \"tools\",\n        \"utility\"\n      ],\n      \"createdAt\": \"2025-02-16T16:19:47.596171+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"li\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2024-06-17T07:46:24.641140+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"hello16\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"hello18\",\n      \"description\": \"test\",\n      \"version\": \"0.1.35\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2025-03-12T06:45:06.740849+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"hello19\",\n      \"description\": \"\",\n      \"version\": \"0.1.2\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2024-07-31T08:42:29.245421+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"hello2\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2024-06-17T08:09:36.743017+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"hello23\",\n      \"description\": \"\",\n      \"version\": \"0.1.2\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"hello24\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"mooncake\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"test_postadd\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2025-04-09T07:46:45.840608+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"unstable_io\",\n      \"description\": \"Unstable IO package for MoonBit\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [\n        \"io\"\n      ],\n      \"createdAt\": \"2024-07-04T08:00:41.577085+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"nested\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"nested\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"nested\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"loneoutpost\",\n      \"name\": \"core-extra\",\n      \"description\": \"experimental extras for `moonbit/core`.\",\n      \"version\": \"0.0.6\",\n      \"keywords\": [\n        \"core\"\n      ],\n      \"createdAt\": \"2024-06-03T10:11:41.349647+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"lucifer1004\",\n      \"name\": \"mooncake\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"mizchi\",\n      \"name\": \"js_io\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"js\"\n      ],\n      \"createdAt\": \"2024-04-22T02:22:00.182813+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"mizchi\",\n      \"name\": \"js_regexp\",\n      \"description\": \"JS RegExp binding\",\n      \"version\": \"0.0.4\",\n      \"keywords\": [\n        \"regexp\"\n      ],\n      \"createdAt\": \"2024-04-17T03:43:48.244515+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"mizchi\",\n      \"name\": \"json\",\n      \"description\": \"simple json parser\",\n      \"version\": \"0.4.0\",\n      \"keywords\": [\n        \"json\"\n      ],\n      \"createdAt\": \"2024-04-30T17:39:25.061037+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"mizchi\",\n      \"name\": \"protocol\",\n      \"description\": \"\",\n      \"version\": \"0.0.5\",\n      \"keywords\": [\n        \"js\"\n      ],\n      \"createdAt\": \"2024-05-07T20:33:53.012583+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"moonbit-courses\",\n      \"name\": \"minimoonbit-courses\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-08-23T07:24:55.418749+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"moonbitlang\",\n      \"name\": \"std\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"myfreess\",\n      \"name\": \"myers-diff\",\n      \"description\": \"Myers diff algorithm\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"diff\",\n        \"meyers\"\n      ],\n      \"createdAt\": \"2024-07-18T07:59:34.603097+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"oboard\",\n      \"name\": \"mooncrypto\",\n      \"description\": \"MoonBit Crypto Library\",\n      \"version\": \"0.1.8\",\n      \"keywords\": [\n        \"crypto\",\n        \"加密\",\n        \"md5\",\n        \"sha\",\n        \"base64\"\n      ],\n      \"createdAt\": \"2024-07-30T12:09:43.313495+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"oboard\",\n      \"name\": \"moonetx\",\n      \"description\": \"MoonBit网络分析扩展\",\n      \"version\": \"0.1.5\",\n      \"keywords\": [\n        \"moonbit\",\n        \"moonetx\",\n        \"network\",\n        \"networkx\"\n      ],\n      \"createdAt\": \"2024-07-31T07:23:03.295398+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"peter-jerry-ye\",\n      \"name\": \"advent_of_code\",\n      \"description\": \"\",\n      \"version\": \"0.3.1-fix\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-01-26T08:48:45.349484+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"peter-jerry-ye\",\n      \"name\": \"assertion\",\n      \"description\": \"\",\n      \"version\": \"0.2.1\",\n      \"keywords\": [],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"peter-jerry-ye\",\n      \"name\": \"json\",\n      \"description\": \"\",\n      \"version\": \"0.4.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-09-04T02:39:51.114591+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"peter-jerry-ye\",\n      \"name\": \"memory\",\n      \"description\": \"\",\n      \"version\": \"0.8.4\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-11-25T08:44:51.346515+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"peter-jerry-ye\",\n      \"name\": \"parser-combinator\",\n      \"description\": \"\",\n      \"version\": \"0.9.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-09-04T02:21:08.851501+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"suiyunonghen\",\n      \"name\": \"linklist\",\n      \"description\": \"Double Linked List 双链表\",\n      \"version\": \"0.1.7\",\n      \"keywords\": [\n        \"Double Linked List\",\n        \"双链表\"\n      ],\n      \"createdAt\": \"2024-11-26T02:28:44.862312+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"summer-boythink\",\n      \"name\": \"moonorm\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-03-15T08:32:45.512162+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"test\",\n      \"name\": \"B\",\n      \"description\": \"\",\n      \"version\": \"0.1.2\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"test\",\n      \"name\": \"C\",\n      \"description\": \"\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"test\",\n      \"name\": \"D\",\n      \"description\": \"\",\n      \"version\": \"0.1.4\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"test\",\n      \"name\": \"E\",\n      \"description\": \"\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"test\",\n      \"name\": \"F\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"test\",\n      \"name\": \"G\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"tmkx\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.0.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-07-03T03:18:08.426528+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"iter\",\n      \"description\": \"\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2024-09-04T02:46:47.501114+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"malloc\",\n      \"description\": \"An simple external allocator\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2024-11-25T06:22:55.414002+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"narray\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-09-29T06:11:35.618944+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"ops\",\n      \"description\": \"\",\n      \"version\": \"0.0.2\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2024-09-04T02:47:51.112936+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"pcre2\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-18T08:32:02.406969+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"torch\",\n      \"description\": \"PyTorch-like tensor operations implemented in MoonBit\",\n      \"version\": \"0.2.8\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-26T05:00:59.496859+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"webgpu\",\n      \"description\": \"\",\n      \"version\": \"0.1.7\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-09T15:54:00.943996+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"wangziling\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.0.1\",\n      \"keywords\": [],\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"xunyoyo\",\n      \"name\": \"Permutation\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-11-15T10:48:43.405249+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"yamajik\",\n      \"name\": \"dapr\",\n      \"description\": \"\",\n      \"version\": \"0.1.11\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-12-11T07:09:02.084989+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"yamajik\",\n      \"name\": \"wasi-bindings\",\n      \"description\": \"\",\n      \"version\": \"0.2.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-12-04T08:51:22.804911+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"yamajik\",\n      \"name\": \"wasi\",\n      \"description\": \"\",\n      \"version\": \"0.1.25\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-12-11T07:03:46.754274+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"yj-qin\",\n      \"name\": \"moonlox\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-16T01:52:00.566502+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"在最新版本中无法构建\",\n    \"metadata\": {\n      \"author\": \"yoshitsugu\",\n      \"name\": \"parsem\",\n      \"description\": \"Parser combinator for Moonbit\",\n      \"version\": \"0.0.3\",\n      \"keywords\": [\n        \"parser\",\n        \"parser combinator\"\n      ],\n      \"createdAt\": \"2024-12-30T11:13:52.654944+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的'summation'函数功能过于基础（累加运算），这类简单数学运算通常应由标准库提供。代码库缺少详细文档（README仅包含基础信息）、未提供实际应用场景说明、版本号0.1.0表明处于早期开发阶段，且未体现特殊优化或广泛用途需求，无法形成生态价值。\",\n    \"metadata\": {\n      \"author\": \"202306123\",\n      \"name\": \"lib_mbt\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-03T11:58:59.044858+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库存在多个关键问题：\\n1. 文档严重缺失（README仅包含基础标题，缺少使用说明和示例）\\n2. 功能实现简单单一（仅包含名为'fwshzu'的未明确功能）\\n3. 未体现核心价值（没有显示出解决复杂问题或提供创新解决方案的能力）\\n4. 缺乏元数据显示（版本信息、许可证等不完整，无仓库链接）\\n5. 代码组织结构不规范（没有标准包管理和模块划分体系）\\n这些缺陷表明它无法作为生态重要组件保留。\",\n    \"metadata\": {\n      \"author\": \"2459822546\",\n      \"name\": \"fwshz\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-08T16:05:57.260466+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库仅提供查找最小值功能，这属于基础算法且通常由标准库覆盖。文档和描述信息缺失，未体现出优于标准实现或独特价值。关键词和版本信息也未完善，建议不作为生态重点保留。\",\n    \"metadata\": {\n      \"author\": \"BigThree33\",\n      \"name\": \"find_min\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-28T05:56:12.743277+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该库实现了Lazy初始化功能，但功能过于基础。其README仅两行描述缺乏使用示例和API文档，生态价值不足。核心功能（如延迟计算）通常应由标准库提供或与更高级框架整合。当前实现未展示足够的创新性或者性能优势，难以作为独立重要生态组件保留。\",\n    \"metadata\": {\n      \"author\": \"CAIMEOX\",\n      \"name\": \"lazy\",\n      \"description\": \"Lazy Initialized Value\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"lazy\"\n      ],\n      \"createdAt\": \"2025-03-10T13:28:39.691191+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然展示了包名可支持中文的特性，但缺乏实际功能和文档支持，仅包含一个名为'hello'的值。未体现关键需求或技术优势，文档不齐全且功能过于简单，不适合作为生态中的重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"CAIMEOX\",\n      \"name\": \"原来可以发中文包\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-05-11T11:59:52.944489+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库目前实现的KMP算法属于常见字符串算法，虽然需求真实存在，但通常应由标准库或更全面的算法库提供。项目文档不完整，缺乏详细的使用说明、示例和性能分析，且其他提到的算法如Manacher、AC自动机等尚未完成。此外，代码库未展示独特优化或创新，作为单独生态项目的重要性不足。建议完善功能、文档并添加测试后再评估其价值。\",\n    \"metadata\": {\n      \"author\": \"CMoonBack\",\n      \"name\": \"string-Algorithm\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-11-27T14:48:40.907576+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库旨在封装现有库 moonbitlang/x/fs 以简化文件操作，但目前提供的功能（如 open、read、write 等基础操作）与底层库的实现重叠度较高，未能体现出明显的附加价值或创新性。文档虽然包含基础用法示例，但缺乏高级用例、错误处理示例或性能优化的说明，无法有效展示其优势。此外，关键功能如错误处理机制未充分展示（示例中直接使用 unwrap 存在隐患），生态系统中若已有成熟文件操作库时，该模块难以形成竞争力。核心文件读写功能通常应由标准库提供，除非本库在易用性/扩展性上有显著提升，当前信息不足以证明其必要性。\",\n    \"metadata\": {\n      \"author\": \"Erolaffy\",\n      \"name\": \"easyio\",\n      \"description\": \"A simple file operation module\",\n      \"version\": \"0.2.1\",\n      \"keywords\": [\n        \"easyio\",\n        \"fs\"\n      ],\n      \"createdAt\": \"2025-02-27T01:46:06.101265+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库当前的代码价值不足以作为生态重要项目保留。分析依据如下：1. 核心功能暴露唯一函数'hello'未体现业务价值，类似问候功能的实用性和不可替代性不足；2. 项目文档内容异常（含控制字符\\u0016），没有有效说明功能定位和用途；3. 项目结构存在冗余嵌套（Eunoiay/Eunoiay两层同名目录），缺乏合理模块化；4. 版本号为初始0.1.0且近两年无更新，维护状态存疑。综合判断未能证明其解决了实际复杂问题或带来创新方案。\",\n    \"metadata\": {\n      \"author\": \"Eunoiay\",\n      \"name\": \"Eunoiay\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-11T14:56:39.635652+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供了质数检测功能，但这是一个常见的需求，通常应由标准库或更综合的数学库覆盖。虽然文档齐全且结构合规，但其功能性单一，缺乏性能优化（如Miller-Rabin测试等），无法作为生态中的重要独立库保留。建议合并到更全面的数学库中以提高生态效率。\",\n    \"metadata\": {\n      \"author\": \"GreyIcesea\",\n      \"name\": \"isprime\",\n      \"description\": \"A lightweight prime number detection library for MoonBit\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"prime\",\n        \"math\",\n        \"number\"\n      ],\n      \"createdAt\": \"2025-02-27T15:36:12.439126+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的Rope数据结构实现基础功能，但存在以下不足：1.项目文档极为简陋（README仅一行标题），缺乏使用说明和技术细节。2.基础功能如length/to_string等存在与标准库重复嫌疑，未见特殊性能优化说明。3.Metadata信息不完整（无仓库地址、关键词、详细描述），项目维护性存疑。4.无测试用例与基准测试数据，代码质量无法验证。5.版本号0.1.0表明尚未进入稳定阶段。作为生态关键组件需更成熟的工程化建设。\",\n    \"metadata\": {\n      \"author\": \"HeChTo\",\n      \"name\": \"rope\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-08T09:53:00.178499+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库信息显示存在多项关键缺失：1. 缺少具体功能描述（description为空），难以判断项目定位和实际需求场景 2. 关键词列表为空，文档仅包含基本README文件 3. 仅导出单一的'read'方法，但未说明具体功能实现 4. 没有展示任何算法优化或独特价值，无法验证其是否超越标准库实现 5. 缺少社区认证指标如星标/贡献者等 6. 项目结构过于简单（仅1个lib模块+1个方法），未达到独立生态包的标准\",\n    \"metadata\": {\n      \"author\": \"JPLovever\",\n      \"name\": \"fkshz\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-02T13:51:17.010856+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库实现了基本的加减乘除功能，但这些功能通常由编程语言的标准库或基础数学库提供，没有体现出独特或优化的实现。项目文档和说明较为简单，没有展示出特别的需求场景或性能优势。因此，作为生态中的重要代码库保留的必要性不足。\",\n    \"metadata\": {\n      \"author\": \"Kilig\",\n      \"name\": \"MATH\",\n      \"description\": \"实现加减乘除\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-12T07:46:24.684889+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"虽然Base16编码和解码是一个实用功能，但大多数编程语言的标准库已经提供了成熟的实现。例如，Moonbit语言可能已经在标准库中包含了类似的工具，或者存在更流行、维护更好的第三方库。此外，该代码库的功能相对简单，文档和测试覆盖可能不足，缺乏足够的创新性或优化以区分于现有解决方案。如果标准库或主流社区尚未提供相关支持，且该实现具备显著优势（如性能优化、更友好的API设计），才有保留价值。\",\n    \"metadata\": {\n      \"author\": \"LI7282\",\n      \"name\": \"base16\",\n      \"description\": \"Implemented Base16 (hexadecimal) encoding and decoding functionality\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"base16\"\n      ],\n      \"createdAt\": \"2025-03-02T04:34:17.997501+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的功能是寻找最大值，这是一个非常基础且常见的需求，通常编程语言的标准库或内置函数已经提供了高效的实现（例如Python的max函数）。虽然该代码库包含README和版本信息，但缺乏具体的实现细节和性能优化的说明，无法证明其相较于标准库有显著优势。此外，文档内容过于简单，未提供使用示例、API说明或贡献指南，难以支持其作为生态重要组件。因此，该代码库在当前形式下不具备保留为重要生态组件的必要性。\",\n    \"metadata\": {\n      \"author\": \"Ljw030710\",\n      \"name\": \"find_max\",\n      \"description\": \"find the max\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"find-max\"\n      ],\n      \"createdAt\": \"2025-02-28T04:32:15.641421+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库作为生态重要项目的评估要素分析：\\n\\n1. **功能定位问题**：\\n   - 主要提供代数结构抽象（如AddGroup/Num等）和基本数值类型实现，这类基础数学抽象通常应由标准库或核心数学库提供。\\n   - 当前仅包含Int/Double的简单实现，覆盖类型有限，无创新性代数结构或高性能实现\\n\\n2. **实现完整性问题**：\\n   - MulGroup/AddGroup等关键trait未具体实现，核心功能未完成\\n   - 缺乏复合数据类型（如复数/矩阵）的支持，抽象层级较低\\n\\n3. **生态适配性问题**：\\n   - README文档缺失具体使用场景和设计文档\\n   - 依赖关系不明确，与Luna Project其他模块的整合路径未说明\\n   - 未体现与现有生态系统的互补性（如作为扩展库应有的差异化功能）\\n\\n4. **代码质量指示**：\\n   - 项目处于0.2.0-alpha阶段，成熟度不足\\n   - 核心trait的impl存在明显空缺（如AddGroup无实现）\\n\\n当前状态不符合生态核心库标准，建议作为实验性组件或重新规划功能边界\",\n    \"metadata\": {\n      \"author\": \"Luna-Flow\",\n      \"name\": \"luna-generic\",\n      \"description\": \"General abstraction and structures for Luna Project\",\n      \"version\": \"0.2.0-alpha-1\",\n      \"keywords\": [\n        \"math\",\n        \"algebra\"\n      ],\n      \"createdAt\": \"2025-03-25T01:53:50.401427+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的功能较为基础，主要以数组和数学工具为主，内容过于简单，如arr_sum、clamp、is_between等函数。这些功能通常已由标准库提供，且文档缺失（README无实际内容），缺乏维护迹象（项目自2025年4月创建后无显著更新）。此外，命名为luna-utils但未展示独特生态价值，依赖关系局限于同一组织下的其他项目，并未解决特定领域痛点。核心算法未能展示显著优化或创新，不满足生态重要代码库的标准。\",\n    \"metadata\": {\n      \"author\": \"Luna-Flow\",\n      \"name\": \"luna-utils\",\n      \"description\": \"A utils library, a part of LunaFlow.\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"utils\",\n        \"math\"\n      ],\n      \"createdAt\": \"2025-04-04T18:26:55.896900+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库目前不足以作为生态中的重要代码库保留。原因如下：1. 缺乏详细的项目描述和文档，README内容极为简单，无法帮助用户理解和使用；2. 功能模块如Task、Person等未见明确且独特的功能定位，可能只是基础功能的简单实现；3. 依赖项如moonchor等可能尚未成熟，且自身未展示出显著的技术优势或创新点；4. 项目结构较为基础，各子模块如store、test等尚未填充实际有价值的内容。需要进一步明确应用场景、完善文档和增强模块的核心竞争力。\",\n    \"metadata\": {\n      \"author\": \"Milky2018\",\n      \"name\": \"moonlight\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-05-13T07:11:58.243950+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"虽然该库是一个命令行参数解析器（常见需求），但作者明确在README中标注'Warning: it is for self-use and experimental, not for production'，表明尚未达到生产级稳定性。提供的功能如JSON基础实现可能与成熟的参数解析库存在差距，且文档不完善（仅引导查看测试用例），依赖项单一且社区活跃度不明确。此外，版本迭代均为0.1.x小版本更新，可能表示功能尚不完善，暂不适合作为生态关键组件\",\n    \"metadata\": {\n      \"author\": \"Milky2018\",\n      \"name\": \"options\",\n      \"description\": \"Command line argument parser for MoonBit\",\n      \"version\": \"0.1.2\",\n      \"keywords\": [\n        \"CLI\",\n        \"argument parser\",\n        \"command line\"\n      ],\n      \"createdAt\": \"2025-05-07T08:12:36.242383+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然提供了一些工具函数（如alert、run_async等），但存在以下几个关键问题：\\n1. 文档不全。README仅包含“Do you like it?”未提供任何功能说明或使用示例，开发者无法快速理解库的用途和方法。\\n2. 功能定位不清晰。核心功能如异步处理等应由成熟库实现，未展示相较于标准库的显著优势或创新点。\\n3. 代码贡献度低。版本迭代集中在0.1.x且发布版本间无重大更新，维护持续性存疑。\\n4. 未说明具体应用场景。当前提供的工具函数难以满足生态中的核心需求，缺乏不可替代性。\",\n    \"metadata\": {\n      \"author\": \"Milky2018\",\n      \"name\": \"toolkit\",\n      \"description\": \"Toolkit library for common use.\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [\n        \"utils\",\n        \"toolkit\"\n      ],\n      \"createdAt\": \"2025-05-13T07:13:48.613061+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库存在多个不符合生态重要保留条件的因素：\\n1. 功能规模不足 - 当前模块仅包含一个简单的'hello'函数，属于基础功能范畴，通常应由标准库实现\\n2. 文档描述缺失 - README仅含项目名称，没有提供使用说明、接口文档或示例代码\\n3. 缺乏维护迹象 - 项目在两年内没有更新记录，关键词和描述字段均为空\\n4. 代码结构单一 - 目录层级不清晰，模块划分简单，没有体现出复杂系统的设计\\n5. 许可证适当性 - Apache-2.0协议对超小型项目而言略显冗余，没有看到必要的版权声明\\n建议：若需保留应增加实用性功能、完善测试和文档，建立可持续维护机制\",\n    \"metadata\": {\n      \"author\": \"Near-Jungnune\",\n      \"name\": \"Near-Jungnune\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-09T09:02:35.836780+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"代码库信息显示其功能较为简单，包含如打印函数、数学计算等基础功能（例如sqrt_int、print_zigzag等）。这些功能属于基础工具类，通常应由标准库提供，缺乏独特性或创新性。此外，文档README内容极为简略，未提供有效说明或使用示例，无法帮助用户理解和使用。项目关键词、描述均为空，维护和社区支持信息缺失，说明项目成熟度和维护度不足。综上，该代码库不适合作为生态中的重要项目保留。\",\n    \"metadata\": {\n      \"author\": \"PegasusPlusUS\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-12-06T00:59:15.352703+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"代码库存在多个不达标特征：1. 项目文档极不完善（README仅包含标题），缺乏使用说明和核心功能描述。2. 核心功能定位模糊，values列表中包含 'greeting' 'hello' 等与考试审查无关的功能，表明功能聚焦度严重不足。3. 核心类型设计存在重大缺陷，ExamResult和Student两个类型均为空壳结构，缺乏属性和方法支撑。4. 项目缺乏基础测试验证，版本迭代历史空白。5. 模块分层混乱，lib子模块的hello方法与主功能无逻辑关联。综上所述，该项目无法满足生态库对功能完整性、文档可维护性和架构合理性的基本要求。\",\n    \"metadata\": {\n      \"author\": \"Penguinsltp\",\n      \"name\": \"examine\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-04-02T09:19:17.841277+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库缺乏必要的基础信息：1. 项目描述为空（description字段） 2. 版本号处于0.1.0初始阶段，表明项目未成熟 3. 关键词为空（keywords）4. 无开源仓库地址（repository字段）5. README仅包含标题无实质性内容 6. 模块索引中只存在简单测试函数'package_hello'，没有任何有价值的功能实现。综合判断该项目目前处于初始草稿阶段，尚未具备开源生态价值。\",\n    \"metadata\": {\n      \"author\": \"QZL-max\",\n      \"name\": \"QZL-max\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-12T13:15:02.476701+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库实现了一个稳定的归并排序算法，虽然归并排序在时间复杂度上为O(n log n)且稳定，但排序算法通常应由标准库提供，除非有显著的优化或特殊功能。代码库的文档非常基础，仅提及了基本功能，缺乏详细的使用说明、API文档和性能测试数据。关键词和描述字段均为空，版本号较低（0.1.0），未提及许可证或仓库信息，显示项目成熟度和维护性不足。没有展示独特的优势或满足未覆盖的需求，因此不适合作为生态中的重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"Refined_heart\",\n      \"name\": \"Sort\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-20T07:39:06.996185+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的功能非常基础，仅包含一个返回 'hello' 的函数，缺乏实际应用场景和独特价值。代码库的文档（README）内容过于简略，没有详细说明使用场景、API文档或贡献指南。关键词和描述字段均为空，缺少必要的元数据支持生态搜索和分类。此类基础功能通常由标准库或成熟工具链覆盖，独立维护缺乏必要性。模块结构和版本管理（0.1.0）也表明项目处于早期实验阶段，未达到生态组件要求的稳定性和深度。\",\n    \"metadata\": {\n      \"author\": \"SeisanSoda\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-12T17:23:24.141160+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然提供了加载.env文件的功能并具备基本文档，但其作为生态重要库的核心价值存在多个疑问：\\n1. 功能范畴较小，标准化可能性高（通常应由标准库或核心框架集成此类功能）\\n2. 文档表述存在矛盾（如声称不修改全局环境但API名为'load_and_modify_override'）\\n3. 替代方案考量不足（未说明相比现有实现如Rust版本的特殊优势）\\n4. 没有体现足够的创新点（变量替换等基础功能已属常见）\\n5. 需求真实性问题（MoonBit生态尚在早期可能更需要核心库完善而非细分工具）\\n建议作为临时解决方案存在，不宜作为生态核心库长期保留\",\n    \"metadata\": {\n      \"author\": \"ShellWen\",\n      \"name\": \"dotenv-mbt\",\n      \"description\": \"removed\",\n      \"version\": \"0.9.9\",\n      \"keywords\": [\n        \"dotenv\",\n        \"moonbit\"\n      ],\n      \"createdAt\": \"2025-03-26T03:00:13.566690+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供计算整数数组的中位数功能。虽然中位数计算是实际存在的需求，但多数编程语言的标准库或常用第三方库已经包含高效实现。此项目提供的功能相对基础，文档仅描述了基本功能，缺乏更详细的用例、性能说明或高级功能（如处理大数组、多种数据类型等）。此外，版本号0.2.0显示项目尚未成熟，且仓库地址为空，社区和维护性存疑。如无特殊优化或独特功能，现有标准库已足够覆盖需求，因此不建议作为生态中的重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"Tianci-King\",\n      \"name\": \"hello\",\n      \"description\": \"median\",\n      \"version\": \"0.2.0\",\n      \"keywords\": [\n        \"median\"\n      ],\n      \"createdAt\": \"2025-01-16T15:46:28.100579+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的功能是计算数组的中位数，这是一个相对基础且常见的数学运算需求。虽然中位数计算在数据分析中有一定应用场景，但大多数主流编程语言的标准库或常用数学库（如Python的statistics/numpy、JavaScript的lodash等）都已提供了高效的实现。\\n\\n分析其代码库现状：1. 文档仅包含基础说明，缺乏API文档和使用示例；2. 没有显示出性能优化或特殊算法（如流式计算中位数等进阶功能）；3. 版本迭代较少（当前版本0.3.0），社区活跃度不足。\\n\\n因此建议开发者优先使用语言标准库或成熟的数学库，该独立代码库在生态中的必要性较低，不建议作为重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"Tianci-King\",\n      \"name\": \"median\",\n      \"description\": \"计算数组的中位数\",\n      \"version\": \"0.3.0\",\n      \"keywords\": [\n        \"median\"\n      ],\n      \"createdAt\": \"2025-01-16T15:57:43.472065+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库实现了一个使用牛顿迭代法计算平方根的函数，虽然其功能正确，但存在多个问题：1. 文档不完整，README仅有简单代码示例缺乏详细使用说明与API文档；2. 功能过于基础，平方根计算属于编程语言标准库的标配功能（如Python的math.sqrt），重复造轮子价值有限；3. 代码实现缺乏优化亮点，未体现比标准库更优秀的特点（如更高精度或更快速度）；4. 项目结构不完整，无测试用例和性能基准，难以保证可靠性。综合来看不具备作为重要生态库保留的必要性。\",\n    \"metadata\": {\n      \"author\": \"WenqiChen3019\",\n      \"name\": \"sqrt\",\n      \"description\": \"\",\n      \"version\": \"0.1.4\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-25T09:36:33.171676+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的描述、关键词和文档信息都比较缺乏，整体内容较为简单。唯一的函数是'hello'，可能只是一个示例或占位符代码，并未体现具体的功能或解决实际问题的能力。没有明确的说明和实际应用场景，且代码规模过小，不足以作为生态中的重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"YHSZ-ONEC\",\n      \"name\": \"yhsz\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-11T13:41:59.854488+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供了一个模糊搜索的基本实现，但存在以下问题：1. 文档不齐全，README仅包含简单示例，缺少API文档和使用说明；2. 功能实现过于基础，没有展示与现有解决方案的差异化优势；3. 测试用例较为简单，缺乏完整性和性能测试；4. 未明确说明适用场景，常规字符串搜索需求大多数语言标准库已覆盖\",\n    \"metadata\": {\n      \"author\": \"Yoorkin\",\n      \"name\": \"fuzzy_search\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"search\"\n      ],\n      \"createdAt\": \"2025-03-27T05:42:51.310533+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"1. 开发者已弃用并建议用户迁移到其他官方维护模块（moonbitlang/x/stack）\\n2. 核心功能为基础数据结构实现，正常情况下应由标准库提供\\n3. 文档存在明显维护警告，持续维护性存疑\\n4. 无特殊性能优化或扩展功能的说明，缺乏竞争力\\n5. 版本迭代停滞，最后一次更新为9个月前（2024-09-04）\\n6. 未发现多平台适配、复杂场景优化等不可替代价值\",\n    \"metadata\": {\n      \"author\": \"Yoorkin\",\n      \"name\": \"stack\",\n      \"description\": \"\",\n      \"version\": \"0.1.4\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-09-04T03:19:26.586011+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的README内容过于简单（仅包含# username/hello），缺乏详细的文档说明。其描述和关键词（test）表明其主要用途可能仅用于测试目的，未明确展示实际需求或独特功能。模块中的功能（如hello函数）未体现出解决复杂问题或提供优于标准库的实现，不符合生态重要代码库的标准。\",\n    \"metadata\": {\n      \"author\": \"Young-Flash\",\n      \"name\": \"try_publish\",\n      \"description\": \"\",\n      \"version\": \"0.1.6\",\n      \"keywords\": [\n        \"test\"\n      ],\n      \"createdAt\": \"2025-03-05T08:40:07.339267+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的功能过于简单，仅包含类似问候语（greeting、hello）的函数，没有实际复杂的功能需求。文档内容不完善，README缺乏详细说明和使用指南。没有明确的关键词和项目描述，缺乏社区或生态价值。此类基础功能通常由简单示例或教程涵盖，不需要独立维护为生态中的重要代码库。\",\n    \"metadata\": {\n      \"author\": \"baobolong\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-11T15:36:48.405017+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的名称为 'sexp'，可能旨在实现S-表达式的处理。提供的元数据如作者、版本等基础信息齐全，但描述和关键词为空，缺乏对功能和用途的说明。文档中仅有标题，没有详细内容，导致用户无法了解库的实际功能和用法。资源中的源代码文件 'types.mbt' 未公开具体实现，难以评估功能完整性和优化程度。尽管S-表达式在某些领域（如Lisp）很重要，但若无文档和具体实现展示其优势或独特性（如高效性、扩展功能），无法判断其必要性。当前信息不足以证明该库在生态中作为重要组件保留的价值。\",\n    \"metadata\": {\n      \"author\": \"bobzhang\",\n      \"name\": \"sexp\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的是一个基础的lower_bound功能实现，虽具备基本的二分查找能力，但存在几个关键问题：1、文档不完整README内容几乎为空，缺乏使用说明及API文档；2、这类算法通常应由标准库统一实现（如大多数语言中的STL或Collections已包含类似功能），除非性能或实现方式上有显著创新但未见描述；3、模块索引显示核心功能代码量可能较小（仅暴露hello和find两个value），功能单一不足以构成独立生态组件；4、缺少必要的单元测试及社区认可迹象。因此作为独立生态库保留的价值较低，更适合作为学习示例或集成到更高层次工具中。\",\n    \"metadata\": {\n      \"author\": \"buggg-hfc\",\n      \"name\": \"hello\",\n      \"description\": \"A easy lower_bound function\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"lower_bound\",\n        \"binary find\"\n      ],\n      \"createdAt\": \"2025-01-23T13:13:26.074126+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该算法库包含基础的DSU（并查集）和Fenwick Tree（树状数组）实现，此类数据结构属于通用算法组件。文档中仅有Dsu的简单示例且缺乏完整API说明及单元测试覆盖率。现有实现功能较基础，未见创新优化（例如路径压缩、按秩合并等高级特性），难以超越标准库实现。项目仓库无详细文档说明，版本号仅0.1.0，维护性不足。建议优先使用标准库或更成熟的通用算法库。\",\n    \"metadata\": {\n      \"author\": \"chhnb\",\n      \"name\": \"algorithm\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-18T13:04:29.916901+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的功能是检查整数是否为质数。虽然基础功能存在，但文档过于简略，仅提供了基本说明，缺乏详细的API文档和使用示例。此外，质数检测作为常见的数学问题，通常应由标准库或成熟的数学库提供，除非实现有显著优化或独特功能。此代码库未体现出性能优化或特殊功能，因此不适合作为生态中的重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"chronostesis\",\n      \"name\": \"check_prime\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-18T08:57:50.533686+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的功能非常简单，仅包含一个'hello'函数，缺乏实际应用场景和必要的文档说明。项目中README内容极为贫乏，无法提供基本使用指南或贡献规范，不符合生态核心库要求的文档完整性。此外，基本打印功能应由语言标准库实现，无需独立维护专门库。版本信息（0.1.0）和未发布的特性表明其处于早期实验阶段，不具备生产级代码的稳定性要求。\",\n    \"metadata\": {\n      \"author\": \"cyhforlight\",\n      \"name\": \"moonbit-hello-card\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-26T17:08:53.071981+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库存在多个不利于保留为生态重要项目的问题。首先，其元数据信息不完整，包括缺少描述（description）、关键词（keywords）、版本库地址（repository）等关键信息，这会降低项目的可发现性和可信度。其次，代码库提供的唯一函数名为'hello'，功能不明确，可能是简单的示例代码，无法解决实际需求，缺乏实用性和独特性。此外，模块索引显示没有定义任何特性（traits）、类型（types）或类型别名（typealias），表明代码库可能处于早期开发或实验阶段，未形成稳定功能模块。文档方面，README仅包含项目名称，缺乏安装指南、使用示例和API文档，无法有效指导用户使用。综合来看，该项目当前状态不符合生态重要代码库的标准，建议进一步明确需求、完善文档并开发有价值的功能后再考虑保留。\",\n    \"metadata\": {\n      \"author\": \"djisnj\",\n      \"name\": \"djisnj\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-11T13:46:47.441234+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库存在多个关键缺陷：1. 核心功能仅有'median'中间值计算功能，属于基础数学范畴且多数语言标准库已覆盖 2. 完全缺乏必要文档说明（README仅包含名称）3. 未提供单元测试和示例代码 4. 版本信息不完整（0.1.1仍属早期阶段）5. 代码结构过于简单且无创新性 6. 模块划分不合理（存在空模块main）。当前状态不能满足生态重要组件标准，建议补充完整功能、文档和测试后再评估。\",\n    \"metadata\": {\n      \"author\": \"dongyvxuan\",\n      \"name\": \"dongyx\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-05T14:17:47.596817+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然涉及字体处理，但主要功能是为各开源字体提供数据模块而非提供字体处理工具或算法。每个字体模块仅包含一个'font'值，缺乏实际字体操作功能如解析、渲染或转换。文档说明集中在许可证和字体存放位置，缺少API文档和使用示例，开发者无法有效集成和使用。此外，该项目将每种字体分散到不同仓库，维护和扩展性差，且需求较为边缘，标准字体库已能满足大部分需求，生态重要性不足。\",\n    \"metadata\": {\n      \"author\": \"gmlewis\",\n      \"name\": \"fonts-p\",\n      \"description\": \"Experimental package to manipulate open source font data.\",\n      \"version\": \"0.15.11\",\n      \"keywords\": [\n        \"html5 canvas\",\n        \"pdf\",\n        \"svg\",\n        \"open source\",\n        \"fonts\"\n      ],\n      \"createdAt\": \"2025-05-09T12:02:37.940424+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库存在以下几个问题：\\n1. 项目描述字段完全为空，缺乏基本的项目说明文档。\\n2. README内容极其简略，仅包含标题，没有使用说明、功能描述等必要信息。\\n3. 代码功能单一，仅包含'greeting'和'hello'这类演示性函数，不具备解决实际问题的技术复杂性。\\n4. 未体现出比标准库更优的算法或功能实现。\\n5. 缺乏版本迭代、测试覆盖、许可证等重要开源项目元素。\\n6. 项目结构和keywords字段均为空白，不利于模块化复用及生态集成。\",\n    \"metadata\": {\n      \"author\": \"hachi\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-08T15:20:56.400167+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库作为排序算法库，但未展示其相较于标准库或现有库的明显优势。其文档内容匮乏（仅有# hachi/sort），缺乏关键功能描述、实现细节及性能基准。功能方面，当前暴露的值如'hello'和'plus'与排序无关，可能存在代码结构混乱或未完成开发的情况。此外，模块层级设计较简单，未体现出处理复杂排序场景的能力。综合来看，该库尚未达到生态中重要代码库的标准，需完善文档、明确核心价值并验证性能优化点。\",\n    \"metadata\": {\n      \"author\": \"hachi\",\n      \"name\": \"sort\",\n      \"description\": \"\",\n      \"version\": \"0.1.12\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-08T15:48:23.168928+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库仅提供摩尔斯电码的编码解码功能，功能较为单一且实现较为基础。CTF工具库通常需要涵盖更广泛的安全领域工具（如加解密、流量分析、逆向工程等），当前功能不足以支撑其作为生态重要代码库。此外，文档和版本信息较为简略（如缺少详细的API文档和使用示例），项目维护和更新情况未知，且社区参与度（如star、fork等指标）未提及，进一步降低其必要性。类似功能可能已存在于更成熟的开源项目（如CyberChef）中。\",\n    \"metadata\": {\n      \"author\": \"hanstechnow\",\n      \"name\": \"ctf_tools\",\n      \"description\": \"CTF toolkit with morsecode encode/decode.\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-15T12:55:49.239999+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的功能是CLI的求和计算，这类基础功能通常由标准库或更成熟的工具提供，且未见明显优化或独特创新。文档较简陋（如README仅标题），依赖较少但未体现必需性。虽然版本更新显示维护，但未能证明其在生态中的必要性或优势。\",\n    \"metadata\": {\n      \"author\": \"hzqdf\",\n      \"name\": \"sum-calc\",\n      \"description\": \"A CLI sum calc.\",\n      \"version\": \"0.0.20250321\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-22T02:01:23.341245+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然尝试提供类似Rust的Copy、Clone等特质和一些类型抽象（如Lazy、Ordering），但存在以下问题：1. 提供的多为基础类型适配实现，无显著创新性，且可能应由标准库提供。2. README文档极为简单，缺少用法示例和设计理念说明。3. 代码库缺乏高价值抽象（如Rep、TypeName等实用价值存疑）。4. 项目描述中提到'以探索语言特性为主、性能不作为优先项'，说明定位是实验性质而非生产级工具。综合来看，暂不具备生态重要代码库的必要性和质量要求。\",\n    \"metadata\": {\n      \"author\": \"illusory0x0\",\n      \"name\": \"base\",\n      \"description\": \"\",\n      \"version\": \"0.2.0\",\n      \"keywords\": [\n        \"functional-programming\"\n      ],\n      \"createdAt\": \"2025-01-18T21:30:57.473790+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供了类型强制转换功能，类似于Haskell的coerce和C++的reinterpret_cast，这类操作通常属于底层、不安全的编程范畴，应由语言本身或标准库提供，而非独立第三方库。文档仅说明功能而无安全警告，存在潜在风险。代码结构简单，功能单一，未体现创新或优化价值，且容易引发误用和内存安全问题，不适合作为生态重要组件保留。此外，现代编程语言应鼓励类型安全而非强制转换，该库可能违背最佳实践。\",\n    \"metadata\": {\n      \"author\": \"illusory0x0\",\n      \"name\": \"coerce\",\n      \"description\": \"Provide coerce functions and examples\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"unsafe\",\n        \"coerce\",\n        \"intrinsic\",\n        \"magic\"\n      ],\n      \"createdAt\": \"2025-01-20T04:33:18.233966+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然在JavaScript与WASM的绑定上有一定实现，但存在以下问题：1. 文档不完整，README内容缺失，影响开发者使用；2. 实现内容多为类型转换与基础对象封装（如ArrayBuffer、Console等），这些功能通常应由标准库或成熟框架(如wasm-bindgen)提供，重复实现意义不大；3. 类型系统覆盖虽广（如Int/UInt各变种），但对于实际应用场景必要性存疑；4. 未体现性能优化或独特功能，无法成为生态必需组件。建议考虑与现有WASM工具链整合而非独立维护。\",\n    \"metadata\": {\n      \"author\": \"illusory0x0\",\n      \"name\": \"jcore\",\n      \"description\": \"JavaScript core library' s wasm binding\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"wasm\",\n        \"ffi\",\n        \"javascript\",\n        \"core\"\n      ],\n      \"createdAt\": \"2025-03-09T03:27:56.469840+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然实现了惰性求值和递归相关功能，但存在以下几个关键问题：\\n1. 核心功能如even/odd判断和斐波那契数列实现过于简单，这类基础功能更适合由语言标准库实现而非第三方库\\n2. 文档质量不足，README主要提供示例链接但缺乏API文档和使用说明\\n3. 示例代码中提到的解析器实现直接参照其他语言版本，没有体现该库的独特价值\\n4. 依赖的运行时环境（如Haskell的Graph Reduction）无法在Moonbit中完全支持，导致真正需要惰性求值的场景实现受限\\n5. 提交记录显示自创建以来没有持续维护迹象，作为生态系统重要库需要活跃的维护团队\\n从设计定位来看，该类库更应作为语言内置特性而非独立生态组件\",\n    \"metadata\": {\n      \"author\": \"illusory0x0\",\n      \"name\": \"lazy\",\n      \"description\": \"a lazy library support recursion\",\n      \"version\": \"0.1.2\",\n      \"keywords\": [\n        \"lazy\",\n        \"lazy recursion\"\n      ],\n      \"createdAt\": \"2025-04-04T00:22:10.991181+00:00\",\n      \"today\": \"2025-05-14T02:49:21.554Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然实现了格式化打印功能，但存在多个关键问题：\\n1. 文档严重缺失（README为空，无使用说明）\\n2. 实现方案未达到生态级要求（依赖项过少，功能覆盖面有限）\\n3. 核心功能与主流pretty printer库相比缺乏创新点\\n4. 类型系统设计未体现高性能或独特优势\\n5. 缺少必要的注释和示例代码\\n建议优先使用经过验证的成熟pretty print解决方案，暂不适合作为生态关键组件保留\",\n    \"metadata\": {\n      \"author\": \"illusory0x0\",\n      \"name\": \"prettyprinter\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-20T01:13:02.659610+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库缺乏清晰的文档和描述，README内容极为简单，未提供任何使用说明或功能简介。其模块仅包含一个无实际用途的'hello'函数，未体现出解决特定需求的能力。此外，未提及任何独特的算法或优于标准库的实现，且需求场景不明确。因此，无法作为生态中的重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"jankin_li\",\n      \"name\": \"Learn_Test1\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-10-21T08:10:16.056674+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库功能极其基础，仅包含'greeting'和'hello'等字符串输出功能，这类简单问候语功能无法构成生态核心组件。说明文档缺失（README仅含基础标题），无详细说明及使用案例。未体现独特算法、业务场景适配或高性能实现，此类功能更适合作为业务代码片段而非独立库。项目信息中keywords/description均为空，缺乏维护迹象，不符合生态重要代码库标准。\",\n    \"metadata\": {\n      \"author\": \"jankin_li\",\n      \"name\": \"new_lib\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-10-22T02:39:11.341304+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然涉及ISO 3166国家代码的数据处理，但现有实现价值较低。README标记为WIP且内容极为简陋，缺乏维护状态说明和基础文档指引。核心代码仅包含四个查询函数和硬编码数据，未展现高效的查询算法或扩展机制。关键模块如数据更新、错误处理、测试覆盖等均未实现。作为国家代码这种标准化数据集，开发者直接采用官方提供的标准库或成熟第三方库更为可靠。当前版本缺乏持续维护的迹象（如Pull Request机制未有效说明），且未达到替代标准库的技术指标。\",\n    \"metadata\": {\n      \"author\": \"justjoheinz\",\n      \"name\": \"iso-country\",\n      \"description\": \"A list of country codes and names in ISO 3166 format\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"iso\",\n        \"country\",\n        \"countries\",\n        \"iso3166\"\n      ],\n      \"createdAt\": \"2025-02-20T08:43:11.427537+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库目前提供的功能非常基础，仅包含简单的问候函数（例如`greeting`和`hello`），这类功能通常在标准库或更复杂的工具库中存在。文档（README.md）内容极为简单，缺乏使用示例和详细说明，不利于用户理解和使用。此外，未提供代码仓库地址与许可证信息，社区维护性和可信度不足。项目描述和关键词过于笼统，无法明确其核心价值或解决的具体问题。综上所述，其功能和文档均未达到生态重要代码库的标准。\",\n    \"metadata\": {\n      \"author\": \"kinoamyfx\",\n      \"name\": \"moon-axe-tools\",\n      \"description\": \"\",\n      \"version\": \"0.0.1-SNAPSHOT\",\n      \"keywords\": [\n        \"lib\",\n        \"tools\",\n        \"common\"\n      ],\n      \"createdAt\": \"2024-12-02T13:00:38.907603+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库名为nanoid，通常用于生成唯一ID，但现有实现过于简单。根据提供的元数据：1. 文档不完善，README仅包含名称，缺乏使用说明和API文档；2. 代码结构简陋，moduleIndex显示仅有new函数，功能不足；3. 依赖项为空，未集成加密安全方法或优化算法；4. 社区信息缺失，如stars、issues等，活跃度存疑。标准库或成熟库（如原nanoid）已提供更健壮、安全、高效的实现。因此不适合作为生态重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"ledao\",\n      \"name\": \"nanoid\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-12-27T07:03:12.404784+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"代码库缺乏足够的文档和说明，README内容极为简单（只有# username/hello），无法帮助用户理解模块功能和用法；代码库描述的组件如gpio和task，其功能通常是ESP32开发的标准库已经提供的，而该代码库未体现出显著的优化或独特功能；此外，未提供详细的示例或实际应用场景说明，导致难以判断其必要性和优势；版本更新记录显示只有0.1.8和0.1.9且频繁发布，可能稳定性不足，故不适合作为生态重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"test_esp32\",\n      \"description\": \"\",\n      \"version\": \"0.1.9\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2025-04-14T03:49:27.793421+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"根据提供的代码库信息，作者名为'lijunchen'，项目名称为'test_postadd2'，版本0.1.1，依赖于'lijunchen/test_postadd' 0.1.0。代码库描述为空，README内容为'test postadd script'，缺乏详细文档。项目中仅包含一个值为'hello'的导出函数，功能过于简单且未体现具体应用场景或必要性，类似测试性质的脚本。此外，postadd脚本仅调用Python3执行build.py，无说明实际用途或优化点。未提及任何创新或解决实际问题的功能，无法作为生态中重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"lijunchen\",\n      \"name\": \"test_postadd2\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [\n        \"mooncakes-test\"\n      ],\n      \"createdAt\": \"2025-04-15T08:04:05.047942+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的功能是'在数字的正确位置插入数字'，这属于非常具体且狭窄的应用场景，通常这类功能更适合作为通用工具库的一部分而非独立生态项目。代码库文档异常简单（仅一句描述），缺乏功能示例、API说明和测试用例，生态贡献能力有限。同时数字插入功能实现复杂度较低，容易被其他通用库覆盖，且标准数学库常规情况下不需要此类独立模块。此外版本更新和社区活跃度等信息缺失，难以证明其维护活跃度。\",\n    \"metadata\": {\n      \"author\": \"littleotherut\",\n      \"name\": \"digit-insert\",\n      \"description\": \"Insert digit into number at the correct position\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-03T14:11:39.285656+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的功能非常基础，仅包含一个简单的'hello'函数，类似于常见的示例代码。没有明确的关键词、详细描述或文档说明，无法确定其解决了什么具体的、有价值的问题。缺乏文档、测试和实际应用场景支持，且功能过于简单，无法成为生态中的重要部分。\",\n    \"metadata\": {\n      \"author\": \"locing112\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.6\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-26T14:11:09.086062+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的功能是寻找列表中的最小值，这通常是编程语言标准库或基础库中的内置功能（例如Python的min函数），无需额外实现。项目文档极为简单，没有详细说明使用场景、API文档或性能优势，缺乏维护和社区支持的迹象。此外，没有明确的版本更新或贡献记录，说明需求可能已被现有标准库覆盖，生态保留价值低。\",\n    \"metadata\": {\n      \"author\": \"luolingkan\",\n      \"name\": \"find_min_num\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-28T08:19:22.047929+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的功能过于基础，仅包含一个名为 'hello' 的函数，没有体现出解决特定需求或复杂问题的能力。文档内容极为简略（仅标题），缺乏使用说明、API文档及示例，无法有效支持开发者集成或贡献。版本信息显示其维护性不足，关键字段如描述、关键词均为空，项目结构和模块索引也未展现创新性或高性能算法。整体来看不具备作为生态重要代码库的条件。\",\n    \"metadata\": {\n      \"author\": \"lyf597\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-27T07:11:09.200855+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库实现了用牛顿迭代法计算的平方根函数，虽然数学方法正确，但存在多个严重缺陷：\\n1. 文档不完整（README中未描述参数定义、精度控制方法、接口说明等关键信息）\\n2. 核心功能覆盖不足（未处理负数、零值等边缘情况）\\n3. 代码结构存疑（存在无关的'hello'导出值）\\n4. 缺乏测试用例和性能基准\\n5. 未能证明相对于标准库实现的优势\\n这类数学函数更适合由语言标准库提供，除非该项目能证明在性能、精度或定制化方面的显著优势。\",\n    \"metadata\": {\n      \"author\": \"misika727\",\n      \"name\": \"sqrt\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-11T12:02:37.165588+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库'moonbit-js-ffi/js'主要提供了MoonBit与JavaScript的FFI库的核心函数和类。分析其模块结构和文件，如array.js.mbt、promise.js.mbt等，功能围绕基本JS数据类型的桥接操作。然而存在以下问题：1) 描述空泛，文档不完整，仅提供文件夹指引而无具体使用说明；2) 缺乏独特创新性，类似FFI桥接功能通常由语言运行时或标准库实现，未体现性能优化或高级抽象；3) 代码库规模较小，未体现复杂场景下的生态价值。此外，许可证Apache-2.0虽合规，但无活跃社区或持续维护迹象，难以作为长期生态核心依赖。\",\n    \"metadata\": {\n      \"author\": \"moonbit-js-ffi\",\n      \"name\": \"js\",\n      \"description\": \"\",\n      \"version\": \"0.2.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-06-13T15:41:51.834985+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的目的是提供一个不使用`println`的abort handler，但功能过于简单且应用场景有限。通常，abort处理应由编程语言的标准库或运行时环境提供，确保稳定性和兼容性。当前提供的`abort`函数未展示独特优势或必要创新，文档（如README）内容简短，缺乏详细说明和使用示例，难以作为生态重要组件维护。若需求仅为最小化依赖，可以通过标准库扩展或其他轻量级方案实现，无需独立代码库。\",\n    \"metadata\": {\n      \"author\": \"moonbitlang\",\n      \"name\": \"dummy_abort\",\n      \"description\": \"\",\n      \"version\": \"0.2.0\",\n      \"keywords\": [\n        \"abort handler\"\n      ],\n      \"createdAt\": \"2025-05-12T08:00:44.027508+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库作为lex运行时的实现，虽然具备词法分析基础功能，但存在以下关键问题：1. 文档严重缺失，README仅有一个标题，没有使用说明和API文档；2. 代码结构简单，功能基础，未展现出优于标准库或其他成熟轮子的竞争力；3. commit记录显示最后一次更新为2025年3月，维护情况存疑；4. 缺少测试用例和示例代码，无法验证可靠性。这类基础组件应优先选用已有成熟解决方案，建议合并到更大的语言工具库或加强自身功能的特有优势。\",\n    \"metadata\": {\n      \"author\": \"moonbitlang\",\n      \"name\": \"lex-runtime\",\n      \"description\": \"\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-07T13:16:36.623930+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该项目为mbt_lexer词法分析器库，存在以下不足：\\n1. 文档缺失：README仅有标题而无实际使用说明\\n2. 功能定位不明确：名称显示和ulex相关但依赖项版本较低（ulex 0.1.0），可能属于实验性质\\n3. 开发完成度低：版本号0.0.1且代码结构显示大量Show trait包装，核心解析逻辑可能未完善\\n4. 未展现创新性：词法生成器属于成熟领域，若仅在标准库包装则生态价值有限\\n建议提供完整文档并证明其性能优势后再评估\",\n    \"metadata\": {\n      \"author\": \"moonbitlang\",\n      \"name\": \"mbt-lexer\",\n      \"description\": \"\",\n      \"version\": \"0.0.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-31T03:07:33.428508+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的功能主要为词法分析相关的工具，如BytesLexbuf和StringLexbuf的实现，这类基础功能通常应由标准库或主流框架提供以确保兼容性和维护性。然而，当前包缺乏详细的文档（README内容仅标题层级）、版本历史碎片化（存在多个小版本发布记录）、无明确使用场景说明及生态定位，且未展示显著的性能优化或创新设计，因此难以证明其作为独立生态重要组件的必要性。此外，缺少社区贡献和持续维护的迹象也会降低长期保留价值。\",\n    \"metadata\": {\n      \"author\": \"moonbitlang\",\n      \"name\": \"ulex-runtime\",\n      \"description\": \"\",\n      \"version\": \"0.4.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-04-21T08:28:20.437751+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的功能较为基础，仅包含一个名为'hello'的函数，未体现出解决特定复杂需求或创新性。开发者未提供详细的文档描述（README内容简短，缺乏使用方法和示例），且项目缺少关键词、描述和版本更新信息。代码库结构简单，模块功能单一，类似功能通常由语言标准库实现，未展示明显优势或扩展性。整体评估不符合生态重要代码库的标准。\",\n    \"metadata\": {\n      \"author\": \"my-xn\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-28T08:22:35.565745+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然提供了Unicode CaseFold功能，但存在多个关键缺陷：1. 文档不完善（README仅提供生成脚本说明而无API文档和使用示例）2. 核心实现内容不足（源码文件显示可能仅为基本映射表实现）3. 缺少社区验证（仅0.1.x版本且无开源协作迹象）4. 基础功能应优先由标准库承载。与成熟案例(如Rust的unicode-casefold)相比，当前完成度不足以作为生态重要组件保留。\",\n    \"metadata\": {\n      \"author\": \"myfreess\",\n      \"name\": \"casefold\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-05-09T09:03:02.528484+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库名为'mbt_LIB'，仅包含一个名为'odd'的功能模块，从描述信息和关键字来看缺乏具体用途说明。根据模块索引显示，当前实现的功能仅包含奇数判断（values:\\\"odd\\\"），此类基础功能通常应由标准库提供，无需单独维护。代码库缺乏文档说明（readme_content为空），无版本历史、许可证信息及代码示例，无法证明其独特价值或实现优势。综合判断其功能单一且标准库可替代，不具备作为生态重要代码库保留的价值。\",\n    \"metadata\": {\n      \"author\": \"nanlingyin\",\n      \"name\": \"mbt_LIB\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-03T11:33:17.981154+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库缺乏必要的基本维护要素：1、文档内容极度匮乏，仅有一个无实际内容的README文件；2、功能模块存在空白，main包內无有效函数导出；3、项目描述和关键词字段均为空，难以体现实际需求场景；4、作为版本0.1.0的初始项目，代码规模仅含一个基础helloworld函数，无法形成独立生态价值；5、缺乏测试用例和贡献指引，不符合现代开源项目规范。此类基础功能应优先通过语言标准库实现而非独立维护。\",\n    \"metadata\": {\n      \"author\": \"orangenin\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-09T08:09:56.240504+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库主要包含解决在线判题系统（如OJ）题目的小型算法问题，例如查找唯一数字、格式化数字字符串、有效括号检测等。这些问题多是针对特定编程练习的场景，功能较为基础和零散，未形成通用、高效的算法库或工具。文档部分仅有基础描述，缺乏详细的API和使用说明。虽然部分题目如Gray码、凯撒密码等具有一定的实用性，但整体来看，这些功能更适合作为练习题或教学示例，而非生态中需保留的重要代码库。建议作为学习资源存档，而非持续维护的核心项目。\",\n    \"metadata\": {\n      \"author\": \"pai2shub\",\n      \"name\": \"alg\",\n      \"description\": \"MoonBit Online Judge Problem Set Solved\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [\n        \"MoonBit\",\n        \"Online Judge\"\n      ],\n      \"createdAt\": \"2025-03-17T01:37:03.529011+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然提供了一些基于Wasm组件模型的IO和HTTP功能，但其文档不完整（README中列有TODO项且缺少详细说明），功能与WASI标准库重叠，并未展现出明显的优势或扩展性。核心功能可能更适合由标准库实现，且尚未实现同步操作等计划功能，不足以作为生态中的重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"peter-jerry-ye\",\n      \"name\": \"io\",\n      \"description\": \"\",\n      \"version\": \"0.3.2\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-05-06T06:19:06.626411+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库（js-ffi）的主要功能是允许MoonBit与JavaScript进行交互，属于特定语言间的桥接工具。但存在以下问题：1. 文档不完善，README仅提供警告和简短描述，缺乏具体使用示例和API说明。2. 项目处于alpha阶段，未经过充分测试和生产验证，稳定性存疑。3. 功能覆盖范围有限，当前仅支持基本类型转换和一些对象操作，对于复杂场景（如异步处理、错误处理）的支持不够完善。4. MoonBit可能已有更成熟的标准库或官方推荐的FFI方案，此库缺乏竞争优势。5. 社区活跃度和维护状况不明，存在项目停滞风险。综上，暂时不适合作为生态重要代码库保留，需进一步功能完善和文档增强。\",\n    \"metadata\": {\n      \"author\": \"rami3l\",\n      \"name\": \"js-ffi\",\n      \"description\": \"\",\n      \"version\": \"0.2.4\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-04-24T03:42:34.150769+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库旨在提供国际化(i18n)支持，但存在几个关键问题：1. README内容极为简略，缺乏基本的使用文档和功能说明，不利于开发者理解和使用。2. 模块结构松散，例如`main`模块中没有任何导出值，功能实现不明确。3. 现有功能如`hello`函数可能过于基础，尚未体现国际化所需的复数处理、日期格式化等复杂需求。4. 没有展示与现有生态的整合或独特优势，难以替代成熟的i18n库。因此，当前版本不足以作为生态中的重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"remain11\",\n      \"name\": \"i18n\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-17T07:00:07.853896+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"这个代码库提供了在列表中查找最大值的功能。然而，查找最大值是一个基础且常见的需求，通常应由编程语言的标准库提供，例如Python的max()函数。虽然该代码库有文档、版本控制和许可证，但并未展示优于标准库的独特优化或额外功能。在生态系统中保留此类重复功能的代码库必要性不大，除非它能提供显著的性能优势或扩展功能。当前的实现似乎未达到这一标准，因此不建议保留。\",\n    \"metadata\": {\n      \"author\": \"shiheat\",\n      \"name\": \"find_max\",\n      \"description\": \"find the maximum value in a list\",\n      \"version\": \"0.3.0\",\n      \"keywords\": [\n        \"find_max\"\n      ],\n      \"createdAt\": \"2025-01-17T05:38:08.746793+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"根据提供的代码库信息，项目名称为Calculator，但没有详细的描述和版本说明，文档内容仅有基本的README，无明显维护痕迹（如仓库地址和许可信息不完全）。该库功能为计算器，属于常见工具类，通常应由标准库或成熟第三方库实现。现有资料未能展示其独特优势或创新点，因此不适合作为生态重要项目保留。\",\n    \"metadata\": {\n      \"author\": \"sjzbxhsj\",\n      \"name\": \"Calculator\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-26T06:44:29.298466+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库在文档和维护状态上存在问题。README内容较为简单，主要是使用说明和开发命令，但关键部分如Usage标记为TODO，缺乏详细的功能说明和API文档。代码库依赖其他特定模块（tiye/quaternion、tiye/dom-ffi），但未提供相关文档或链接，增加了用户理解和使用难度。功能方面，虽然涉及三维图形和数学处理（如四元树、超立方体等），可能满足特定需求，但其实现优劣未明确展示，且属于较为小众的领域，通用性有限。许可证和版本信息完整，但没有社区贡献或测试覆盖信息，维护活跃度不明。综上，文档不完善、依赖不明确及应用场景特殊，不建议作为生态重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"tiye\",\n      \"name\": \"caterfoil\",\n      \"description\": \"\",\n      \"version\": \"0.0.2\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-19T11:20:44.674355+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库为Cirru语言实现的EDN（Extensible Data Notation）解析器，属于特定领域的数据表达式格式支持。但存在以下问题：1. 版本号0.0.8表明项目尚处于早期实验阶段（Experimental port）；2. README中明确标注TODO包含测试和引用实现，说明核心功能尚未完备；3. 文档示例简略，缺乏完整的使用说明和API文档；4. 依赖管理较为薄弱（仅1个解析器依赖）；5. 2025年的创建时间推测可能是mock数据，但结合开发进度判断未达到生态库标准。建议观察发展后再评估。\",\n    \"metadata\": {\n      \"author\": \"tiye\",\n      \"name\": \"cirru-edn\",\n      \"description\": \"Extensible Data Notation in Cirru\",\n      \"version\": \"0.0.8\",\n      \"keywords\": [\n        \"cirru\",\n        \"edn\"\n      ],\n      \"createdAt\": \"2025-04-24T17:35:32.451468+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供了生成词汇表分片索引的实现，虽然看起来是解决分布式系统中排序问题的重要功能，但存在以下问题：\\n1. 文档缺失：README仅提供基本用法示例，没有详细接口说明、算法原理、性能分析或应用场景指导。\\n2. 功能局限性：仅实现两个核心函数key_between和n_key_between，缺乏完善的错误处理机制（仅定义KeyError未说明触发条件）和辅助功能。\\n3. 未体现独特优势：类似分片索引算法已广泛用于分布式系统（如CRDTs），但代码库未展示相比现有实现的性能优势或算法创新性。\\n4. 关键信息缺失：无测试覆盖率报告、基准测试数据和实际应用案例，难以评估稳定性和可靠性。\\n建议补充完整文档、增加测试用例、优化异常处理并发布性能对比数据后再考虑作为生态关键组件。\",\n    \"metadata\": {\n      \"author\": \"tiye\",\n      \"name\": \"lexicon-fractional-index\",\n      \"description\": \"\",\n      \"version\": \"0.0.2\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-11-09T08:21:56.700548+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库名为atomics，提供了原子操作相关的函数如i32_atomic_rmw_cmpxchg、i32_atomic_store等。这类功能通常应由底层语言标准库或运行时环境（如WebAssembly）原生支持，而自行实现的原子操作可能存在兼容性和稳定性风险。文档极度匮乏（README只有占位符），无详细说明和测试用例，缺乏维护迹象（如仓库、许可证信息不完整）。核心功能定位与生态需求重叠，且未体现出优于标准实现的优势，因此不建议保留为重要生态库。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"atomics\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-12-25T09:28:26.604533+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然提供了C语言FFI绑定功能，但定位存在问题。C语言FFI绑定属于底层基础设施，通常应由编程语言标准库或官方工具链提供（如Rust的libc），第三方独立实现的绑定库可能导致兼容性问题和维护困难。当前仓库文档内容单薄缺乏详细功能说明，版本号0.1.13显示尚处早期阶段，模块索引中未发现实际功能结构体或函数暴露。且仓库名称‘c’在包管理系统中可能产生命名冲突，综上判断其生态价值不足建议不保留为重要代码库。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"c\",\n      \"description\": \"FFI Binding to C\",\n      \"version\": \"0.1.13\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-04-14T03:11:37.884054+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的主要功能是提供MoonBit语言与JavaScript的互操作性支持，包括基础类型的转换（如数组、对象、字符串等）以及JavaScript值的封装和转换。这属于语言交互的核心功能，理论上存在真实需求，但分析其实现发现：\\n1. 文档非常匮乏，README仅有一句简单描述，缺乏使用示例和API文档；\\n2. 核心功能如语言互操作通常应该由标准库或官方工具链提供，社区维护可能难以保证兼容性；\\n3. 代码库的代码量较少（仅有几个基础类型的封装），且未体现出明显的创新性或性能优势；\\n4. version 0.2.1显示项目尚处早期阶段，生态维护可能不成熟。虽然需求存在，但缺乏必要的文档和官方支持，不建议作为生态重要组件保留。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"js\",\n      \"description\": \"\",\n      \"version\": \"0.2.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-04-04T08:21:01.438922+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的文档不齐全，描述和README.md内容非常简略，缺乏必要的使用说明和功能描述。代码提供的内容较少，仅有一个名为hello的函数值，但具体功能不明确。项目缺少足够的关键词和分类信息，难以判断其具体用途和必要性。此外，没有明确的存储库链接，降低了透明度和可维护性。目前的代码量和功能不足以证明其作为生态中重要代码库的保留价值。需要进一步补充文档、明确需求背景和扩展功能模块。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"submodule-test\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-04-02T06:56:14.553567+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库是Tree-sitter的C语言语法解析器，用于在编辑器等工具中实现语法高亮和代码分析。虽然这类库在生态中有其作用，但可能存在以下问题：1. 作为特定语言的解析器，其需求通常应由标准工具链或广泛维护的社区项目覆盖；2. 代码库依赖他人维护的tree_sitter_language包，可能存在维护风险；3. 文档缺失（readme_content为空），不利于用户理解和使用；4. 虽然版本更新频繁，但未明显提及独特优势或性能提升，难以判断是否优于其他同类实现。建议优先选用更成熟、文档齐全的替代品。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"tree_sitter_c\",\n      \"description\": \"\",\n      \"version\": \"0.1.15\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-05-09T09:33:51.566990+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该库 tree_sitter_css 作为 Tree-sitter 的 CSS 语法解析器，属于生态基础设施。功能定位准确且需求真实存在，解析器对 IDE/编辑器语法高亮非常重要。但版本号显示处于开发阶段(0.1.x)，发布历史简单说明社区活跃度不足，文档不完整（readme_content 为空），缺少使用说明和示例，影响开发者集成。虽然核心功能必要但维护状态待观察，建议补充完善文档并建立持续维护机制后保留。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"tree_sitter_css\",\n      \"description\": \"\",\n      \"version\": \"0.1.15\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-05-09T09:33:49.679615+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库是为Tree-sitter的Java语法解析器提供绑定，确实解决了特定需求。但检查资源文件发现主要包含语法定义和生成的解析器代码（parser.c, wasm等），这些通常应由Tree-sitter官方维护。虽然版本迭代较多，但文档内容为空（readme_content为空），缺乏使用说明和示例，不符合生态重要项目的文档要求。此外，作为语言解析工具，开发者更倾向使用官方维护的版本以确保兼容性和长期支持。因此该项目缺乏独特性及完善文档，不适合作为生态重要代码库保留。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"tree_sitter_java\",\n      \"description\": \"\",\n      \"version\": \"0.1.15\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-05-09T09:33:36.930484+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供了一个树状语法分析语言类型，用于生成的tree-sitter绑定。但存在几个关键问题：1. 缺乏详细说明文档（Readme仅一标题），无法指导用户使用。2. 项目内容过于狭窄，仅定义基础类型且无具体实现示例。3. 实际应用场景不明确，tree-sitter生态已有成熟类型定义，该库未体现差异化优势。4. 未展示性能优化或独特功能，替代性较强。因此该库不具备成为重要生态组件的必要性和竞争力。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"tree_sitter_language\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-02T10:00:19.602947+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库看似是用于处理Markdown内联语法的Tree-sitter语法解析器，通常Tree-sitter需要特定语法定义来支持编辑器的高亮和解析功能。然而，核心问题在于：1. 文档不完整（readme_content为空），缺乏使用说明和示例，难以被开发者有效使用。2. Markdown的内联语法解析已是成熟需求，但大多数主流编辑器或解析库（如remark、markdown-it等）已实现了良好的支持，且Tree-sitter官方可能已有相关实现。3. 包依赖仅有一个内部库，社区维护性和可扩展性存疑。4. 虽然包含WASM文件可能优化了性能，但没有显著优于现有解决方案的证据。综上，该项目在文档、必要性、生态整合等方面存在不足，暂不建议作为重要生态库保留。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"tree_sitter_markdown_inline\",\n      \"description\": \"\",\n      \"version\": \"0.1.15\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-05-09T09:33:20.739612+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库tree_sitter_query尽管具备完整的模块结构和发布版本，但其核心功能存在冗余性风险。首先，Tree-sitter作为成熟语法解析工具，查询功能通常应由官方库提供支持，未见文档明确说明相比官方实现的优势。其次，模块索引显示未导出任何有效类型或接口，文档缺失说明具体应用场景。最后，binding.mbt等文件指向语法解析器的直接复用，未见创新性功能实现，无法证明能提供超越原生态系统的价值。建议优先使用官方维护的查询组件。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"tree_sitter_query\",\n      \"description\": \"\",\n      \"version\": \"0.1.15\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-05-09T09:33:30.874066+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库 tree_sitter_tsx 是为 Tree-sitter 语法解析器提供 TypeScript TSX 支持的绑定库。虽然 Tree-sitter 是生态中的重要工具，但此类语法解析器绑定通常应由官方或社区广泛维护的项目提供支持。查询其仓库链接实际指向 tree-sitter-typescript 官方仓库，说明该库可能只是官方实现的分包或镜像版本。此外，从元数据看，该库文档缺失（readme_content 为空）、维护者个人账户下发布，依赖单一且版本更新局限于补丁级别，缺乏持续维护的迹象。对于关键基础设施类库，生态更依赖官方统一维护的权威版本，个人镜像库容易导致生态碎片化。因此，该代码库不具备作为重要生态保留的必要性。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"tree_sitter_tsx\",\n      \"description\": \"\",\n      \"version\": \"0.1.15\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-05-09T09:33:46.130881+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库虽然提供了一些WebAssembly相关的功能模块（如内存操作、原子操作、数据加载存储等），但存在以下关键问题：1. 项目文档极其匮乏（README仅包含标题），缺乏基本的使用说明和API文档；2. 核心功能重复造轮子，大多数内存操作和数据类型处理本应由WASM标准库或运行时环境提供；3. 缺乏明确的差异化功能，看不出其在生态中的独特价值；4. 代码组织混乱，存在遗留文件（ignore.mbt）未清理。这类基础功能模块更适合作为标准库的补充而非独立生态项目维护。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"wasm\",\n      \"description\": \"\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-18T11:10:25.644457+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供JavaScript互操作的绑定功能，这是一个真实的需求，尤其是在需要与现有JavaScript代码或库集成的场景。然而，存在几个重要问题：1. 文档不齐全，README仅包含基本描述，缺乏使用示例和API文档；2. 功能实现较为基础，目前只涵盖了对象、数组和字符串的基本操作，可能不足以成为生态中的重要依赖；3. 代码库的维护性和社区支持情况不明确，创建时间和更新频率未知，可能影响长期可持续性。建议完善文档并扩展功能后再评估其作为核心库的潜力。\",\n    \"metadata\": {\n      \"author\": \"tonyfettes\",\n      \"name\": \"js\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-08T01:44:24.718799+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库实现了计数排序、基数排序和桶排序，但排序算法通常应由标准库提供，除非有显著的优化或独特功能。当前版本仅支持整数数组，且计划中的泛型实现尚未完成。虽然提到了低时间复杂度，但未提供具体性能数据或基准测试证明其优势。文档较为基础，缺乏详细的使用示例和API说明，可能会影响开发者采用。此外，未提及与其他库的集成或实际应用场景，难以证明其作为生态中重要代码库的必要性。\",\n    \"metadata\": {\n      \"author\": \"wangjuwudi\",\n      \"name\": \"line_sort\",\n      \"description\": \"some functions about line sort\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"sort\",\n        \"low time complexity\"\n      ],\n      \"createdAt\": \"2025-02-15T04:15:52.805772+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"根据提供的信息，该代码库名为'compare'，功能可能涉及比较操作，但目前文档仅有一个占位符README，缺乏关键描述、安装说明和用例。元数据中描述字段为空，关键字也未定义，导致用途不明确。提供的函数如'compare_and_print'可能是基础的数值或数据比较功能，这类功能通常已由标准库或常用库覆盖，除非实现方法独特或性能优化显著，但缺乏相关文档证明其优越性。作为生态中的重要代码库需具备明确需求、充分文档和实际应用场景，此项目未达到标准。\",\n    \"metadata\": {\n      \"author\": \"wjy030522\",\n      \"name\": \"compare\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-09T00:19:19.933826+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的功能非常简单，仅包含一个问候函数，未体现足够复杂性或独特性。缺乏文档（README内容为空）、仓库链接及详细描述，关键元数据如许可证和版本信息虽存在但未弥补功能单一性问题。此类基础功能更适合整合到现有工具库而非独立维护，建议增加实际功能或文档后重新评估。\",\n    \"metadata\": {\n      \"author\": \"wjy030522\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-09T00:26:24.793249+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库存在多个不适合作为重要生态项目保留的问题：1. 功能代码极为简单（仅一个‘hello’函数），未解决实际复杂需求。2. 项目描述、文档完全缺失（README仅剩标题），不符合开源项目规范。3. 依赖项空白，缺乏生态整合性。4. 关键元信息如许可证声明不完整。5. 未包含任何类型定义或高级功能模块，代码价值过低。此类基础代码更适合作为示例项目而非核心依赖库。\",\n    \"metadata\": {\n      \"author\": \"wstreet\",\n      \"name\": \"moontest\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-10-21T03:15:18.852797+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的字符串转整数功能是编程中常见的需求，通常由标准库或内置函数实现（如JavaScript的parseInt、Python的int()）。没有明显的性能优化或扩展功能说明（如自定义进制解析、错误处理增强），且文档和资源信息较为基础。此类基础转换功能建议直接使用语言原生支持方案，单独维护生态包的收益较低。\",\n    \"metadata\": {\n      \"author\": \"wwj1203\",\n      \"name\": \"string2int\",\n      \"description\": \"This is a package that make a string to integer conversion.\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\n        \"string2int\"\n      ],\n      \"createdAt\": \"2025-01-21T14:15:17.500549+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库存在以下问题：1. 缺乏关键文档，README内容极其简单，未描述功能和使用方法；2. 代码库功能模糊，模块仅包含'greeting'和'hello'等演示性函数，未体现实际应用场景；3. 依赖关系薄弱（仅依赖一个未知库），且未展示独特技术优势；4. 未提供版本更新说明和社区贡献指南，生态价值不足。\",\n    \"metadata\": {\n      \"author\": \"wzzc-dev\",\n      \"name\": \"teager\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-22T07:19:19.104379+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库作为生态中的重要代码库存在的理由不足。首先，描述、关键词和文档几乎为空，导致用户难以理解项目用途和功能。其次，虽然涉及Webview和FFI，但现有功能如创建、销毁、运行窗口和设置基本属性，多为基础操作，且没有展示创新点或优于现有解决方案的地方。第三方Webview库（如webview、tauri等）通常功能更丰富、文档完善且社区活跃。此外，项目缺乏明确的用例或独特价值，难以吸引开发者和维护者，贡献度有限。因此，除非项目能显著提升功能或文档，否则不适合作为重要生态库保留。\",\n    \"metadata\": {\n      \"author\": \"wzzc-dev\",\n      \"name\": \"webview-ffi\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-07T05:58:58.518561+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库不具备作为生态重要组件保留的条件。主要问题包括：1. 项目描述缺失（description为空）且缺乏完善的文档说明（README仅包含简单命令无功能描述）；2. 代码量过少（仅含hello函数且结构简单）功能单一，主要用作示例demo；3. 核心功能依赖第三方库webview-ffi，未体现出独特的实现价值；4. 无版本更新记录且缺乏测试构建流程说明，维护性不足；5. 类似网页视图功能应由成熟框架实现，当前实现未展示优化或创新之处。综上，该项目更适合作为示例代码而非生态基石。\",\n    \"metadata\": {\n      \"author\": \"wzzc-dev\",\n      \"name\": \"webview-mbt-demo\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-05T02:39:18.680768+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"这个代码库提供了一个计算数组元素和的函数，但功能过于简单，属于基础操作。类似功能通常由标准库提供，无需单独维护。文档中存在版本号不一致（0.2.2 vs 0.1.1）、仓库地址混乱等问题，且描述信息不完整。项目结构仅包含少数基础函数，缺乏复杂性和实用价值，不符合生态重要代码库标准。\",\n    \"metadata\": {\n      \"author\": \"xavier865\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.2.2\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-01-24T13:30:42.611548+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的功能非常有限，仅包含一个名为'hello'的函数，文档和描述均不完善。README内容不完整且存在乱码，缺乏基本的使用说明和示例。此外，没有明确的需求场景或问题解决目标，无法确定其实用性。因此，该代码库不符合作为重要生态项目保留的标准。\",\n    \"metadata\": {\n      \"author\": \"xing0818\",\n      \"name\": \"xing0818\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-11T13:31:44.729211+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库实现了数组的排列相关功能，包括生成下一个/上一个字典序排列和检查排列关系。虽然这些功能在某些场景下有用，但通常属于标准库或算法库的范畴，比如C++的STL就有`next_permutation`和`prev_permutation`。除非实现具有显著的性能优化或Moonbit语言缺乏标准库支持，否则作为独立生态库的必要性不足。此外，文档虽然提供了基本示例，但缺乏深入的API说明、性能基准测试和贡献指南，降低了长期维护的可能性。建议评估Moonbit标准库是否已涵盖此类功能，若未覆盖则需要补充更完整的文档和测试用例以增强生态价值。\",\n    \"metadata\": {\n      \"author\": \"xunyoyo\",\n      \"name\": \"permutation\",\n      \"description\": \"Array permutation.\",\n      \"version\": \"0.1.3\",\n      \"keywords\": [],\n      \"createdAt\": \"2024-11-17T16:19:56.797966+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库作为MoonBit包管理示例文件，功能单一且示范性质明显，主要展示模块导入和基本问候功能。虽文档结构清晰，但核心功能过于基础（打印问候语），类似功能通常应由标准库实现或作为教学案例。未体现高性能算法或复杂场景解决能力，不具备生态重要代码库的必要性。\",\n    \"metadata\": {\n      \"author\": \"yangqing\",\n      \"name\": \"hello\",\n      \"description\": \"MoonBit package management example file.\",\n      \"version\": \"0.2.2\",\n      \"keywords\": [\n        \"hello\",\n        \"greeting\",\n        \"moonbit\"\n      ],\n      \"createdAt\": \"2024-09-26T08:29:03.308888+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供了min和max功能，这些功能通常是编程语言标准库中的基础功能。作者提供的文档信息不足（仅含有空描述和基础README），且代码库没有体现显著的性能优化、特殊算法或扩展功能。代码库缺乏实际生态价值，建议优先使用语言内置函数或更成熟的数值处理库。\",\n    \"metadata\": {\n      \"author\": \"yanyeting\",\n      \"name\": \"minmax\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-03T14:38:28.199589+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库作为树状数组的实现，其核心功能可能已由标准库或其他成熟库提供。文档不足（仅README内容为‘树状数组’），缺乏详细说明和使用示例，难以支持用户有效使用。代码库结构简单，提供的功能模块中只有`lib`模块包含一个`hello`值，未展示实际实现的树状数组功能，可能未完成或功能不完整。此外，版本号0.1.1表明项目处于早期阶段，稳定性和可靠性存疑。综合来看，当前状态不足以成为生态中的重要代码库。\",\n    \"metadata\": {\n      \"author\": \"yueTc\",\n      \"name\": \"Binary-Indexed-Tree\",\n      \"description\": \"\",\n      \"version\": \"0.1.1\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-27T12:22:58.365476+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库目前作为生态重要项目的保留价值不足，主要原因如下：\\n1. 功能定位不明确：虽标注为\\\"Personal Utils\\\"，但实现了Monad transformers (如Reader)、容器类型(如Many)、字符串处理(Hex/ULID)等较为通用的函数式编程工具，但缺乏核心创新点，与现有moonbit生态的标准库和主流第三方库存在较大重叠。\\n2. 文档严重缺失：README仅有一个WIP标题，无任何使用说明、API文档或示例代码，极大阻碍开发者采用和维护。\\n3. 结构合理性存疑：如同时存在Predicate和Prediate（疑似拼写错误）类型，Ulid模块与标准UUID库功能重复但实现不完善，存在代码质量问题。\\n4. 应用场景不清晰：虽包含实用工具，但未能体现解决特定领域痛点的能力，例如cedar前缀树模块未与具体应用场景（如路由匹配）深度整合，难以体现独特性。\",\n    \"metadata\": {\n      \"author\": \"yuyi919\",\n      \"name\": \"shared-lib\",\n      \"description\": \"[WIP] Personal Utils\",\n      \"version\": \"0.1.6\",\n      \"keywords\": [\n        \"utility\"\n      ],\n      \"createdAt\": \"2025-03-26T03:19:59.618539+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库提供的功能为'hello'，通常是一个简单的示例或测试项目，缺乏实际生产价值。没有详细文档描述（README内容仅有标题），未提及解决的问题或独特优势，需求场景不明确。作为模块没有展示高级功能或优于标准库的实现，不足以成为生态中的重要项目。建议补充实际功能和完善文档后再评估。\",\n    \"metadata\": {\n      \"author\": \"yxsql74\",\n      \"name\": \"hello\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-03-06T12:01:42.137785+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  },\n  {\n    \"verify\": false,\n    \"reason\": \"该代码库的功能是计算阶乘，这是一个非常基础且常见的数学运算，通常在编程语言的标准库或数学库中都有实现。代码库的文档非常简单，仅有最基本的README文件且内容为空，缺乏使用示例、API文档和贡献指南等重要信息。项目的元数据中缺少描述、关键词和仓库链接，这降低了其可发现性和可信度。此外，除非该实现有特殊的优化或算法改进（如并行计算、大数处理等），否则作为独立生态库的价值有限。建议将此功能整合到更广泛的数学工具库中，而非单独维护。\",\n    \"metadata\": {\n      \"author\": \"zhangshun-123\",\n      \"name\": \"factorial\",\n      \"description\": \"\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [],\n      \"createdAt\": \"2025-02-24T09:53:38.805498+00:00\",\n      \"today\": \"2025-05-14T02:49:21.555Z\"\n    }\n  }\n]";
const moonbitlang$mooncakes$page$home$$decode_module_indices$46$42$bind$124$111 = "/";
const moonbitlang$mooncakes$view$tree$$view$46$collapsed$124$15 = "border-t-[4px] border-t-transparent border-l-[6px] border-l-gray-400 border-b-[4px] border-b-transparent";
const illusory0x0$fuzzy_match$$the_one_and_only = { found: false, start_idx: 0, end_idx: 0 };
const illusory0x0$fuzzy_match$$new$46$42$bind$124$264 = " ";
const moonbitlang$mooncakes$page$docs$$load$46$42$bind$124$948 = "/";
const moonbitlang$mooncakes$page$docs$$load$46$42$bind$124$957 = "Documentation";
const moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1467 = "Package";
const moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1470 = "Trait";
const moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1473 = "Type";
const moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1476 = "Method";
const moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1479 = "Typealias";
const moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1482 = "Value";
const moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1485 = "Type";
const moonbitlang$mooncakes$page$docs$$find_node$46$42$bind$124$1534 = "/";
const moonbitlang$mooncakes$page$docs$$find_node$46$42$bind$124$1535 = "/";
const moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1767 = "/";
const moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1766 = "/";
const moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1764 = "/";
const moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1765 = "/";
const moonbitlang$mooncakes$page$docs$$card_mode_toggle$46$img_class$124$420 = "w-[15px] h-[15px]";
const moonbitlang$mooncakes$page$docs$$card_mode_toggle$46$btn_focused$124$421 = "border border-mooncake2 bg-opacity-10 bg-yellow-500";
const moonbitlang$mooncakes$page$docs$$card_mode_toggle$46$lbtn_normal$124$422 = "border-y border-l hover:border-mooncake2";
const moonbitlang$mooncakes$page$docs$$card_mode_toggle$46$rbtn_normal$124$423 = "border-y border-r hover:border-mooncake2";
const moonbitlang$mooncakes$page$docs$$misc_doc$46$package_link_class$124$124 = "font-roboto text-sm px-1 py-[1px] bg-yellow-600 bg-opacity-20 hover:bg-opacity-30 rounded";
const moonbitlang$mooncakes$page$docs$$meta_info$46$42$bind$124$2339 = "/";
const moonbitlang$mooncakes$page$docs$$source_list$46$42$bind$124$2436 = "/";
const moonbitlang$mooncakes$main$$route$46$42$bind$124$82 = "/";
const moonbitlang$core$json$$non_ascii_whitespace = moonbitlang$core$json$$CharClass$of([{ _0: 160, _1: 160 }, { _0: 5760, _1: 5760 }, { _0: 8192, _1: 8202 }, { _0: 8232, _1: 8233 }, { _0: 8239, _1: 8239 }, { _0: 8287, _1: 8287 }, { _0: 12288, _1: 12288 }, { _0: 65279, _1: 65279 }]);
const moonbitlang$core$double$$neg_infinity = moonbitlang$core$int64$$Int64$reinterpret_as_double($_4503599627370496L);
const moonbitlang$core$double$$not_a_number = moonbitlang$core$int64$$Int64$reinterpret_as_double($9221120237041090561L);
const moonbitlang$core$double$$infinity = moonbitlang$core$int64$$Int64$reinterpret_as_double($9218868437227405312L);
const moonbitlang$core$strconv$$max_mantissa_fast_path = moonbitlang$core$builtin$$Shl$op_shl$6$($2L, 52);
const rami3l$cmark$cmark_base$$curr_id = moonbitlang$core$ref$$Ref$new$7$(0);
const rami3l$cmark$cmark_base$$text_loc_none = { file: rami3l$cmark$cmark_base$$file_path_none, first_byte: -1, last_byte: -1, first_line: rami3l$cmark$cmark_base$$line_pos_none, last_line: rami3l$cmark$cmark_base$$line_pos_none };
const rami3l$cmark$cmark_base$$meta_none = rami3l$cmark$cmark_base$$Meta$new(rami3l$cmark$cmark_base$$Meta$new$46$loc$46$default());
const rami3l$cmark$char$$html_named_entities = moonbitlang$core$json$$Json$object(moonbitlang$core$builtin$$Map$from_array$8$([{ _0: "AElig", _1: moonbitlang$core$json$$Json$string("Æ") }, { _0: "AMP", _1: moonbitlang$core$json$$Json$string("&") }, { _0: "Aacute", _1: moonbitlang$core$json$$Json$string("Á") }, { _0: "Abreve", _1: moonbitlang$core$json$$Json$string("Ă") }, { _0: "Acirc", _1: moonbitlang$core$json$$Json$string("Â") }, { _0: "Acy", _1: moonbitlang$core$json$$Json$string("А") }, { _0: "Afr", _1: moonbitlang$core$json$$Json$string("𝔄") }, { _0: "Agrave", _1: moonbitlang$core$json$$Json$string("À") }, { _0: "Alpha", _1: moonbitlang$core$json$$Json$string("Α") }, { _0: "Amacr", _1: moonbitlang$core$json$$Json$string("Ā") }, { _0: "And", _1: moonbitlang$core$json$$Json$string("⩓") }, { _0: "Aogon", _1: moonbitlang$core$json$$Json$string("Ą") }, { _0: "Aopf", _1: moonbitlang$core$json$$Json$string("𝔸") }, { _0: "ApplyFunction", _1: moonbitlang$core$json$$Json$string("⁡") }, { _0: "Aring", _1: moonbitlang$core$json$$Json$string("Å") }, { _0: "Ascr", _1: moonbitlang$core$json$$Json$string("𝒜") }, { _0: "Assign", _1: moonbitlang$core$json$$Json$string("≔") }, { _0: "Atilde", _1: moonbitlang$core$json$$Json$string("Ã") }, { _0: "Auml", _1: moonbitlang$core$json$$Json$string("Ä") }, { _0: "Backslash", _1: moonbitlang$core$json$$Json$string("∖") }, { _0: "Barv", _1: moonbitlang$core$json$$Json$string("⫧") }, { _0: "Barwed", _1: moonbitlang$core$json$$Json$string("⌆") }, { _0: "Bcy", _1: moonbitlang$core$json$$Json$string("Б") }, { _0: "Because", _1: moonbitlang$core$json$$Json$string("∵") }, { _0: "Bernoullis", _1: moonbitlang$core$json$$Json$string("ℬ") }, { _0: "Beta", _1: moonbitlang$core$json$$Json$string("Β") }, { _0: "Bfr", _1: moonbitlang$core$json$$Json$string("𝔅") }, { _0: "Bopf", _1: moonbitlang$core$json$$Json$string("𝔹") }, { _0: "Breve", _1: moonbitlang$core$json$$Json$string("˘") }, { _0: "Bscr", _1: moonbitlang$core$json$$Json$string("ℬ") }, { _0: "Bumpeq", _1: moonbitlang$core$json$$Json$string("≎") }, { _0: "CHcy", _1: moonbitlang$core$json$$Json$string("Ч") }, { _0: "COPY", _1: moonbitlang$core$json$$Json$string("©") }, { _0: "Cacute", _1: moonbitlang$core$json$$Json$string("Ć") }, { _0: "Cap", _1: moonbitlang$core$json$$Json$string("⋒") }, { _0: "CapitalDifferentialD", _1: moonbitlang$core$json$$Json$string("ⅅ") }, { _0: "Cayleys", _1: moonbitlang$core$json$$Json$string("ℭ") }, { _0: "Ccaron", _1: moonbitlang$core$json$$Json$string("Č") }, { _0: "Ccedil", _1: moonbitlang$core$json$$Json$string("Ç") }, { _0: "Ccirc", _1: moonbitlang$core$json$$Json$string("Ĉ") }, { _0: "Cconint", _1: moonbitlang$core$json$$Json$string("∰") }, { _0: "Cdot", _1: moonbitlang$core$json$$Json$string("Ċ") }, { _0: "Cedilla", _1: moonbitlang$core$json$$Json$string("¸") }, { _0: "CenterDot", _1: moonbitlang$core$json$$Json$string("·") }, { _0: "Cfr", _1: moonbitlang$core$json$$Json$string("ℭ") }, { _0: "Chi", _1: moonbitlang$core$json$$Json$string("Χ") }, { _0: "CircleDot", _1: moonbitlang$core$json$$Json$string("⊙") }, { _0: "CircleMinus", _1: moonbitlang$core$json$$Json$string("⊖") }, { _0: "CirclePlus", _1: moonbitlang$core$json$$Json$string("⊕") }, { _0: "CircleTimes", _1: moonbitlang$core$json$$Json$string("⊗") }, { _0: "ClockwiseContourIntegral", _1: moonbitlang$core$json$$Json$string("∲") }, { _0: "CloseCurlyDoubleQuote", _1: moonbitlang$core$json$$Json$string("”") }, { _0: "CloseCurlyQuote", _1: moonbitlang$core$json$$Json$string("’") }, { _0: "Colon", _1: moonbitlang$core$json$$Json$string("∷") }, { _0: "Colone", _1: moonbitlang$core$json$$Json$string("⩴") }, { _0: "Congruent", _1: moonbitlang$core$json$$Json$string("≡") }, { _0: "Conint", _1: moonbitlang$core$json$$Json$string("∯") }, { _0: "ContourIntegral", _1: moonbitlang$core$json$$Json$string("∮") }, { _0: "Copf", _1: moonbitlang$core$json$$Json$string("ℂ") }, { _0: "Coproduct", _1: moonbitlang$core$json$$Json$string("∐") }, { _0: "CounterClockwiseContourIntegral", _1: moonbitlang$core$json$$Json$string("∳") }, { _0: "Cross", _1: moonbitlang$core$json$$Json$string("⨯") }, { _0: "Cscr", _1: moonbitlang$core$json$$Json$string("𝒞") }, { _0: "Cup", _1: moonbitlang$core$json$$Json$string("⋓") }, { _0: "CupCap", _1: moonbitlang$core$json$$Json$string("≍") }, { _0: "DD", _1: moonbitlang$core$json$$Json$string("ⅅ") }, { _0: "DDotrahd", _1: moonbitlang$core$json$$Json$string("⤑") }, { _0: "DJcy", _1: moonbitlang$core$json$$Json$string("Ђ") }, { _0: "DScy", _1: moonbitlang$core$json$$Json$string("Ѕ") }, { _0: "DZcy", _1: moonbitlang$core$json$$Json$string("Џ") }, { _0: "Dagger", _1: moonbitlang$core$json$$Json$string("‡") }, { _0: "Darr", _1: moonbitlang$core$json$$Json$string("↡") }, { _0: "Dashv", _1: moonbitlang$core$json$$Json$string("⫤") }, { _0: "Dcaron", _1: moonbitlang$core$json$$Json$string("Ď") }, { _0: "Dcy", _1: moonbitlang$core$json$$Json$string("Д") }, { _0: "Del", _1: moonbitlang$core$json$$Json$string("∇") }, { _0: "Delta", _1: moonbitlang$core$json$$Json$string("Δ") }, { _0: "Dfr", _1: moonbitlang$core$json$$Json$string("𝔇") }, { _0: "DiacriticalAcute", _1: moonbitlang$core$json$$Json$string("´") }, { _0: "DiacriticalDot", _1: moonbitlang$core$json$$Json$string("˙") }, { _0: "DiacriticalDoubleAcute", _1: moonbitlang$core$json$$Json$string("˝") }, { _0: "DiacriticalGrave", _1: moonbitlang$core$json$$Json$string("`") }, { _0: "DiacriticalTilde", _1: moonbitlang$core$json$$Json$string("˜") }, { _0: "Diamond", _1: moonbitlang$core$json$$Json$string("⋄") }, { _0: "DifferentialD", _1: moonbitlang$core$json$$Json$string("ⅆ") }, { _0: "Dopf", _1: moonbitlang$core$json$$Json$string("𝔻") }, { _0: "Dot", _1: moonbitlang$core$json$$Json$string("¨") }, { _0: "DotDot", _1: moonbitlang$core$json$$Json$string("⃜") }, { _0: "DotEqual", _1: moonbitlang$core$json$$Json$string("≐") }, { _0: "DoubleContourIntegral", _1: moonbitlang$core$json$$Json$string("∯") }, { _0: "DoubleDot", _1: moonbitlang$core$json$$Json$string("¨") }, { _0: "DoubleDownArrow", _1: moonbitlang$core$json$$Json$string("⇓") }, { _0: "DoubleLeftArrow", _1: moonbitlang$core$json$$Json$string("⇐") }, { _0: "DoubleLeftRightArrow", _1: moonbitlang$core$json$$Json$string("⇔") }, { _0: "DoubleLeftTee", _1: moonbitlang$core$json$$Json$string("⫤") }, { _0: "DoubleLongLeftArrow", _1: moonbitlang$core$json$$Json$string("⟸") }, { _0: "DoubleLongLeftRightArrow", _1: moonbitlang$core$json$$Json$string("⟺") }, { _0: "DoubleLongRightArrow", _1: moonbitlang$core$json$$Json$string("⟹") }, { _0: "DoubleRightArrow", _1: moonbitlang$core$json$$Json$string("⇒") }, { _0: "DoubleRightTee", _1: moonbitlang$core$json$$Json$string("⊨") }, { _0: "DoubleUpArrow", _1: moonbitlang$core$json$$Json$string("⇑") }, { _0: "DoubleUpDownArrow", _1: moonbitlang$core$json$$Json$string("⇕") }, { _0: "DoubleVerticalBar", _1: moonbitlang$core$json$$Json$string("∥") }, { _0: "DownArrow", _1: moonbitlang$core$json$$Json$string("↓") }, { _0: "DownArrowBar", _1: moonbitlang$core$json$$Json$string("⤓") }, { _0: "DownArrowUpArrow", _1: moonbitlang$core$json$$Json$string("⇵") }, { _0: "DownBreve", _1: moonbitlang$core$json$$Json$string("̑") }, { _0: "DownLeftRightVector", _1: moonbitlang$core$json$$Json$string("⥐") }, { _0: "DownLeftTeeVector", _1: moonbitlang$core$json$$Json$string("⥞") }, { _0: "DownLeftVector", _1: moonbitlang$core$json$$Json$string("↽") }, { _0: "DownLeftVectorBar", _1: moonbitlang$core$json$$Json$string("⥖") }, { _0: "DownRightTeeVector", _1: moonbitlang$core$json$$Json$string("⥟") }, { _0: "DownRightVector", _1: moonbitlang$core$json$$Json$string("⇁") }, { _0: "DownRightVectorBar", _1: moonbitlang$core$json$$Json$string("⥗") }, { _0: "DownTee", _1: moonbitlang$core$json$$Json$string("⊤") }, { _0: "DownTeeArrow", _1: moonbitlang$core$json$$Json$string("↧") }, { _0: "Downarrow", _1: moonbitlang$core$json$$Json$string("⇓") }, { _0: "Dscr", _1: moonbitlang$core$json$$Json$string("𝒟") }, { _0: "Dstrok", _1: moonbitlang$core$json$$Json$string("Đ") }, { _0: "ENG", _1: moonbitlang$core$json$$Json$string("Ŋ") }, { _0: "ETH", _1: moonbitlang$core$json$$Json$string("Ð") }, { _0: "Eacute", _1: moonbitlang$core$json$$Json$string("É") }, { _0: "Ecaron", _1: moonbitlang$core$json$$Json$string("Ě") }, { _0: "Ecirc", _1: moonbitlang$core$json$$Json$string("Ê") }, { _0: "Ecy", _1: moonbitlang$core$json$$Json$string("Э") }, { _0: "Edot", _1: moonbitlang$core$json$$Json$string("Ė") }, { _0: "Efr", _1: moonbitlang$core$json$$Json$string("𝔈") }, { _0: "Egrave", _1: moonbitlang$core$json$$Json$string("È") }, { _0: "Element", _1: moonbitlang$core$json$$Json$string("∈") }, { _0: "Emacr", _1: moonbitlang$core$json$$Json$string("Ē") }, { _0: "EmptySmallSquare", _1: moonbitlang$core$json$$Json$string("◻") }, { _0: "EmptyVerySmallSquare", _1: moonbitlang$core$json$$Json$string("▫") }, { _0: "Eogon", _1: moonbitlang$core$json$$Json$string("Ę") }, { _0: "Eopf", _1: moonbitlang$core$json$$Json$string("𝔼") }, { _0: "Epsilon", _1: moonbitlang$core$json$$Json$string("Ε") }, { _0: "Equal", _1: moonbitlang$core$json$$Json$string("⩵") }, { _0: "EqualTilde", _1: moonbitlang$core$json$$Json$string("≂") }, { _0: "Equilibrium", _1: moonbitlang$core$json$$Json$string("⇌") }, { _0: "Escr", _1: moonbitlang$core$json$$Json$string("ℰ") }, { _0: "Esim", _1: moonbitlang$core$json$$Json$string("⩳") }, { _0: "Eta", _1: moonbitlang$core$json$$Json$string("Η") }, { _0: "Euml", _1: moonbitlang$core$json$$Json$string("Ë") }, { _0: "Exists", _1: moonbitlang$core$json$$Json$string("∃") }, { _0: "ExponentialE", _1: moonbitlang$core$json$$Json$string("ⅇ") }, { _0: "Fcy", _1: moonbitlang$core$json$$Json$string("Ф") }, { _0: "Ffr", _1: moonbitlang$core$json$$Json$string("𝔉") }, { _0: "FilledSmallSquare", _1: moonbitlang$core$json$$Json$string("◼") }, { _0: "FilledVerySmallSquare", _1: moonbitlang$core$json$$Json$string("▪") }, { _0: "Fopf", _1: moonbitlang$core$json$$Json$string("𝔽") }, { _0: "ForAll", _1: moonbitlang$core$json$$Json$string("∀") }, { _0: "Fouriertrf", _1: moonbitlang$core$json$$Json$string("ℱ") }, { _0: "Fscr", _1: moonbitlang$core$json$$Json$string("ℱ") }, { _0: "GJcy", _1: moonbitlang$core$json$$Json$string("Ѓ") }, { _0: "GT", _1: moonbitlang$core$json$$Json$string(">") }, { _0: "Gamma", _1: moonbitlang$core$json$$Json$string("Γ") }, { _0: "Gammad", _1: moonbitlang$core$json$$Json$string("Ϝ") }, { _0: "Gbreve", _1: moonbitlang$core$json$$Json$string("Ğ") }, { _0: "Gcedil", _1: moonbitlang$core$json$$Json$string("Ģ") }, { _0: "Gcirc", _1: moonbitlang$core$json$$Json$string("Ĝ") }, { _0: "Gcy", _1: moonbitlang$core$json$$Json$string("Г") }, { _0: "Gdot", _1: moonbitlang$core$json$$Json$string("Ġ") }, { _0: "Gfr", _1: moonbitlang$core$json$$Json$string("𝔊") }, { _0: "Gg", _1: moonbitlang$core$json$$Json$string("⋙") }, { _0: "Gopf", _1: moonbitlang$core$json$$Json$string("𝔾") }, { _0: "GreaterEqual", _1: moonbitlang$core$json$$Json$string("≥") }, { _0: "GreaterEqualLess", _1: moonbitlang$core$json$$Json$string("⋛") }, { _0: "GreaterFullEqual", _1: moonbitlang$core$json$$Json$string("≧") }, { _0: "GreaterGreater", _1: moonbitlang$core$json$$Json$string("⪢") }, { _0: "GreaterLess", _1: moonbitlang$core$json$$Json$string("≷") }, { _0: "GreaterSlantEqual", _1: moonbitlang$core$json$$Json$string("⩾") }, { _0: "GreaterTilde", _1: moonbitlang$core$json$$Json$string("≳") }, { _0: "Gscr", _1: moonbitlang$core$json$$Json$string("𝒢") }, { _0: "Gt", _1: moonbitlang$core$json$$Json$string("≫") }, { _0: "HARDcy", _1: moonbitlang$core$json$$Json$string("Ъ") }, { _0: "Hacek", _1: moonbitlang$core$json$$Json$string("ˇ") }, { _0: "Hat", _1: moonbitlang$core$json$$Json$string("^") }, { _0: "Hcirc", _1: moonbitlang$core$json$$Json$string("Ĥ") }, { _0: "Hfr", _1: moonbitlang$core$json$$Json$string("ℌ") }, { _0: "HilbertSpace", _1: moonbitlang$core$json$$Json$string("ℋ") }, { _0: "Hopf", _1: moonbitlang$core$json$$Json$string("ℍ") }, { _0: "HorizontalLine", _1: moonbitlang$core$json$$Json$string("─") }, { _0: "Hscr", _1: moonbitlang$core$json$$Json$string("ℋ") }, { _0: "Hstrok", _1: moonbitlang$core$json$$Json$string("Ħ") }, { _0: "HumpDownHump", _1: moonbitlang$core$json$$Json$string("≎") }, { _0: "HumpEqual", _1: moonbitlang$core$json$$Json$string("≏") }, { _0: "IEcy", _1: moonbitlang$core$json$$Json$string("Е") }, { _0: "IJlig", _1: moonbitlang$core$json$$Json$string("Ĳ") }, { _0: "IOcy", _1: moonbitlang$core$json$$Json$string("Ё") }, { _0: "Iacute", _1: moonbitlang$core$json$$Json$string("Í") }, { _0: "Icirc", _1: moonbitlang$core$json$$Json$string("Î") }, { _0: "Icy", _1: moonbitlang$core$json$$Json$string("И") }, { _0: "Idot", _1: moonbitlang$core$json$$Json$string("İ") }, { _0: "Ifr", _1: moonbitlang$core$json$$Json$string("ℑ") }, { _0: "Igrave", _1: moonbitlang$core$json$$Json$string("Ì") }, { _0: "Im", _1: moonbitlang$core$json$$Json$string("ℑ") }, { _0: "Imacr", _1: moonbitlang$core$json$$Json$string("Ī") }, { _0: "ImaginaryI", _1: moonbitlang$core$json$$Json$string("ⅈ") }, { _0: "Implies", _1: moonbitlang$core$json$$Json$string("⇒") }, { _0: "Int", _1: moonbitlang$core$json$$Json$string("∬") }, { _0: "Integral", _1: moonbitlang$core$json$$Json$string("∫") }, { _0: "Intersection", _1: moonbitlang$core$json$$Json$string("⋂") }, { _0: "InvisibleComma", _1: moonbitlang$core$json$$Json$string("⁣") }, { _0: "InvisibleTimes", _1: moonbitlang$core$json$$Json$string("⁢") }, { _0: "Iogon", _1: moonbitlang$core$json$$Json$string("Į") }, { _0: "Iopf", _1: moonbitlang$core$json$$Json$string("𝕀") }, { _0: "Iota", _1: moonbitlang$core$json$$Json$string("Ι") }, { _0: "Iscr", _1: moonbitlang$core$json$$Json$string("ℐ") }, { _0: "Itilde", _1: moonbitlang$core$json$$Json$string("Ĩ") }, { _0: "Iukcy", _1: moonbitlang$core$json$$Json$string("І") }, { _0: "Iuml", _1: moonbitlang$core$json$$Json$string("Ï") }, { _0: "Jcirc", _1: moonbitlang$core$json$$Json$string("Ĵ") }, { _0: "Jcy", _1: moonbitlang$core$json$$Json$string("Й") }, { _0: "Jfr", _1: moonbitlang$core$json$$Json$string("𝔍") }, { _0: "Jopf", _1: moonbitlang$core$json$$Json$string("𝕁") }, { _0: "Jscr", _1: moonbitlang$core$json$$Json$string("𝒥") }, { _0: "Jsercy", _1: moonbitlang$core$json$$Json$string("Ј") }, { _0: "Jukcy", _1: moonbitlang$core$json$$Json$string("Є") }, { _0: "KHcy", _1: moonbitlang$core$json$$Json$string("Х") }, { _0: "KJcy", _1: moonbitlang$core$json$$Json$string("Ќ") }, { _0: "Kappa", _1: moonbitlang$core$json$$Json$string("Κ") }, { _0: "Kcedil", _1: moonbitlang$core$json$$Json$string("Ķ") }, { _0: "Kcy", _1: moonbitlang$core$json$$Json$string("К") }, { _0: "Kfr", _1: moonbitlang$core$json$$Json$string("𝔎") }, { _0: "Kopf", _1: moonbitlang$core$json$$Json$string("𝕂") }, { _0: "Kscr", _1: moonbitlang$core$json$$Json$string("𝒦") }, { _0: "LJcy", _1: moonbitlang$core$json$$Json$string("Љ") }, { _0: "LT", _1: moonbitlang$core$json$$Json$string("<") }, { _0: "Lacute", _1: moonbitlang$core$json$$Json$string("Ĺ") }, { _0: "Lambda", _1: moonbitlang$core$json$$Json$string("Λ") }, { _0: "Lang", _1: moonbitlang$core$json$$Json$string("⟪") }, { _0: "Laplacetrf", _1: moonbitlang$core$json$$Json$string("ℒ") }, { _0: "Larr", _1: moonbitlang$core$json$$Json$string("↞") }, { _0: "Lcaron", _1: moonbitlang$core$json$$Json$string("Ľ") }, { _0: "Lcedil", _1: moonbitlang$core$json$$Json$string("Ļ") }, { _0: "Lcy", _1: moonbitlang$core$json$$Json$string("Л") }, { _0: "LeftAngleBracket", _1: moonbitlang$core$json$$Json$string("⟨") }, { _0: "LeftArrow", _1: moonbitlang$core$json$$Json$string("←") }, { _0: "LeftArrowBar", _1: moonbitlang$core$json$$Json$string("⇤") }, { _0: "LeftArrowRightArrow", _1: moonbitlang$core$json$$Json$string("⇆") }, { _0: "LeftCeiling", _1: moonbitlang$core$json$$Json$string("⌈") }, { _0: "LeftDoubleBracket", _1: moonbitlang$core$json$$Json$string("⟦") }, { _0: "LeftDownTeeVector", _1: moonbitlang$core$json$$Json$string("⥡") }, { _0: "LeftDownVector", _1: moonbitlang$core$json$$Json$string("⇃") }, { _0: "LeftDownVectorBar", _1: moonbitlang$core$json$$Json$string("⥙") }, { _0: "LeftFloor", _1: moonbitlang$core$json$$Json$string("⌊") }, { _0: "LeftRightArrow", _1: moonbitlang$core$json$$Json$string("↔") }, { _0: "LeftRightVector", _1: moonbitlang$core$json$$Json$string("⥎") }, { _0: "LeftTee", _1: moonbitlang$core$json$$Json$string("⊣") }, { _0: "LeftTeeArrow", _1: moonbitlang$core$json$$Json$string("↤") }, { _0: "LeftTeeVector", _1: moonbitlang$core$json$$Json$string("⥚") }, { _0: "LeftTriangle", _1: moonbitlang$core$json$$Json$string("⊲") }, { _0: "LeftTriangleBar", _1: moonbitlang$core$json$$Json$string("⧏") }, { _0: "LeftTriangleEqual", _1: moonbitlang$core$json$$Json$string("⊴") }, { _0: "LeftUpDownVector", _1: moonbitlang$core$json$$Json$string("⥑") }, { _0: "LeftUpTeeVector", _1: moonbitlang$core$json$$Json$string("⥠") }, { _0: "LeftUpVector", _1: moonbitlang$core$json$$Json$string("↿") }, { _0: "LeftUpVectorBar", _1: moonbitlang$core$json$$Json$string("⥘") }, { _0: "LeftVector", _1: moonbitlang$core$json$$Json$string("↼") }, { _0: "LeftVectorBar", _1: moonbitlang$core$json$$Json$string("⥒") }, { _0: "Leftarrow", _1: moonbitlang$core$json$$Json$string("⇐") }, { _0: "Leftrightarrow", _1: moonbitlang$core$json$$Json$string("⇔") }, { _0: "LessEqualGreater", _1: moonbitlang$core$json$$Json$string("⋚") }, { _0: "LessFullEqual", _1: moonbitlang$core$json$$Json$string("≦") }, { _0: "LessGreater", _1: moonbitlang$core$json$$Json$string("≶") }, { _0: "LessLess", _1: moonbitlang$core$json$$Json$string("⪡") }, { _0: "LessSlantEqual", _1: moonbitlang$core$json$$Json$string("⩽") }, { _0: "LessTilde", _1: moonbitlang$core$json$$Json$string("≲") }, { _0: "Lfr", _1: moonbitlang$core$json$$Json$string("𝔏") }, { _0: "Ll", _1: moonbitlang$core$json$$Json$string("⋘") }, { _0: "Lleftarrow", _1: moonbitlang$core$json$$Json$string("⇚") }, { _0: "Lmidot", _1: moonbitlang$core$json$$Json$string("Ŀ") }, { _0: "LongLeftArrow", _1: moonbitlang$core$json$$Json$string("⟵") }, { _0: "LongLeftRightArrow", _1: moonbitlang$core$json$$Json$string("⟷") }, { _0: "LongRightArrow", _1: moonbitlang$core$json$$Json$string("⟶") }, { _0: "Longleftarrow", _1: moonbitlang$core$json$$Json$string("⟸") }, { _0: "Longleftrightarrow", _1: moonbitlang$core$json$$Json$string("⟺") }, { _0: "Longrightarrow", _1: moonbitlang$core$json$$Json$string("⟹") }, { _0: "Lopf", _1: moonbitlang$core$json$$Json$string("𝕃") }, { _0: "LowerLeftArrow", _1: moonbitlang$core$json$$Json$string("↙") }, { _0: "LowerRightArrow", _1: moonbitlang$core$json$$Json$string("↘") }, { _0: "Lscr", _1: moonbitlang$core$json$$Json$string("ℒ") }, { _0: "Lsh", _1: moonbitlang$core$json$$Json$string("↰") }, { _0: "Lstrok", _1: moonbitlang$core$json$$Json$string("Ł") }, { _0: "Lt", _1: moonbitlang$core$json$$Json$string("≪") }, { _0: "Map", _1: moonbitlang$core$json$$Json$string("⤅") }, { _0: "Mcy", _1: moonbitlang$core$json$$Json$string("М") }, { _0: "MediumSpace", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "Mellintrf", _1: moonbitlang$core$json$$Json$string("ℳ") }, { _0: "Mfr", _1: moonbitlang$core$json$$Json$string("𝔐") }, { _0: "MinusPlus", _1: moonbitlang$core$json$$Json$string("∓") }, { _0: "Mopf", _1: moonbitlang$core$json$$Json$string("𝕄") }, { _0: "Mscr", _1: moonbitlang$core$json$$Json$string("ℳ") }, { _0: "Mu", _1: moonbitlang$core$json$$Json$string("Μ") }, { _0: "NJcy", _1: moonbitlang$core$json$$Json$string("Њ") }, { _0: "Nacute", _1: moonbitlang$core$json$$Json$string("Ń") }, { _0: "Ncaron", _1: moonbitlang$core$json$$Json$string("Ň") }, { _0: "Ncedil", _1: moonbitlang$core$json$$Json$string("Ņ") }, { _0: "Ncy", _1: moonbitlang$core$json$$Json$string("Н") }, { _0: "NegativeMediumSpace", _1: moonbitlang$core$json$$Json$string("​") }, { _0: "NegativeThickSpace", _1: moonbitlang$core$json$$Json$string("​") }, { _0: "NegativeThinSpace", _1: moonbitlang$core$json$$Json$string("​") }, { _0: "NegativeVeryThinSpace", _1: moonbitlang$core$json$$Json$string("​") }, { _0: "NestedGreaterGreater", _1: moonbitlang$core$json$$Json$string("≫") }, { _0: "NestedLessLess", _1: moonbitlang$core$json$$Json$string("≪") }, { _0: "NewLine", _1: moonbitlang$core$json$$Json$string("\n") }, { _0: "Nfr", _1: moonbitlang$core$json$$Json$string("𝔑") }, { _0: "NoBreak", _1: moonbitlang$core$json$$Json$string("⁠") }, { _0: "NonBreakingSpace", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "Nopf", _1: moonbitlang$core$json$$Json$string("ℕ") }, { _0: "Not", _1: moonbitlang$core$json$$Json$string("⫬") }, { _0: "NotCongruent", _1: moonbitlang$core$json$$Json$string("≢") }, { _0: "NotCupCap", _1: moonbitlang$core$json$$Json$string("≭") }, { _0: "NotDoubleVerticalBar", _1: moonbitlang$core$json$$Json$string("∦") }, { _0: "NotElement", _1: moonbitlang$core$json$$Json$string("∉") }, { _0: "NotEqual", _1: moonbitlang$core$json$$Json$string("≠") }, { _0: "NotEqualTilde", _1: moonbitlang$core$json$$Json$string("≂̸") }, { _0: "NotExists", _1: moonbitlang$core$json$$Json$string("∄") }, { _0: "NotGreater", _1: moonbitlang$core$json$$Json$string("≯") }, { _0: "NotGreaterEqual", _1: moonbitlang$core$json$$Json$string("≱") }, { _0: "NotGreaterFullEqual", _1: moonbitlang$core$json$$Json$string("≧̸") }, { _0: "NotGreaterGreater", _1: moonbitlang$core$json$$Json$string("≫̸") }, { _0: "NotGreaterLess", _1: moonbitlang$core$json$$Json$string("≹") }, { _0: "NotGreaterSlantEqual", _1: moonbitlang$core$json$$Json$string("⩾̸") }, { _0: "NotGreaterTilde", _1: moonbitlang$core$json$$Json$string("≵") }, { _0: "NotHumpDownHump", _1: moonbitlang$core$json$$Json$string("≎̸") }, { _0: "NotHumpEqual", _1: moonbitlang$core$json$$Json$string("≏̸") }, { _0: "NotLeftTriangle", _1: moonbitlang$core$json$$Json$string("⋪") }, { _0: "NotLeftTriangleBar", _1: moonbitlang$core$json$$Json$string("⧏̸") }, { _0: "NotLeftTriangleEqual", _1: moonbitlang$core$json$$Json$string("⋬") }, { _0: "NotLess", _1: moonbitlang$core$json$$Json$string("≮") }, { _0: "NotLessEqual", _1: moonbitlang$core$json$$Json$string("≰") }, { _0: "NotLessGreater", _1: moonbitlang$core$json$$Json$string("≸") }, { _0: "NotLessLess", _1: moonbitlang$core$json$$Json$string("≪̸") }, { _0: "NotLessSlantEqual", _1: moonbitlang$core$json$$Json$string("⩽̸") }, { _0: "NotLessTilde", _1: moonbitlang$core$json$$Json$string("≴") }, { _0: "NotNestedGreaterGreater", _1: moonbitlang$core$json$$Json$string("⪢̸") }, { _0: "NotNestedLessLess", _1: moonbitlang$core$json$$Json$string("⪡̸") }, { _0: "NotPrecedes", _1: moonbitlang$core$json$$Json$string("⊀") }, { _0: "NotPrecedesEqual", _1: moonbitlang$core$json$$Json$string("⪯̸") }, { _0: "NotPrecedesSlantEqual", _1: moonbitlang$core$json$$Json$string("⋠") }, { _0: "NotReverseElement", _1: moonbitlang$core$json$$Json$string("∌") }, { _0: "NotRightTriangle", _1: moonbitlang$core$json$$Json$string("⋫") }, { _0: "NotRightTriangleBar", _1: moonbitlang$core$json$$Json$string("⧐̸") }, { _0: "NotRightTriangleEqual", _1: moonbitlang$core$json$$Json$string("⋭") }, { _0: "NotSquareSubset", _1: moonbitlang$core$json$$Json$string("⊏̸") }, { _0: "NotSquareSubsetEqual", _1: moonbitlang$core$json$$Json$string("⋢") }, { _0: "NotSquareSuperset", _1: moonbitlang$core$json$$Json$string("⊐̸") }, { _0: "NotSquareSupersetEqual", _1: moonbitlang$core$json$$Json$string("⋣") }, { _0: "NotSubset", _1: moonbitlang$core$json$$Json$string("⊂⃒") }, { _0: "NotSubsetEqual", _1: moonbitlang$core$json$$Json$string("⊈") }, { _0: "NotSucceeds", _1: moonbitlang$core$json$$Json$string("⊁") }, { _0: "NotSucceedsEqual", _1: moonbitlang$core$json$$Json$string("⪰̸") }, { _0: "NotSucceedsSlantEqual", _1: moonbitlang$core$json$$Json$string("⋡") }, { _0: "NotSucceedsTilde", _1: moonbitlang$core$json$$Json$string("≿̸") }, { _0: "NotSuperset", _1: moonbitlang$core$json$$Json$string("⊃⃒") }, { _0: "NotSupersetEqual", _1: moonbitlang$core$json$$Json$string("⊉") }, { _0: "NotTilde", _1: moonbitlang$core$json$$Json$string("≁") }, { _0: "NotTildeEqual", _1: moonbitlang$core$json$$Json$string("≄") }, { _0: "NotTildeFullEqual", _1: moonbitlang$core$json$$Json$string("≇") }, { _0: "NotTildeTilde", _1: moonbitlang$core$json$$Json$string("≉") }, { _0: "NotVerticalBar", _1: moonbitlang$core$json$$Json$string("∤") }, { _0: "Nscr", _1: moonbitlang$core$json$$Json$string("𝒩") }, { _0: "Ntilde", _1: moonbitlang$core$json$$Json$string("Ñ") }, { _0: "Nu", _1: moonbitlang$core$json$$Json$string("Ν") }, { _0: "OElig", _1: moonbitlang$core$json$$Json$string("Œ") }, { _0: "Oacute", _1: moonbitlang$core$json$$Json$string("Ó") }, { _0: "Ocirc", _1: moonbitlang$core$json$$Json$string("Ô") }, { _0: "Ocy", _1: moonbitlang$core$json$$Json$string("О") }, { _0: "Odblac", _1: moonbitlang$core$json$$Json$string("Ő") }, { _0: "Ofr", _1: moonbitlang$core$json$$Json$string("𝔒") }, { _0: "Ograve", _1: moonbitlang$core$json$$Json$string("Ò") }, { _0: "Omacr", _1: moonbitlang$core$json$$Json$string("Ō") }, { _0: "Omega", _1: moonbitlang$core$json$$Json$string("Ω") }, { _0: "Omicron", _1: moonbitlang$core$json$$Json$string("Ο") }, { _0: "Oopf", _1: moonbitlang$core$json$$Json$string("𝕆") }, { _0: "OpenCurlyDoubleQuote", _1: moonbitlang$core$json$$Json$string("“") }, { _0: "OpenCurlyQuote", _1: moonbitlang$core$json$$Json$string("‘") }, { _0: "Or", _1: moonbitlang$core$json$$Json$string("⩔") }, { _0: "Oscr", _1: moonbitlang$core$json$$Json$string("𝒪") }, { _0: "Oslash", _1: moonbitlang$core$json$$Json$string("Ø") }, { _0: "Otilde", _1: moonbitlang$core$json$$Json$string("Õ") }, { _0: "Otimes", _1: moonbitlang$core$json$$Json$string("⨷") }, { _0: "Ouml", _1: moonbitlang$core$json$$Json$string("Ö") }, { _0: "OverBar", _1: moonbitlang$core$json$$Json$string("‾") }, { _0: "OverBrace", _1: moonbitlang$core$json$$Json$string("⏞") }, { _0: "OverBracket", _1: moonbitlang$core$json$$Json$string("⎴") }, { _0: "OverParenthesis", _1: moonbitlang$core$json$$Json$string("⏜") }, { _0: "PartialD", _1: moonbitlang$core$json$$Json$string("∂") }, { _0: "Pcy", _1: moonbitlang$core$json$$Json$string("П") }, { _0: "Pfr", _1: moonbitlang$core$json$$Json$string("𝔓") }, { _0: "Phi", _1: moonbitlang$core$json$$Json$string("Φ") }, { _0: "Pi", _1: moonbitlang$core$json$$Json$string("Π") }, { _0: "PlusMinus", _1: moonbitlang$core$json$$Json$string("±") }, { _0: "Poincareplane", _1: moonbitlang$core$json$$Json$string("ℌ") }, { _0: "Popf", _1: moonbitlang$core$json$$Json$string("ℙ") }, { _0: "Pr", _1: moonbitlang$core$json$$Json$string("⪻") }, { _0: "Precedes", _1: moonbitlang$core$json$$Json$string("≺") }, { _0: "PrecedesEqual", _1: moonbitlang$core$json$$Json$string("⪯") }, { _0: "PrecedesSlantEqual", _1: moonbitlang$core$json$$Json$string("≼") }, { _0: "PrecedesTilde", _1: moonbitlang$core$json$$Json$string("≾") }, { _0: "Prime", _1: moonbitlang$core$json$$Json$string("″") }, { _0: "Product", _1: moonbitlang$core$json$$Json$string("∏") }, { _0: "Proportion", _1: moonbitlang$core$json$$Json$string("∷") }, { _0: "Proportional", _1: moonbitlang$core$json$$Json$string("∝") }, { _0: "Pscr", _1: moonbitlang$core$json$$Json$string("𝒫") }, { _0: "Psi", _1: moonbitlang$core$json$$Json$string("Ψ") }, { _0: "QUOT", _1: moonbitlang$core$json$$Json$string("\"") }, { _0: "Qfr", _1: moonbitlang$core$json$$Json$string("𝔔") }, { _0: "Qopf", _1: moonbitlang$core$json$$Json$string("ℚ") }, { _0: "Qscr", _1: moonbitlang$core$json$$Json$string("𝒬") }, { _0: "RBarr", _1: moonbitlang$core$json$$Json$string("⤐") }, { _0: "REG", _1: moonbitlang$core$json$$Json$string("®") }, { _0: "Racute", _1: moonbitlang$core$json$$Json$string("Ŕ") }, { _0: "Rang", _1: moonbitlang$core$json$$Json$string("⟫") }, { _0: "Rarr", _1: moonbitlang$core$json$$Json$string("↠") }, { _0: "Rarrtl", _1: moonbitlang$core$json$$Json$string("⤖") }, { _0: "Rcaron", _1: moonbitlang$core$json$$Json$string("Ř") }, { _0: "Rcedil", _1: moonbitlang$core$json$$Json$string("Ŗ") }, { _0: "Rcy", _1: moonbitlang$core$json$$Json$string("Р") }, { _0: "Re", _1: moonbitlang$core$json$$Json$string("ℜ") }, { _0: "ReverseElement", _1: moonbitlang$core$json$$Json$string("∋") }, { _0: "ReverseEquilibrium", _1: moonbitlang$core$json$$Json$string("⇋") }, { _0: "ReverseUpEquilibrium", _1: moonbitlang$core$json$$Json$string("⥯") }, { _0: "Rfr", _1: moonbitlang$core$json$$Json$string("ℜ") }, { _0: "Rho", _1: moonbitlang$core$json$$Json$string("Ρ") }, { _0: "RightAngleBracket", _1: moonbitlang$core$json$$Json$string("⟩") }, { _0: "RightArrow", _1: moonbitlang$core$json$$Json$string("→") }, { _0: "RightArrowBar", _1: moonbitlang$core$json$$Json$string("⇥") }, { _0: "RightArrowLeftArrow", _1: moonbitlang$core$json$$Json$string("⇄") }, { _0: "RightCeiling", _1: moonbitlang$core$json$$Json$string("⌉") }, { _0: "RightDoubleBracket", _1: moonbitlang$core$json$$Json$string("⟧") }, { _0: "RightDownTeeVector", _1: moonbitlang$core$json$$Json$string("⥝") }, { _0: "RightDownVector", _1: moonbitlang$core$json$$Json$string("⇂") }, { _0: "RightDownVectorBar", _1: moonbitlang$core$json$$Json$string("⥕") }, { _0: "RightFloor", _1: moonbitlang$core$json$$Json$string("⌋") }, { _0: "RightTee", _1: moonbitlang$core$json$$Json$string("⊢") }, { _0: "RightTeeArrow", _1: moonbitlang$core$json$$Json$string("↦") }, { _0: "RightTeeVector", _1: moonbitlang$core$json$$Json$string("⥛") }, { _0: "RightTriangle", _1: moonbitlang$core$json$$Json$string("⊳") }, { _0: "RightTriangleBar", _1: moonbitlang$core$json$$Json$string("⧐") }, { _0: "RightTriangleEqual", _1: moonbitlang$core$json$$Json$string("⊵") }, { _0: "RightUpDownVector", _1: moonbitlang$core$json$$Json$string("⥏") }, { _0: "RightUpTeeVector", _1: moonbitlang$core$json$$Json$string("⥜") }, { _0: "RightUpVector", _1: moonbitlang$core$json$$Json$string("↾") }, { _0: "RightUpVectorBar", _1: moonbitlang$core$json$$Json$string("⥔") }, { _0: "RightVector", _1: moonbitlang$core$json$$Json$string("⇀") }, { _0: "RightVectorBar", _1: moonbitlang$core$json$$Json$string("⥓") }, { _0: "Rightarrow", _1: moonbitlang$core$json$$Json$string("⇒") }, { _0: "Ropf", _1: moonbitlang$core$json$$Json$string("ℝ") }, { _0: "RoundImplies", _1: moonbitlang$core$json$$Json$string("⥰") }, { _0: "Rrightarrow", _1: moonbitlang$core$json$$Json$string("⇛") }, { _0: "Rscr", _1: moonbitlang$core$json$$Json$string("ℛ") }, { _0: "Rsh", _1: moonbitlang$core$json$$Json$string("↱") }, { _0: "RuleDelayed", _1: moonbitlang$core$json$$Json$string("⧴") }, { _0: "SHCHcy", _1: moonbitlang$core$json$$Json$string("Щ") }, { _0: "SHcy", _1: moonbitlang$core$json$$Json$string("Ш") }, { _0: "SOFTcy", _1: moonbitlang$core$json$$Json$string("Ь") }, { _0: "Sacute", _1: moonbitlang$core$json$$Json$string("Ś") }, { _0: "Sc", _1: moonbitlang$core$json$$Json$string("⪼") }, { _0: "Scaron", _1: moonbitlang$core$json$$Json$string("Š") }, { _0: "Scedil", _1: moonbitlang$core$json$$Json$string("Ş") }, { _0: "Scirc", _1: moonbitlang$core$json$$Json$string("Ŝ") }, { _0: "Scy", _1: moonbitlang$core$json$$Json$string("С") }, { _0: "Sfr", _1: moonbitlang$core$json$$Json$string("𝔖") }, { _0: "ShortDownArrow", _1: moonbitlang$core$json$$Json$string("↓") }, { _0: "ShortLeftArrow", _1: moonbitlang$core$json$$Json$string("←") }, { _0: "ShortRightArrow", _1: moonbitlang$core$json$$Json$string("→") }, { _0: "ShortUpArrow", _1: moonbitlang$core$json$$Json$string("↑") }, { _0: "Sigma", _1: moonbitlang$core$json$$Json$string("Σ") }, { _0: "SmallCircle", _1: moonbitlang$core$json$$Json$string("∘") }, { _0: "Sopf", _1: moonbitlang$core$json$$Json$string("𝕊") }, { _0: "Sqrt", _1: moonbitlang$core$json$$Json$string("√") }, { _0: "Square", _1: moonbitlang$core$json$$Json$string("□") }, { _0: "SquareIntersection", _1: moonbitlang$core$json$$Json$string("⊓") }, { _0: "SquareSubset", _1: moonbitlang$core$json$$Json$string("⊏") }, { _0: "SquareSubsetEqual", _1: moonbitlang$core$json$$Json$string("⊑") }, { _0: "SquareSuperset", _1: moonbitlang$core$json$$Json$string("⊐") }, { _0: "SquareSupersetEqual", _1: moonbitlang$core$json$$Json$string("⊒") }, { _0: "SquareUnion", _1: moonbitlang$core$json$$Json$string("⊔") }, { _0: "Sscr", _1: moonbitlang$core$json$$Json$string("𝒮") }, { _0: "Star", _1: moonbitlang$core$json$$Json$string("⋆") }, { _0: "Sub", _1: moonbitlang$core$json$$Json$string("⋐") }, { _0: "Subset", _1: moonbitlang$core$json$$Json$string("⋐") }, { _0: "SubsetEqual", _1: moonbitlang$core$json$$Json$string("⊆") }, { _0: "Succeeds", _1: moonbitlang$core$json$$Json$string("≻") }, { _0: "SucceedsEqual", _1: moonbitlang$core$json$$Json$string("⪰") }, { _0: "SucceedsSlantEqual", _1: moonbitlang$core$json$$Json$string("≽") }, { _0: "SucceedsTilde", _1: moonbitlang$core$json$$Json$string("≿") }, { _0: "SuchThat", _1: moonbitlang$core$json$$Json$string("∋") }, { _0: "Sum", _1: moonbitlang$core$json$$Json$string("∑") }, { _0: "Sup", _1: moonbitlang$core$json$$Json$string("⋑") }, { _0: "Superset", _1: moonbitlang$core$json$$Json$string("⊃") }, { _0: "SupersetEqual", _1: moonbitlang$core$json$$Json$string("⊇") }, { _0: "Supset", _1: moonbitlang$core$json$$Json$string("⋑") }, { _0: "THORN", _1: moonbitlang$core$json$$Json$string("Þ") }, { _0: "TRADE", _1: moonbitlang$core$json$$Json$string("™") }, { _0: "TSHcy", _1: moonbitlang$core$json$$Json$string("Ћ") }, { _0: "TScy", _1: moonbitlang$core$json$$Json$string("Ц") }, { _0: "Tab", _1: moonbitlang$core$json$$Json$string("\t") }, { _0: "Tau", _1: moonbitlang$core$json$$Json$string("Τ") }, { _0: "Tcaron", _1: moonbitlang$core$json$$Json$string("Ť") }, { _0: "Tcedil", _1: moonbitlang$core$json$$Json$string("Ţ") }, { _0: "Tcy", _1: moonbitlang$core$json$$Json$string("Т") }, { _0: "Tfr", _1: moonbitlang$core$json$$Json$string("𝔗") }, { _0: "Therefore", _1: moonbitlang$core$json$$Json$string("∴") }, { _0: "Theta", _1: moonbitlang$core$json$$Json$string("Θ") }, { _0: "ThickSpace", _1: moonbitlang$core$json$$Json$string("  ") }, { _0: "ThinSpace", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "Tilde", _1: moonbitlang$core$json$$Json$string("∼") }, { _0: "TildeEqual", _1: moonbitlang$core$json$$Json$string("≃") }, { _0: "TildeFullEqual", _1: moonbitlang$core$json$$Json$string("≅") }, { _0: "TildeTilde", _1: moonbitlang$core$json$$Json$string("≈") }, { _0: "Topf", _1: moonbitlang$core$json$$Json$string("𝕋") }, { _0: "TripleDot", _1: moonbitlang$core$json$$Json$string("⃛") }, { _0: "Tscr", _1: moonbitlang$core$json$$Json$string("𝒯") }, { _0: "Tstrok", _1: moonbitlang$core$json$$Json$string("Ŧ") }, { _0: "Uacute", _1: moonbitlang$core$json$$Json$string("Ú") }, { _0: "Uarr", _1: moonbitlang$core$json$$Json$string("↟") }, { _0: "Uarrocir", _1: moonbitlang$core$json$$Json$string("⥉") }, { _0: "Ubrcy", _1: moonbitlang$core$json$$Json$string("Ў") }, { _0: "Ubreve", _1: moonbitlang$core$json$$Json$string("Ŭ") }, { _0: "Ucirc", _1: moonbitlang$core$json$$Json$string("Û") }, { _0: "Ucy", _1: moonbitlang$core$json$$Json$string("У") }, { _0: "Udblac", _1: moonbitlang$core$json$$Json$string("Ű") }, { _0: "Ufr", _1: moonbitlang$core$json$$Json$string("𝔘") }, { _0: "Ugrave", _1: moonbitlang$core$json$$Json$string("Ù") }, { _0: "Umacr", _1: moonbitlang$core$json$$Json$string("Ū") }, { _0: "UnderBar", _1: moonbitlang$core$json$$Json$string("_") }, { _0: "UnderBrace", _1: moonbitlang$core$json$$Json$string("⏟") }, { _0: "UnderBracket", _1: moonbitlang$core$json$$Json$string("⎵") }, { _0: "UnderParenthesis", _1: moonbitlang$core$json$$Json$string("⏝") }, { _0: "Union", _1: moonbitlang$core$json$$Json$string("⋃") }, { _0: "UnionPlus", _1: moonbitlang$core$json$$Json$string("⊎") }, { _0: "Uogon", _1: moonbitlang$core$json$$Json$string("Ų") }, { _0: "Uopf", _1: moonbitlang$core$json$$Json$string("𝕌") }, { _0: "UpArrow", _1: moonbitlang$core$json$$Json$string("↑") }, { _0: "UpArrowBar", _1: moonbitlang$core$json$$Json$string("⤒") }, { _0: "UpArrowDownArrow", _1: moonbitlang$core$json$$Json$string("⇅") }, { _0: "UpDownArrow", _1: moonbitlang$core$json$$Json$string("↕") }, { _0: "UpEquilibrium", _1: moonbitlang$core$json$$Json$string("⥮") }, { _0: "UpTee", _1: moonbitlang$core$json$$Json$string("⊥") }, { _0: "UpTeeArrow", _1: moonbitlang$core$json$$Json$string("↥") }, { _0: "Uparrow", _1: moonbitlang$core$json$$Json$string("⇑") }, { _0: "Updownarrow", _1: moonbitlang$core$json$$Json$string("⇕") }, { _0: "UpperLeftArrow", _1: moonbitlang$core$json$$Json$string("↖") }, { _0: "UpperRightArrow", _1: moonbitlang$core$json$$Json$string("↗") }, { _0: "Upsi", _1: moonbitlang$core$json$$Json$string("ϒ") }, { _0: "Upsilon", _1: moonbitlang$core$json$$Json$string("Υ") }, { _0: "Uring", _1: moonbitlang$core$json$$Json$string("Ů") }, { _0: "Uscr", _1: moonbitlang$core$json$$Json$string("𝒰") }, { _0: "Utilde", _1: moonbitlang$core$json$$Json$string("Ũ") }, { _0: "Uuml", _1: moonbitlang$core$json$$Json$string("Ü") }, { _0: "VDash", _1: moonbitlang$core$json$$Json$string("⊫") }, { _0: "Vbar", _1: moonbitlang$core$json$$Json$string("⫫") }, { _0: "Vcy", _1: moonbitlang$core$json$$Json$string("В") }, { _0: "Vdash", _1: moonbitlang$core$json$$Json$string("⊩") }, { _0: "Vdashl", _1: moonbitlang$core$json$$Json$string("⫦") }, { _0: "Vee", _1: moonbitlang$core$json$$Json$string("⋁") }, { _0: "Verbar", _1: moonbitlang$core$json$$Json$string("‖") }, { _0: "Vert", _1: moonbitlang$core$json$$Json$string("‖") }, { _0: "VerticalBar", _1: moonbitlang$core$json$$Json$string("∣") }, { _0: "VerticalLine", _1: moonbitlang$core$json$$Json$string("|") }, { _0: "VerticalSeparator", _1: moonbitlang$core$json$$Json$string("❘") }, { _0: "VerticalTilde", _1: moonbitlang$core$json$$Json$string("≀") }, { _0: "VeryThinSpace", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "Vfr", _1: moonbitlang$core$json$$Json$string("𝔙") }, { _0: "Vopf", _1: moonbitlang$core$json$$Json$string("𝕍") }, { _0: "Vscr", _1: moonbitlang$core$json$$Json$string("𝒱") }, { _0: "Vvdash", _1: moonbitlang$core$json$$Json$string("⊪") }, { _0: "Wcirc", _1: moonbitlang$core$json$$Json$string("Ŵ") }, { _0: "Wedge", _1: moonbitlang$core$json$$Json$string("⋀") }, { _0: "Wfr", _1: moonbitlang$core$json$$Json$string("𝔚") }, { _0: "Wopf", _1: moonbitlang$core$json$$Json$string("𝕎") }, { _0: "Wscr", _1: moonbitlang$core$json$$Json$string("𝒲") }, { _0: "Xfr", _1: moonbitlang$core$json$$Json$string("𝔛") }, { _0: "Xi", _1: moonbitlang$core$json$$Json$string("Ξ") }, { _0: "Xopf", _1: moonbitlang$core$json$$Json$string("𝕏") }, { _0: "Xscr", _1: moonbitlang$core$json$$Json$string("𝒳") }, { _0: "YAcy", _1: moonbitlang$core$json$$Json$string("Я") }, { _0: "YIcy", _1: moonbitlang$core$json$$Json$string("Ї") }, { _0: "YUcy", _1: moonbitlang$core$json$$Json$string("Ю") }, { _0: "Yacute", _1: moonbitlang$core$json$$Json$string("Ý") }, { _0: "Ycirc", _1: moonbitlang$core$json$$Json$string("Ŷ") }, { _0: "Ycy", _1: moonbitlang$core$json$$Json$string("Ы") }, { _0: "Yfr", _1: moonbitlang$core$json$$Json$string("𝔜") }, { _0: "Yopf", _1: moonbitlang$core$json$$Json$string("𝕐") }, { _0: "Yscr", _1: moonbitlang$core$json$$Json$string("𝒴") }, { _0: "Yuml", _1: moonbitlang$core$json$$Json$string("Ÿ") }, { _0: "ZHcy", _1: moonbitlang$core$json$$Json$string("Ж") }, { _0: "Zacute", _1: moonbitlang$core$json$$Json$string("Ź") }, { _0: "Zcaron", _1: moonbitlang$core$json$$Json$string("Ž") }, { _0: "Zcy", _1: moonbitlang$core$json$$Json$string("З") }, { _0: "Zdot", _1: moonbitlang$core$json$$Json$string("Ż") }, { _0: "ZeroWidthSpace", _1: moonbitlang$core$json$$Json$string("​") }, { _0: "Zeta", _1: moonbitlang$core$json$$Json$string("Ζ") }, { _0: "Zfr", _1: moonbitlang$core$json$$Json$string("ℨ") }, { _0: "Zopf", _1: moonbitlang$core$json$$Json$string("ℤ") }, { _0: "Zscr", _1: moonbitlang$core$json$$Json$string("𝒵") }, { _0: "aacute", _1: moonbitlang$core$json$$Json$string("á") }, { _0: "abreve", _1: moonbitlang$core$json$$Json$string("ă") }, { _0: "ac", _1: moonbitlang$core$json$$Json$string("∾") }, { _0: "acE", _1: moonbitlang$core$json$$Json$string("∾̳") }, { _0: "acd", _1: moonbitlang$core$json$$Json$string("∿") }, { _0: "acirc", _1: moonbitlang$core$json$$Json$string("â") }, { _0: "acute", _1: moonbitlang$core$json$$Json$string("´") }, { _0: "acy", _1: moonbitlang$core$json$$Json$string("а") }, { _0: "aelig", _1: moonbitlang$core$json$$Json$string("æ") }, { _0: "af", _1: moonbitlang$core$json$$Json$string("⁡") }, { _0: "afr", _1: moonbitlang$core$json$$Json$string("𝔞") }, { _0: "agrave", _1: moonbitlang$core$json$$Json$string("à") }, { _0: "alefsym", _1: moonbitlang$core$json$$Json$string("ℵ") }, { _0: "aleph", _1: moonbitlang$core$json$$Json$string("ℵ") }, { _0: "alpha", _1: moonbitlang$core$json$$Json$string("α") }, { _0: "amacr", _1: moonbitlang$core$json$$Json$string("ā") }, { _0: "amalg", _1: moonbitlang$core$json$$Json$string("⨿") }, { _0: "amp", _1: moonbitlang$core$json$$Json$string("&") }, { _0: "and", _1: moonbitlang$core$json$$Json$string("∧") }, { _0: "andand", _1: moonbitlang$core$json$$Json$string("⩕") }, { _0: "andd", _1: moonbitlang$core$json$$Json$string("⩜") }, { _0: "andslope", _1: moonbitlang$core$json$$Json$string("⩘") }, { _0: "andv", _1: moonbitlang$core$json$$Json$string("⩚") }, { _0: "ang", _1: moonbitlang$core$json$$Json$string("∠") }, { _0: "ange", _1: moonbitlang$core$json$$Json$string("⦤") }, { _0: "angle", _1: moonbitlang$core$json$$Json$string("∠") }, { _0: "angmsd", _1: moonbitlang$core$json$$Json$string("∡") }, { _0: "angmsdaa", _1: moonbitlang$core$json$$Json$string("⦨") }, { _0: "angmsdab", _1: moonbitlang$core$json$$Json$string("⦩") }, { _0: "angmsdac", _1: moonbitlang$core$json$$Json$string("⦪") }, { _0: "angmsdad", _1: moonbitlang$core$json$$Json$string("⦫") }, { _0: "angmsdae", _1: moonbitlang$core$json$$Json$string("⦬") }, { _0: "angmsdaf", _1: moonbitlang$core$json$$Json$string("⦭") }, { _0: "angmsdag", _1: moonbitlang$core$json$$Json$string("⦮") }, { _0: "angmsdah", _1: moonbitlang$core$json$$Json$string("⦯") }, { _0: "angrt", _1: moonbitlang$core$json$$Json$string("∟") }, { _0: "angrtvb", _1: moonbitlang$core$json$$Json$string("⊾") }, { _0: "angrtvbd", _1: moonbitlang$core$json$$Json$string("⦝") }, { _0: "angsph", _1: moonbitlang$core$json$$Json$string("∢") }, { _0: "angst", _1: moonbitlang$core$json$$Json$string("Å") }, { _0: "angzarr", _1: moonbitlang$core$json$$Json$string("⍼") }, { _0: "aogon", _1: moonbitlang$core$json$$Json$string("ą") }, { _0: "aopf", _1: moonbitlang$core$json$$Json$string("𝕒") }, { _0: "ap", _1: moonbitlang$core$json$$Json$string("≈") }, { _0: "apE", _1: moonbitlang$core$json$$Json$string("⩰") }, { _0: "apacir", _1: moonbitlang$core$json$$Json$string("⩯") }, { _0: "ape", _1: moonbitlang$core$json$$Json$string("≊") }, { _0: "apid", _1: moonbitlang$core$json$$Json$string("≋") }, { _0: "apos", _1: moonbitlang$core$json$$Json$string("'") }, { _0: "approx", _1: moonbitlang$core$json$$Json$string("≈") }, { _0: "approxeq", _1: moonbitlang$core$json$$Json$string("≊") }, { _0: "aring", _1: moonbitlang$core$json$$Json$string("å") }, { _0: "ascr", _1: moonbitlang$core$json$$Json$string("𝒶") }, { _0: "ast", _1: moonbitlang$core$json$$Json$string("*") }, { _0: "asymp", _1: moonbitlang$core$json$$Json$string("≈") }, { _0: "asympeq", _1: moonbitlang$core$json$$Json$string("≍") }, { _0: "atilde", _1: moonbitlang$core$json$$Json$string("ã") }, { _0: "auml", _1: moonbitlang$core$json$$Json$string("ä") }, { _0: "awconint", _1: moonbitlang$core$json$$Json$string("∳") }, { _0: "awint", _1: moonbitlang$core$json$$Json$string("⨑") }, { _0: "bNot", _1: moonbitlang$core$json$$Json$string("⫭") }, { _0: "backcong", _1: moonbitlang$core$json$$Json$string("≌") }, { _0: "backepsilon", _1: moonbitlang$core$json$$Json$string("϶") }, { _0: "backprime", _1: moonbitlang$core$json$$Json$string("‵") }, { _0: "backsim", _1: moonbitlang$core$json$$Json$string("∽") }, { _0: "backsimeq", _1: moonbitlang$core$json$$Json$string("⋍") }, { _0: "barvee", _1: moonbitlang$core$json$$Json$string("⊽") }, { _0: "barwed", _1: moonbitlang$core$json$$Json$string("⌅") }, { _0: "barwedge", _1: moonbitlang$core$json$$Json$string("⌅") }, { _0: "bbrk", _1: moonbitlang$core$json$$Json$string("⎵") }, { _0: "bbrktbrk", _1: moonbitlang$core$json$$Json$string("⎶") }, { _0: "bcong", _1: moonbitlang$core$json$$Json$string("≌") }, { _0: "bcy", _1: moonbitlang$core$json$$Json$string("б") }, { _0: "bdquo", _1: moonbitlang$core$json$$Json$string("„") }, { _0: "becaus", _1: moonbitlang$core$json$$Json$string("∵") }, { _0: "because", _1: moonbitlang$core$json$$Json$string("∵") }, { _0: "bemptyv", _1: moonbitlang$core$json$$Json$string("⦰") }, { _0: "bepsi", _1: moonbitlang$core$json$$Json$string("϶") }, { _0: "bernou", _1: moonbitlang$core$json$$Json$string("ℬ") }, { _0: "beta", _1: moonbitlang$core$json$$Json$string("β") }, { _0: "beth", _1: moonbitlang$core$json$$Json$string("ℶ") }, { _0: "between", _1: moonbitlang$core$json$$Json$string("≬") }, { _0: "bfr", _1: moonbitlang$core$json$$Json$string("𝔟") }, { _0: "bigcap", _1: moonbitlang$core$json$$Json$string("⋂") }, { _0: "bigcirc", _1: moonbitlang$core$json$$Json$string("◯") }, { _0: "bigcup", _1: moonbitlang$core$json$$Json$string("⋃") }, { _0: "bigodot", _1: moonbitlang$core$json$$Json$string("⨀") }, { _0: "bigoplus", _1: moonbitlang$core$json$$Json$string("⨁") }, { _0: "bigotimes", _1: moonbitlang$core$json$$Json$string("⨂") }, { _0: "bigsqcup", _1: moonbitlang$core$json$$Json$string("⨆") }, { _0: "bigstar", _1: moonbitlang$core$json$$Json$string("★") }, { _0: "bigtriangledown", _1: moonbitlang$core$json$$Json$string("▽") }, { _0: "bigtriangleup", _1: moonbitlang$core$json$$Json$string("△") }, { _0: "biguplus", _1: moonbitlang$core$json$$Json$string("⨄") }, { _0: "bigvee", _1: moonbitlang$core$json$$Json$string("⋁") }, { _0: "bigwedge", _1: moonbitlang$core$json$$Json$string("⋀") }, { _0: "bkarow", _1: moonbitlang$core$json$$Json$string("⤍") }, { _0: "blacklozenge", _1: moonbitlang$core$json$$Json$string("⧫") }, { _0: "blacksquare", _1: moonbitlang$core$json$$Json$string("▪") }, { _0: "blacktriangle", _1: moonbitlang$core$json$$Json$string("▴") }, { _0: "blacktriangledown", _1: moonbitlang$core$json$$Json$string("▾") }, { _0: "blacktriangleleft", _1: moonbitlang$core$json$$Json$string("◂") }, { _0: "blacktriangleright", _1: moonbitlang$core$json$$Json$string("▸") }, { _0: "blank", _1: moonbitlang$core$json$$Json$string("␣") }, { _0: "blk12", _1: moonbitlang$core$json$$Json$string("▒") }, { _0: "blk14", _1: moonbitlang$core$json$$Json$string("░") }, { _0: "blk34", _1: moonbitlang$core$json$$Json$string("▓") }, { _0: "block", _1: moonbitlang$core$json$$Json$string("█") }, { _0: "bne", _1: moonbitlang$core$json$$Json$string("=⃥") }, { _0: "bnequiv", _1: moonbitlang$core$json$$Json$string("≡⃥") }, { _0: "bnot", _1: moonbitlang$core$json$$Json$string("⌐") }, { _0: "bopf", _1: moonbitlang$core$json$$Json$string("𝕓") }, { _0: "bot", _1: moonbitlang$core$json$$Json$string("⊥") }, { _0: "bottom", _1: moonbitlang$core$json$$Json$string("⊥") }, { _0: "bowtie", _1: moonbitlang$core$json$$Json$string("⋈") }, { _0: "boxDL", _1: moonbitlang$core$json$$Json$string("╗") }, { _0: "boxDR", _1: moonbitlang$core$json$$Json$string("╔") }, { _0: "boxDl", _1: moonbitlang$core$json$$Json$string("╖") }, { _0: "boxDr", _1: moonbitlang$core$json$$Json$string("╓") }, { _0: "boxH", _1: moonbitlang$core$json$$Json$string("═") }, { _0: "boxHD", _1: moonbitlang$core$json$$Json$string("╦") }, { _0: "boxHU", _1: moonbitlang$core$json$$Json$string("╩") }, { _0: "boxHd", _1: moonbitlang$core$json$$Json$string("╤") }, { _0: "boxHu", _1: moonbitlang$core$json$$Json$string("╧") }, { _0: "boxUL", _1: moonbitlang$core$json$$Json$string("╝") }, { _0: "boxUR", _1: moonbitlang$core$json$$Json$string("╚") }, { _0: "boxUl", _1: moonbitlang$core$json$$Json$string("╜") }, { _0: "boxUr", _1: moonbitlang$core$json$$Json$string("╙") }, { _0: "boxV", _1: moonbitlang$core$json$$Json$string("║") }, { _0: "boxVH", _1: moonbitlang$core$json$$Json$string("╬") }, { _0: "boxVL", _1: moonbitlang$core$json$$Json$string("╣") }, { _0: "boxVR", _1: moonbitlang$core$json$$Json$string("╠") }, { _0: "boxVh", _1: moonbitlang$core$json$$Json$string("╫") }, { _0: "boxVl", _1: moonbitlang$core$json$$Json$string("╢") }, { _0: "boxVr", _1: moonbitlang$core$json$$Json$string("╟") }, { _0: "boxbox", _1: moonbitlang$core$json$$Json$string("⧉") }, { _0: "boxdL", _1: moonbitlang$core$json$$Json$string("╕") }, { _0: "boxdR", _1: moonbitlang$core$json$$Json$string("╒") }, { _0: "boxdl", _1: moonbitlang$core$json$$Json$string("┐") }, { _0: "boxdr", _1: moonbitlang$core$json$$Json$string("┌") }, { _0: "boxh", _1: moonbitlang$core$json$$Json$string("─") }, { _0: "boxhD", _1: moonbitlang$core$json$$Json$string("╥") }, { _0: "boxhU", _1: moonbitlang$core$json$$Json$string("╨") }, { _0: "boxhd", _1: moonbitlang$core$json$$Json$string("┬") }, { _0: "boxhu", _1: moonbitlang$core$json$$Json$string("┴") }, { _0: "boxminus", _1: moonbitlang$core$json$$Json$string("⊟") }, { _0: "boxplus", _1: moonbitlang$core$json$$Json$string("⊞") }, { _0: "boxtimes", _1: moonbitlang$core$json$$Json$string("⊠") }, { _0: "boxuL", _1: moonbitlang$core$json$$Json$string("╛") }, { _0: "boxuR", _1: moonbitlang$core$json$$Json$string("╘") }, { _0: "boxul", _1: moonbitlang$core$json$$Json$string("┘") }, { _0: "boxur", _1: moonbitlang$core$json$$Json$string("└") }, { _0: "boxv", _1: moonbitlang$core$json$$Json$string("│") }, { _0: "boxvH", _1: moonbitlang$core$json$$Json$string("╪") }, { _0: "boxvL", _1: moonbitlang$core$json$$Json$string("╡") }, { _0: "boxvR", _1: moonbitlang$core$json$$Json$string("╞") }, { _0: "boxvh", _1: moonbitlang$core$json$$Json$string("┼") }, { _0: "boxvl", _1: moonbitlang$core$json$$Json$string("┤") }, { _0: "boxvr", _1: moonbitlang$core$json$$Json$string("├") }, { _0: "bprime", _1: moonbitlang$core$json$$Json$string("‵") }, { _0: "breve", _1: moonbitlang$core$json$$Json$string("˘") }, { _0: "brvbar", _1: moonbitlang$core$json$$Json$string("¦") }, { _0: "bscr", _1: moonbitlang$core$json$$Json$string("𝒷") }, { _0: "bsemi", _1: moonbitlang$core$json$$Json$string("⁏") }, { _0: "bsim", _1: moonbitlang$core$json$$Json$string("∽") }, { _0: "bsime", _1: moonbitlang$core$json$$Json$string("⋍") }, { _0: "bsol", _1: moonbitlang$core$json$$Json$string("\\") }, { _0: "bsolb", _1: moonbitlang$core$json$$Json$string("⧅") }, { _0: "bsolhsub", _1: moonbitlang$core$json$$Json$string("⟈") }, { _0: "bull", _1: moonbitlang$core$json$$Json$string("•") }, { _0: "bullet", _1: moonbitlang$core$json$$Json$string("•") }, { _0: "bump", _1: moonbitlang$core$json$$Json$string("≎") }, { _0: "bumpE", _1: moonbitlang$core$json$$Json$string("⪮") }, { _0: "bumpe", _1: moonbitlang$core$json$$Json$string("≏") }, { _0: "bumpeq", _1: moonbitlang$core$json$$Json$string("≏") }, { _0: "cacute", _1: moonbitlang$core$json$$Json$string("ć") }, { _0: "cap", _1: moonbitlang$core$json$$Json$string("∩") }, { _0: "capand", _1: moonbitlang$core$json$$Json$string("⩄") }, { _0: "capbrcup", _1: moonbitlang$core$json$$Json$string("⩉") }, { _0: "capcap", _1: moonbitlang$core$json$$Json$string("⩋") }, { _0: "capcup", _1: moonbitlang$core$json$$Json$string("⩇") }, { _0: "capdot", _1: moonbitlang$core$json$$Json$string("⩀") }, { _0: "caps", _1: moonbitlang$core$json$$Json$string("∩︀") }, { _0: "caret", _1: moonbitlang$core$json$$Json$string("⁁") }, { _0: "caron", _1: moonbitlang$core$json$$Json$string("ˇ") }, { _0: "ccaps", _1: moonbitlang$core$json$$Json$string("⩍") }, { _0: "ccaron", _1: moonbitlang$core$json$$Json$string("č") }, { _0: "ccedil", _1: moonbitlang$core$json$$Json$string("ç") }, { _0: "ccirc", _1: moonbitlang$core$json$$Json$string("ĉ") }, { _0: "ccups", _1: moonbitlang$core$json$$Json$string("⩌") }, { _0: "ccupssm", _1: moonbitlang$core$json$$Json$string("⩐") }, { _0: "cdot", _1: moonbitlang$core$json$$Json$string("ċ") }, { _0: "cedil", _1: moonbitlang$core$json$$Json$string("¸") }, { _0: "cemptyv", _1: moonbitlang$core$json$$Json$string("⦲") }, { _0: "cent", _1: moonbitlang$core$json$$Json$string("¢") }, { _0: "centerdot", _1: moonbitlang$core$json$$Json$string("·") }, { _0: "cfr", _1: moonbitlang$core$json$$Json$string("𝔠") }, { _0: "chcy", _1: moonbitlang$core$json$$Json$string("ч") }, { _0: "check", _1: moonbitlang$core$json$$Json$string("✓") }, { _0: "checkmark", _1: moonbitlang$core$json$$Json$string("✓") }, { _0: "chi", _1: moonbitlang$core$json$$Json$string("χ") }, { _0: "cir", _1: moonbitlang$core$json$$Json$string("○") }, { _0: "cirE", _1: moonbitlang$core$json$$Json$string("⧃") }, { _0: "circ", _1: moonbitlang$core$json$$Json$string("ˆ") }, { _0: "circeq", _1: moonbitlang$core$json$$Json$string("≗") }, { _0: "circlearrowleft", _1: moonbitlang$core$json$$Json$string("↺") }, { _0: "circlearrowright", _1: moonbitlang$core$json$$Json$string("↻") }, { _0: "circledR", _1: moonbitlang$core$json$$Json$string("®") }, { _0: "circledS", _1: moonbitlang$core$json$$Json$string("Ⓢ") }, { _0: "circledast", _1: moonbitlang$core$json$$Json$string("⊛") }, { _0: "circledcirc", _1: moonbitlang$core$json$$Json$string("⊚") }, { _0: "circleddash", _1: moonbitlang$core$json$$Json$string("⊝") }, { _0: "cire", _1: moonbitlang$core$json$$Json$string("≗") }, { _0: "cirfnint", _1: moonbitlang$core$json$$Json$string("⨐") }, { _0: "cirmid", _1: moonbitlang$core$json$$Json$string("⫯") }, { _0: "cirscir", _1: moonbitlang$core$json$$Json$string("⧂") }, { _0: "clubs", _1: moonbitlang$core$json$$Json$string("♣") }, { _0: "clubsuit", _1: moonbitlang$core$json$$Json$string("♣") }, { _0: "colon", _1: moonbitlang$core$json$$Json$string(":") }, { _0: "colone", _1: moonbitlang$core$json$$Json$string("≔") }, { _0: "coloneq", _1: moonbitlang$core$json$$Json$string("≔") }, { _0: "comma", _1: moonbitlang$core$json$$Json$string(",") }, { _0: "commat", _1: moonbitlang$core$json$$Json$string("@") }, { _0: "comp", _1: moonbitlang$core$json$$Json$string("∁") }, { _0: "compfn", _1: moonbitlang$core$json$$Json$string("∘") }, { _0: "complement", _1: moonbitlang$core$json$$Json$string("∁") }, { _0: "complexes", _1: moonbitlang$core$json$$Json$string("ℂ") }, { _0: "cong", _1: moonbitlang$core$json$$Json$string("≅") }, { _0: "congdot", _1: moonbitlang$core$json$$Json$string("⩭") }, { _0: "conint", _1: moonbitlang$core$json$$Json$string("∮") }, { _0: "copf", _1: moonbitlang$core$json$$Json$string("𝕔") }, { _0: "coprod", _1: moonbitlang$core$json$$Json$string("∐") }, { _0: "copy", _1: moonbitlang$core$json$$Json$string("©") }, { _0: "copysr", _1: moonbitlang$core$json$$Json$string("℗") }, { _0: "crarr", _1: moonbitlang$core$json$$Json$string("↵") }, { _0: "cross", _1: moonbitlang$core$json$$Json$string("✗") }, { _0: "cscr", _1: moonbitlang$core$json$$Json$string("𝒸") }, { _0: "csub", _1: moonbitlang$core$json$$Json$string("⫏") }, { _0: "csube", _1: moonbitlang$core$json$$Json$string("⫑") }, { _0: "csup", _1: moonbitlang$core$json$$Json$string("⫐") }, { _0: "csupe", _1: moonbitlang$core$json$$Json$string("⫒") }, { _0: "ctdot", _1: moonbitlang$core$json$$Json$string("⋯") }, { _0: "cudarrl", _1: moonbitlang$core$json$$Json$string("⤸") }, { _0: "cudarrr", _1: moonbitlang$core$json$$Json$string("⤵") }, { _0: "cuepr", _1: moonbitlang$core$json$$Json$string("⋞") }, { _0: "cuesc", _1: moonbitlang$core$json$$Json$string("⋟") }, { _0: "cularr", _1: moonbitlang$core$json$$Json$string("↶") }, { _0: "cularrp", _1: moonbitlang$core$json$$Json$string("⤽") }, { _0: "cup", _1: moonbitlang$core$json$$Json$string("∪") }, { _0: "cupbrcap", _1: moonbitlang$core$json$$Json$string("⩈") }, { _0: "cupcap", _1: moonbitlang$core$json$$Json$string("⩆") }, { _0: "cupcup", _1: moonbitlang$core$json$$Json$string("⩊") }, { _0: "cupdot", _1: moonbitlang$core$json$$Json$string("⊍") }, { _0: "cupor", _1: moonbitlang$core$json$$Json$string("⩅") }, { _0: "cups", _1: moonbitlang$core$json$$Json$string("∪︀") }, { _0: "curarr", _1: moonbitlang$core$json$$Json$string("↷") }, { _0: "curarrm", _1: moonbitlang$core$json$$Json$string("⤼") }, { _0: "curlyeqprec", _1: moonbitlang$core$json$$Json$string("⋞") }, { _0: "curlyeqsucc", _1: moonbitlang$core$json$$Json$string("⋟") }, { _0: "curlyvee", _1: moonbitlang$core$json$$Json$string("⋎") }, { _0: "curlywedge", _1: moonbitlang$core$json$$Json$string("⋏") }, { _0: "curren", _1: moonbitlang$core$json$$Json$string("¤") }, { _0: "curvearrowleft", _1: moonbitlang$core$json$$Json$string("↶") }, { _0: "curvearrowright", _1: moonbitlang$core$json$$Json$string("↷") }, { _0: "cuvee", _1: moonbitlang$core$json$$Json$string("⋎") }, { _0: "cuwed", _1: moonbitlang$core$json$$Json$string("⋏") }, { _0: "cwconint", _1: moonbitlang$core$json$$Json$string("∲") }, { _0: "cwint", _1: moonbitlang$core$json$$Json$string("∱") }, { _0: "cylcty", _1: moonbitlang$core$json$$Json$string("⌭") }, { _0: "dArr", _1: moonbitlang$core$json$$Json$string("⇓") }, { _0: "dHar", _1: moonbitlang$core$json$$Json$string("⥥") }, { _0: "dagger", _1: moonbitlang$core$json$$Json$string("†") }, { _0: "daleth", _1: moonbitlang$core$json$$Json$string("ℸ") }, { _0: "darr", _1: moonbitlang$core$json$$Json$string("↓") }, { _0: "dash", _1: moonbitlang$core$json$$Json$string("‐") }, { _0: "dashv", _1: moonbitlang$core$json$$Json$string("⊣") }, { _0: "dbkarow", _1: moonbitlang$core$json$$Json$string("⤏") }, { _0: "dblac", _1: moonbitlang$core$json$$Json$string("˝") }, { _0: "dcaron", _1: moonbitlang$core$json$$Json$string("ď") }, { _0: "dcy", _1: moonbitlang$core$json$$Json$string("д") }, { _0: "dd", _1: moonbitlang$core$json$$Json$string("ⅆ") }, { _0: "ddagger", _1: moonbitlang$core$json$$Json$string("‡") }, { _0: "ddarr", _1: moonbitlang$core$json$$Json$string("⇊") }, { _0: "ddotseq", _1: moonbitlang$core$json$$Json$string("⩷") }, { _0: "deg", _1: moonbitlang$core$json$$Json$string("°") }, { _0: "delta", _1: moonbitlang$core$json$$Json$string("δ") }, { _0: "demptyv", _1: moonbitlang$core$json$$Json$string("⦱") }, { _0: "dfisht", _1: moonbitlang$core$json$$Json$string("⥿") }, { _0: "dfr", _1: moonbitlang$core$json$$Json$string("𝔡") }, { _0: "dharl", _1: moonbitlang$core$json$$Json$string("⇃") }, { _0: "dharr", _1: moonbitlang$core$json$$Json$string("⇂") }, { _0: "diam", _1: moonbitlang$core$json$$Json$string("⋄") }, { _0: "diamond", _1: moonbitlang$core$json$$Json$string("⋄") }, { _0: "diamondsuit", _1: moonbitlang$core$json$$Json$string("♦") }, { _0: "diams", _1: moonbitlang$core$json$$Json$string("♦") }, { _0: "die", _1: moonbitlang$core$json$$Json$string("¨") }, { _0: "digamma", _1: moonbitlang$core$json$$Json$string("ϝ") }, { _0: "disin", _1: moonbitlang$core$json$$Json$string("⋲") }, { _0: "div", _1: moonbitlang$core$json$$Json$string("÷") }, { _0: "divide", _1: moonbitlang$core$json$$Json$string("÷") }, { _0: "divideontimes", _1: moonbitlang$core$json$$Json$string("⋇") }, { _0: "divonx", _1: moonbitlang$core$json$$Json$string("⋇") }, { _0: "djcy", _1: moonbitlang$core$json$$Json$string("ђ") }, { _0: "dlcorn", _1: moonbitlang$core$json$$Json$string("⌞") }, { _0: "dlcrop", _1: moonbitlang$core$json$$Json$string("⌍") }, { _0: "dollar", _1: moonbitlang$core$json$$Json$string("$") }, { _0: "dopf", _1: moonbitlang$core$json$$Json$string("𝕕") }, { _0: "dot", _1: moonbitlang$core$json$$Json$string("˙") }, { _0: "doteq", _1: moonbitlang$core$json$$Json$string("≐") }, { _0: "doteqdot", _1: moonbitlang$core$json$$Json$string("≑") }, { _0: "dotminus", _1: moonbitlang$core$json$$Json$string("∸") }, { _0: "dotplus", _1: moonbitlang$core$json$$Json$string("∔") }, { _0: "dotsquare", _1: moonbitlang$core$json$$Json$string("⊡") }, { _0: "doublebarwedge", _1: moonbitlang$core$json$$Json$string("⌆") }, { _0: "downarrow", _1: moonbitlang$core$json$$Json$string("↓") }, { _0: "downdownarrows", _1: moonbitlang$core$json$$Json$string("⇊") }, { _0: "downharpoonleft", _1: moonbitlang$core$json$$Json$string("⇃") }, { _0: "downharpoonright", _1: moonbitlang$core$json$$Json$string("⇂") }, { _0: "drbkarow", _1: moonbitlang$core$json$$Json$string("⤐") }, { _0: "drcorn", _1: moonbitlang$core$json$$Json$string("⌟") }, { _0: "drcrop", _1: moonbitlang$core$json$$Json$string("⌌") }, { _0: "dscr", _1: moonbitlang$core$json$$Json$string("𝒹") }, { _0: "dscy", _1: moonbitlang$core$json$$Json$string("ѕ") }, { _0: "dsol", _1: moonbitlang$core$json$$Json$string("⧶") }, { _0: "dstrok", _1: moonbitlang$core$json$$Json$string("đ") }, { _0: "dtdot", _1: moonbitlang$core$json$$Json$string("⋱") }, { _0: "dtri", _1: moonbitlang$core$json$$Json$string("▿") }, { _0: "dtrif", _1: moonbitlang$core$json$$Json$string("▾") }, { _0: "duarr", _1: moonbitlang$core$json$$Json$string("⇵") }, { _0: "duhar", _1: moonbitlang$core$json$$Json$string("⥯") }, { _0: "dwangle", _1: moonbitlang$core$json$$Json$string("⦦") }, { _0: "dzcy", _1: moonbitlang$core$json$$Json$string("џ") }, { _0: "dzigrarr", _1: moonbitlang$core$json$$Json$string("⟿") }, { _0: "eDDot", _1: moonbitlang$core$json$$Json$string("⩷") }, { _0: "eDot", _1: moonbitlang$core$json$$Json$string("≑") }, { _0: "eacute", _1: moonbitlang$core$json$$Json$string("é") }, { _0: "easter", _1: moonbitlang$core$json$$Json$string("⩮") }, { _0: "ecaron", _1: moonbitlang$core$json$$Json$string("ě") }, { _0: "ecir", _1: moonbitlang$core$json$$Json$string("≖") }, { _0: "ecirc", _1: moonbitlang$core$json$$Json$string("ê") }, { _0: "ecolon", _1: moonbitlang$core$json$$Json$string("≕") }, { _0: "ecy", _1: moonbitlang$core$json$$Json$string("э") }, { _0: "edot", _1: moonbitlang$core$json$$Json$string("ė") }, { _0: "ee", _1: moonbitlang$core$json$$Json$string("ⅇ") }, { _0: "efDot", _1: moonbitlang$core$json$$Json$string("≒") }, { _0: "efr", _1: moonbitlang$core$json$$Json$string("𝔢") }, { _0: "eg", _1: moonbitlang$core$json$$Json$string("⪚") }, { _0: "egrave", _1: moonbitlang$core$json$$Json$string("è") }, { _0: "egs", _1: moonbitlang$core$json$$Json$string("⪖") }, { _0: "egsdot", _1: moonbitlang$core$json$$Json$string("⪘") }, { _0: "el", _1: moonbitlang$core$json$$Json$string("⪙") }, { _0: "elinters", _1: moonbitlang$core$json$$Json$string("⏧") }, { _0: "ell", _1: moonbitlang$core$json$$Json$string("ℓ") }, { _0: "els", _1: moonbitlang$core$json$$Json$string("⪕") }, { _0: "elsdot", _1: moonbitlang$core$json$$Json$string("⪗") }, { _0: "emacr", _1: moonbitlang$core$json$$Json$string("ē") }, { _0: "empty", _1: moonbitlang$core$json$$Json$string("∅") }, { _0: "emptyset", _1: moonbitlang$core$json$$Json$string("∅") }, { _0: "emptyv", _1: moonbitlang$core$json$$Json$string("∅") }, { _0: "emsp13", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "emsp14", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "emsp", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "eng", _1: moonbitlang$core$json$$Json$string("ŋ") }, { _0: "ensp", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "eogon", _1: moonbitlang$core$json$$Json$string("ę") }, { _0: "eopf", _1: moonbitlang$core$json$$Json$string("𝕖") }, { _0: "epar", _1: moonbitlang$core$json$$Json$string("⋕") }, { _0: "eparsl", _1: moonbitlang$core$json$$Json$string("⧣") }, { _0: "eplus", _1: moonbitlang$core$json$$Json$string("⩱") }, { _0: "epsi", _1: moonbitlang$core$json$$Json$string("ε") }, { _0: "epsilon", _1: moonbitlang$core$json$$Json$string("ε") }, { _0: "epsiv", _1: moonbitlang$core$json$$Json$string("ϵ") }, { _0: "eqcirc", _1: moonbitlang$core$json$$Json$string("≖") }, { _0: "eqcolon", _1: moonbitlang$core$json$$Json$string("≕") }, { _0: "eqsim", _1: moonbitlang$core$json$$Json$string("≂") }, { _0: "eqslantgtr", _1: moonbitlang$core$json$$Json$string("⪖") }, { _0: "eqslantless", _1: moonbitlang$core$json$$Json$string("⪕") }, { _0: "equals", _1: moonbitlang$core$json$$Json$string("=") }, { _0: "equest", _1: moonbitlang$core$json$$Json$string("≟") }, { _0: "equiv", _1: moonbitlang$core$json$$Json$string("≡") }, { _0: "equivDD", _1: moonbitlang$core$json$$Json$string("⩸") }, { _0: "eqvparsl", _1: moonbitlang$core$json$$Json$string("⧥") }, { _0: "erDot", _1: moonbitlang$core$json$$Json$string("≓") }, { _0: "erarr", _1: moonbitlang$core$json$$Json$string("⥱") }, { _0: "escr", _1: moonbitlang$core$json$$Json$string("ℯ") }, { _0: "esdot", _1: moonbitlang$core$json$$Json$string("≐") }, { _0: "esim", _1: moonbitlang$core$json$$Json$string("≂") }, { _0: "eta", _1: moonbitlang$core$json$$Json$string("η") }, { _0: "eth", _1: moonbitlang$core$json$$Json$string("ð") }, { _0: "euml", _1: moonbitlang$core$json$$Json$string("ë") }, { _0: "euro", _1: moonbitlang$core$json$$Json$string("€") }, { _0: "excl", _1: moonbitlang$core$json$$Json$string("!") }, { _0: "exist", _1: moonbitlang$core$json$$Json$string("∃") }, { _0: "expectation", _1: moonbitlang$core$json$$Json$string("ℰ") }, { _0: "exponentiale", _1: moonbitlang$core$json$$Json$string("ⅇ") }, { _0: "fallingdotseq", _1: moonbitlang$core$json$$Json$string("≒") }, { _0: "fcy", _1: moonbitlang$core$json$$Json$string("ф") }, { _0: "female", _1: moonbitlang$core$json$$Json$string("♀") }, { _0: "ffilig", _1: moonbitlang$core$json$$Json$string("ﬃ") }, { _0: "fflig", _1: moonbitlang$core$json$$Json$string("ﬀ") }, { _0: "ffllig", _1: moonbitlang$core$json$$Json$string("ﬄ") }, { _0: "ffr", _1: moonbitlang$core$json$$Json$string("𝔣") }, { _0: "filig", _1: moonbitlang$core$json$$Json$string("ﬁ") }, { _0: "fjlig", _1: moonbitlang$core$json$$Json$string("fj") }, { _0: "flat", _1: moonbitlang$core$json$$Json$string("♭") }, { _0: "fllig", _1: moonbitlang$core$json$$Json$string("ﬂ") }, { _0: "fltns", _1: moonbitlang$core$json$$Json$string("▱") }, { _0: "fnof", _1: moonbitlang$core$json$$Json$string("ƒ") }, { _0: "fopf", _1: moonbitlang$core$json$$Json$string("𝕗") }, { _0: "forall", _1: moonbitlang$core$json$$Json$string("∀") }, { _0: "fork", _1: moonbitlang$core$json$$Json$string("⋔") }, { _0: "forkv", _1: moonbitlang$core$json$$Json$string("⫙") }, { _0: "fpartint", _1: moonbitlang$core$json$$Json$string("⨍") }, { _0: "frac12", _1: moonbitlang$core$json$$Json$string("½") }, { _0: "frac13", _1: moonbitlang$core$json$$Json$string("⅓") }, { _0: "frac14", _1: moonbitlang$core$json$$Json$string("¼") }, { _0: "frac15", _1: moonbitlang$core$json$$Json$string("⅕") }, { _0: "frac16", _1: moonbitlang$core$json$$Json$string("⅙") }, { _0: "frac18", _1: moonbitlang$core$json$$Json$string("⅛") }, { _0: "frac23", _1: moonbitlang$core$json$$Json$string("⅔") }, { _0: "frac25", _1: moonbitlang$core$json$$Json$string("⅖") }, { _0: "frac34", _1: moonbitlang$core$json$$Json$string("¾") }, { _0: "frac35", _1: moonbitlang$core$json$$Json$string("⅗") }, { _0: "frac38", _1: moonbitlang$core$json$$Json$string("⅜") }, { _0: "frac45", _1: moonbitlang$core$json$$Json$string("⅘") }, { _0: "frac56", _1: moonbitlang$core$json$$Json$string("⅚") }, { _0: "frac58", _1: moonbitlang$core$json$$Json$string("⅝") }, { _0: "frac78", _1: moonbitlang$core$json$$Json$string("⅞") }, { _0: "frasl", _1: moonbitlang$core$json$$Json$string("⁄") }, { _0: "frown", _1: moonbitlang$core$json$$Json$string("⌢") }, { _0: "fscr", _1: moonbitlang$core$json$$Json$string("𝒻") }, { _0: "gE", _1: moonbitlang$core$json$$Json$string("≧") }, { _0: "gEl", _1: moonbitlang$core$json$$Json$string("⪌") }, { _0: "gacute", _1: moonbitlang$core$json$$Json$string("ǵ") }, { _0: "gamma", _1: moonbitlang$core$json$$Json$string("γ") }, { _0: "gammad", _1: moonbitlang$core$json$$Json$string("ϝ") }, { _0: "gap", _1: moonbitlang$core$json$$Json$string("⪆") }, { _0: "gbreve", _1: moonbitlang$core$json$$Json$string("ğ") }, { _0: "gcirc", _1: moonbitlang$core$json$$Json$string("ĝ") }, { _0: "gcy", _1: moonbitlang$core$json$$Json$string("г") }, { _0: "gdot", _1: moonbitlang$core$json$$Json$string("ġ") }, { _0: "ge", _1: moonbitlang$core$json$$Json$string("≥") }, { _0: "gel", _1: moonbitlang$core$json$$Json$string("⋛") }, { _0: "geq", _1: moonbitlang$core$json$$Json$string("≥") }, { _0: "geqq", _1: moonbitlang$core$json$$Json$string("≧") }, { _0: "geqslant", _1: moonbitlang$core$json$$Json$string("⩾") }, { _0: "ges", _1: moonbitlang$core$json$$Json$string("⩾") }, { _0: "gescc", _1: moonbitlang$core$json$$Json$string("⪩") }, { _0: "gesdot", _1: moonbitlang$core$json$$Json$string("⪀") }, { _0: "gesdoto", _1: moonbitlang$core$json$$Json$string("⪂") }, { _0: "gesdotol", _1: moonbitlang$core$json$$Json$string("⪄") }, { _0: "gesl", _1: moonbitlang$core$json$$Json$string("⋛︀") }, { _0: "gesles", _1: moonbitlang$core$json$$Json$string("⪔") }, { _0: "gfr", _1: moonbitlang$core$json$$Json$string("𝔤") }, { _0: "gg", _1: moonbitlang$core$json$$Json$string("≫") }, { _0: "ggg", _1: moonbitlang$core$json$$Json$string("⋙") }, { _0: "gimel", _1: moonbitlang$core$json$$Json$string("ℷ") }, { _0: "gjcy", _1: moonbitlang$core$json$$Json$string("ѓ") }, { _0: "gl", _1: moonbitlang$core$json$$Json$string("≷") }, { _0: "glE", _1: moonbitlang$core$json$$Json$string("⪒") }, { _0: "gla", _1: moonbitlang$core$json$$Json$string("⪥") }, { _0: "glj", _1: moonbitlang$core$json$$Json$string("⪤") }, { _0: "gnE", _1: moonbitlang$core$json$$Json$string("≩") }, { _0: "gnap", _1: moonbitlang$core$json$$Json$string("⪊") }, { _0: "gnapprox", _1: moonbitlang$core$json$$Json$string("⪊") }, { _0: "gne", _1: moonbitlang$core$json$$Json$string("⪈") }, { _0: "gneq", _1: moonbitlang$core$json$$Json$string("⪈") }, { _0: "gneqq", _1: moonbitlang$core$json$$Json$string("≩") }, { _0: "gnsim", _1: moonbitlang$core$json$$Json$string("⋧") }, { _0: "gopf", _1: moonbitlang$core$json$$Json$string("𝕘") }, { _0: "grave", _1: moonbitlang$core$json$$Json$string("`") }, { _0: "gscr", _1: moonbitlang$core$json$$Json$string("ℊ") }, { _0: "gsim", _1: moonbitlang$core$json$$Json$string("≳") }, { _0: "gsime", _1: moonbitlang$core$json$$Json$string("⪎") }, { _0: "gsiml", _1: moonbitlang$core$json$$Json$string("⪐") }, { _0: "gt", _1: moonbitlang$core$json$$Json$string(">") }, { _0: "gtcc", _1: moonbitlang$core$json$$Json$string("⪧") }, { _0: "gtcir", _1: moonbitlang$core$json$$Json$string("⩺") }, { _0: "gtdot", _1: moonbitlang$core$json$$Json$string("⋗") }, { _0: "gtlPar", _1: moonbitlang$core$json$$Json$string("⦕") }, { _0: "gtquest", _1: moonbitlang$core$json$$Json$string("⩼") }, { _0: "gtrapprox", _1: moonbitlang$core$json$$Json$string("⪆") }, { _0: "gtrarr", _1: moonbitlang$core$json$$Json$string("⥸") }, { _0: "gtrdot", _1: moonbitlang$core$json$$Json$string("⋗") }, { _0: "gtreqless", _1: moonbitlang$core$json$$Json$string("⋛") }, { _0: "gtreqqless", _1: moonbitlang$core$json$$Json$string("⪌") }, { _0: "gtrless", _1: moonbitlang$core$json$$Json$string("≷") }, { _0: "gtrsim", _1: moonbitlang$core$json$$Json$string("≳") }, { _0: "gvertneqq", _1: moonbitlang$core$json$$Json$string("≩︀") }, { _0: "gvnE", _1: moonbitlang$core$json$$Json$string("≩︀") }, { _0: "hArr", _1: moonbitlang$core$json$$Json$string("⇔") }, { _0: "hairsp", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "half", _1: moonbitlang$core$json$$Json$string("½") }, { _0: "hamilt", _1: moonbitlang$core$json$$Json$string("ℋ") }, { _0: "hardcy", _1: moonbitlang$core$json$$Json$string("ъ") }, { _0: "harr", _1: moonbitlang$core$json$$Json$string("↔") }, { _0: "harrcir", _1: moonbitlang$core$json$$Json$string("⥈") }, { _0: "harrw", _1: moonbitlang$core$json$$Json$string("↭") }, { _0: "hbar", _1: moonbitlang$core$json$$Json$string("ℏ") }, { _0: "hcirc", _1: moonbitlang$core$json$$Json$string("ĥ") }, { _0: "hearts", _1: moonbitlang$core$json$$Json$string("♥") }, { _0: "heartsuit", _1: moonbitlang$core$json$$Json$string("♥") }, { _0: "hellip", _1: moonbitlang$core$json$$Json$string("…") }, { _0: "hercon", _1: moonbitlang$core$json$$Json$string("⊹") }, { _0: "hfr", _1: moonbitlang$core$json$$Json$string("𝔥") }, { _0: "hksearow", _1: moonbitlang$core$json$$Json$string("⤥") }, { _0: "hkswarow", _1: moonbitlang$core$json$$Json$string("⤦") }, { _0: "hoarr", _1: moonbitlang$core$json$$Json$string("⇿") }, { _0: "homtht", _1: moonbitlang$core$json$$Json$string("∻") }, { _0: "hookleftarrow", _1: moonbitlang$core$json$$Json$string("↩") }, { _0: "hookrightarrow", _1: moonbitlang$core$json$$Json$string("↪") }, { _0: "hopf", _1: moonbitlang$core$json$$Json$string("𝕙") }, { _0: "horbar", _1: moonbitlang$core$json$$Json$string("―") }, { _0: "hscr", _1: moonbitlang$core$json$$Json$string("𝒽") }, { _0: "hslash", _1: moonbitlang$core$json$$Json$string("ℏ") }, { _0: "hstrok", _1: moonbitlang$core$json$$Json$string("ħ") }, { _0: "hybull", _1: moonbitlang$core$json$$Json$string("⁃") }, { _0: "hyphen", _1: moonbitlang$core$json$$Json$string("‐") }, { _0: "iacute", _1: moonbitlang$core$json$$Json$string("í") }, { _0: "ic", _1: moonbitlang$core$json$$Json$string("⁣") }, { _0: "icirc", _1: moonbitlang$core$json$$Json$string("î") }, { _0: "icy", _1: moonbitlang$core$json$$Json$string("и") }, { _0: "iecy", _1: moonbitlang$core$json$$Json$string("е") }, { _0: "iexcl", _1: moonbitlang$core$json$$Json$string("¡") }, { _0: "iff", _1: moonbitlang$core$json$$Json$string("⇔") }, { _0: "ifr", _1: moonbitlang$core$json$$Json$string("𝔦") }, { _0: "igrave", _1: moonbitlang$core$json$$Json$string("ì") }, { _0: "ii", _1: moonbitlang$core$json$$Json$string("ⅈ") }, { _0: "iiiint", _1: moonbitlang$core$json$$Json$string("⨌") }, { _0: "iiint", _1: moonbitlang$core$json$$Json$string("∭") }, { _0: "iinfin", _1: moonbitlang$core$json$$Json$string("⧜") }, { _0: "iiota", _1: moonbitlang$core$json$$Json$string("℩") }, { _0: "ijlig", _1: moonbitlang$core$json$$Json$string("ĳ") }, { _0: "imacr", _1: moonbitlang$core$json$$Json$string("ī") }, { _0: "image", _1: moonbitlang$core$json$$Json$string("ℑ") }, { _0: "imagline", _1: moonbitlang$core$json$$Json$string("ℐ") }, { _0: "imagpart", _1: moonbitlang$core$json$$Json$string("ℑ") }, { _0: "imath", _1: moonbitlang$core$json$$Json$string("ı") }, { _0: "imof", _1: moonbitlang$core$json$$Json$string("⊷") }, { _0: "imped", _1: moonbitlang$core$json$$Json$string("Ƶ") }, { _0: "in", _1: moonbitlang$core$json$$Json$string("∈") }, { _0: "incare", _1: moonbitlang$core$json$$Json$string("℅") }, { _0: "infin", _1: moonbitlang$core$json$$Json$string("∞") }, { _0: "infintie", _1: moonbitlang$core$json$$Json$string("⧝") }, { _0: "inodot", _1: moonbitlang$core$json$$Json$string("ı") }, { _0: "int", _1: moonbitlang$core$json$$Json$string("∫") }, { _0: "intcal", _1: moonbitlang$core$json$$Json$string("⊺") }, { _0: "integers", _1: moonbitlang$core$json$$Json$string("ℤ") }, { _0: "intercal", _1: moonbitlang$core$json$$Json$string("⊺") }, { _0: "intlarhk", _1: moonbitlang$core$json$$Json$string("⨗") }, { _0: "intprod", _1: moonbitlang$core$json$$Json$string("⨼") }, { _0: "iocy", _1: moonbitlang$core$json$$Json$string("ё") }, { _0: "iogon", _1: moonbitlang$core$json$$Json$string("į") }, { _0: "iopf", _1: moonbitlang$core$json$$Json$string("𝕚") }, { _0: "iota", _1: moonbitlang$core$json$$Json$string("ι") }, { _0: "iprod", _1: moonbitlang$core$json$$Json$string("⨼") }, { _0: "iquest", _1: moonbitlang$core$json$$Json$string("¿") }, { _0: "iscr", _1: moonbitlang$core$json$$Json$string("𝒾") }, { _0: "isin", _1: moonbitlang$core$json$$Json$string("∈") }, { _0: "isinE", _1: moonbitlang$core$json$$Json$string("⋹") }, { _0: "isindot", _1: moonbitlang$core$json$$Json$string("⋵") }, { _0: "isins", _1: moonbitlang$core$json$$Json$string("⋴") }, { _0: "isinsv", _1: moonbitlang$core$json$$Json$string("⋳") }, { _0: "isinv", _1: moonbitlang$core$json$$Json$string("∈") }, { _0: "it", _1: moonbitlang$core$json$$Json$string("⁢") }, { _0: "itilde", _1: moonbitlang$core$json$$Json$string("ĩ") }, { _0: "iukcy", _1: moonbitlang$core$json$$Json$string("і") }, { _0: "iuml", _1: moonbitlang$core$json$$Json$string("ï") }, { _0: "jcirc", _1: moonbitlang$core$json$$Json$string("ĵ") }, { _0: "jcy", _1: moonbitlang$core$json$$Json$string("й") }, { _0: "jfr", _1: moonbitlang$core$json$$Json$string("𝔧") }, { _0: "jmath", _1: moonbitlang$core$json$$Json$string("ȷ") }, { _0: "jopf", _1: moonbitlang$core$json$$Json$string("𝕛") }, { _0: "jscr", _1: moonbitlang$core$json$$Json$string("𝒿") }, { _0: "jsercy", _1: moonbitlang$core$json$$Json$string("ј") }, { _0: "jukcy", _1: moonbitlang$core$json$$Json$string("є") }, { _0: "kappa", _1: moonbitlang$core$json$$Json$string("κ") }, { _0: "kappav", _1: moonbitlang$core$json$$Json$string("ϰ") }, { _0: "kcedil", _1: moonbitlang$core$json$$Json$string("ķ") }, { _0: "kcy", _1: moonbitlang$core$json$$Json$string("к") }, { _0: "kfr", _1: moonbitlang$core$json$$Json$string("𝔨") }, { _0: "kgreen", _1: moonbitlang$core$json$$Json$string("ĸ") }, { _0: "khcy", _1: moonbitlang$core$json$$Json$string("х") }, { _0: "kjcy", _1: moonbitlang$core$json$$Json$string("ќ") }, { _0: "kopf", _1: moonbitlang$core$json$$Json$string("𝕜") }, { _0: "kscr", _1: moonbitlang$core$json$$Json$string("𝓀") }, { _0: "lAarr", _1: moonbitlang$core$json$$Json$string("⇚") }, { _0: "lArr", _1: moonbitlang$core$json$$Json$string("⇐") }, { _0: "lAtail", _1: moonbitlang$core$json$$Json$string("⤛") }, { _0: "lBarr", _1: moonbitlang$core$json$$Json$string("⤎") }, { _0: "lE", _1: moonbitlang$core$json$$Json$string("≦") }, { _0: "lEg", _1: moonbitlang$core$json$$Json$string("⪋") }, { _0: "lHar", _1: moonbitlang$core$json$$Json$string("⥢") }, { _0: "lacute", _1: moonbitlang$core$json$$Json$string("ĺ") }, { _0: "laemptyv", _1: moonbitlang$core$json$$Json$string("⦴") }, { _0: "lagran", _1: moonbitlang$core$json$$Json$string("ℒ") }, { _0: "lambda", _1: moonbitlang$core$json$$Json$string("λ") }, { _0: "lang", _1: moonbitlang$core$json$$Json$string("⟨") }, { _0: "langd", _1: moonbitlang$core$json$$Json$string("⦑") }, { _0: "langle", _1: moonbitlang$core$json$$Json$string("⟨") }, { _0: "lap", _1: moonbitlang$core$json$$Json$string("⪅") }, { _0: "laquo", _1: moonbitlang$core$json$$Json$string("«") }, { _0: "larr", _1: moonbitlang$core$json$$Json$string("←") }, { _0: "larrb", _1: moonbitlang$core$json$$Json$string("⇤") }, { _0: "larrbfs", _1: moonbitlang$core$json$$Json$string("⤟") }, { _0: "larrfs", _1: moonbitlang$core$json$$Json$string("⤝") }, { _0: "larrhk", _1: moonbitlang$core$json$$Json$string("↩") }, { _0: "larrlp", _1: moonbitlang$core$json$$Json$string("↫") }, { _0: "larrpl", _1: moonbitlang$core$json$$Json$string("⤹") }, { _0: "larrsim", _1: moonbitlang$core$json$$Json$string("⥳") }, { _0: "larrtl", _1: moonbitlang$core$json$$Json$string("↢") }, { _0: "lat", _1: moonbitlang$core$json$$Json$string("⪫") }, { _0: "latail", _1: moonbitlang$core$json$$Json$string("⤙") }, { _0: "late", _1: moonbitlang$core$json$$Json$string("⪭") }, { _0: "lates", _1: moonbitlang$core$json$$Json$string("⪭︀") }, { _0: "lbarr", _1: moonbitlang$core$json$$Json$string("⤌") }, { _0: "lbbrk", _1: moonbitlang$core$json$$Json$string("❲") }, { _0: "lbrace", _1: moonbitlang$core$json$$Json$string("{") }, { _0: "lbrack", _1: moonbitlang$core$json$$Json$string("[") }, { _0: "lbrke", _1: moonbitlang$core$json$$Json$string("⦋") }, { _0: "lbrksld", _1: moonbitlang$core$json$$Json$string("⦏") }, { _0: "lbrkslu", _1: moonbitlang$core$json$$Json$string("⦍") }, { _0: "lcaron", _1: moonbitlang$core$json$$Json$string("ľ") }, { _0: "lcedil", _1: moonbitlang$core$json$$Json$string("ļ") }, { _0: "lceil", _1: moonbitlang$core$json$$Json$string("⌈") }, { _0: "lcub", _1: moonbitlang$core$json$$Json$string("{") }, { _0: "lcy", _1: moonbitlang$core$json$$Json$string("л") }, { _0: "ldca", _1: moonbitlang$core$json$$Json$string("⤶") }, { _0: "ldquo", _1: moonbitlang$core$json$$Json$string("“") }, { _0: "ldquor", _1: moonbitlang$core$json$$Json$string("„") }, { _0: "ldrdhar", _1: moonbitlang$core$json$$Json$string("⥧") }, { _0: "ldrushar", _1: moonbitlang$core$json$$Json$string("⥋") }, { _0: "ldsh", _1: moonbitlang$core$json$$Json$string("↲") }, { _0: "le", _1: moonbitlang$core$json$$Json$string("≤") }, { _0: "leftarrow", _1: moonbitlang$core$json$$Json$string("←") }, { _0: "leftarrowtail", _1: moonbitlang$core$json$$Json$string("↢") }, { _0: "leftharpoondown", _1: moonbitlang$core$json$$Json$string("↽") }, { _0: "leftharpoonup", _1: moonbitlang$core$json$$Json$string("↼") }, { _0: "leftleftarrows", _1: moonbitlang$core$json$$Json$string("⇇") }, { _0: "leftrightarrow", _1: moonbitlang$core$json$$Json$string("↔") }, { _0: "leftrightarrows", _1: moonbitlang$core$json$$Json$string("⇆") }, { _0: "leftrightharpoons", _1: moonbitlang$core$json$$Json$string("⇋") }, { _0: "leftrightsquigarrow", _1: moonbitlang$core$json$$Json$string("↭") }, { _0: "leftthreetimes", _1: moonbitlang$core$json$$Json$string("⋋") }, { _0: "leg", _1: moonbitlang$core$json$$Json$string("⋚") }, { _0: "leq", _1: moonbitlang$core$json$$Json$string("≤") }, { _0: "leqq", _1: moonbitlang$core$json$$Json$string("≦") }, { _0: "leqslant", _1: moonbitlang$core$json$$Json$string("⩽") }, { _0: "les", _1: moonbitlang$core$json$$Json$string("⩽") }, { _0: "lescc", _1: moonbitlang$core$json$$Json$string("⪨") }, { _0: "lesdot", _1: moonbitlang$core$json$$Json$string("⩿") }, { _0: "lesdoto", _1: moonbitlang$core$json$$Json$string("⪁") }, { _0: "lesdotor", _1: moonbitlang$core$json$$Json$string("⪃") }, { _0: "lesg", _1: moonbitlang$core$json$$Json$string("⋚︀") }, { _0: "lesges", _1: moonbitlang$core$json$$Json$string("⪓") }, { _0: "lessapprox", _1: moonbitlang$core$json$$Json$string("⪅") }, { _0: "lessdot", _1: moonbitlang$core$json$$Json$string("⋖") }, { _0: "lesseqgtr", _1: moonbitlang$core$json$$Json$string("⋚") }, { _0: "lesseqqgtr", _1: moonbitlang$core$json$$Json$string("⪋") }, { _0: "lessgtr", _1: moonbitlang$core$json$$Json$string("≶") }, { _0: "lesssim", _1: moonbitlang$core$json$$Json$string("≲") }, { _0: "lfisht", _1: moonbitlang$core$json$$Json$string("⥼") }, { _0: "lfloor", _1: moonbitlang$core$json$$Json$string("⌊") }, { _0: "lfr", _1: moonbitlang$core$json$$Json$string("𝔩") }, { _0: "lg", _1: moonbitlang$core$json$$Json$string("≶") }, { _0: "lgE", _1: moonbitlang$core$json$$Json$string("⪑") }, { _0: "lhard", _1: moonbitlang$core$json$$Json$string("↽") }, { _0: "lharu", _1: moonbitlang$core$json$$Json$string("↼") }, { _0: "lharul", _1: moonbitlang$core$json$$Json$string("⥪") }, { _0: "lhblk", _1: moonbitlang$core$json$$Json$string("▄") }, { _0: "ljcy", _1: moonbitlang$core$json$$Json$string("љ") }, { _0: "ll", _1: moonbitlang$core$json$$Json$string("≪") }, { _0: "llarr", _1: moonbitlang$core$json$$Json$string("⇇") }, { _0: "llcorner", _1: moonbitlang$core$json$$Json$string("⌞") }, { _0: "llhard", _1: moonbitlang$core$json$$Json$string("⥫") }, { _0: "lltri", _1: moonbitlang$core$json$$Json$string("◺") }, { _0: "lmidot", _1: moonbitlang$core$json$$Json$string("ŀ") }, { _0: "lmoust", _1: moonbitlang$core$json$$Json$string("⎰") }, { _0: "lmoustache", _1: moonbitlang$core$json$$Json$string("⎰") }, { _0: "lnE", _1: moonbitlang$core$json$$Json$string("≨") }, { _0: "lnap", _1: moonbitlang$core$json$$Json$string("⪉") }, { _0: "lnapprox", _1: moonbitlang$core$json$$Json$string("⪉") }, { _0: "lne", _1: moonbitlang$core$json$$Json$string("⪇") }, { _0: "lneq", _1: moonbitlang$core$json$$Json$string("⪇") }, { _0: "lneqq", _1: moonbitlang$core$json$$Json$string("≨") }, { _0: "lnsim", _1: moonbitlang$core$json$$Json$string("⋦") }, { _0: "loang", _1: moonbitlang$core$json$$Json$string("⟬") }, { _0: "loarr", _1: moonbitlang$core$json$$Json$string("⇽") }, { _0: "lobrk", _1: moonbitlang$core$json$$Json$string("⟦") }, { _0: "longleftarrow", _1: moonbitlang$core$json$$Json$string("⟵") }, { _0: "longleftrightarrow", _1: moonbitlang$core$json$$Json$string("⟷") }, { _0: "longmapsto", _1: moonbitlang$core$json$$Json$string("⟼") }, { _0: "longrightarrow", _1: moonbitlang$core$json$$Json$string("⟶") }, { _0: "looparrowleft", _1: moonbitlang$core$json$$Json$string("↫") }, { _0: "looparrowright", _1: moonbitlang$core$json$$Json$string("↬") }, { _0: "lopar", _1: moonbitlang$core$json$$Json$string("⦅") }, { _0: "lopf", _1: moonbitlang$core$json$$Json$string("𝕝") }, { _0: "loplus", _1: moonbitlang$core$json$$Json$string("⨭") }, { _0: "lotimes", _1: moonbitlang$core$json$$Json$string("⨴") }, { _0: "lowast", _1: moonbitlang$core$json$$Json$string("∗") }, { _0: "lowbar", _1: moonbitlang$core$json$$Json$string("_") }, { _0: "loz", _1: moonbitlang$core$json$$Json$string("◊") }, { _0: "lozenge", _1: moonbitlang$core$json$$Json$string("◊") }, { _0: "lozf", _1: moonbitlang$core$json$$Json$string("⧫") }, { _0: "lpar", _1: moonbitlang$core$json$$Json$string("(") }, { _0: "lparlt", _1: moonbitlang$core$json$$Json$string("⦓") }, { _0: "lrarr", _1: moonbitlang$core$json$$Json$string("⇆") }, { _0: "lrcorner", _1: moonbitlang$core$json$$Json$string("⌟") }, { _0: "lrhar", _1: moonbitlang$core$json$$Json$string("⇋") }, { _0: "lrhard", _1: moonbitlang$core$json$$Json$string("⥭") }, { _0: "lrm", _1: moonbitlang$core$json$$Json$string("‎") }, { _0: "lrtri", _1: moonbitlang$core$json$$Json$string("⊿") }, { _0: "lsaquo", _1: moonbitlang$core$json$$Json$string("‹") }, { _0: "lscr", _1: moonbitlang$core$json$$Json$string("𝓁") }, { _0: "lsh", _1: moonbitlang$core$json$$Json$string("↰") }, { _0: "lsim", _1: moonbitlang$core$json$$Json$string("≲") }, { _0: "lsime", _1: moonbitlang$core$json$$Json$string("⪍") }, { _0: "lsimg", _1: moonbitlang$core$json$$Json$string("⪏") }, { _0: "lsqb", _1: moonbitlang$core$json$$Json$string("[") }, { _0: "lsquo", _1: moonbitlang$core$json$$Json$string("‘") }, { _0: "lsquor", _1: moonbitlang$core$json$$Json$string("‚") }, { _0: "lstrok", _1: moonbitlang$core$json$$Json$string("ł") }, { _0: "lt", _1: moonbitlang$core$json$$Json$string("<") }, { _0: "ltcc", _1: moonbitlang$core$json$$Json$string("⪦") }, { _0: "ltcir", _1: moonbitlang$core$json$$Json$string("⩹") }, { _0: "ltdot", _1: moonbitlang$core$json$$Json$string("⋖") }, { _0: "lthree", _1: moonbitlang$core$json$$Json$string("⋋") }, { _0: "ltimes", _1: moonbitlang$core$json$$Json$string("⋉") }, { _0: "ltlarr", _1: moonbitlang$core$json$$Json$string("⥶") }, { _0: "ltquest", _1: moonbitlang$core$json$$Json$string("⩻") }, { _0: "ltrPar", _1: moonbitlang$core$json$$Json$string("⦖") }, { _0: "ltri", _1: moonbitlang$core$json$$Json$string("◃") }, { _0: "ltrie", _1: moonbitlang$core$json$$Json$string("⊴") }, { _0: "ltrif", _1: moonbitlang$core$json$$Json$string("◂") }, { _0: "lurdshar", _1: moonbitlang$core$json$$Json$string("⥊") }, { _0: "luruhar", _1: moonbitlang$core$json$$Json$string("⥦") }, { _0: "lvertneqq", _1: moonbitlang$core$json$$Json$string("≨︀") }, { _0: "lvnE", _1: moonbitlang$core$json$$Json$string("≨︀") }, { _0: "mDDot", _1: moonbitlang$core$json$$Json$string("∺") }, { _0: "macr", _1: moonbitlang$core$json$$Json$string("¯") }, { _0: "male", _1: moonbitlang$core$json$$Json$string("♂") }, { _0: "malt", _1: moonbitlang$core$json$$Json$string("✠") }, { _0: "maltese", _1: moonbitlang$core$json$$Json$string("✠") }, { _0: "map", _1: moonbitlang$core$json$$Json$string("↦") }, { _0: "mapsto", _1: moonbitlang$core$json$$Json$string("↦") }, { _0: "mapstodown", _1: moonbitlang$core$json$$Json$string("↧") }, { _0: "mapstoleft", _1: moonbitlang$core$json$$Json$string("↤") }, { _0: "mapstoup", _1: moonbitlang$core$json$$Json$string("↥") }, { _0: "marker", _1: moonbitlang$core$json$$Json$string("▮") }, { _0: "mcomma", _1: moonbitlang$core$json$$Json$string("⨩") }, { _0: "mcy", _1: moonbitlang$core$json$$Json$string("м") }, { _0: "mdash", _1: moonbitlang$core$json$$Json$string("—") }, { _0: "measuredangle", _1: moonbitlang$core$json$$Json$string("∡") }, { _0: "mfr", _1: moonbitlang$core$json$$Json$string("𝔪") }, { _0: "mho", _1: moonbitlang$core$json$$Json$string("℧") }, { _0: "micro", _1: moonbitlang$core$json$$Json$string("µ") }, { _0: "mid", _1: moonbitlang$core$json$$Json$string("∣") }, { _0: "midast", _1: moonbitlang$core$json$$Json$string("*") }, { _0: "midcir", _1: moonbitlang$core$json$$Json$string("⫰") }, { _0: "middot", _1: moonbitlang$core$json$$Json$string("·") }, { _0: "minus", _1: moonbitlang$core$json$$Json$string("−") }, { _0: "minusb", _1: moonbitlang$core$json$$Json$string("⊟") }, { _0: "minusd", _1: moonbitlang$core$json$$Json$string("∸") }, { _0: "minusdu", _1: moonbitlang$core$json$$Json$string("⨪") }, { _0: "mlcp", _1: moonbitlang$core$json$$Json$string("⫛") }, { _0: "mldr", _1: moonbitlang$core$json$$Json$string("…") }, { _0: "mnplus", _1: moonbitlang$core$json$$Json$string("∓") }, { _0: "models", _1: moonbitlang$core$json$$Json$string("⊧") }, { _0: "mopf", _1: moonbitlang$core$json$$Json$string("𝕞") }, { _0: "mp", _1: moonbitlang$core$json$$Json$string("∓") }, { _0: "mscr", _1: moonbitlang$core$json$$Json$string("𝓂") }, { _0: "mstpos", _1: moonbitlang$core$json$$Json$string("∾") }, { _0: "mu", _1: moonbitlang$core$json$$Json$string("μ") }, { _0: "multimap", _1: moonbitlang$core$json$$Json$string("⊸") }, { _0: "mumap", _1: moonbitlang$core$json$$Json$string("⊸") }, { _0: "nGg", _1: moonbitlang$core$json$$Json$string("⋙̸") }, { _0: "nGt", _1: moonbitlang$core$json$$Json$string("≫⃒") }, { _0: "nGtv", _1: moonbitlang$core$json$$Json$string("≫̸") }, { _0: "nLeftarrow", _1: moonbitlang$core$json$$Json$string("⇍") }, { _0: "nLeftrightarrow", _1: moonbitlang$core$json$$Json$string("⇎") }, { _0: "nLl", _1: moonbitlang$core$json$$Json$string("⋘̸") }, { _0: "nLt", _1: moonbitlang$core$json$$Json$string("≪⃒") }, { _0: "nLtv", _1: moonbitlang$core$json$$Json$string("≪̸") }, { _0: "nRightarrow", _1: moonbitlang$core$json$$Json$string("⇏") }, { _0: "nVDash", _1: moonbitlang$core$json$$Json$string("⊯") }, { _0: "nVdash", _1: moonbitlang$core$json$$Json$string("⊮") }, { _0: "nabla", _1: moonbitlang$core$json$$Json$string("∇") }, { _0: "nacute", _1: moonbitlang$core$json$$Json$string("ń") }, { _0: "nang", _1: moonbitlang$core$json$$Json$string("∠⃒") }, { _0: "nap", _1: moonbitlang$core$json$$Json$string("≉") }, { _0: "napE", _1: moonbitlang$core$json$$Json$string("⩰̸") }, { _0: "napid", _1: moonbitlang$core$json$$Json$string("≋̸") }, { _0: "napos", _1: moonbitlang$core$json$$Json$string("ŉ") }, { _0: "napprox", _1: moonbitlang$core$json$$Json$string("≉") }, { _0: "natur", _1: moonbitlang$core$json$$Json$string("♮") }, { _0: "natural", _1: moonbitlang$core$json$$Json$string("♮") }, { _0: "naturals", _1: moonbitlang$core$json$$Json$string("ℕ") }, { _0: "nbsp", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "nbump", _1: moonbitlang$core$json$$Json$string("≎̸") }, { _0: "nbumpe", _1: moonbitlang$core$json$$Json$string("≏̸") }, { _0: "ncap", _1: moonbitlang$core$json$$Json$string("⩃") }, { _0: "ncaron", _1: moonbitlang$core$json$$Json$string("ň") }, { _0: "ncedil", _1: moonbitlang$core$json$$Json$string("ņ") }, { _0: "ncong", _1: moonbitlang$core$json$$Json$string("≇") }, { _0: "ncongdot", _1: moonbitlang$core$json$$Json$string("⩭̸") }, { _0: "ncup", _1: moonbitlang$core$json$$Json$string("⩂") }, { _0: "ncy", _1: moonbitlang$core$json$$Json$string("н") }, { _0: "ndash", _1: moonbitlang$core$json$$Json$string("–") }, { _0: "ne", _1: moonbitlang$core$json$$Json$string("≠") }, { _0: "neArr", _1: moonbitlang$core$json$$Json$string("⇗") }, { _0: "nearhk", _1: moonbitlang$core$json$$Json$string("⤤") }, { _0: "nearr", _1: moonbitlang$core$json$$Json$string("↗") }, { _0: "nearrow", _1: moonbitlang$core$json$$Json$string("↗") }, { _0: "nedot", _1: moonbitlang$core$json$$Json$string("≐̸") }, { _0: "nequiv", _1: moonbitlang$core$json$$Json$string("≢") }, { _0: "nesear", _1: moonbitlang$core$json$$Json$string("⤨") }, { _0: "nesim", _1: moonbitlang$core$json$$Json$string("≂̸") }, { _0: "nexist", _1: moonbitlang$core$json$$Json$string("∄") }, { _0: "nexists", _1: moonbitlang$core$json$$Json$string("∄") }, { _0: "nfr", _1: moonbitlang$core$json$$Json$string("𝔫") }, { _0: "ngE", _1: moonbitlang$core$json$$Json$string("≧̸") }, { _0: "nge", _1: moonbitlang$core$json$$Json$string("≱") }, { _0: "ngeq", _1: moonbitlang$core$json$$Json$string("≱") }, { _0: "ngeqq", _1: moonbitlang$core$json$$Json$string("≧̸") }, { _0: "ngeqslant", _1: moonbitlang$core$json$$Json$string("⩾̸") }, { _0: "nges", _1: moonbitlang$core$json$$Json$string("⩾̸") }, { _0: "ngsim", _1: moonbitlang$core$json$$Json$string("≵") }, { _0: "ngt", _1: moonbitlang$core$json$$Json$string("≯") }, { _0: "ngtr", _1: moonbitlang$core$json$$Json$string("≯") }, { _0: "nhArr", _1: moonbitlang$core$json$$Json$string("⇎") }, { _0: "nharr", _1: moonbitlang$core$json$$Json$string("↮") }, { _0: "nhpar", _1: moonbitlang$core$json$$Json$string("⫲") }, { _0: "ni", _1: moonbitlang$core$json$$Json$string("∋") }, { _0: "nis", _1: moonbitlang$core$json$$Json$string("⋼") }, { _0: "nisd", _1: moonbitlang$core$json$$Json$string("⋺") }, { _0: "niv", _1: moonbitlang$core$json$$Json$string("∋") }, { _0: "njcy", _1: moonbitlang$core$json$$Json$string("њ") }, { _0: "nlArr", _1: moonbitlang$core$json$$Json$string("⇍") }, { _0: "nlE", _1: moonbitlang$core$json$$Json$string("≦̸") }, { _0: "nlarr", _1: moonbitlang$core$json$$Json$string("↚") }, { _0: "nldr", _1: moonbitlang$core$json$$Json$string("‥") }, { _0: "nle", _1: moonbitlang$core$json$$Json$string("≰") }, { _0: "nleftarrow", _1: moonbitlang$core$json$$Json$string("↚") }, { _0: "nleftrightarrow", _1: moonbitlang$core$json$$Json$string("↮") }, { _0: "nleq", _1: moonbitlang$core$json$$Json$string("≰") }, { _0: "nleqq", _1: moonbitlang$core$json$$Json$string("≦̸") }, { _0: "nleqslant", _1: moonbitlang$core$json$$Json$string("⩽̸") }, { _0: "nles", _1: moonbitlang$core$json$$Json$string("⩽̸") }, { _0: "nless", _1: moonbitlang$core$json$$Json$string("≮") }, { _0: "nlsim", _1: moonbitlang$core$json$$Json$string("≴") }, { _0: "nlt", _1: moonbitlang$core$json$$Json$string("≮") }, { _0: "nltri", _1: moonbitlang$core$json$$Json$string("⋪") }, { _0: "nltrie", _1: moonbitlang$core$json$$Json$string("⋬") }, { _0: "nmid", _1: moonbitlang$core$json$$Json$string("∤") }, { _0: "nopf", _1: moonbitlang$core$json$$Json$string("𝕟") }, { _0: "not", _1: moonbitlang$core$json$$Json$string("¬") }, { _0: "notin", _1: moonbitlang$core$json$$Json$string("∉") }, { _0: "notinE", _1: moonbitlang$core$json$$Json$string("⋹̸") }, { _0: "notindot", _1: moonbitlang$core$json$$Json$string("⋵̸") }, { _0: "notinva", _1: moonbitlang$core$json$$Json$string("∉") }, { _0: "notinvb", _1: moonbitlang$core$json$$Json$string("⋷") }, { _0: "notinvc", _1: moonbitlang$core$json$$Json$string("⋶") }, { _0: "notni", _1: moonbitlang$core$json$$Json$string("∌") }, { _0: "notniva", _1: moonbitlang$core$json$$Json$string("∌") }, { _0: "notnivb", _1: moonbitlang$core$json$$Json$string("⋾") }, { _0: "notnivc", _1: moonbitlang$core$json$$Json$string("⋽") }, { _0: "npar", _1: moonbitlang$core$json$$Json$string("∦") }, { _0: "nparallel", _1: moonbitlang$core$json$$Json$string("∦") }, { _0: "nparsl", _1: moonbitlang$core$json$$Json$string("⫽⃥") }, { _0: "npart", _1: moonbitlang$core$json$$Json$string("∂̸") }, { _0: "npolint", _1: moonbitlang$core$json$$Json$string("⨔") }, { _0: "npr", _1: moonbitlang$core$json$$Json$string("⊀") }, { _0: "nprcue", _1: moonbitlang$core$json$$Json$string("⋠") }, { _0: "npre", _1: moonbitlang$core$json$$Json$string("⪯̸") }, { _0: "nprec", _1: moonbitlang$core$json$$Json$string("⊀") }, { _0: "npreceq", _1: moonbitlang$core$json$$Json$string("⪯̸") }, { _0: "nrArr", _1: moonbitlang$core$json$$Json$string("⇏") }, { _0: "nrarr", _1: moonbitlang$core$json$$Json$string("↛") }, { _0: "nrarrc", _1: moonbitlang$core$json$$Json$string("⤳̸") }, { _0: "nrarrw", _1: moonbitlang$core$json$$Json$string("↝̸") }, { _0: "nrightarrow", _1: moonbitlang$core$json$$Json$string("↛") }, { _0: "nrtri", _1: moonbitlang$core$json$$Json$string("⋫") }, { _0: "nrtrie", _1: moonbitlang$core$json$$Json$string("⋭") }, { _0: "nsc", _1: moonbitlang$core$json$$Json$string("⊁") }, { _0: "nsccue", _1: moonbitlang$core$json$$Json$string("⋡") }, { _0: "nsce", _1: moonbitlang$core$json$$Json$string("⪰̸") }, { _0: "nscr", _1: moonbitlang$core$json$$Json$string("𝓃") }, { _0: "nshortmid", _1: moonbitlang$core$json$$Json$string("∤") }, { _0: "nshortparallel", _1: moonbitlang$core$json$$Json$string("∦") }, { _0: "nsim", _1: moonbitlang$core$json$$Json$string("≁") }, { _0: "nsime", _1: moonbitlang$core$json$$Json$string("≄") }, { _0: "nsimeq", _1: moonbitlang$core$json$$Json$string("≄") }, { _0: "nsmid", _1: moonbitlang$core$json$$Json$string("∤") }, { _0: "nspar", _1: moonbitlang$core$json$$Json$string("∦") }, { _0: "nsqsube", _1: moonbitlang$core$json$$Json$string("⋢") }, { _0: "nsqsupe", _1: moonbitlang$core$json$$Json$string("⋣") }, { _0: "nsub", _1: moonbitlang$core$json$$Json$string("⊄") }, { _0: "nsubE", _1: moonbitlang$core$json$$Json$string("⫅̸") }, { _0: "nsube", _1: moonbitlang$core$json$$Json$string("⊈") }, { _0: "nsubset", _1: moonbitlang$core$json$$Json$string("⊂⃒") }, { _0: "nsubseteq", _1: moonbitlang$core$json$$Json$string("⊈") }, { _0: "nsubseteqq", _1: moonbitlang$core$json$$Json$string("⫅̸") }, { _0: "nsucc", _1: moonbitlang$core$json$$Json$string("⊁") }, { _0: "nsucceq", _1: moonbitlang$core$json$$Json$string("⪰̸") }, { _0: "nsup", _1: moonbitlang$core$json$$Json$string("⊅") }, { _0: "nsupE", _1: moonbitlang$core$json$$Json$string("⫆̸") }, { _0: "nsupe", _1: moonbitlang$core$json$$Json$string("⊉") }, { _0: "nsupset", _1: moonbitlang$core$json$$Json$string("⊃⃒") }, { _0: "nsupseteq", _1: moonbitlang$core$json$$Json$string("⊉") }, { _0: "nsupseteqq", _1: moonbitlang$core$json$$Json$string("⫆̸") }, { _0: "ntgl", _1: moonbitlang$core$json$$Json$string("≹") }, { _0: "ntilde", _1: moonbitlang$core$json$$Json$string("ñ") }, { _0: "ntlg", _1: moonbitlang$core$json$$Json$string("≸") }, { _0: "ntriangleleft", _1: moonbitlang$core$json$$Json$string("⋪") }, { _0: "ntrianglelefteq", _1: moonbitlang$core$json$$Json$string("⋬") }, { _0: "ntriangleright", _1: moonbitlang$core$json$$Json$string("⋫") }, { _0: "ntrianglerighteq", _1: moonbitlang$core$json$$Json$string("⋭") }, { _0: "nu", _1: moonbitlang$core$json$$Json$string("ν") }, { _0: "num", _1: moonbitlang$core$json$$Json$string("#") }, { _0: "numero", _1: moonbitlang$core$json$$Json$string("№") }, { _0: "numsp", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "nvDash", _1: moonbitlang$core$json$$Json$string("⊭") }, { _0: "nvHarr", _1: moonbitlang$core$json$$Json$string("⤄") }, { _0: "nvap", _1: moonbitlang$core$json$$Json$string("≍⃒") }, { _0: "nvdash", _1: moonbitlang$core$json$$Json$string("⊬") }, { _0: "nvge", _1: moonbitlang$core$json$$Json$string("≥⃒") }, { _0: "nvgt", _1: moonbitlang$core$json$$Json$string(">⃒") }, { _0: "nvinfin", _1: moonbitlang$core$json$$Json$string("⧞") }, { _0: "nvlArr", _1: moonbitlang$core$json$$Json$string("⤂") }, { _0: "nvle", _1: moonbitlang$core$json$$Json$string("≤⃒") }, { _0: "nvlt", _1: moonbitlang$core$json$$Json$string("<⃒") }, { _0: "nvltrie", _1: moonbitlang$core$json$$Json$string("⊴⃒") }, { _0: "nvrArr", _1: moonbitlang$core$json$$Json$string("⤃") }, { _0: "nvrtrie", _1: moonbitlang$core$json$$Json$string("⊵⃒") }, { _0: "nvsim", _1: moonbitlang$core$json$$Json$string("∼⃒") }, { _0: "nwArr", _1: moonbitlang$core$json$$Json$string("⇖") }, { _0: "nwarhk", _1: moonbitlang$core$json$$Json$string("⤣") }, { _0: "nwarr", _1: moonbitlang$core$json$$Json$string("↖") }, { _0: "nwarrow", _1: moonbitlang$core$json$$Json$string("↖") }, { _0: "nwnear", _1: moonbitlang$core$json$$Json$string("⤧") }, { _0: "oS", _1: moonbitlang$core$json$$Json$string("Ⓢ") }, { _0: "oacute", _1: moonbitlang$core$json$$Json$string("ó") }, { _0: "oast", _1: moonbitlang$core$json$$Json$string("⊛") }, { _0: "ocir", _1: moonbitlang$core$json$$Json$string("⊚") }, { _0: "ocirc", _1: moonbitlang$core$json$$Json$string("ô") }, { _0: "ocy", _1: moonbitlang$core$json$$Json$string("о") }, { _0: "odash", _1: moonbitlang$core$json$$Json$string("⊝") }, { _0: "odblac", _1: moonbitlang$core$json$$Json$string("ő") }, { _0: "odiv", _1: moonbitlang$core$json$$Json$string("⨸") }, { _0: "odot", _1: moonbitlang$core$json$$Json$string("⊙") }, { _0: "odsold", _1: moonbitlang$core$json$$Json$string("⦼") }, { _0: "oelig", _1: moonbitlang$core$json$$Json$string("œ") }, { _0: "ofcir", _1: moonbitlang$core$json$$Json$string("⦿") }, { _0: "ofr", _1: moonbitlang$core$json$$Json$string("𝔬") }, { _0: "ogon", _1: moonbitlang$core$json$$Json$string("˛") }, { _0: "ograve", _1: moonbitlang$core$json$$Json$string("ò") }, { _0: "ogt", _1: moonbitlang$core$json$$Json$string("⧁") }, { _0: "ohbar", _1: moonbitlang$core$json$$Json$string("⦵") }, { _0: "ohm", _1: moonbitlang$core$json$$Json$string("Ω") }, { _0: "oint", _1: moonbitlang$core$json$$Json$string("∮") }, { _0: "olarr", _1: moonbitlang$core$json$$Json$string("↺") }, { _0: "olcir", _1: moonbitlang$core$json$$Json$string("⦾") }, { _0: "olcross", _1: moonbitlang$core$json$$Json$string("⦻") }, { _0: "oline", _1: moonbitlang$core$json$$Json$string("‾") }, { _0: "olt", _1: moonbitlang$core$json$$Json$string("⧀") }, { _0: "omacr", _1: moonbitlang$core$json$$Json$string("ō") }, { _0: "omega", _1: moonbitlang$core$json$$Json$string("ω") }, { _0: "omicron", _1: moonbitlang$core$json$$Json$string("ο") }, { _0: "omid", _1: moonbitlang$core$json$$Json$string("⦶") }, { _0: "ominus", _1: moonbitlang$core$json$$Json$string("⊖") }, { _0: "oopf", _1: moonbitlang$core$json$$Json$string("𝕠") }, { _0: "opar", _1: moonbitlang$core$json$$Json$string("⦷") }, { _0: "operp", _1: moonbitlang$core$json$$Json$string("⦹") }, { _0: "oplus", _1: moonbitlang$core$json$$Json$string("⊕") }, { _0: "or", _1: moonbitlang$core$json$$Json$string("∨") }, { _0: "orarr", _1: moonbitlang$core$json$$Json$string("↻") }, { _0: "ord", _1: moonbitlang$core$json$$Json$string("⩝") }, { _0: "order", _1: moonbitlang$core$json$$Json$string("ℴ") }, { _0: "orderof", _1: moonbitlang$core$json$$Json$string("ℴ") }, { _0: "ordf", _1: moonbitlang$core$json$$Json$string("ª") }, { _0: "ordm", _1: moonbitlang$core$json$$Json$string("º") }, { _0: "origof", _1: moonbitlang$core$json$$Json$string("⊶") }, { _0: "oror", _1: moonbitlang$core$json$$Json$string("⩖") }, { _0: "orslope", _1: moonbitlang$core$json$$Json$string("⩗") }, { _0: "orv", _1: moonbitlang$core$json$$Json$string("⩛") }, { _0: "oscr", _1: moonbitlang$core$json$$Json$string("ℴ") }, { _0: "oslash", _1: moonbitlang$core$json$$Json$string("ø") }, { _0: "osol", _1: moonbitlang$core$json$$Json$string("⊘") }, { _0: "otilde", _1: moonbitlang$core$json$$Json$string("õ") }, { _0: "otimes", _1: moonbitlang$core$json$$Json$string("⊗") }, { _0: "otimesas", _1: moonbitlang$core$json$$Json$string("⨶") }, { _0: "ouml", _1: moonbitlang$core$json$$Json$string("ö") }, { _0: "ovbar", _1: moonbitlang$core$json$$Json$string("⌽") }, { _0: "par", _1: moonbitlang$core$json$$Json$string("∥") }, { _0: "para", _1: moonbitlang$core$json$$Json$string("¶") }, { _0: "parallel", _1: moonbitlang$core$json$$Json$string("∥") }, { _0: "parsim", _1: moonbitlang$core$json$$Json$string("⫳") }, { _0: "parsl", _1: moonbitlang$core$json$$Json$string("⫽") }, { _0: "part", _1: moonbitlang$core$json$$Json$string("∂") }, { _0: "pcy", _1: moonbitlang$core$json$$Json$string("п") }, { _0: "percnt", _1: moonbitlang$core$json$$Json$string("%") }, { _0: "period", _1: moonbitlang$core$json$$Json$string(".") }, { _0: "permil", _1: moonbitlang$core$json$$Json$string("‰") }, { _0: "perp", _1: moonbitlang$core$json$$Json$string("⊥") }, { _0: "pertenk", _1: moonbitlang$core$json$$Json$string("‱") }, { _0: "pfr", _1: moonbitlang$core$json$$Json$string("𝔭") }, { _0: "phi", _1: moonbitlang$core$json$$Json$string("φ") }, { _0: "phiv", _1: moonbitlang$core$json$$Json$string("ϕ") }, { _0: "phmmat", _1: moonbitlang$core$json$$Json$string("ℳ") }, { _0: "phone", _1: moonbitlang$core$json$$Json$string("☎") }, { _0: "pi", _1: moonbitlang$core$json$$Json$string("π") }, { _0: "pitchfork", _1: moonbitlang$core$json$$Json$string("⋔") }, { _0: "piv", _1: moonbitlang$core$json$$Json$string("ϖ") }, { _0: "planck", _1: moonbitlang$core$json$$Json$string("ℏ") }, { _0: "planckh", _1: moonbitlang$core$json$$Json$string("ℎ") }, { _0: "plankv", _1: moonbitlang$core$json$$Json$string("ℏ") }, { _0: "plus", _1: moonbitlang$core$json$$Json$string("+") }, { _0: "plusacir", _1: moonbitlang$core$json$$Json$string("⨣") }, { _0: "plusb", _1: moonbitlang$core$json$$Json$string("⊞") }, { _0: "pluscir", _1: moonbitlang$core$json$$Json$string("⨢") }, { _0: "plusdo", _1: moonbitlang$core$json$$Json$string("∔") }, { _0: "plusdu", _1: moonbitlang$core$json$$Json$string("⨥") }, { _0: "pluse", _1: moonbitlang$core$json$$Json$string("⩲") }, { _0: "plusmn", _1: moonbitlang$core$json$$Json$string("±") }, { _0: "plussim", _1: moonbitlang$core$json$$Json$string("⨦") }, { _0: "plustwo", _1: moonbitlang$core$json$$Json$string("⨧") }, { _0: "pm", _1: moonbitlang$core$json$$Json$string("±") }, { _0: "pointint", _1: moonbitlang$core$json$$Json$string("⨕") }, { _0: "popf", _1: moonbitlang$core$json$$Json$string("𝕡") }, { _0: "pound", _1: moonbitlang$core$json$$Json$string("£") }, { _0: "pr", _1: moonbitlang$core$json$$Json$string("≺") }, { _0: "prE", _1: moonbitlang$core$json$$Json$string("⪳") }, { _0: "prap", _1: moonbitlang$core$json$$Json$string("⪷") }, { _0: "prcue", _1: moonbitlang$core$json$$Json$string("≼") }, { _0: "pre", _1: moonbitlang$core$json$$Json$string("⪯") }, { _0: "prec", _1: moonbitlang$core$json$$Json$string("≺") }, { _0: "precapprox", _1: moonbitlang$core$json$$Json$string("⪷") }, { _0: "preccurlyeq", _1: moonbitlang$core$json$$Json$string("≼") }, { _0: "preceq", _1: moonbitlang$core$json$$Json$string("⪯") }, { _0: "precnapprox", _1: moonbitlang$core$json$$Json$string("⪹") }, { _0: "precneqq", _1: moonbitlang$core$json$$Json$string("⪵") }, { _0: "precnsim", _1: moonbitlang$core$json$$Json$string("⋨") }, { _0: "precsim", _1: moonbitlang$core$json$$Json$string("≾") }, { _0: "prime", _1: moonbitlang$core$json$$Json$string("′") }, { _0: "primes", _1: moonbitlang$core$json$$Json$string("ℙ") }, { _0: "prnE", _1: moonbitlang$core$json$$Json$string("⪵") }, { _0: "prnap", _1: moonbitlang$core$json$$Json$string("⪹") }, { _0: "prnsim", _1: moonbitlang$core$json$$Json$string("⋨") }, { _0: "prod", _1: moonbitlang$core$json$$Json$string("∏") }, { _0: "profalar", _1: moonbitlang$core$json$$Json$string("⌮") }, { _0: "profline", _1: moonbitlang$core$json$$Json$string("⌒") }, { _0: "profsurf", _1: moonbitlang$core$json$$Json$string("⌓") }, { _0: "prop", _1: moonbitlang$core$json$$Json$string("∝") }, { _0: "propto", _1: moonbitlang$core$json$$Json$string("∝") }, { _0: "prsim", _1: moonbitlang$core$json$$Json$string("≾") }, { _0: "prurel", _1: moonbitlang$core$json$$Json$string("⊰") }, { _0: "pscr", _1: moonbitlang$core$json$$Json$string("𝓅") }, { _0: "psi", _1: moonbitlang$core$json$$Json$string("ψ") }, { _0: "puncsp", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "qfr", _1: moonbitlang$core$json$$Json$string("𝔮") }, { _0: "qint", _1: moonbitlang$core$json$$Json$string("⨌") }, { _0: "qopf", _1: moonbitlang$core$json$$Json$string("𝕢") }, { _0: "qprime", _1: moonbitlang$core$json$$Json$string("⁗") }, { _0: "qscr", _1: moonbitlang$core$json$$Json$string("𝓆") }, { _0: "quaternions", _1: moonbitlang$core$json$$Json$string("ℍ") }, { _0: "quatint", _1: moonbitlang$core$json$$Json$string("⨖") }, { _0: "quest", _1: moonbitlang$core$json$$Json$string("?") }, { _0: "questeq", _1: moonbitlang$core$json$$Json$string("≟") }, { _0: "quot", _1: moonbitlang$core$json$$Json$string("\"") }, { _0: "rAarr", _1: moonbitlang$core$json$$Json$string("⇛") }, { _0: "rArr", _1: moonbitlang$core$json$$Json$string("⇒") }, { _0: "rAtail", _1: moonbitlang$core$json$$Json$string("⤜") }, { _0: "rBarr", _1: moonbitlang$core$json$$Json$string("⤏") }, { _0: "rHar", _1: moonbitlang$core$json$$Json$string("⥤") }, { _0: "race", _1: moonbitlang$core$json$$Json$string("∽̱") }, { _0: "racute", _1: moonbitlang$core$json$$Json$string("ŕ") }, { _0: "radic", _1: moonbitlang$core$json$$Json$string("√") }, { _0: "raemptyv", _1: moonbitlang$core$json$$Json$string("⦳") }, { _0: "rang", _1: moonbitlang$core$json$$Json$string("⟩") }, { _0: "rangd", _1: moonbitlang$core$json$$Json$string("⦒") }, { _0: "range", _1: moonbitlang$core$json$$Json$string("⦥") }, { _0: "rangle", _1: moonbitlang$core$json$$Json$string("⟩") }, { _0: "raquo", _1: moonbitlang$core$json$$Json$string("»") }, { _0: "rarr", _1: moonbitlang$core$json$$Json$string("→") }, { _0: "rarrap", _1: moonbitlang$core$json$$Json$string("⥵") }, { _0: "rarrb", _1: moonbitlang$core$json$$Json$string("⇥") }, { _0: "rarrbfs", _1: moonbitlang$core$json$$Json$string("⤠") }, { _0: "rarrc", _1: moonbitlang$core$json$$Json$string("⤳") }, { _0: "rarrfs", _1: moonbitlang$core$json$$Json$string("⤞") }, { _0: "rarrhk", _1: moonbitlang$core$json$$Json$string("↪") }, { _0: "rarrlp", _1: moonbitlang$core$json$$Json$string("↬") }, { _0: "rarrpl", _1: moonbitlang$core$json$$Json$string("⥅") }, { _0: "rarrsim", _1: moonbitlang$core$json$$Json$string("⥴") }, { _0: "rarrtl", _1: moonbitlang$core$json$$Json$string("↣") }, { _0: "rarrw", _1: moonbitlang$core$json$$Json$string("↝") }, { _0: "ratail", _1: moonbitlang$core$json$$Json$string("⤚") }, { _0: "ratio", _1: moonbitlang$core$json$$Json$string("∶") }, { _0: "rationals", _1: moonbitlang$core$json$$Json$string("ℚ") }, { _0: "rbarr", _1: moonbitlang$core$json$$Json$string("⤍") }, { _0: "rbbrk", _1: moonbitlang$core$json$$Json$string("❳") }, { _0: "rbrace", _1: moonbitlang$core$json$$Json$string("}") }, { _0: "rbrack", _1: moonbitlang$core$json$$Json$string("]") }, { _0: "rbrke", _1: moonbitlang$core$json$$Json$string("⦌") }, { _0: "rbrksld", _1: moonbitlang$core$json$$Json$string("⦎") }, { _0: "rbrkslu", _1: moonbitlang$core$json$$Json$string("⦐") }, { _0: "rcaron", _1: moonbitlang$core$json$$Json$string("ř") }, { _0: "rcedil", _1: moonbitlang$core$json$$Json$string("ŗ") }, { _0: "rceil", _1: moonbitlang$core$json$$Json$string("⌉") }, { _0: "rcub", _1: moonbitlang$core$json$$Json$string("}") }, { _0: "rcy", _1: moonbitlang$core$json$$Json$string("р") }, { _0: "rdca", _1: moonbitlang$core$json$$Json$string("⤷") }, { _0: "rdldhar", _1: moonbitlang$core$json$$Json$string("⥩") }, { _0: "rdquo", _1: moonbitlang$core$json$$Json$string("”") }, { _0: "rdquor", _1: moonbitlang$core$json$$Json$string("”") }, { _0: "rdsh", _1: moonbitlang$core$json$$Json$string("↳") }, { _0: "real", _1: moonbitlang$core$json$$Json$string("ℜ") }, { _0: "realine", _1: moonbitlang$core$json$$Json$string("ℛ") }, { _0: "realpart", _1: moonbitlang$core$json$$Json$string("ℜ") }, { _0: "reals", _1: moonbitlang$core$json$$Json$string("ℝ") }, { _0: "rect", _1: moonbitlang$core$json$$Json$string("▭") }, { _0: "reg", _1: moonbitlang$core$json$$Json$string("®") }, { _0: "rfisht", _1: moonbitlang$core$json$$Json$string("⥽") }, { _0: "rfloor", _1: moonbitlang$core$json$$Json$string("⌋") }, { _0: "rfr", _1: moonbitlang$core$json$$Json$string("𝔯") }, { _0: "rhard", _1: moonbitlang$core$json$$Json$string("⇁") }, { _0: "rharu", _1: moonbitlang$core$json$$Json$string("⇀") }, { _0: "rharul", _1: moonbitlang$core$json$$Json$string("⥬") }, { _0: "rho", _1: moonbitlang$core$json$$Json$string("ρ") }, { _0: "rhov", _1: moonbitlang$core$json$$Json$string("ϱ") }, { _0: "rightarrow", _1: moonbitlang$core$json$$Json$string("→") }, { _0: "rightarrowtail", _1: moonbitlang$core$json$$Json$string("↣") }, { _0: "rightharpoondown", _1: moonbitlang$core$json$$Json$string("⇁") }, { _0: "rightharpoonup", _1: moonbitlang$core$json$$Json$string("⇀") }, { _0: "rightleftarrows", _1: moonbitlang$core$json$$Json$string("⇄") }, { _0: "rightleftharpoons", _1: moonbitlang$core$json$$Json$string("⇌") }, { _0: "rightrightarrows", _1: moonbitlang$core$json$$Json$string("⇉") }, { _0: "rightsquigarrow", _1: moonbitlang$core$json$$Json$string("↝") }, { _0: "rightthreetimes", _1: moonbitlang$core$json$$Json$string("⋌") }, { _0: "ring", _1: moonbitlang$core$json$$Json$string("˚") }, { _0: "risingdotseq", _1: moonbitlang$core$json$$Json$string("≓") }, { _0: "rlarr", _1: moonbitlang$core$json$$Json$string("⇄") }, { _0: "rlhar", _1: moonbitlang$core$json$$Json$string("⇌") }, { _0: "rlm", _1: moonbitlang$core$json$$Json$string("‏") }, { _0: "rmoust", _1: moonbitlang$core$json$$Json$string("⎱") }, { _0: "rmoustache", _1: moonbitlang$core$json$$Json$string("⎱") }, { _0: "rnmid", _1: moonbitlang$core$json$$Json$string("⫮") }, { _0: "roang", _1: moonbitlang$core$json$$Json$string("⟭") }, { _0: "roarr", _1: moonbitlang$core$json$$Json$string("⇾") }, { _0: "robrk", _1: moonbitlang$core$json$$Json$string("⟧") }, { _0: "ropar", _1: moonbitlang$core$json$$Json$string("⦆") }, { _0: "ropf", _1: moonbitlang$core$json$$Json$string("𝕣") }, { _0: "roplus", _1: moonbitlang$core$json$$Json$string("⨮") }, { _0: "rotimes", _1: moonbitlang$core$json$$Json$string("⨵") }, { _0: "rpar", _1: moonbitlang$core$json$$Json$string(")") }, { _0: "rpargt", _1: moonbitlang$core$json$$Json$string("⦔") }, { _0: "rppolint", _1: moonbitlang$core$json$$Json$string("⨒") }, { _0: "rrarr", _1: moonbitlang$core$json$$Json$string("⇉") }, { _0: "rsaquo", _1: moonbitlang$core$json$$Json$string("›") }, { _0: "rscr", _1: moonbitlang$core$json$$Json$string("𝓇") }, { _0: "rsh", _1: moonbitlang$core$json$$Json$string("↱") }, { _0: "rsqb", _1: moonbitlang$core$json$$Json$string("]") }, { _0: "rsquo", _1: moonbitlang$core$json$$Json$string("’") }, { _0: "rsquor", _1: moonbitlang$core$json$$Json$string("’") }, { _0: "rthree", _1: moonbitlang$core$json$$Json$string("⋌") }, { _0: "rtimes", _1: moonbitlang$core$json$$Json$string("⋊") }, { _0: "rtri", _1: moonbitlang$core$json$$Json$string("▹") }, { _0: "rtrie", _1: moonbitlang$core$json$$Json$string("⊵") }, { _0: "rtrif", _1: moonbitlang$core$json$$Json$string("▸") }, { _0: "rtriltri", _1: moonbitlang$core$json$$Json$string("⧎") }, { _0: "ruluhar", _1: moonbitlang$core$json$$Json$string("⥨") }, { _0: "rx", _1: moonbitlang$core$json$$Json$string("℞") }, { _0: "sacute", _1: moonbitlang$core$json$$Json$string("ś") }, { _0: "sbquo", _1: moonbitlang$core$json$$Json$string("‚") }, { _0: "sc", _1: moonbitlang$core$json$$Json$string("≻") }, { _0: "scE", _1: moonbitlang$core$json$$Json$string("⪴") }, { _0: "scap", _1: moonbitlang$core$json$$Json$string("⪸") }, { _0: "scaron", _1: moonbitlang$core$json$$Json$string("š") }, { _0: "sccue", _1: moonbitlang$core$json$$Json$string("≽") }, { _0: "sce", _1: moonbitlang$core$json$$Json$string("⪰") }, { _0: "scedil", _1: moonbitlang$core$json$$Json$string("ş") }, { _0: "scirc", _1: moonbitlang$core$json$$Json$string("ŝ") }, { _0: "scnE", _1: moonbitlang$core$json$$Json$string("⪶") }, { _0: "scnap", _1: moonbitlang$core$json$$Json$string("⪺") }, { _0: "scnsim", _1: moonbitlang$core$json$$Json$string("⋩") }, { _0: "scpolint", _1: moonbitlang$core$json$$Json$string("⨓") }, { _0: "scsim", _1: moonbitlang$core$json$$Json$string("≿") }, { _0: "scy", _1: moonbitlang$core$json$$Json$string("с") }, { _0: "sdot", _1: moonbitlang$core$json$$Json$string("⋅") }, { _0: "sdotb", _1: moonbitlang$core$json$$Json$string("⊡") }, { _0: "sdote", _1: moonbitlang$core$json$$Json$string("⩦") }, { _0: "seArr", _1: moonbitlang$core$json$$Json$string("⇘") }, { _0: "searhk", _1: moonbitlang$core$json$$Json$string("⤥") }, { _0: "searr", _1: moonbitlang$core$json$$Json$string("↘") }, { _0: "searrow", _1: moonbitlang$core$json$$Json$string("↘") }, { _0: "sect", _1: moonbitlang$core$json$$Json$string("§") }, { _0: "semi", _1: moonbitlang$core$json$$Json$string(";") }, { _0: "seswar", _1: moonbitlang$core$json$$Json$string("⤩") }, { _0: "setminus", _1: moonbitlang$core$json$$Json$string("∖") }, { _0: "setmn", _1: moonbitlang$core$json$$Json$string("∖") }, { _0: "sext", _1: moonbitlang$core$json$$Json$string("✶") }, { _0: "sfr", _1: moonbitlang$core$json$$Json$string("𝔰") }, { _0: "sfrown", _1: moonbitlang$core$json$$Json$string("⌢") }, { _0: "sharp", _1: moonbitlang$core$json$$Json$string("♯") }, { _0: "shchcy", _1: moonbitlang$core$json$$Json$string("щ") }, { _0: "shcy", _1: moonbitlang$core$json$$Json$string("ш") }, { _0: "shortmid", _1: moonbitlang$core$json$$Json$string("∣") }, { _0: "shortparallel", _1: moonbitlang$core$json$$Json$string("∥") }, { _0: "shy", _1: moonbitlang$core$json$$Json$string("­") }, { _0: "sigma", _1: moonbitlang$core$json$$Json$string("σ") }, { _0: "sigmaf", _1: moonbitlang$core$json$$Json$string("ς") }, { _0: "sigmav", _1: moonbitlang$core$json$$Json$string("ς") }, { _0: "sim", _1: moonbitlang$core$json$$Json$string("∼") }, { _0: "simdot", _1: moonbitlang$core$json$$Json$string("⩪") }, { _0: "sime", _1: moonbitlang$core$json$$Json$string("≃") }, { _0: "simeq", _1: moonbitlang$core$json$$Json$string("≃") }, { _0: "simg", _1: moonbitlang$core$json$$Json$string("⪞") }, { _0: "simgE", _1: moonbitlang$core$json$$Json$string("⪠") }, { _0: "siml", _1: moonbitlang$core$json$$Json$string("⪝") }, { _0: "simlE", _1: moonbitlang$core$json$$Json$string("⪟") }, { _0: "simne", _1: moonbitlang$core$json$$Json$string("≆") }, { _0: "simplus", _1: moonbitlang$core$json$$Json$string("⨤") }, { _0: "simrarr", _1: moonbitlang$core$json$$Json$string("⥲") }, { _0: "slarr", _1: moonbitlang$core$json$$Json$string("←") }, { _0: "smallsetminus", _1: moonbitlang$core$json$$Json$string("∖") }, { _0: "smashp", _1: moonbitlang$core$json$$Json$string("⨳") }, { _0: "smeparsl", _1: moonbitlang$core$json$$Json$string("⧤") }, { _0: "smid", _1: moonbitlang$core$json$$Json$string("∣") }, { _0: "smile", _1: moonbitlang$core$json$$Json$string("⌣") }, { _0: "smt", _1: moonbitlang$core$json$$Json$string("⪪") }, { _0: "smte", _1: moonbitlang$core$json$$Json$string("⪬") }, { _0: "smtes", _1: moonbitlang$core$json$$Json$string("⪬︀") }, { _0: "softcy", _1: moonbitlang$core$json$$Json$string("ь") }, { _0: "sol", _1: moonbitlang$core$json$$Json$string("/") }, { _0: "solb", _1: moonbitlang$core$json$$Json$string("⧄") }, { _0: "solbar", _1: moonbitlang$core$json$$Json$string("⌿") }, { _0: "sopf", _1: moonbitlang$core$json$$Json$string("𝕤") }, { _0: "spades", _1: moonbitlang$core$json$$Json$string("♠") }, { _0: "spadesuit", _1: moonbitlang$core$json$$Json$string("♠") }, { _0: "spar", _1: moonbitlang$core$json$$Json$string("∥") }, { _0: "sqcap", _1: moonbitlang$core$json$$Json$string("⊓") }, { _0: "sqcaps", _1: moonbitlang$core$json$$Json$string("⊓︀") }, { _0: "sqcup", _1: moonbitlang$core$json$$Json$string("⊔") }, { _0: "sqcups", _1: moonbitlang$core$json$$Json$string("⊔︀") }, { _0: "sqsub", _1: moonbitlang$core$json$$Json$string("⊏") }, { _0: "sqsube", _1: moonbitlang$core$json$$Json$string("⊑") }, { _0: "sqsubset", _1: moonbitlang$core$json$$Json$string("⊏") }, { _0: "sqsubseteq", _1: moonbitlang$core$json$$Json$string("⊑") }, { _0: "sqsup", _1: moonbitlang$core$json$$Json$string("⊐") }, { _0: "sqsupe", _1: moonbitlang$core$json$$Json$string("⊒") }, { _0: "sqsupset", _1: moonbitlang$core$json$$Json$string("⊐") }, { _0: "sqsupseteq", _1: moonbitlang$core$json$$Json$string("⊒") }, { _0: "squ", _1: moonbitlang$core$json$$Json$string("□") }, { _0: "square", _1: moonbitlang$core$json$$Json$string("□") }, { _0: "squarf", _1: moonbitlang$core$json$$Json$string("▪") }, { _0: "squf", _1: moonbitlang$core$json$$Json$string("▪") }, { _0: "srarr", _1: moonbitlang$core$json$$Json$string("→") }, { _0: "sscr", _1: moonbitlang$core$json$$Json$string("𝓈") }, { _0: "ssetmn", _1: moonbitlang$core$json$$Json$string("∖") }, { _0: "ssmile", _1: moonbitlang$core$json$$Json$string("⌣") }, { _0: "sstarf", _1: moonbitlang$core$json$$Json$string("⋆") }, { _0: "star", _1: moonbitlang$core$json$$Json$string("☆") }, { _0: "starf", _1: moonbitlang$core$json$$Json$string("★") }, { _0: "straightepsilon", _1: moonbitlang$core$json$$Json$string("ϵ") }, { _0: "straightphi", _1: moonbitlang$core$json$$Json$string("ϕ") }, { _0: "strns", _1: moonbitlang$core$json$$Json$string("¯") }, { _0: "sub", _1: moonbitlang$core$json$$Json$string("⊂") }, { _0: "subE", _1: moonbitlang$core$json$$Json$string("⫅") }, { _0: "subdot", _1: moonbitlang$core$json$$Json$string("⪽") }, { _0: "sube", _1: moonbitlang$core$json$$Json$string("⊆") }, { _0: "subedot", _1: moonbitlang$core$json$$Json$string("⫃") }, { _0: "submult", _1: moonbitlang$core$json$$Json$string("⫁") }, { _0: "subnE", _1: moonbitlang$core$json$$Json$string("⫋") }, { _0: "subne", _1: moonbitlang$core$json$$Json$string("⊊") }, { _0: "subplus", _1: moonbitlang$core$json$$Json$string("⪿") }, { _0: "subrarr", _1: moonbitlang$core$json$$Json$string("⥹") }, { _0: "subset", _1: moonbitlang$core$json$$Json$string("⊂") }, { _0: "subseteq", _1: moonbitlang$core$json$$Json$string("⊆") }, { _0: "subseteqq", _1: moonbitlang$core$json$$Json$string("⫅") }, { _0: "subsetneq", _1: moonbitlang$core$json$$Json$string("⊊") }, { _0: "subsetneqq", _1: moonbitlang$core$json$$Json$string("⫋") }, { _0: "subsim", _1: moonbitlang$core$json$$Json$string("⫇") }, { _0: "subsub", _1: moonbitlang$core$json$$Json$string("⫕") }, { _0: "subsup", _1: moonbitlang$core$json$$Json$string("⫓") }, { _0: "succ", _1: moonbitlang$core$json$$Json$string("≻") }, { _0: "succapprox", _1: moonbitlang$core$json$$Json$string("⪸") }, { _0: "succcurlyeq", _1: moonbitlang$core$json$$Json$string("≽") }, { _0: "succeq", _1: moonbitlang$core$json$$Json$string("⪰") }, { _0: "succnapprox", _1: moonbitlang$core$json$$Json$string("⪺") }, { _0: "succneqq", _1: moonbitlang$core$json$$Json$string("⪶") }, { _0: "succnsim", _1: moonbitlang$core$json$$Json$string("⋩") }, { _0: "succsim", _1: moonbitlang$core$json$$Json$string("≿") }, { _0: "sum", _1: moonbitlang$core$json$$Json$string("∑") }, { _0: "sung", _1: moonbitlang$core$json$$Json$string("♪") }, { _0: "sup1", _1: moonbitlang$core$json$$Json$string("¹") }, { _0: "sup2", _1: moonbitlang$core$json$$Json$string("²") }, { _0: "sup3", _1: moonbitlang$core$json$$Json$string("³") }, { _0: "sup", _1: moonbitlang$core$json$$Json$string("⊃") }, { _0: "supE", _1: moonbitlang$core$json$$Json$string("⫆") }, { _0: "supdot", _1: moonbitlang$core$json$$Json$string("⪾") }, { _0: "supdsub", _1: moonbitlang$core$json$$Json$string("⫘") }, { _0: "supe", _1: moonbitlang$core$json$$Json$string("⊇") }, { _0: "supedot", _1: moonbitlang$core$json$$Json$string("⫄") }, { _0: "suphsol", _1: moonbitlang$core$json$$Json$string("⟉") }, { _0: "suphsub", _1: moonbitlang$core$json$$Json$string("⫗") }, { _0: "suplarr", _1: moonbitlang$core$json$$Json$string("⥻") }, { _0: "supmult", _1: moonbitlang$core$json$$Json$string("⫂") }, { _0: "supnE", _1: moonbitlang$core$json$$Json$string("⫌") }, { _0: "supne", _1: moonbitlang$core$json$$Json$string("⊋") }, { _0: "supplus", _1: moonbitlang$core$json$$Json$string("⫀") }, { _0: "supset", _1: moonbitlang$core$json$$Json$string("⊃") }, { _0: "supseteq", _1: moonbitlang$core$json$$Json$string("⊇") }, { _0: "supseteqq", _1: moonbitlang$core$json$$Json$string("⫆") }, { _0: "supsetneq", _1: moonbitlang$core$json$$Json$string("⊋") }, { _0: "supsetneqq", _1: moonbitlang$core$json$$Json$string("⫌") }, { _0: "supsim", _1: moonbitlang$core$json$$Json$string("⫈") }, { _0: "supsub", _1: moonbitlang$core$json$$Json$string("⫔") }, { _0: "supsup", _1: moonbitlang$core$json$$Json$string("⫖") }, { _0: "swArr", _1: moonbitlang$core$json$$Json$string("⇙") }, { _0: "swarhk", _1: moonbitlang$core$json$$Json$string("⤦") }, { _0: "swarr", _1: moonbitlang$core$json$$Json$string("↙") }, { _0: "swarrow", _1: moonbitlang$core$json$$Json$string("↙") }, { _0: "swnwar", _1: moonbitlang$core$json$$Json$string("⤪") }, { _0: "szlig", _1: moonbitlang$core$json$$Json$string("ß") }, { _0: "target", _1: moonbitlang$core$json$$Json$string("⌖") }, { _0: "tau", _1: moonbitlang$core$json$$Json$string("τ") }, { _0: "tbrk", _1: moonbitlang$core$json$$Json$string("⎴") }, { _0: "tcaron", _1: moonbitlang$core$json$$Json$string("ť") }, { _0: "tcedil", _1: moonbitlang$core$json$$Json$string("ţ") }, { _0: "tcy", _1: moonbitlang$core$json$$Json$string("т") }, { _0: "tdot", _1: moonbitlang$core$json$$Json$string("⃛") }, { _0: "telrec", _1: moonbitlang$core$json$$Json$string("⌕") }, { _0: "tfr", _1: moonbitlang$core$json$$Json$string("𝔱") }, { _0: "there4", _1: moonbitlang$core$json$$Json$string("∴") }, { _0: "therefore", _1: moonbitlang$core$json$$Json$string("∴") }, { _0: "theta", _1: moonbitlang$core$json$$Json$string("θ") }, { _0: "thetasym", _1: moonbitlang$core$json$$Json$string("ϑ") }, { _0: "thetav", _1: moonbitlang$core$json$$Json$string("ϑ") }, { _0: "thickapprox", _1: moonbitlang$core$json$$Json$string("≈") }, { _0: "thicksim", _1: moonbitlang$core$json$$Json$string("∼") }, { _0: "thinsp", _1: moonbitlang$core$json$$Json$string(" ") }, { _0: "thkap", _1: moonbitlang$core$json$$Json$string("≈") }, { _0: "thksim", _1: moonbitlang$core$json$$Json$string("∼") }, { _0: "thorn", _1: moonbitlang$core$json$$Json$string("þ") }, { _0: "tilde", _1: moonbitlang$core$json$$Json$string("˜") }, { _0: "times", _1: moonbitlang$core$json$$Json$string("×") }, { _0: "timesb", _1: moonbitlang$core$json$$Json$string("⊠") }, { _0: "timesbar", _1: moonbitlang$core$json$$Json$string("⨱") }, { _0: "timesd", _1: moonbitlang$core$json$$Json$string("⨰") }, { _0: "tint", _1: moonbitlang$core$json$$Json$string("∭") }, { _0: "toea", _1: moonbitlang$core$json$$Json$string("⤨") }, { _0: "top", _1: moonbitlang$core$json$$Json$string("⊤") }, { _0: "topbot", _1: moonbitlang$core$json$$Json$string("⌶") }, { _0: "topcir", _1: moonbitlang$core$json$$Json$string("⫱") }, { _0: "topf", _1: moonbitlang$core$json$$Json$string("𝕥") }, { _0: "topfork", _1: moonbitlang$core$json$$Json$string("⫚") }, { _0: "tosa", _1: moonbitlang$core$json$$Json$string("⤩") }, { _0: "tprime", _1: moonbitlang$core$json$$Json$string("‴") }, { _0: "trade", _1: moonbitlang$core$json$$Json$string("™") }, { _0: "triangle", _1: moonbitlang$core$json$$Json$string("▵") }, { _0: "triangledown", _1: moonbitlang$core$json$$Json$string("▿") }, { _0: "triangleleft", _1: moonbitlang$core$json$$Json$string("◃") }, { _0: "trianglelefteq", _1: moonbitlang$core$json$$Json$string("⊴") }, { _0: "triangleq", _1: moonbitlang$core$json$$Json$string("≜") }, { _0: "triangleright", _1: moonbitlang$core$json$$Json$string("▹") }, { _0: "trianglerighteq", _1: moonbitlang$core$json$$Json$string("⊵") }, { _0: "tridot", _1: moonbitlang$core$json$$Json$string("◬") }, { _0: "trie", _1: moonbitlang$core$json$$Json$string("≜") }, { _0: "triminus", _1: moonbitlang$core$json$$Json$string("⨺") }, { _0: "triplus", _1: moonbitlang$core$json$$Json$string("⨹") }, { _0: "trisb", _1: moonbitlang$core$json$$Json$string("⧍") }, { _0: "tritime", _1: moonbitlang$core$json$$Json$string("⨻") }, { _0: "trpezium", _1: moonbitlang$core$json$$Json$string("⏢") }, { _0: "tscr", _1: moonbitlang$core$json$$Json$string("𝓉") }, { _0: "tscy", _1: moonbitlang$core$json$$Json$string("ц") }, { _0: "tshcy", _1: moonbitlang$core$json$$Json$string("ћ") }, { _0: "tstrok", _1: moonbitlang$core$json$$Json$string("ŧ") }, { _0: "twixt", _1: moonbitlang$core$json$$Json$string("≬") }, { _0: "twoheadleftarrow", _1: moonbitlang$core$json$$Json$string("↞") }, { _0: "twoheadrightarrow", _1: moonbitlang$core$json$$Json$string("↠") }, { _0: "uArr", _1: moonbitlang$core$json$$Json$string("⇑") }, { _0: "uHar", _1: moonbitlang$core$json$$Json$string("⥣") }, { _0: "uacute", _1: moonbitlang$core$json$$Json$string("ú") }, { _0: "uarr", _1: moonbitlang$core$json$$Json$string("↑") }, { _0: "ubrcy", _1: moonbitlang$core$json$$Json$string("ў") }, { _0: "ubreve", _1: moonbitlang$core$json$$Json$string("ŭ") }, { _0: "ucirc", _1: moonbitlang$core$json$$Json$string("û") }, { _0: "ucy", _1: moonbitlang$core$json$$Json$string("у") }, { _0: "udarr", _1: moonbitlang$core$json$$Json$string("⇅") }, { _0: "udblac", _1: moonbitlang$core$json$$Json$string("ű") }, { _0: "udhar", _1: moonbitlang$core$json$$Json$string("⥮") }, { _0: "ufisht", _1: moonbitlang$core$json$$Json$string("⥾") }, { _0: "ufr", _1: moonbitlang$core$json$$Json$string("𝔲") }, { _0: "ugrave", _1: moonbitlang$core$json$$Json$string("ù") }, { _0: "uharl", _1: moonbitlang$core$json$$Json$string("↿") }, { _0: "uharr", _1: moonbitlang$core$json$$Json$string("↾") }, { _0: "uhblk", _1: moonbitlang$core$json$$Json$string("▀") }, { _0: "ulcorn", _1: moonbitlang$core$json$$Json$string("⌜") }, { _0: "ulcorner", _1: moonbitlang$core$json$$Json$string("⌜") }, { _0: "ulcrop", _1: moonbitlang$core$json$$Json$string("⌏") }, { _0: "ultri", _1: moonbitlang$core$json$$Json$string("◸") }, { _0: "umacr", _1: moonbitlang$core$json$$Json$string("ū") }, { _0: "uml", _1: moonbitlang$core$json$$Json$string("¨") }, { _0: "uogon", _1: moonbitlang$core$json$$Json$string("ų") }, { _0: "uopf", _1: moonbitlang$core$json$$Json$string("𝕦") }, { _0: "uparrow", _1: moonbitlang$core$json$$Json$string("↑") }, { _0: "updownarrow", _1: moonbitlang$core$json$$Json$string("↕") }, { _0: "upharpoonleft", _1: moonbitlang$core$json$$Json$string("↿") }, { _0: "upharpoonright", _1: moonbitlang$core$json$$Json$string("↾") }, { _0: "uplus", _1: moonbitlang$core$json$$Json$string("⊎") }, { _0: "upsi", _1: moonbitlang$core$json$$Json$string("υ") }, { _0: "upsih", _1: moonbitlang$core$json$$Json$string("ϒ") }, { _0: "upsilon", _1: moonbitlang$core$json$$Json$string("υ") }, { _0: "upuparrows", _1: moonbitlang$core$json$$Json$string("⇈") }, { _0: "urcorn", _1: moonbitlang$core$json$$Json$string("⌝") }, { _0: "urcorner", _1: moonbitlang$core$json$$Json$string("⌝") }, { _0: "urcrop", _1: moonbitlang$core$json$$Json$string("⌎") }, { _0: "uring", _1: moonbitlang$core$json$$Json$string("ů") }, { _0: "urtri", _1: moonbitlang$core$json$$Json$string("◹") }, { _0: "uscr", _1: moonbitlang$core$json$$Json$string("𝓊") }, { _0: "utdot", _1: moonbitlang$core$json$$Json$string("⋰") }, { _0: "utilde", _1: moonbitlang$core$json$$Json$string("ũ") }, { _0: "utri", _1: moonbitlang$core$json$$Json$string("▵") }, { _0: "utrif", _1: moonbitlang$core$json$$Json$string("▴") }, { _0: "uuarr", _1: moonbitlang$core$json$$Json$string("⇈") }, { _0: "uuml", _1: moonbitlang$core$json$$Json$string("ü") }, { _0: "uwangle", _1: moonbitlang$core$json$$Json$string("⦧") }, { _0: "vArr", _1: moonbitlang$core$json$$Json$string("⇕") }, { _0: "vBar", _1: moonbitlang$core$json$$Json$string("⫨") }, { _0: "vBarv", _1: moonbitlang$core$json$$Json$string("⫩") }, { _0: "vDash", _1: moonbitlang$core$json$$Json$string("⊨") }, { _0: "vangrt", _1: moonbitlang$core$json$$Json$string("⦜") }, { _0: "varepsilon", _1: moonbitlang$core$json$$Json$string("ϵ") }, { _0: "varkappa", _1: moonbitlang$core$json$$Json$string("ϰ") }, { _0: "varnothing", _1: moonbitlang$core$json$$Json$string("∅") }, { _0: "varphi", _1: moonbitlang$core$json$$Json$string("ϕ") }, { _0: "varpi", _1: moonbitlang$core$json$$Json$string("ϖ") }, { _0: "varpropto", _1: moonbitlang$core$json$$Json$string("∝") }, { _0: "varr", _1: moonbitlang$core$json$$Json$string("↕") }, { _0: "varrho", _1: moonbitlang$core$json$$Json$string("ϱ") }, { _0: "varsigma", _1: moonbitlang$core$json$$Json$string("ς") }, { _0: "varsubsetneq", _1: moonbitlang$core$json$$Json$string("⊊︀") }, { _0: "varsubsetneqq", _1: moonbitlang$core$json$$Json$string("⫋︀") }, { _0: "varsupsetneq", _1: moonbitlang$core$json$$Json$string("⊋︀") }, { _0: "varsupsetneqq", _1: moonbitlang$core$json$$Json$string("⫌︀") }, { _0: "vartheta", _1: moonbitlang$core$json$$Json$string("ϑ") }, { _0: "vartriangleleft", _1: moonbitlang$core$json$$Json$string("⊲") }, { _0: "vartriangleright", _1: moonbitlang$core$json$$Json$string("⊳") }, { _0: "vcy", _1: moonbitlang$core$json$$Json$string("в") }, { _0: "vdash", _1: moonbitlang$core$json$$Json$string("⊢") }, { _0: "vee", _1: moonbitlang$core$json$$Json$string("∨") }, { _0: "veebar", _1: moonbitlang$core$json$$Json$string("⊻") }, { _0: "veeeq", _1: moonbitlang$core$json$$Json$string("≚") }, { _0: "vellip", _1: moonbitlang$core$json$$Json$string("⋮") }, { _0: "verbar", _1: moonbitlang$core$json$$Json$string("|") }, { _0: "vert", _1: moonbitlang$core$json$$Json$string("|") }, { _0: "vfr", _1: moonbitlang$core$json$$Json$string("𝔳") }, { _0: "vltri", _1: moonbitlang$core$json$$Json$string("⊲") }, { _0: "vnsub", _1: moonbitlang$core$json$$Json$string("⊂⃒") }, { _0: "vnsup", _1: moonbitlang$core$json$$Json$string("⊃⃒") }, { _0: "vopf", _1: moonbitlang$core$json$$Json$string("𝕧") }, { _0: "vprop", _1: moonbitlang$core$json$$Json$string("∝") }, { _0: "vrtri", _1: moonbitlang$core$json$$Json$string("⊳") }, { _0: "vscr", _1: moonbitlang$core$json$$Json$string("𝓋") }, { _0: "vsubnE", _1: moonbitlang$core$json$$Json$string("⫋︀") }, { _0: "vsubne", _1: moonbitlang$core$json$$Json$string("⊊︀") }, { _0: "vsupnE", _1: moonbitlang$core$json$$Json$string("⫌︀") }, { _0: "vsupne", _1: moonbitlang$core$json$$Json$string("⊋︀") }, { _0: "vzigzag", _1: moonbitlang$core$json$$Json$string("⦚") }, { _0: "wcirc", _1: moonbitlang$core$json$$Json$string("ŵ") }, { _0: "wedbar", _1: moonbitlang$core$json$$Json$string("⩟") }, { _0: "wedge", _1: moonbitlang$core$json$$Json$string("∧") }, { _0: "wedgeq", _1: moonbitlang$core$json$$Json$string("≙") }, { _0: "weierp", _1: moonbitlang$core$json$$Json$string("℘") }, { _0: "wfr", _1: moonbitlang$core$json$$Json$string("𝔴") }, { _0: "wopf", _1: moonbitlang$core$json$$Json$string("𝕨") }, { _0: "wp", _1: moonbitlang$core$json$$Json$string("℘") }, { _0: "wr", _1: moonbitlang$core$json$$Json$string("≀") }, { _0: "wreath", _1: moonbitlang$core$json$$Json$string("≀") }, { _0: "wscr", _1: moonbitlang$core$json$$Json$string("𝓌") }, { _0: "xcap", _1: moonbitlang$core$json$$Json$string("⋂") }, { _0: "xcirc", _1: moonbitlang$core$json$$Json$string("◯") }, { _0: "xcup", _1: moonbitlang$core$json$$Json$string("⋃") }, { _0: "xdtri", _1: moonbitlang$core$json$$Json$string("▽") }, { _0: "xfr", _1: moonbitlang$core$json$$Json$string("𝔵") }, { _0: "xhArr", _1: moonbitlang$core$json$$Json$string("⟺") }, { _0: "xharr", _1: moonbitlang$core$json$$Json$string("⟷") }, { _0: "xi", _1: moonbitlang$core$json$$Json$string("ξ") }, { _0: "xlArr", _1: moonbitlang$core$json$$Json$string("⟸") }, { _0: "xlarr", _1: moonbitlang$core$json$$Json$string("⟵") }, { _0: "xmap", _1: moonbitlang$core$json$$Json$string("⟼") }, { _0: "xnis", _1: moonbitlang$core$json$$Json$string("⋻") }, { _0: "xodot", _1: moonbitlang$core$json$$Json$string("⨀") }, { _0: "xopf", _1: moonbitlang$core$json$$Json$string("𝕩") }, { _0: "xoplus", _1: moonbitlang$core$json$$Json$string("⨁") }, { _0: "xotime", _1: moonbitlang$core$json$$Json$string("⨂") }, { _0: "xrArr", _1: moonbitlang$core$json$$Json$string("⟹") }, { _0: "xrarr", _1: moonbitlang$core$json$$Json$string("⟶") }, { _0: "xscr", _1: moonbitlang$core$json$$Json$string("𝓍") }, { _0: "xsqcup", _1: moonbitlang$core$json$$Json$string("⨆") }, { _0: "xuplus", _1: moonbitlang$core$json$$Json$string("⨄") }, { _0: "xutri", _1: moonbitlang$core$json$$Json$string("△") }, { _0: "xvee", _1: moonbitlang$core$json$$Json$string("⋁") }, { _0: "xwedge", _1: moonbitlang$core$json$$Json$string("⋀") }, { _0: "yacute", _1: moonbitlang$core$json$$Json$string("ý") }, { _0: "yacy", _1: moonbitlang$core$json$$Json$string("я") }, { _0: "ycirc", _1: moonbitlang$core$json$$Json$string("ŷ") }, { _0: "ycy", _1: moonbitlang$core$json$$Json$string("ы") }, { _0: "yen", _1: moonbitlang$core$json$$Json$string("¥") }, { _0: "yfr", _1: moonbitlang$core$json$$Json$string("𝔶") }, { _0: "yicy", _1: moonbitlang$core$json$$Json$string("ї") }, { _0: "yopf", _1: moonbitlang$core$json$$Json$string("𝕪") }, { _0: "yscr", _1: moonbitlang$core$json$$Json$string("𝓎") }, { _0: "yucy", _1: moonbitlang$core$json$$Json$string("ю") }, { _0: "yuml", _1: moonbitlang$core$json$$Json$string("ÿ") }, { _0: "zacute", _1: moonbitlang$core$json$$Json$string("ź") }, { _0: "zcaron", _1: moonbitlang$core$json$$Json$string("ž") }, { _0: "zcy", _1: moonbitlang$core$json$$Json$string("з") }, { _0: "zdot", _1: moonbitlang$core$json$$Json$string("ż") }, { _0: "zeetrf", _1: moonbitlang$core$json$$Json$string("ℨ") }, { _0: "zeta", _1: moonbitlang$core$json$$Json$string("ζ") }, { _0: "zfr", _1: moonbitlang$core$json$$Json$string("𝔷") }, { _0: "zhcy", _1: moonbitlang$core$json$$Json$string("ж") }, { _0: "zigrarr", _1: moonbitlang$core$json$$Json$string("⇝") }, { _0: "zopf", _1: moonbitlang$core$json$$Json$string("𝕫") }, { _0: "zscr", _1: moonbitlang$core$json$$Json$string("𝓏") }, { _0: "zwj", _1: moonbitlang$core$json$$Json$string("‍") }, { _0: "zwnj", _1: moonbitlang$core$json$$Json$string("‌") }]));
const rami3l$cmark$cmark$$layout_empty = rami3l$cmark$cmark$$layout_of_string(rami3l$cmark$cmark$$layout_of_string$46$meta$46$default(), "");
const rami3l$cmark$cmark_base$$html_start_cond_6_set = moonbitlang$core$set$$Set$of$9$(["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "section", "source", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"]);
const rami3l$cmark$cmark_base$$html_start_cond_1_set = moonbitlang$core$set$$Set$of$9$(["pre", "script", "style", "textarea"]);
const moonbitlang$mooncakes$util$highlight$$operators = moonbitlang$core$set$$Set$from_iter$10$(moonbitlang$core$string$$String$iter("+-*/%&|{}()[]<>!?=,.:;~"));
const moonbitlang$mooncakes$util$highlight$$keywords = moonbitlang$core$set$$Set$of$9$(["fn", "let", "type", "struct", "enum", "impl", "trait", "derive", "match", "if", "else", "typealias", "guard", "for", "in", "while", "loop", "break", "continue", "return", "pub", "priv", "mut", "with", "test"]);
const moonbitlang$mooncakes$config$$builtins_package_path = moonbitlang$core$builtin$$Map$from_array$11$([{ _0: "Bool", _1: "core/bool" }, { _0: "Byte", _1: "core/byte" }, { _0: "Bytes", _1: "core/bytes" }, { _0: "Char", _1: "core/char" }, { _0: "Double", _1: "core/double" }, { _0: "FixedArray", _1: "core/array" }, { _0: "Array", _1: "core/array" }, { _0: "Float", _1: "core/float" }, { _0: "Int", _1: "core/int" }, { _0: "Int16", _1: "core/int16" }, { _0: "Int64", _1: "core/int64" }, { _0: "String", _1: "core/string" }, { _0: "UInt", _1: "core/uint" }]);
function moonbitlang$core$abort$$abort$12$(msg) {
  $panic();
}
function moonbitlang$core$abort$$abort$13$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$14$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$15$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$16$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$17$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$18$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$7$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$9$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$19$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$20$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$21$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$22$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$23$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$24$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$25$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$26$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$27$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$28$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$29$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$30$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$31$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$32$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$33$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$34$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$35$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$36$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$37$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$38$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$39$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$40$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$41$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$42$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$43$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$10$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$44$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$45$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$46$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$47$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$48$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$49$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$50$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$51$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$52$(msg) {
  return $panic();
}
function moonbitlang$core$option$$Option$map$53$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$map$54$(self, f) {
  if (self.$tag === 1) {
    const _Some = self;
    const _t = _Some._0;
    return new Option$Some$0$(f(_t));
  } else {
    return Option$None$0$;
  }
}
function moonbitlang$core$option$$Option$map$55$(self, f) {
  if (self.$tag === 1) {
    const _Some = self;
    const _t = _Some._0;
    return new Option$Some$0$(f(_t));
  } else {
    return Option$None$0$;
  }
}
function moonbitlang$core$option$$Option$map$11$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$map$56$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$map$57$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$map$58$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$map$59$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$map$60$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$map$61$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$map$62$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$map_or$63$(self, default_, f) {
  if (self.$tag === 0) {
    return default_;
  } else {
    const _Some = self;
    const _x = _Some._0;
    return f(_x);
  }
}
function moonbitlang$core$option$$Option$map_or$64$(self, default_, f) {
  if (self === undefined) {
    return default_;
  } else {
    const _Some = self;
    const _x = _Some;
    return f(_x);
  }
}
function moonbitlang$core$option$$Option$bind$53$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$bind$65$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _t = _Some;
    return f(_t);
  }
}
function moonbitlang$core$option$$Option$is_empty$66$(self) {
  return self === undefined;
}
function moonbitlang$core$option$$Option$is_empty$7$(self) {
  return self === undefined;
}
function moonbitlang$core$option$$Option$or$9$(self, default_) {
  if (self === undefined) {
    return default_;
  } else {
    const _Some = self;
    const _t = _Some;
    return _t;
  }
}
function moonbitlang$core$option$$Option$or$67$(self, default_) {
  if (self === undefined) {
    return default_;
  } else {
    const _Some = self;
    const _t = _Some;
    return _t;
  }
}
function moonbitlang$core$option$$Option$or$68$(self, default_) {
  if (self === undefined) {
    return default_;
  } else {
    const _Some = self;
    const _t = _Some;
    return _t;
  }
}
function moonbitlang$core$option$$Option$or$69$(self, default_) {
  if (self === undefined) {
    return default_;
  } else {
    const _Some = self;
    const _t = _Some;
    return _t;
  }
}
function moonbitlang$core$option$$Option$or_else$51$(self, default_) {
  if (self === undefined) {
    return default_();
  } else {
    const _Some = self;
    const _t = _Some;
    return _t;
  }
}
function moonbitlang$core$builtin$$Compare$compare$70$(self, other) {
  if (self === undefined) {
    return other === undefined ? 0 : -1;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return 1;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return $compare_int(_x, _y);
    }
  }
}
function moonbitlang$core$option$$Option$iter$51$(self) {
  if (self === undefined) {
    return moonbitlang$core$builtin$$Iter$empty$51$();
  } else {
    const _Some = self;
    const _v = _Some;
    return moonbitlang$core$builtin$$Iter$singleton$51$(_v);
  }
}
function moonbitlang$core$string$$concat(strings, separator) {
  if (strings.length === 0) {
    return "";
  } else {
    const _hd = strings[0];
    const _x = moonbitlang$core$array$$Array$op_as_view$9$(strings, 1, strings.length);
    let size_hint = _hd.length;
    const _len = moonbitlang$core$array$$ArrayView$length$9$(_x);
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const s = _x.buf[_x.start + _i | 0];
        size_hint = size_hint + (s.length + separator.length | 0) | 0;
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    size_hint = size_hint << 1;
    const buf = moonbitlang$core$builtin$$StringBuilder$new(size_hint);
    moonbitlang$core$builtin$$Logger$write_string$71$(buf, _hd);
    if (separator === "") {
      const _len$2 = moonbitlang$core$array$$ArrayView$length$9$(_x);
      let _tmp$2 = 0;
      while (true) {
        const _i = _tmp$2;
        if (_i < _len$2) {
          const s = _x.buf[_x.start + _i | 0];
          moonbitlang$core$builtin$$Logger$write_string$71$(buf, s);
          _tmp$2 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    } else {
      const _len$2 = moonbitlang$core$array$$ArrayView$length$9$(_x);
      let _tmp$2 = 0;
      while (true) {
        const _i = _tmp$2;
        if (_i < _len$2) {
          const s = _x.buf[_x.start + _i | 0];
          moonbitlang$core$builtin$$Logger$write_string$71$(buf, separator);
          moonbitlang$core$builtin$$Logger$write_string$71$(buf, s);
          _tmp$2 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    }
    return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
  }
}
function moonbitlang$core$string$$concat$46$separator$46$default() {
  return "";
}
function moonbitlang$core$string$$is_trailing_surrogate(c) {
  return 56320 <= c && c <= 57343;
}
function moonbitlang$core$string$$String$offset_of_nth_char_backward(self, n, start_offset, end_offset) {
  let char_count = 0;
  let utf16_offset = end_offset;
  while (true) {
    if ((utf16_offset - 1 | 0) >= start_offset && char_count < n) {
      const _tmp = utf16_offset - 1 | 0;
      const c = self.charCodeAt(_tmp);
      if (moonbitlang$core$string$$is_trailing_surrogate(c)) {
        utf16_offset = utf16_offset - 2 | 0;
      } else {
        utf16_offset = utf16_offset - 1 | 0;
      }
      char_count = char_count + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return char_count < n || utf16_offset < start_offset ? undefined : utf16_offset;
}
function moonbitlang$core$string$$is_leading_surrogate(c) {
  return 55296 <= c && c <= 56319;
}
function moonbitlang$core$string$$String$offset_of_nth_char_forward(self, n, start_offset, end_offset) {
  if (start_offset >= 0 && start_offset <= end_offset) {
    let utf16_offset = start_offset;
    let char_count = 0;
    while (true) {
      if (utf16_offset < end_offset && char_count < n) {
        const _tmp = utf16_offset;
        const c = self.charCodeAt(_tmp);
        if (moonbitlang$core$string$$is_leading_surrogate(c)) {
          utf16_offset = utf16_offset + 2 | 0;
        } else {
          utf16_offset = utf16_offset + 1 | 0;
        }
        char_count = char_count + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return char_count < n || utf16_offset >= end_offset ? undefined : utf16_offset;
  } else {
    return moonbitlang$core$abort$$abort$14$("Invalid start index");
  }
}
function moonbitlang$core$string$$String$offset_of_nth_char(self, i, start_offset, end_offset) {
  return i >= 0 ? moonbitlang$core$string$$String$offset_of_nth_char_forward(self, i, start_offset, end_offset) : moonbitlang$core$string$$String$offset_of_nth_char_backward(self, -i, start_offset, end_offset);
}
function moonbitlang$core$string$$StringView$length(self) {
  return self.end - self.start | 0;
}
function moonbitlang$core$string$$String$view(self, start_offset, end_offset) {
  return start_offset >= 0 && (start_offset <= end_offset && end_offset <= self.length) ? { str: self, start: start_offset, end: end_offset } : moonbitlang$core$abort$$abort$16$("Invalid index for View");
}
function moonbitlang$core$string$$String$view$46$start_offset$46$default() {
  return 0;
}
function moonbitlang$core$string$$String$view$46$end_offset$46$default(self) {
  return self.length;
}
function moonbitlang$core$string$$StringView$view(self, start_offset, end_offset) {
  return start_offset >= 0 && (start_offset <= end_offset && end_offset <= moonbitlang$core$string$$StringView$length(self)) ? { str: self.str, start: self.start + start_offset | 0, end: self.start + end_offset | 0 } : moonbitlang$core$abort$$abort$16$("Invalid index for View");
}
function moonbitlang$core$string$$StringView$view$46$start_offset$46$default() {
  return 0;
}
function moonbitlang$core$string$$StringView$view$46$end_offset$46$default(self) {
  return moonbitlang$core$string$$StringView$length(self);
}
function moonbitlang$core$string$$StringView$unsafe_charcode_at(self, index) {
  const _tmp = self.str;
  const _tmp$2 = self.start + index | 0;
  return _tmp.charCodeAt(_tmp$2);
}
function moonbitlang$core$string$$String$char_length_eq(self, len, start_offset, end_offset) {
  let _tmp = start_offset;
  let _tmp$2 = 0;
  while (true) {
    const index = _tmp;
    const count = _tmp$2;
    if (index < end_offset && count < len) {
      const c1 = self.charCodeAt(index);
      if (moonbitlang$core$string$$is_leading_surrogate(c1) && (index + 1 | 0) < end_offset) {
        const _tmp$3 = index + 1 | 0;
        const c2 = self.charCodeAt(_tmp$3);
        if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
          const _tmp$4 = index + 2 | 0;
          const _tmp$5 = count + 1 | 0;
          _tmp = _tmp$4;
          _tmp$2 = _tmp$5;
          continue;
        } else {
          moonbitlang$core$abort$$abort$12$("invalid surrogate pair");
        }
      }
      const _tmp$3 = index + 1 | 0;
      const _tmp$4 = count + 1 | 0;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    } else {
      return count === len && index === end_offset;
    }
  }
}
function moonbitlang$core$string$$String$char_length_ge(self, len, start_offset, end_offset) {
  let _tmp = start_offset;
  let _tmp$2 = 0;
  while (true) {
    const index = _tmp;
    const count = _tmp$2;
    if (index < end_offset && count < len) {
      const c1 = self.charCodeAt(index);
      if (moonbitlang$core$string$$is_leading_surrogate(c1) && (index + 1 | 0) < end_offset) {
        const _tmp$3 = index + 1 | 0;
        const c2 = self.charCodeAt(_tmp$3);
        if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
          const _tmp$4 = index + 2 | 0;
          const _tmp$5 = count + 1 | 0;
          _tmp = _tmp$4;
          _tmp$2 = _tmp$5;
          continue;
        } else {
          moonbitlang$core$abort$$abort$12$("invalid surrogate pair");
        }
      }
      const _tmp$3 = index + 1 | 0;
      const _tmp$4 = count + 1 | 0;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    } else {
      return count >= len;
    }
  }
}
function moonbitlang$core$builtin$$Show$to_string$16$(self) {
  return moonbitlang$core$string$$String$substring(self.str, self.start, self.end);
}
function moonbitlang$core$string$$code_point_of_surrogate_pair(leading, trailing) {
  return (((Math.imul(leading - 55296 | 0, 1024) | 0) + trailing | 0) - 56320 | 0) + 65536 | 0;
}
function moonbitlang$core$string$$StringView$iter(self) {
  return moonbitlang$core$builtin$$Iter$new$10$((yield_) => {
    const _start402 = self.start;
    const _end403 = self.end;
    let _tmp = _start402;
    while (true) {
      const index = _tmp;
      if (index < _end403) {
        const _tmp$2 = self.str;
        const c1 = _tmp$2.charCodeAt(index);
        if (moonbitlang$core$string$$is_leading_surrogate(c1) && (index + 1 | 0) < self.end) {
          const _tmp$3 = self.str;
          const _tmp$4 = index + 1 | 0;
          const c2 = _tmp$3.charCodeAt(_tmp$4);
          if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
            const c = moonbitlang$core$string$$code_point_of_surrogate_pair(c1, c2);
            const _bind = yield_(c);
            if (_bind === 1) {
              _tmp = index + 2 | 0;
              continue;
            } else {
              return 0;
            }
          }
        }
        const _bind = yield_(c1);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = index + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$string$$StringView$iter2(self) {
  return moonbitlang$core$builtin$$Iter2$new$72$((yield_) => {
    const len = moonbitlang$core$string$$StringView$length(self);
    let _tmp = 0;
    let _tmp$2 = 0;
    while (true) {
      const index = _tmp;
      const n = _tmp$2;
      if (index < len) {
        const _tmp$3 = self.str;
        const _tmp$4 = self.start + index | 0;
        const c1 = _tmp$3.charCodeAt(_tmp$4);
        if (moonbitlang$core$string$$is_leading_surrogate(c1) && (index + 1 | 0) < len) {
          const _tmp$5 = self.str;
          const _tmp$6 = (self.start + index | 0) + 1 | 0;
          const c2 = _tmp$5.charCodeAt(_tmp$6);
          if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
            const c = moonbitlang$core$string$$code_point_of_surrogate_pair(c1, c2);
            const _bind = yield_(n, c);
            if (_bind === 1) {
              const _tmp$7 = index + 2 | 0;
              const _tmp$8 = n + 1 | 0;
              _tmp = _tmp$7;
              _tmp$2 = _tmp$8;
              continue;
            } else {
              return 0;
            }
          }
        }
        const _bind = yield_(n, c1);
        if (_bind === 1) {
        } else {
          return 0;
        }
        const _tmp$5 = index + 1 | 0;
        const _tmp$6 = n + 1 | 0;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$builtin$$Eq$op_equal$16$(self, other) {
  const len = moonbitlang$core$string$$StringView$length(self);
  if (len === moonbitlang$core$string$$StringView$length(other)) {
    if (self.str === other.str && self.start === other.start) {
      return true;
    }
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = self.str;
        const _tmp$3 = self.start + i | 0;
        const _tmp$4 = _tmp$2.charCodeAt(_tmp$3);
        const _tmp$5 = other.str;
        const _tmp$6 = other.start + i | 0;
        if (_tmp$4 === _tmp$5.charCodeAt(_tmp$6)) {
        } else {
          return false;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return true;
  } else {
    return false;
  }
}
function moonbitlang$core$string$$String$from_array(chars) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(Math.imul(chars.length, 4) | 0);
  const _len = chars.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const c = chars[_i];
      moonbitlang$core$builtin$$Logger$write_char$71$(buf, c);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$string$$String$from_iter(iter) {
  const chars = moonbitlang$core$builtin$$Iter$collect$10$(iter);
  return moonbitlang$core$string$$String$from_array(chars);
}
function moonbitlang$core$string$$StringView$find(self, str) {
  const len = moonbitlang$core$string$$StringView$length(self);
  const sub_len = moonbitlang$core$string$$StringView$length(str);
  if (sub_len > 0) {
    if (sub_len <= len) {
      const max_idx = len - sub_len | 0;
      const first = moonbitlang$core$string$$StringView$unsafe_charcode_at(str, 0);
      let i = 0;
      while (true) {
        if (i <= max_idx) {
          while (true) {
            if (i < len && moonbitlang$core$string$$StringView$unsafe_charcode_at(self, i) !== first) {
              i = i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          if (i <= max_idx) {
            let _tmp = 1;
            while (true) {
              const j = _tmp;
              if (j < sub_len) {
                if (moonbitlang$core$string$$StringView$unsafe_charcode_at(self, i + j | 0) !== moonbitlang$core$string$$StringView$unsafe_charcode_at(str, j)) {
                  break;
                }
                _tmp = j + 1 | 0;
                continue;
              } else {
                return i;
              }
            }
          }
          i = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return undefined;
    } else {
      return undefined;
    }
  } else {
    return 0;
  }
}
function moonbitlang$core$string$$StringView$find_by(self, pred) {
  const _foreach_result = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$1$ };
  const _bind = moonbitlang$core$string$$StringView$iter2(self);
  _bind((i, c) => {
    if (pred(c)) {
      _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$1$(i);
      return 0;
    }
    return 1;
  });
  const _tmp = _foreach_result.val;
  switch (_tmp.$tag) {
    case 0: {
      break;
    }
    case 1: {
      const _break = _tmp;
      _break._0;
      break;
    }
    case 2: {
      const _return = _tmp;
      return _return._0;
    }
    case 3: {
      $panic();
      break;
    }
    default: {
      $panic();
    }
  }
  return undefined;
}
function moonbitlang$core$string$$String$find_by(self, pred) {
  return moonbitlang$core$string$$StringView$find_by({ str: self, start: 0, end: self.length }, pred);
}
function moonbitlang$core$string$$StringView$has_prefix(self, str) {
  const _bind = moonbitlang$core$string$$StringView$find(self, str);
  if (_bind === undefined) {
    return false;
  } else {
    const _Some = _bind;
    const _i = _Some;
    return _i === 0;
  }
}
function moonbitlang$core$string$$String$has_prefix(self, str) {
  return moonbitlang$core$string$$StringView$has_prefix({ str: self, start: 0, end: self.length }, str);
}
function moonbitlang$core$string$$StringView$contains(self, str) {
  const _bind = moonbitlang$core$string$$StringView$find(self, str);
  return !(_bind === undefined);
}
function moonbitlang$core$string$$String$contains(self, str) {
  return moonbitlang$core$string$$StringView$contains({ str: self, start: 0, end: self.length }, str);
}
function moonbitlang$core$string$$StringView$contains_char(self, c) {
  return moonbitlang$core$builtin$$Iter$any$10$(moonbitlang$core$string$$StringView$iter(self), (ch) => ch === c);
}
function moonbitlang$core$string$$StringView$trim_start(self, char_set) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (moonbitlang$core$string$$String$char_length_eq(_param.str, 0, _param.start, _param.end)) {
      return _param;
    } else {
      const _c = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 0, _param.start, _param.end));
      const _tmp$2 = _param.str;
      const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
      let _tmp$3;
      if (_bind === undefined) {
        _tmp$3 = _param.end;
      } else {
        const _Some = _bind;
        _tmp$3 = _Some;
      }
      const _tmp$4 = _tmp$3;
      const _x = { str: _tmp$2, start: _tmp$4, end: _param.end };
      if (moonbitlang$core$string$$StringView$contains_char(char_set, _c)) {
        _tmp = _x;
        continue;
      } else {
        return _param;
      }
    }
  }
}
function moonbitlang$core$string$$StringView$trim_end(self, char_set) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (moonbitlang$core$string$$String$char_length_eq(_param.str, 0, _param.start, _param.end)) {
      return _param;
    } else {
      const _c = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char(_param.str, -1, _param.start, _param.end));
      const _x = { str: _param.str, start: _param.start, end: moonbitlang$core$string$$String$offset_of_nth_char(_param.str, -1, _param.start, _param.end) };
      if (moonbitlang$core$string$$StringView$contains_char(char_set, _c)) {
        _tmp = _x;
        continue;
      } else {
        return _param;
      }
    }
  }
}
function moonbitlang$core$string$$StringView$trim(self, char_set) {
  return moonbitlang$core$string$$StringView$trim_end(moonbitlang$core$string$$StringView$trim_start(self, char_set), char_set);
}
function moonbitlang$core$string$$String$trim(self, char_set) {
  return moonbitlang$core$string$$StringView$trim({ str: self, start: 0, end: self.length }, char_set);
}
function moonbitlang$core$string$$StringView$is_empty(self) {
  return moonbitlang$core$string$$StringView$length(self) === 0;
}
function moonbitlang$core$string$$String$is_empty(self) {
  return self === "";
}
function moonbitlang$core$string$$String$iter(self) {
  return moonbitlang$core$builtin$$Iter$new$10$((yield_) => {
    const len = self.length;
    let _tmp = 0;
    while (true) {
      const index = _tmp;
      if (index < len) {
        const c1 = self.charCodeAt(index);
        if (moonbitlang$core$string$$is_leading_surrogate(c1) && (index + 1 | 0) < len) {
          const _tmp$2 = index + 1 | 0;
          const c2 = self.charCodeAt(_tmp$2);
          if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
            const c = moonbitlang$core$string$$code_point_of_surrogate_pair(c1, c2);
            const _bind = yield_(c);
            if (_bind === 1) {
              _tmp = index + 2 | 0;
              continue;
            } else {
              return 0;
            }
          }
        }
        const _bind = yield_(c1);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = index + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$string$$String$repeat(self, n) {
  if (n <= 0) {
    return "";
  } else {
    if (n === 1) {
      return self;
    } else {
      const len = self.length;
      const buf = moonbitlang$core$builtin$$StringBuilder$new(Math.imul(len, n) | 0);
      const str = self;
      let _tmp = 0;
      while (true) {
        const _ = _tmp;
        if (_ < n) {
          moonbitlang$core$builtin$$Logger$write_string$71$(buf, str);
          _tmp = _ + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
    }
  }
}
function moonbitlang$core$string$$StringView$split(self, sep) {
  const sep_len = moonbitlang$core$string$$StringView$length(sep);
  if (sep_len === 0) {
    const _bind = moonbitlang$core$string$$StringView$iter(self);
    return (_p) => _bind((_p$2) => {
      const _arg = moonbitlang$core$builtin$$Show$to_string$10$(_p$2);
      const _arg$2 = moonbitlang$core$string$$String$view$46$start_offset$46$default();
      const _arg$3 = moonbitlang$core$string$$String$view$46$end_offset$46$default(_arg);
      return _p(moonbitlang$core$string$$String$view(_arg, _arg$2, _arg$3));
    });
  }
  return moonbitlang$core$builtin$$Iter$new$16$((yield_) => {
    let view = self;
    while (true) {
      const _bind = moonbitlang$core$string$$StringView$find(view, sep);
      if (_bind === undefined) {
        return yield_(view);
      } else {
        const _Some = _bind;
        const _end = _Some;
        const _bind$2 = yield_(moonbitlang$core$string$$StringView$view(view, moonbitlang$core$string$$StringView$view$46$start_offset$46$default(), _end));
        if (_bind$2 === 1) {
          const _arg = view;
          const _arg$2 = _end + sep_len | 0;
          const _arg$3 = moonbitlang$core$string$$StringView$view$46$end_offset$46$default(_arg);
          view = moonbitlang$core$string$$StringView$view(_arg, _arg$2, _arg$3);
        } else {
          return 0;
        }
        continue;
      }
    }
  });
}
function moonbitlang$core$string$$String$split(self, sep) {
  return moonbitlang$core$string$$StringView$split({ str: self, start: 0, end: self.length }, sep);
}
function moonbitlang$core$string$$String$to_lower(self) {
  const _bind = moonbitlang$core$string$$String$find_by(self, moonbitlang$core$char$$Char$is_ascii_uppercase);
  if (_bind === undefined) {
    return self;
  } else {
    const _Some = _bind;
    const _idx = _Some;
    const buf = moonbitlang$core$builtin$$StringBuilder$new(self.length);
    moonbitlang$core$builtin$$Logger$write_string$71$(buf, moonbitlang$core$builtin$$Show$to_string$16$(moonbitlang$core$string$$String$view(self, moonbitlang$core$string$$String$view$46$start_offset$46$default(), _idx)));
    const _arg = moonbitlang$core$string$$String$view$46$end_offset$46$default(self);
    const _bind$2 = moonbitlang$core$string$$StringView$iter(moonbitlang$core$string$$String$view(self, _idx, _arg));
    _bind$2((c) => {
      if (moonbitlang$core$char$$Char$is_ascii_uppercase(c)) {
        moonbitlang$core$builtin$$Logger$write_char$71$(buf, c + 32 | 0);
      } else {
        moonbitlang$core$builtin$$Logger$write_char$71$(buf, c);
      }
      return 1;
    });
    return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
  }
}
function moonbitlang$core$string$$String$to_upper(self) {
  const _bind = moonbitlang$core$string$$String$find_by(self, moonbitlang$core$char$$Char$is_ascii_lowercase);
  if (_bind === undefined) {
    return self;
  } else {
    const _Some = _bind;
    const _idx = _Some;
    const buf = moonbitlang$core$builtin$$StringBuilder$new(self.length);
    moonbitlang$core$builtin$$Logger$write_string$71$(buf, moonbitlang$core$builtin$$Show$to_string$16$(moonbitlang$core$string$$String$view(self, moonbitlang$core$string$$String$view$46$start_offset$46$default(), _idx)));
    const _arg = moonbitlang$core$string$$String$view$46$end_offset$46$default(self);
    const _bind$2 = moonbitlang$core$string$$StringView$iter(moonbitlang$core$string$$String$view(self, _idx, _arg));
    _bind$2((c) => {
      if (moonbitlang$core$char$$Char$is_ascii_lowercase(c)) {
        moonbitlang$core$builtin$$Logger$write_char$71$(buf, c - 32 | 0);
      } else {
        moonbitlang$core$builtin$$Logger$write_char$71$(buf, c);
      }
      return 1;
    });
    return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
  }
}
function moonbitlang$core$builtin$$Compare$compare$9$(self, other) {
  const len = self.length;
  const _bind = $compare_int(len, other.length);
  if (_bind === 0) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const order = $compare_int(self.charCodeAt(i), other.charCodeAt(i));
        if (order !== 0) {
          return order;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return 0;
  } else {
    return _bind;
  }
}
function moonbitlang$core$string$$String$starts_with(self, str) {
  const _arg = moonbitlang$core$string$$String$view$46$start_offset$46$default();
  const _arg$2 = moonbitlang$core$string$$String$view$46$end_offset$46$default(str);
  return moonbitlang$core$string$$String$has_prefix(self, moonbitlang$core$string$$String$view(str, _arg, _arg$2));
}
function moonbitlang$core$string$$String$char_at(self, offset) {
  return offset >= 0 && offset < self.length ? moonbitlang$core$string$$String$unsafe_char_at(self, offset) : moonbitlang$core$abort$$abort$10$("offset out of bounds");
}
function moonbitlang$core$builtin$$Show$output$73$(self, logger) {
  logger.method_0(logger.self, String(self));
}
function moonbitlang$core$set$$calc_grow_threshold(capacity) {
  return (Math.imul(capacity, 13) | 0) / 16 | 0;
}
function moonbitlang$core$set$$power_2_above(x, n) {
  let _tmp = x;
  while (true) {
    const i = _tmp;
    if (i >= n) {
      return i;
    }
    const next = i << 1;
    if (next < 0) {
      return i;
    }
    _tmp = next;
    continue;
  }
}
function moonbitlang$core$set$$Set$new$7$(capacity) {
  const capacity$2 = moonbitlang$core$set$$power_2_above(8, capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = moonbitlang$core$set$$calc_grow_threshold(capacity$2);
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined });
  const _bind$5 = undefined;
  const _bind$6 = undefined;
  return { entries: _bind$3, list: _bind$4, size: 0, capacity: capacity$2, capacity_mask: _bind, growAt: _bind$2, head: _bind$5, tail: _bind$6 };
}
function moonbitlang$core$set$$Set$new$9$(capacity) {
  const capacity$2 = moonbitlang$core$set$$power_2_above(8, capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = moonbitlang$core$set$$calc_grow_threshold(capacity$2);
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined });
  const _bind$5 = undefined;
  const _bind$6 = undefined;
  return { entries: _bind$3, list: _bind$4, size: 0, capacity: capacity$2, capacity_mask: _bind, growAt: _bind$2, head: _bind$5, tail: _bind$6 };
}
function moonbitlang$core$set$$Set$new$10$(capacity) {
  const capacity$2 = moonbitlang$core$set$$power_2_above(8, capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = moonbitlang$core$set$$calc_grow_threshold(capacity$2);
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined });
  const _bind$5 = undefined;
  const _bind$6 = undefined;
  return { entries: _bind$3, list: _bind$4, size: 0, capacity: capacity$2, capacity_mask: _bind, growAt: _bind$2, head: _bind$5, tail: _bind$6 };
}
function moonbitlang$core$set$$Set$new$46$capacity$46$default$7$() {
  return 8;
}
function moonbitlang$core$set$$Set$new$46$capacity$46$default$10$() {
  return 8;
}
function moonbitlang$core$set$$Set$add_entry_to_tail$7$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _tail = _Some;
    const _tmp = self.list;
    const _tmp$2 = _tail.idx;
    $bound_check(_tmp, _tmp$2);
    _tmp[_tmp$2].next = entry;
    const _tmp$3 = self.list;
    const _tmp$4 = entry.idx;
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4].prev = _tail;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$set$$Set$add_entry_to_tail$9$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _tail = _Some;
    const _tmp = self.list;
    const _tmp$2 = _tail.idx;
    $bound_check(_tmp, _tmp$2);
    _tmp[_tmp$2].next = entry;
    const _tmp$3 = self.list;
    const _tmp$4 = entry.idx;
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4].prev = _tail;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$set$$Set$add_entry_to_tail$10$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _tail = _Some;
    const _tmp = self.list;
    const _tmp$2 = _tail.idx;
    $bound_check(_tmp, _tmp$2);
    _tmp[_tmp$2].next = entry;
    const _tmp$3 = self.list;
    const _tmp$4 = entry.idx;
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4].prev = _tail;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$set$$Set$add$7$(self, key) {
  if (self.size >= self.growAt) {
    moonbitlang$core$set$$Set$grow$7$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$7$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const entry = _tmp$3;
    const node = _tmp$4;
    const _tmp$5 = self.entries;
    $bound_check(_tmp$5, idx);
    const _bind = _tmp$5[idx];
    if (_bind === undefined) {
      const _tmp$6 = self.entries;
      $bound_check(_tmp$6, idx);
      _tmp$6[idx] = entry;
      const _tmp$7 = self.list;
      $bound_check(_tmp$7, idx);
      _tmp$7[idx] = node;
      entry.idx = idx;
      moonbitlang$core$set$$Set$add_entry_to_tail$7$(self, insert_entry);
      self.size = self.size + 1 | 0;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      const _tmp$6 = self.list;
      const _tmp$7 = _curr_entry.idx;
      $bound_check(_tmp$6, _tmp$7);
      const curr_node = _tmp$6[_tmp$7];
      if (_curr_entry.hash === entry.hash && _curr_entry.key === entry.key) {
        break;
      }
      if (entry.psl > _curr_entry.psl) {
        const _tmp$8 = self.entries;
        $bound_check(_tmp$8, idx);
        _tmp$8[idx] = entry;
        const _tmp$9 = self.list;
        $bound_check(_tmp$9, idx);
        _tmp$9[idx] = node;
        entry.idx = idx;
        _curr_entry.psl = _curr_entry.psl + 1 | 0;
        const _tmp$10 = i + 1 | 0;
        const _tmp$11 = idx + 1 & self.capacity_mask;
        _tmp = _tmp$10;
        _tmp$2 = _tmp$11;
        _tmp$3 = _curr_entry;
        _tmp$4 = curr_node;
        continue;
      } else {
        entry.psl = entry.psl + 1 | 0;
        const _tmp$8 = i + 1 | 0;
        const _tmp$9 = idx + 1 & self.capacity_mask;
        _tmp = _tmp$8;
        _tmp$2 = _tmp$9;
        continue;
      }
    }
  }
}
function moonbitlang$core$set$$Set$add$9$(self, key) {
  if (self.size >= self.growAt) {
    moonbitlang$core$set$$Set$grow$9$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const entry = _tmp$3;
    const node = _tmp$4;
    const _tmp$5 = self.entries;
    $bound_check(_tmp$5, idx);
    const _bind = _tmp$5[idx];
    if (_bind === undefined) {
      const _tmp$6 = self.entries;
      $bound_check(_tmp$6, idx);
      _tmp$6[idx] = entry;
      const _tmp$7 = self.list;
      $bound_check(_tmp$7, idx);
      _tmp$7[idx] = node;
      entry.idx = idx;
      moonbitlang$core$set$$Set$add_entry_to_tail$9$(self, insert_entry);
      self.size = self.size + 1 | 0;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      const _tmp$6 = self.list;
      const _tmp$7 = _curr_entry.idx;
      $bound_check(_tmp$6, _tmp$7);
      const curr_node = _tmp$6[_tmp$7];
      if (_curr_entry.hash === entry.hash && _curr_entry.key === entry.key) {
        break;
      }
      if (entry.psl > _curr_entry.psl) {
        const _tmp$8 = self.entries;
        $bound_check(_tmp$8, idx);
        _tmp$8[idx] = entry;
        const _tmp$9 = self.list;
        $bound_check(_tmp$9, idx);
        _tmp$9[idx] = node;
        entry.idx = idx;
        _curr_entry.psl = _curr_entry.psl + 1 | 0;
        const _tmp$10 = i + 1 | 0;
        const _tmp$11 = idx + 1 & self.capacity_mask;
        _tmp = _tmp$10;
        _tmp$2 = _tmp$11;
        _tmp$3 = _curr_entry;
        _tmp$4 = curr_node;
        continue;
      } else {
        entry.psl = entry.psl + 1 | 0;
        const _tmp$8 = i + 1 | 0;
        const _tmp$9 = idx + 1 & self.capacity_mask;
        _tmp = _tmp$8;
        _tmp$2 = _tmp$9;
        continue;
      }
    }
  }
}
function moonbitlang$core$set$$Set$add$10$(self, key) {
  if (self.size >= self.growAt) {
    moonbitlang$core$set$$Set$grow$10$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$10$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const entry = _tmp$3;
    const node = _tmp$4;
    const _tmp$5 = self.entries;
    $bound_check(_tmp$5, idx);
    const _bind = _tmp$5[idx];
    if (_bind === undefined) {
      const _tmp$6 = self.entries;
      $bound_check(_tmp$6, idx);
      _tmp$6[idx] = entry;
      const _tmp$7 = self.list;
      $bound_check(_tmp$7, idx);
      _tmp$7[idx] = node;
      entry.idx = idx;
      moonbitlang$core$set$$Set$add_entry_to_tail$10$(self, insert_entry);
      self.size = self.size + 1 | 0;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      const _tmp$6 = self.list;
      const _tmp$7 = _curr_entry.idx;
      $bound_check(_tmp$6, _tmp$7);
      const curr_node = _tmp$6[_tmp$7];
      if (_curr_entry.hash === entry.hash && _curr_entry.key === entry.key) {
        break;
      }
      if (entry.psl > _curr_entry.psl) {
        const _tmp$8 = self.entries;
        $bound_check(_tmp$8, idx);
        _tmp$8[idx] = entry;
        const _tmp$9 = self.list;
        $bound_check(_tmp$9, idx);
        _tmp$9[idx] = node;
        entry.idx = idx;
        _curr_entry.psl = _curr_entry.psl + 1 | 0;
        const _tmp$10 = i + 1 | 0;
        const _tmp$11 = idx + 1 & self.capacity_mask;
        _tmp = _tmp$10;
        _tmp$2 = _tmp$11;
        _tmp$3 = _curr_entry;
        _tmp$4 = curr_node;
        continue;
      } else {
        entry.psl = entry.psl + 1 | 0;
        const _tmp$8 = i + 1 | 0;
        const _tmp$9 = idx + 1 & self.capacity_mask;
        _tmp = _tmp$8;
        _tmp$2 = _tmp$9;
        continue;
      }
    }
  }
}
function moonbitlang$core$set$$Set$grow$7$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$set$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _idx = _x.idx;
      const _key = _x.key;
      moonbitlang$core$set$$Set$add$7$(self, _key);
      $bound_check(old_list, _idx);
      _tmp = old_list[_idx].next;
      continue;
    }
  }
}
function moonbitlang$core$set$$Set$grow$9$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$set$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _idx = _x.idx;
      const _key = _x.key;
      moonbitlang$core$set$$Set$add$9$(self, _key);
      $bound_check(old_list, _idx);
      _tmp = old_list[_idx].next;
      continue;
    }
  }
}
function moonbitlang$core$set$$Set$grow$10$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$set$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _idx = _x.idx;
      const _key = _x.key;
      moonbitlang$core$set$$Set$add$10$(self, _key);
      $bound_check(old_list, _idx);
      _tmp = old_list[_idx].next;
      continue;
    }
  }
}
function moonbitlang$core$set$$Set$contains$9$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      const _tmp$4 = i + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
}
function moonbitlang$core$set$$Set$contains$10$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$10$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      const _tmp$4 = i + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
}
function moonbitlang$core$set$$Set$is_empty$7$(self) {
  return self.size === 0;
}
function moonbitlang$core$set$$Set$iter$7$(self) {
  return moonbitlang$core$builtin$$Iter$new$7$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _key = _x.key;
        const _idx = _x.idx;
        if (moonbitlang$core$builtin$$Eq$op_equal$75$(yield_(_key), 0)) {
          return 0;
        }
        const _tmp$2 = self.list;
        $bound_check(_tmp$2, _idx);
        _tmp = _tmp$2[_idx].next;
        continue;
      }
    }
  });
}
function moonbitlang$core$set$$Set$to_array$7$(self) {
  const res = moonbitlang$core$array$$Array$new$7$(self.size);
  let _tmp = self.head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      break;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _key = _x.key;
      const _idx = _x.idx;
      moonbitlang$core$array$$Array$push$7$(res, _key);
      const _tmp$2 = self.list;
      $bound_check(_tmp$2, _idx);
      _tmp = _tmp$2[_idx].next;
      continue;
    }
  }
  return res;
}
function moonbitlang$core$set$$Set$of$9$(arr) {
  const length = arr.length;
  const m = moonbitlang$core$set$$Set$new$9$(length);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < length) {
      $bound_check(arr, i);
      const e = arr[i];
      moonbitlang$core$set$$Set$add$9$(m, e);
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$set$$Set$from_iter$10$(iter) {
  const m = moonbitlang$core$set$$Set$new$10$(moonbitlang$core$set$$Set$new$46$capacity$46$default$10$());
  iter((_p) => {
    moonbitlang$core$set$$Set$add$10$(m, _p);
    return 1;
  });
  return m;
}
function moonbitlang$core$builtin$$Logger$write_object$76$(self, obj) {
  moonbitlang$core$builtin$$Show$output$76$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$77$(self, obj) {
  moonbitlang$core$builtin$$Show$output$78$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$79$(self, obj) {
  moonbitlang$core$builtin$$Show$output$79$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$80$(self, obj) {
  moonbitlang$core$builtin$$Show$output$81$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$82$(self, obj) {
  moonbitlang$core$builtin$$Show$output$82$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$9$(self, obj) {
  moonbitlang$core$builtin$$Show$output$9$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$17$(self, obj) {
  moonbitlang$core$builtin$$Show$output$17$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$83$(self, obj) {
  moonbitlang$core$builtin$$Show$output$84$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$51$(self, obj) {
  moonbitlang$core$builtin$$Show$output$51$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$85$(self, obj) {
  moonbitlang$core$builtin$$Show$output$85$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$86$(self, obj) {
  moonbitlang$core$builtin$$Show$output$87$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$88$(self, obj) {
  moonbitlang$core$builtin$$Show$output$89$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$7$(self, obj) {
  moonbitlang$core$builtin$$Show$output$7$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$90$(self, obj) {
  moonbitlang$core$builtin$$Show$output$90$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$91$(self, obj) {
  moonbitlang$core$builtin$$Show$output$92$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$93$(self, obj) {
  moonbitlang$core$builtin$$Show$output$93$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$94$(self, obj) {
  moonbitlang$core$builtin$$Show$output$95$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$96$(self, obj) {
  moonbitlang$core$builtin$$Show$output$97$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$98$(self, obj) {
  moonbitlang$core$builtin$$Show$output$99$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$100$(self, obj) {
  moonbitlang$core$builtin$$Show$output$101$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$102$(self, obj) {
  moonbitlang$core$builtin$$Show$output$103$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$104$(self, obj) {
  moonbitlang$core$builtin$$Show$output$105$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$106$(self, obj) {
  moonbitlang$core$builtin$$Show$output$107$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$108$(self, obj) {
  moonbitlang$core$builtin$$Show$output$109$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$110$(self, obj) {
  moonbitlang$core$builtin$$Show$output$111$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$112$(self, obj) {
  moonbitlang$core$builtin$$Show$output$113$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$114$(self, obj) {
  moonbitlang$core$builtin$$Show$output$115$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$116$(self, obj) {
  moonbitlang$core$builtin$$Show$output$116$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$117$(self, obj) {
  moonbitlang$core$builtin$$Show$output$118$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$119$(self, obj) {
  moonbitlang$core$builtin$$Show$output$119$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$120$(self, obj) {
  moonbitlang$core$builtin$$Show$output$121$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$122$(self, obj) {
  moonbitlang$core$builtin$$Show$output$123$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$124$(self, obj) {
  moonbitlang$core$builtin$$Show$output$125$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$126$(self, obj) {
  moonbitlang$core$builtin$$Show$output$127$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$128$(self, obj) {
  moonbitlang$core$builtin$$Show$output$129$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$130$(self, obj) {
  moonbitlang$core$builtin$$Show$output$131$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$132$(self, obj) {
  moonbitlang$core$builtin$$Show$output$133$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$134$(self, obj) {
  moonbitlang$core$builtin$$Show$output$135$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$136$(self, obj) {
  moonbitlang$core$builtin$$Show$output$137$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$138$(self, obj) {
  moonbitlang$core$builtin$$Show$output$139$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$140$(self, obj) {
  moonbitlang$core$builtin$$Show$output$141$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$142$(self, obj) {
  moonbitlang$core$builtin$$Show$output$142$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$143$(self, obj) {
  moonbitlang$core$builtin$$Show$output$143$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$144$(self, obj) {
  moonbitlang$core$builtin$$Show$output$144$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$145$(self, obj) {
  moonbitlang$core$builtin$$Show$output$145$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$146$(self, obj) {
  moonbitlang$core$builtin$$Show$output$146$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$147$(self, obj) {
  moonbitlang$core$builtin$$Show$output$148$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$149$(self, obj) {
  moonbitlang$core$builtin$$Show$output$149$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$150$(self, obj) {
  moonbitlang$core$builtin$$Show$output$150$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$151$(self, obj) {
  moonbitlang$core$builtin$$Show$output$151$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$152$(self, obj) {
  moonbitlang$core$builtin$$Show$output$152$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$153$(self, obj) {
  moonbitlang$core$builtin$$Show$output$154$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$155$(self, obj) {
  moonbitlang$core$builtin$$Show$output$155$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$156$(self, obj) {
  moonbitlang$core$builtin$$Show$output$157$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$158$(self, obj) {
  moonbitlang$core$builtin$$Show$output$158$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$159$(self, obj) {
  moonbitlang$core$builtin$$Show$output$159$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$160$(self, obj) {
  moonbitlang$core$builtin$$Show$output$160$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$161$(self, obj) {
  moonbitlang$core$builtin$$Show$output$161$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$162$(self, obj) {
  moonbitlang$core$builtin$$Show$output$162$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$163$(self, obj) {
  moonbitlang$core$builtin$$Show$output$163$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$164$(self, obj) {
  moonbitlang$core$builtin$$Show$output$164$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$165$(self, obj) {
  moonbitlang$core$builtin$$Show$output$165$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$166$(self, obj) {
  moonbitlang$core$builtin$$Show$output$166$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$167$(self, obj) {
  moonbitlang$core$builtin$$Show$output$167$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$168$(self, obj) {
  moonbitlang$core$builtin$$Show$output$168$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$10$(self, obj) {
  moonbitlang$core$builtin$$Show$output$10$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$169$(self, obj) {
  moonbitlang$core$builtin$$Show$output$169$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$170$(self, obj) {
  moonbitlang$core$builtin$$Show$output$171$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$172$(self, obj) {
  moonbitlang$core$builtin$$Show$output$173$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$174$(self, obj) {
  moonbitlang$core$builtin$$Show$output$174$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$175$(self, obj) {
  moonbitlang$core$builtin$$Show$output$176$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$177$(self, obj) {
  moonbitlang$core$builtin$$Show$output$177$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$178$(self, obj) {
  moonbitlang$core$builtin$$Show$output$179$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$180$(self, obj) {
  moonbitlang$core$builtin$$Show$output$180$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$181$(self, obj) {
  moonbitlang$core$builtin$$Show$output$182$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$183$(self, obj) {
  moonbitlang$core$builtin$$Show$output$183$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$184$(self, obj) {
  moonbitlang$core$builtin$$Show$output$185$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$186$(self, obj) {
  moonbitlang$core$builtin$$Show$output$187$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$188$(self, obj) {
  moonbitlang$core$builtin$$Show$output$188$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$189$(self, obj) {
  moonbitlang$core$builtin$$Show$output$189$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$190$(self, obj) {
  moonbitlang$core$builtin$$Show$output$190$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$191$(self, obj) {
  moonbitlang$core$builtin$$Show$output$191$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$192$(self, obj) {
  moonbitlang$core$builtin$$Show$output$193$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$194$(self, obj) {
  moonbitlang$core$builtin$$Show$output$195$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$196$(self, obj) {
  moonbitlang$core$builtin$$Show$output$197$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$198$(self, obj) {
  moonbitlang$core$builtin$$Show$output$199$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$200$(self, obj) {
  moonbitlang$core$builtin$$Show$output$201$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$202$(self, obj) {
  moonbitlang$core$builtin$$Show$output$202$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$203$(self, obj) {
  moonbitlang$core$builtin$$Show$output$204$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$205$(self, obj) {
  moonbitlang$core$builtin$$Show$output$206$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$207$(self, obj) {
  moonbitlang$core$builtin$$Show$output$207$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$208$(self, obj) {
  moonbitlang$core$builtin$$Show$output$209$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$210$(self, obj) {
  moonbitlang$core$builtin$$Show$output$211$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$212$(self, obj) {
  moonbitlang$core$builtin$$Show$output$213$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$214$(self, obj) {
  moonbitlang$core$builtin$$Show$output$215$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$216$(self, obj) {
  moonbitlang$core$builtin$$Show$output$217$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$218$(self, obj) {
  moonbitlang$core$builtin$$Show$output$219$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$220$(self, obj) {
  moonbitlang$core$builtin$$Show$output$221$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$222$(self, obj) {
  moonbitlang$core$builtin$$Show$output$223$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$224$(self, obj) {
  moonbitlang$core$builtin$$Show$output$225$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$226$(self, obj) {
  moonbitlang$core$builtin$$Show$output$227$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$228$(self, obj) {
  moonbitlang$core$builtin$$Show$output$228$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$229$(self, obj) {
  moonbitlang$core$builtin$$Show$output$229$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$230$(self, obj) {
  moonbitlang$core$builtin$$Show$output$230$(obj, self);
}
function moonbitlang$core$builtin$$Eq$op_equal$75$(_x_2365, _x_2366) {
  if (_x_2365 === 0) {
    if (_x_2366 === 0) {
      return true;
    } else {
      return false;
    }
  } else {
    if (_x_2366 === 1) {
      return true;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Hasher$new(seed) {
  return { acc: (seed >>> 0) + (374761393 >>> 0) | 0 };
}
function moonbitlang$core$builtin$$Hasher$new$46$seed$46$default() {
  return 0;
}
function moonbitlang$core$builtin$$Hasher$combine$9$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$9$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$231$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$231$(value, self);
}
function moonbitlang$core$builtin$$rotl(x, r) {
  return x << r | (x >>> (32 - r | 0) | 0);
}
function moonbitlang$core$builtin$$Hasher$consume4(self, input) {
  self.acc = Math.imul(moonbitlang$core$builtin$$rotl((self.acc >>> 0) + ((Math.imul(input, -1028477379) | 0) >>> 0) | 0, 17), 668265263) | 0;
}
function moonbitlang$core$builtin$$Hasher$combine_uint(self, value) {
  self.acc = (self.acc >>> 0) + (4 >>> 0) | 0;
  moonbitlang$core$builtin$$Hasher$consume4(self, value);
}
function moonbitlang$core$builtin$$Hasher$combine_int(self, value) {
  moonbitlang$core$builtin$$Hasher$combine_uint(self, value);
}
function moonbitlang$core$builtin$$op_ge$232$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$232$(self_, other) >= 0;
}
function moonbitlang$core$builtin$$op_ge$6$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$6$(self_, other) >= 0;
}
function moonbitlang$core$builtin$$op_lt$232$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$232$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$6$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$6$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$14$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$70$(self_, other) < 0;
}
function moonbitlang$core$builtin$$Hasher$combine_string(self, value) {
  const _end2313 = value.length;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < _end2313) {
      moonbitlang$core$builtin$$Hasher$combine_uint(self, value.charCodeAt(i));
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$char$$Char$to_uint(self) {
  return self;
}
function moonbitlang$core$builtin$$Hasher$combine_char(self, value) {
  moonbitlang$core$builtin$$Hasher$combine_uint(self, moonbitlang$core$char$$Char$to_uint(value));
}
function moonbitlang$core$builtin$$Hasher$avalanche(self) {
  let acc = self.acc;
  acc = acc ^ (acc >>> 15 | 0);
  acc = Math.imul(acc, -2048144777) | 0;
  acc = acc ^ (acc >>> 13 | 0);
  acc = Math.imul(acc, -1028477379) | 0;
  acc = acc ^ (acc >>> 16 | 0);
  return acc;
}
function moonbitlang$core$builtin$$Hasher$finalize(self) {
  return moonbitlang$core$builtin$$Hasher$avalanche(self);
}
function moonbitlang$core$builtin$$Hash$hash_combine$9$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_string(hasher, self);
}
function moonbitlang$core$builtin$$Hash$hash$7$(self) {
  const self$2 = self;
  let x = self$2 ^ (self$2 >>> 17 | 0);
  x = Math.imul(x, -312814405) | 0;
  x = x ^ (x >>> 11 | 0);
  x = Math.imul(x, -1404298415) | 0;
  x = x ^ (x >>> 15 | 0);
  x = Math.imul(x, 830770091) | 0;
  x = x ^ (x >>> 14 | 0);
  return x;
}
function moonbitlang$core$builtin$$Hash$hash_combine$7$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self);
}
function moonbitlang$core$builtin$$op_le$232$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$232$(self_, other) <= 0;
}
function moonbitlang$core$builtin$$op_le$6$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$6$(self_, other) <= 0;
}
function moonbitlang$core$builtin$$Default$default$233$() {
  return 0;
}
function moonbitlang$core$builtin$$op_notequal$9$(x, y) {
  return !(x === y);
}
function moonbitlang$core$builtin$$op_notequal$234$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$234$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$75$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$75$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$235$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$235$(x, y);
}
function moonbitlang$core$builtin$$StringBuilder$new(size_hint) {
  return { val: "" };
}
function moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default() {
  return 0;
}
function moonbitlang$core$builtin$$StringBuilder$is_empty(self) {
  return self.val === "";
}
function moonbitlang$core$builtin$$Logger$write_string$71$(self, str) {
  const _bind = self;
  _bind.val = `${_bind.val}${str}`;
}
function moonbitlang$core$builtin$$StringBuilder$to_string(self) {
  return self.val;
}
function moonbitlang$core$builtin$$Logger$write_char$71$(self, ch) {
  const _bind = self;
  _bind.val = `${_bind.val}${moonbitlang$core$builtin$$Show$to_string$10$(ch)}`;
}
function moonbitlang$core$builtin$$Show$to_string$10$(self) {
  return String.fromCodePoint(self);
}
function moonbitlang$core$string$$String$substring(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end;
  }
  return start >= 0 && (start <= end$2 && end$2 <= len) ? self.substring(start, end$2) : $panic();
}
function moonbitlang$core$builtin$$Logger$write_substring$71$(self, str, start, len) {
  const _bind = self;
  _bind.val = `${_bind.val}${moonbitlang$core$string$$String$substring(str, start, start + len | 0)}`;
}
function moonbitlang$core$builtin$$StringBuilder$reset(self) {
  self.val = "";
}
function moonbitlang$core$builtin$$MyInt64$from_int(value) {
  return { hi: value >> 31 & -1, lo: value | 0 };
}
function moonbitlang$core$int$$Int$to_int64(self) {
  return moonbitlang$core$builtin$$MyInt64$from_int(self);
}
function moonbitlang$core$builtin$$MyInt64$to_int(self) {
  return self.lo;
}
function moonbitlang$core$int64$$Int64$to_int(self) {
  return moonbitlang$core$builtin$$MyInt64$to_int(self);
}
function moonbitlang$core$builtin$$output$46$abs$124$1020(n) {
  return n < 0 ? 0 - n | 0 : n;
}
function moonbitlang$core$builtin$$output$46$write_digits$124$1022(_env, num) {
  const logger = _env._1;
  const radix = _env._0;
  const num2 = num / radix | 0;
  if (num2 !== 0) {
    moonbitlang$core$builtin$$output$46$write_digits$124$1022(_env, num2);
  }
  const _tmp = moonbitlang$core$builtin$$output$46$abs$124$1020(num % radix | 0);
  $bound_check("0123456789abcdefghijklmnopqrstuvwxyz", _tmp);
  logger.method_2(logger.self, "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(_tmp));
}
function moonbitlang$core$int$$Int$output(self, logger, radix) {
  if (self < 0) {
    logger.method_2(logger.self, 45);
  }
  const _env = { _0: radix, _1: logger };
  moonbitlang$core$builtin$$output$46$write_digits$124$1022(_env, moonbitlang$core$builtin$$output$46$abs$124$1020(self));
}
function moonbitlang$core$int$$Int$output$46$radix$46$default() {
  return 10;
}
function moonbitlang$core$int$$Int$output_size_hint(radix) {
  return radix >= 2 && radix < 7 ? 36 : radix >= 8 && radix < 15 ? 18 : radix >= 16 && radix <= 36 ? 10 : moonbitlang$core$abort$$abort$7$("radix must be between 2 and 36");
}
function moonbitlang$core$int$$Int$to_string(self, radix) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$int$$Int$output_size_hint(radix));
  moonbitlang$core$int$$Int$output(self, { self: buf, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ }, radix);
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$int$$Int$to_string$46$radix$46$default() {
  return 10;
}
function moonbitlang$core$builtin$$Show$to_string$7$(self) {
  return moonbitlang$core$int$$Int$to_string(self, 10);
}
function moonbitlang$core$builtin$$op_gt$232$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$232$(self_, other) > 0;
}
function moonbitlang$core$builtin$$op_gt$6$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$6$(self_, other) > 0;
}
function moonbitlang$core$builtin$$is_leading_surrogate(c) {
  return 55296 <= c && c <= 56319;
}
function moonbitlang$core$builtin$$is_trailing_surrogate(c) {
  return 56320 <= c && c <= 57343;
}
function moonbitlang$core$string$$String$char_length(self, start_offset, end_offset) {
  if (start_offset >= 0 && (start_offset <= end_offset && end_offset <= self.length)) {
    let _tmp = start_offset;
    let _tmp$2 = 0;
    while (true) {
      const utf16_index = _tmp;
      const char_count = _tmp$2;
      if (utf16_index < end_offset) {
        const c1 = self.charCodeAt(utf16_index);
        if (moonbitlang$core$builtin$$is_leading_surrogate(c1) && (utf16_index + 1 | 0) < end_offset) {
          const _tmp$3 = utf16_index + 1 | 0;
          const c2 = self.charCodeAt(_tmp$3);
          if (moonbitlang$core$builtin$$is_trailing_surrogate(c2)) {
            const _tmp$4 = utf16_index + 2 | 0;
            const _tmp$5 = char_count + 1 | 0;
            _tmp = _tmp$4;
            _tmp$2 = _tmp$5;
            continue;
          } else {
            moonbitlang$core$abort$$abort$12$("invalid surrogate pair");
          }
        }
        const _tmp$3 = utf16_index + 1 | 0;
        const _tmp$4 = char_count + 1 | 0;
        _tmp = _tmp$3;
        _tmp$2 = _tmp$4;
        continue;
      } else {
        return char_count;
      }
    }
  } else {
    return moonbitlang$core$abort$$abort$7$("invalid start or end index for String::codepoint_length");
  }
}
function moonbitlang$core$string$$String$char_length$46$start_offset$46$default() {
  return 0;
}
function moonbitlang$core$string$$String$char_length$46$end_offset$46$default(self) {
  return self.length;
}
function moonbitlang$core$builtin$$code_point_of_surrogate_pair(leading, trailing) {
  return (((Math.imul(leading - 55296 | 0, 1024) | 0) + trailing | 0) - 56320 | 0) + 65536 | 0;
}
function moonbitlang$core$string$$String$unsafe_char_at(self, index) {
  const c1 = self.charCodeAt(index);
  if (moonbitlang$core$builtin$$is_leading_surrogate(c1)) {
    const _tmp = index + 1 | 0;
    const c2 = self.charCodeAt(_tmp);
    return moonbitlang$core$builtin$$code_point_of_surrogate_pair(c1, c2);
  } else {
    return c1;
  }
}
function moonbitlang$core$array$$Array$op_get$7$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$236$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$237$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$9$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$93$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$238$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$108$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$6$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$239$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$73$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$240$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$51$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$241$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$op_get$167$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$uint64$$UInt64$to_int(self) {
  return moonbitlang$core$builtin$$MyInt64$to_int(self);
}
function moonbitlang$core$builtin$$fail$242$(msg, loc) {
  return new Result$Err$2$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$244$(msg, loc) {
  return new Result$Err$3$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$245$(msg, loc) {
  return new Result$Err$4$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$246$(msg, loc) {
  return new Result$Err$5$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$247$(msg, loc) {
  return new Result$Err$6$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$248$(msg, loc) {
  return new Result$Err$7$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$249$(msg, loc) {
  return new Result$Err$8$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$250$(msg, loc) {
  return new Result$Err$9$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$251$(msg, loc) {
  return new Result$Err$10$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$12$(msg, loc) {
  return new Result$Err$11$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$252$(msg, loc) {
  return new Result$Err$12$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$253$(msg, loc) {
  return new Result$Err$13$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$26$(msg, loc) {
  return new Result$Err$14$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$28$(msg, loc) {
  return new Result$Err$15$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$30$(msg, loc) {
  return new Result$Err$16$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$32$(msg, loc) {
  return new Result$Err$17$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$34$(msg, loc) {
  return new Result$Err$18$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$222$(msg, loc) {
  return new Result$Err$19$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$254$(msg, loc) {
  return new Result$Err$20$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$66$(msg, loc) {
  return new Result$Err$21$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$255$(msg, loc) {
  return new Result$Err$22$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$256$(msg, loc) {
  return new Result$Err$23$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$257$(msg, loc) {
  return new Result$Err$24$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$258$(msg, loc) {
  return new Result$Err$25$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$9$(msg, loc) {
  return new Result$Err$26$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$259$(msg, loc) {
  return new Result$Err$27$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$260$(msg, loc) {
  return new Result$Err$28$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$261$(msg, loc) {
  return new Result$Err$29$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$79$(msg, loc) {
  return new Result$Err$30$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$76$(msg, loc) {
  return new Result$Err$31$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$fail$262$(msg, loc) {
  return new Result$Err$32$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`FAILED: ${moonbitlang$core$builtin$$Show$to_string$243$(loc)} ${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`));
}
function moonbitlang$core$builtin$$Eq$op_equal$70$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return _x === _y;
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$263$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return _x === _y;
    }
  }
}
function moonbitlang$core$option$$Option$unwrap$264$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$265$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$253$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$266$(self) {
  if (self.$tag === 0) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some._0;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$267$(self) {
  if (self.$tag === 0) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some._0;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$268$(self) {
  if (self.$tag === 0) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some._0;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$269$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$17$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$9$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$10$(self) {
  if (self === -1) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$16$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$270$(self) {
  if (self.$tag === 0) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some._0;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$271$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$272$(self) {
  if (self.$tag === 0) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some._0;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$273$(self) {
  if (self.$tag === 0) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some._0;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$274$(self) {
  if (self.$tag === 0) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some._0;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$275$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$276$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$277$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$93$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$198$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$278$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$108$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$279$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$280$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$281$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$builtin$$println$9$(input) {
  console.log(moonbitlang$core$builtin$$Show$to_string$9$(input));
}
function moonbitlang$core$builtin$$println$51$(input) {
  console.log(moonbitlang$core$builtin$$Show$to_string$282$(input));
}
function moonbitlang$core$builtin$$Show$output$82$(self, logger) {
  if (self) {
    logger.method_0(logger.self, "true");
    return;
  } else {
    logger.method_0(logger.self, "false");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$7$(self, logger) {
  moonbitlang$core$int$$Int$output(self, logger, moonbitlang$core$int$$Int$output$46$radix$46$default());
}
function moonbitlang$core$builtin$$to_hex_digit(i) {
  return i < 10 ? i + 48 | 0 : (i + 97 | 0) - 10 | 0;
}
function moonbitlang$core$array$$Array$make$283$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$43$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$builtin$$output$46$flush_segment$124$2013(_env, i) {
  const logger = _env._2;
  const segment_start = _env._1;
  const self = _env._0;
  if (i > segment_start.val) {
    logger.method_1(logger.self, self, segment_start.val, i - segment_start.val | 0);
  }
  segment_start.val = i + 1 | 0;
}
function moonbitlang$core$builtin$$Show$output$9$(self, logger) {
  logger.method_2(logger.self, 34);
  const segment_start = { val: 0 };
  const _env = { _0: self, _1: segment_start, _2: logger };
  const _end2016 = self.length;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < _end2016) {
      let c;
      _L: {
        _L$2: {
          const _bind = self.charCodeAt(i);
          switch (_bind) {
            case 34: {
              c = _bind;
              break _L$2;
            }
            case 92: {
              c = _bind;
              break _L$2;
            }
            case 10: {
              moonbitlang$core$builtin$$output$46$flush_segment$124$2013(_env, i);
              logger.method_0(logger.self, "\\n");
              break;
            }
            case 13: {
              moonbitlang$core$builtin$$output$46$flush_segment$124$2013(_env, i);
              logger.method_0(logger.self, "\\r");
              break;
            }
            case 8: {
              moonbitlang$core$builtin$$output$46$flush_segment$124$2013(_env, i);
              logger.method_0(logger.self, "\\b");
              break;
            }
            case 9: {
              moonbitlang$core$builtin$$output$46$flush_segment$124$2013(_env, i);
              logger.method_0(logger.self, "\\t");
              break;
            }
            default: {
              if (_bind < 32) {
                moonbitlang$core$builtin$$output$46$flush_segment$124$2013(_env, i);
                logger.method_0(logger.self, "\\u{");
                logger.method_2(logger.self, moonbitlang$core$builtin$$to_hex_digit(_bind / 16 | 0));
                logger.method_2(logger.self, moonbitlang$core$builtin$$to_hex_digit(_bind % 16 | 0));
                logger.method_2(logger.self, 125);
              }
            }
          }
          break _L;
        }
        moonbitlang$core$builtin$$output$46$flush_segment$124$2013(_env, i);
        logger.method_2(logger.self, 92);
        logger.method_2(logger.self, c);
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$output$46$flush_segment$124$2013(_env, self.length);
  logger.method_2(logger.self, 34);
}
function moonbitlang$core$builtin$$Show$to_string$9$(self) {
  return self;
}
function moonbitlang$core$builtin$$Show$output$284$(self, logger) {
  const _Failure = self;
  const _msg = _Failure._0;
  moonbitlang$core$builtin$$Show$output$9$(`Failure(${moonbitlang$core$builtin$$Show$to_string$9$(_msg)})`, logger);
}
function moonbitlang$core$builtin$$Show$output$81$(self, logger) {
  if (self === undefined) {
    logger.method_0(logger.self, "None");
    return;
  } else {
    const _Some = self;
    const _arg = _Some;
    logger.method_0(logger.self, "Some(");
    moonbitlang$core$builtin$$Logger$write_object$79$(logger, _arg);
    logger.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$87$(self, logger) {
  if (self === undefined) {
    logger.method_0(logger.self, "None");
    return;
  } else {
    const _Some = self;
    const _arg = _Some;
    logger.method_0(logger.self, "Some(");
    moonbitlang$core$builtin$$Logger$write_object$108$(logger, _arg);
    logger.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$92$(self, logger) {
  if (self === undefined) {
    logger.method_0(logger.self, "None");
    return;
  } else {
    const _Some = self;
    const _arg = _Some;
    logger.method_0(logger.self, "Some(");
    moonbitlang$core$builtin$$Logger$write_object$90$(logger, _arg);
    logger.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$154$(self, logger) {
  if (self === undefined) {
    logger.method_0(logger.self, "None");
    return;
  } else {
    const _Some = self;
    const _arg = _Some;
    logger.method_0(logger.self, "Some(");
    moonbitlang$core$builtin$$Logger$write_object$174$(logger, _arg);
    logger.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$179$(self, logger) {
  if (self === undefined) {
    logger.method_0(logger.self, "None");
    return;
  } else {
    const _Some = self;
    const _arg = _Some;
    logger.method_0(logger.self, "Some(");
    moonbitlang$core$builtin$$Logger$write_object$191$(logger, _arg);
    logger.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$182$(self, logger) {
  if (self.$tag === 0) {
    logger.method_0(logger.self, "None");
    return;
  } else {
    const _Some = self;
    const _arg = _Some._0;
    logger.method_0(logger.self, "Some(");
    moonbitlang$core$builtin$$Logger$write_object$83$(logger, _arg);
    logger.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$206$(self, logger) {
  if (self === undefined) {
    logger.method_0(logger.self, "None");
    return;
  } else {
    const _Some = self;
    const _arg = _Some;
    logger.method_0(logger.self, "Some(");
    moonbitlang$core$builtin$$Logger$write_object$208$(logger, _arg);
    logger.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$227$(self, logger) {
  if (self === undefined) {
    logger.method_0(logger.self, "None");
    return;
  } else {
    const _Some = self;
    const _arg = _Some;
    logger.method_0(logger.self, "Some(");
    moonbitlang$core$builtin$$Logger$write_object$228$(logger, _arg);
    logger.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Iter$new$16$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$26$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$28$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$34$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$255$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$10$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$17$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$24$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$285$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$9$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$36$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$23$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$286$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$236$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$253$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$287$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$108$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$220$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$79$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$93$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$198$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$200$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$218$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$288$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$51$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$167$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$289$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$7$(f) {
  return f;
}
function moonbitlang$core$builtin$$Logger$write_iter$17$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$17$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$17$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$79$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$79$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$79$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$167$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$167$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$167$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$108$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$108$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$108$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$51$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$51$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$51$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$93$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$93$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$93$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$198$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$198$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$198$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$200$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$200$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$200$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$218$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$218$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$218$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$220$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$220$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$220$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$17$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$79$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$167$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$108$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$51$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$93$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$198$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$200$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$218$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$220$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$17$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$79$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$167$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$108$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$51$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$93$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$198$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$200$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$218$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$220$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$17$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$79$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$167$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$108$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$51$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$93$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$198$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$200$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$218$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$220$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$17$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$79$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$167$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$108$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$51$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$93$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$198$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$200$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$218$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$220$() {
  return false;
}
function moonbitlang$core$array$$Array$iter$26$(self) {
  return moonbitlang$core$builtin$$Iter$new$26$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$28$(self) {
  return moonbitlang$core$builtin$$Iter$new$28$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$34$(self) {
  return moonbitlang$core$builtin$$Iter$new$34$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$255$(self) {
  return moonbitlang$core$builtin$$Iter$new$255$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$17$(self) {
  return moonbitlang$core$builtin$$Iter$new$17$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$24$(self) {
  return moonbitlang$core$builtin$$Iter$new$24$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$9$(self) {
  return moonbitlang$core$builtin$$Iter$new$9$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$36$(self) {
  return moonbitlang$core$builtin$$Iter$new$36$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$23$(self) {
  return moonbitlang$core$builtin$$Iter$new$23$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$286$(self) {
  return moonbitlang$core$builtin$$Iter$new$286$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$108$(self) {
  return moonbitlang$core$builtin$$Iter$new$108$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$220$(self) {
  return moonbitlang$core$builtin$$Iter$new$220$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$79$(self) {
  return moonbitlang$core$builtin$$Iter$new$79$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$93$(self) {
  return moonbitlang$core$builtin$$Iter$new$93$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$198$(self) {
  return moonbitlang$core$builtin$$Iter$new$198$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$200$(self) {
  return moonbitlang$core$builtin$$Iter$new$200$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$218$(self) {
  return moonbitlang$core$builtin$$Iter$new$218$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$288$(self) {
  return moonbitlang$core$builtin$$Iter$new$288$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$51$(self) {
  return moonbitlang$core$builtin$$Iter$new$51$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$167$(self) {
  return moonbitlang$core$builtin$$Iter$new$167$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$builtin$$Show$output$290$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$17$(logger, moonbitlang$core$array$$Array$iter$17$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$17$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$17$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$17$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$17$());
}
function moonbitlang$core$builtin$$Show$output$78$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$79$(logger, moonbitlang$core$array$$Array$iter$79$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$79$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$79$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$79$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$79$());
}
function moonbitlang$core$builtin$$Show$output$115$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$167$(logger, moonbitlang$core$array$$Array$iter$167$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$167$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$167$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$167$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$167$());
}
function moonbitlang$core$builtin$$Show$output$118$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$108$(logger, moonbitlang$core$array$$Array$iter$108$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$108$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$108$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$108$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$108$());
}
function moonbitlang$core$builtin$$Show$output$171$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$51$(logger, moonbitlang$core$array$$Array$iter$51$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$51$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$51$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$51$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$51$());
}
function moonbitlang$core$builtin$$Show$output$176$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$93$(logger, moonbitlang$core$array$$Array$iter$93$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$93$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$93$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$93$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$93$());
}
function moonbitlang$core$builtin$$Show$output$193$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$198$(logger, moonbitlang$core$array$$Array$iter$198$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$198$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$198$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$198$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$198$());
}
function moonbitlang$core$builtin$$Show$output$195$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$200$(logger, moonbitlang$core$array$$Array$iter$200$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$200$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$200$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$200$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$200$());
}
function moonbitlang$core$builtin$$Show$output$215$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$218$(logger, moonbitlang$core$array$$Array$iter$218$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$218$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$218$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$218$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$218$());
}
function moonbitlang$core$builtin$$Show$output$217$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$220$(logger, moonbitlang$core$array$$Array$iter$220$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$220$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$220$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$220$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$220$());
}
function moonbitlang$core$builtin$$output$46$to_hex_digit$124$1986(i) {
  return i < 10 ? i + 48 | 0 : (i + 97 | 0) - 10 | 0;
}
function moonbitlang$core$builtin$$Show$output$10$(self, logger) {
  logger.method_2(logger.self, 39);
  _L: {
    _L$2: {
      switch (self) {
        case 39: {
          break _L$2;
        }
        case 92: {
          break _L$2;
        }
        case 10: {
          logger.method_0(logger.self, "\\n");
          break;
        }
        case 13: {
          logger.method_0(logger.self, "\\r");
          break;
        }
        case 8: {
          logger.method_0(logger.self, "\\b");
          break;
        }
        case 9: {
          logger.method_0(logger.self, "\\t");
          break;
        }
        default: {
          const code = self;
          if (code < 32) {
            logger.method_0(logger.self, "\\u{");
            logger.method_2(logger.self, moonbitlang$core$builtin$$output$46$to_hex_digit$124$1986(code / 16 | 0));
            logger.method_2(logger.self, moonbitlang$core$builtin$$output$46$to_hex_digit$124$1986(code % 16 | 0));
            logger.method_2(logger.self, 125);
          } else {
            logger.method_2(logger.self, self);
          }
        }
      }
      break _L;
    }
    logger.method_2(logger.self, 92);
    logger.method_2(logger.self, self);
  }
  logger.method_2(logger.self, 39);
}
function moonbitlang$core$builtin$$Iter2$run$291$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter2$new$292$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$293$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$8$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$291$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$72$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$294$(f) {
  return f;
}
function moonbitlang$core$array$$Array$push$295$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$16$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$24$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$296$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$297$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$298$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$23$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$299$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$300$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$286$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$301$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$9$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$26$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$28$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$30$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$32$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$34$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$36$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$38$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$40$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$302$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$303$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$253$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$255$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$10$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$222$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$304$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$257$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$258$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$259$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$260$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$261$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$7$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$17$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$262$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$79$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$288$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$305$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$278$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$306$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$239$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$307$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$198$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$200$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$238$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$220$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$93$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$51$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$218$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$240$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$50$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$167$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$289$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$builtin$$Iter2$to_array$292$(self) {
  const arr = [];
  self((k, v) => {
    moonbitlang$core$array$$Array$push$40$(arr, { _0: k, _1: v });
    return 1;
  });
  return arr;
}
function moonbitlang$core$builtin$$Iter2$to_array$8$(self) {
  const arr = [];
  self((k, v) => {
    moonbitlang$core$array$$Array$push$304$(arr, { _0: k, _1: v });
    return 1;
  });
  return arr;
}
function moonbitlang$core$builtin$$Show$output$173$(self, logger) {
  const _a = self._0;
  const _b = self._1;
  logger.method_0(logger.self, "(");
  moonbitlang$core$builtin$$Logger$write_object$7$(logger, _a);
  logger.method_0(logger.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$7$(logger, _b);
  logger.method_0(logger.self, ")");
}
function moonbitlang$core$builtin$$Show$output$201$(self, logger) {
  const _a = self._0;
  const _b = self._1;
  logger.method_0(logger.self, "(");
  moonbitlang$core$builtin$$Logger$write_object$203$(logger, _a);
  logger.method_0(logger.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$9$(logger, _b);
  logger.method_0(logger.self, ")");
}
function moonbitlang$core$builtin$$Show$output$219$(self, logger) {
  const _a = self._0;
  const _b = self._1;
  logger.method_0(logger.self, "(");
  moonbitlang$core$builtin$$Logger$write_object$51$(logger, _a);
  logger.method_0(logger.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$222$(logger, _b);
  logger.method_0(logger.self, ")");
}
function moonbitlang$core$builtin$$Show$output$223$(self, logger) {
  const _a = self._0;
  const _b = self._1;
  logger.method_0(logger.self, "(");
  moonbitlang$core$builtin$$Logger$write_object$9$(logger, _a);
  logger.method_0(logger.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$9$(logger, _b);
  logger.method_0(logger.self, ")");
}
function moonbitlang$core$builtin$$Show$output$225$(self, logger) {
  const _a = self._0;
  const _b = self._1;
  logger.method_0(logger.self, "(");
  moonbitlang$core$builtin$$Logger$write_object$226$(logger, _a);
  logger.method_0(logger.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$7$(logger, _b);
  logger.method_0(logger.self, ")");
}
function moonbitlang$core$builtin$$Eq$op_equal$233$(self, that) {
  return self === that;
}
function moonbitlang$core$double$$Double$to_int(self) {
  return self !== self ? 0 : self >= 2147483647 ? 2147483647 : self <= -2147483648 ? -2147483648 : self | 0;
}
function moonbitlang$core$builtin$$power_2_above(x, n) {
  let _tmp = x;
  while (true) {
    const i = _tmp;
    if (i >= n) {
      return i;
    }
    const next = i << 1;
    if (next < 0) {
      return i;
    }
    _tmp = next;
    continue;
  }
}
function moonbitlang$core$builtin$$calc_grow_threshold(capacity) {
  return (Math.imul(capacity, 13) | 0) / 16 | 0;
}
function moonbitlang$core$builtin$$Map$new$292$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = moonbitlang$core$builtin$$calc_grow_threshold(capacity$2);
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, growAt: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$308$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = moonbitlang$core$builtin$$calc_grow_threshold(capacity$2);
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, growAt: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$11$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = moonbitlang$core$builtin$$calc_grow_threshold(capacity$2);
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, growAt: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$293$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = moonbitlang$core$builtin$$calc_grow_threshold(capacity$2);
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, growAt: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$8$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = moonbitlang$core$builtin$$calc_grow_threshold(capacity$2);
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, growAt: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$309$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = moonbitlang$core$builtin$$calc_grow_threshold(capacity$2);
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, growAt: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$capacity$46$default$308$() {
  return 8;
}
function moonbitlang$core$builtin$$Map$new$46$capacity$46$default$8$() {
  return 8;
}
function moonbitlang$core$builtin$$Map$new$46$capacity$46$default$309$() {
  return 8;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$292$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    moonbitlang$core$option$$Option$unwrap$275$(_tmp[_bind]).next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$11$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    moonbitlang$core$option$$Option$unwrap$276$(_tmp[_bind]).next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$293$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    moonbitlang$core$option$$Option$unwrap$277$(_tmp[_bind]).next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$8$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    moonbitlang$core$option$$Option$unwrap$279$(_tmp[_bind]).next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$308$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    moonbitlang$core$option$$Option$unwrap$280$(_tmp[_bind]).next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$309$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    moonbitlang$core$option$$Option$unwrap$281$(_tmp[_bind]).next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$set_entry$292$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$11$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$293$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$8$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$308$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$309$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$push_away$292$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$292$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$292$(self, entry$2, idx$2);
        const _tmp$5 = _curr_entry.psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        const _tmp$5 = psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$11$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$11$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$11$(self, entry$2, idx$2);
        const _tmp$5 = _curr_entry.psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        const _tmp$5 = psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$293$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$293$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$293$(self, entry$2, idx$2);
        const _tmp$5 = _curr_entry.psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        const _tmp$5 = psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$8$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$8$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$8$(self, entry$2, idx$2);
        const _tmp$5 = _curr_entry.psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        const _tmp$5 = psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$308$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$308$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$308$(self, entry$2, idx$2);
        const _tmp$5 = _curr_entry.psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        const _tmp$5 = psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$309$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$309$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$309$(self, entry$2, idx$2);
        const _tmp$5 = _curr_entry.psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        const _tmp$5 = psl + 1 | 0;
        const _tmp$6 = idx$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$292$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$292$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$10$(key);
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$292$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      const _tmp$4 = psl + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$292$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set$11$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$11$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$11$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      const _tmp$4 = psl + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$11$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set$293$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$293$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$293$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      const _tmp$4 = psl + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$293$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set$8$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$8$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$8$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      const _tmp$4 = psl + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$8$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set$308$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$308$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$308$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      const _tmp$4 = psl + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$308$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set$309$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$309$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$310$(key);
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$231$(_curr_entry.key, key)) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$309$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      const _tmp$4 = psl + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$309$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$grow$292$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      moonbitlang$core$builtin$$Map$set$292$(self, _key, _value);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$11$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      moonbitlang$core$builtin$$Map$set$11$(self, _key, _value);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$293$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      moonbitlang$core$builtin$$Map$set$293$(self, _key, _value);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$8$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      moonbitlang$core$builtin$$Map$set$8$(self, _key, _value);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$308$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      moonbitlang$core$builtin$$Map$set$308$(self, _key, _value);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$309$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      moonbitlang$core$builtin$$Map$set$309$(self, _key, _value);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$from_array$292$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$292$(arr.length);
  const _p = arr.length;
  let _tmp = 0;
  while (true) {
    const _p$2 = _tmp;
    if (_p$2 < _p) {
      const _p$3 = arr[_p$2];
      const e = _p$3;
      moonbitlang$core$builtin$$Map$set$292$(m, e._0, e._1);
      _tmp = _p$2 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$11$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$11$(arr.length);
  const _p = arr.length;
  let _tmp = 0;
  while (true) {
    const _p$2 = _tmp;
    if (_p$2 < _p) {
      const _p$3 = arr[_p$2];
      const e = _p$3;
      moonbitlang$core$builtin$$Map$set$11$(m, e._0, e._1);
      _tmp = _p$2 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$293$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$293$(arr.length);
  const _p = arr.length;
  let _tmp = 0;
  while (true) {
    const _p$2 = _tmp;
    if (_p$2 < _p) {
      const _p$3 = arr[_p$2];
      const e = _p$3;
      moonbitlang$core$builtin$$Map$set$293$(m, e._0, e._1);
      _tmp = _p$2 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$8$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$8$(arr.length);
  const _p = arr.length;
  let _tmp = 0;
  while (true) {
    const _p$2 = _tmp;
    if (_p$2 < _p) {
      const _p$3 = arr[_p$2];
      const e = _p$3;
      moonbitlang$core$builtin$$Map$set$8$(m, e._0, e._1);
      _tmp = _p$2 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$op_set$292$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$292$(self, key, value);
}
function moonbitlang$core$builtin$$Map$op_set$8$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$8$(self, key, value);
}
function moonbitlang$core$builtin$$Map$op_set$308$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$308$(self, key, value);
}
function moonbitlang$core$builtin$$Map$op_set$309$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$309$(self, key, value);
}
function moonbitlang$core$builtin$$Map$get$8$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      const _tmp$4 = i + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$292$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$10$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return Option$None$33$;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return new Option$Some$33$(_entry.value);
      }
      if (i > _entry.psl) {
        return Option$None$33$;
      }
      const _tmp$4 = i + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$293$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      const _tmp$4 = i + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$11$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      const _tmp$4 = i + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$308$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      const _tmp$4 = i + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$309$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$310$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$231$(_entry.key, key)) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      const _tmp$4 = i + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$op_get$308$(self, key) {
  return moonbitlang$core$builtin$$Map$get$308$(self, key);
}
function moonbitlang$core$builtin$$Map$op_get$309$(self, key) {
  return moonbitlang$core$builtin$$Map$get$309$(self, key);
}
function moonbitlang$core$builtin$$Map$contains$293$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      const _tmp$4 = i + 1 | 0;
      const _tmp$5 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$311$(self, logger) {
  logger.method_0(logger.self, "{");
  let _tmp = 0;
  let _tmp$2 = self.head;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if (_param$2 === undefined) {
      logger.method_0(logger.self, "}");
      return;
    } else {
      const _Some = _param$2;
      const _x = _Some;
      const _key = _x.key;
      const _value = _x.value;
      const _next = _x.next;
      if (_param > 0) {
        logger.method_0(logger.self, ", ");
      }
      moonbitlang$core$builtin$$Logger$write_object$9$(logger, _key);
      logger.method_0(logger.self, ": ");
      moonbitlang$core$builtin$$Logger$write_object$17$(logger, _value);
      const _tmp$3 = _param + 1 | 0;
      _tmp = _tmp$3;
      _tmp$2 = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$is_empty$8$(self) {
  return self.size === 0;
}
function moonbitlang$core$builtin$$Map$iter$308$(self) {
  return moonbitlang$core$builtin$$Iter$new$287$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _next = _x.next;
        const _bind = yield_({ _0: _key, _1: _value });
        if (_bind === 1) {
          _tmp = _next;
          continue;
        } else {
          return 0;
        }
      }
    }
  });
}
function moonbitlang$core$builtin$$Map$iter2$292$(self) {
  return moonbitlang$core$builtin$$Iter2$new$292$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _next = _x.next;
        const _bind = yield_(_key, _value);
        if (_bind === 1) {
          _tmp = _next;
          continue;
        } else {
          return 0;
        }
      }
    }
  });
}
function moonbitlang$core$builtin$$Map$iter2$293$(self) {
  return moonbitlang$core$builtin$$Iter2$new$293$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _next = _x.next;
        const _bind = yield_(_key, _value);
        if (_bind === 1) {
          _tmp = _next;
          continue;
        } else {
          return 0;
        }
      }
    }
  });
}
function moonbitlang$core$builtin$$Map$iter2$8$(self) {
  return moonbitlang$core$builtin$$Iter2$new$8$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _next = _x.next;
        const _bind = yield_(_key, _value);
        if (_bind === 1) {
          _tmp = _next;
          continue;
        } else {
          return 0;
        }
      }
    }
  });
}
function moonbitlang$core$builtin$$Map$values$292$(self) {
  return moonbitlang$core$builtin$$Iter$new$285$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _value = _x.value;
        const _next = _x.next;
        const _bind = yield_(_value);
        if (_bind === 1) {
          _tmp = _next;
          continue;
        } else {
          return 0;
        }
      }
    }
  });
}
function moonbitlang$core$builtin$$Map$from_iter$293$(iter) {
  const m = moonbitlang$core$builtin$$Map$from_array$293$([]);
  iter((e) => {
    moonbitlang$core$builtin$$Map$set$293$(m, e._0, e._1);
    return 1;
  });
  return m;
}
function moonbitlang$core$builtin$$Hash$hash$74$(self) {
  const _self = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$9$(_self, self);
  return moonbitlang$core$builtin$$Hasher$finalize(_self);
}
function moonbitlang$core$builtin$$Hash$hash$310$(self) {
  const _self = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$231$(_self, self);
  return moonbitlang$core$builtin$$Hasher$finalize(_self);
}
function moonbitlang$core$builtin$$Show$to_string$243$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$312$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$313$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$174$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$314$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$17$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$315$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$79$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$316$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$76$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$317$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$149$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$318$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$150$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$319$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$151$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$320$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$158$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$321$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$160$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$322$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$166$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$323$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$82$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$282$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$51$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$2$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$324$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$0$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$325$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$5$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$326$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$3$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$327$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$1$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$284$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$4$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$328$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$repr$10$(t) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$10$(t, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$71$, method_1: moonbitlang$core$builtin$$Logger$write_substring$71$, method_2: moonbitlang$core$builtin$$Logger$write_char$71$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Eq$op_equal$173$(self, other) {
  return self._0 === other._0 && self._1 === other._1;
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$329$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$330$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$331$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$332$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$333$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$Array$unsafe_blit$23$(dst, dst_offset, src, src_offset, len) {
  moonbitlang$core$array$$FixedArray$unsafe_blit$332$(dst, dst_offset, src, src_offset, len);
}
function moonbitlang$core$builtin$$Iter$run$9$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$23$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$236$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$253$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$16$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$10$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$288$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$just_run$10$(self, f) {
  const _func = self;
  _func(f);
}
function moonbitlang$core$builtin$$Iter$any$9$(self, f) {
  return moonbitlang$core$builtin$$op_notequal$75$(moonbitlang$core$builtin$$Iter$run$9$(self, (k) => f(k) ? 0 : 1), 1);
}
function moonbitlang$core$builtin$$Iter$any$10$(self, f) {
  return moonbitlang$core$builtin$$op_notequal$75$(moonbitlang$core$builtin$$Iter$run$10$(self, (k) => f(k) ? 0 : 1), 1);
}
function moonbitlang$core$builtin$$Iter$all$288$(self, f) {
  return moonbitlang$core$builtin$$Eq$op_equal$75$(moonbitlang$core$builtin$$Iter$run$288$(self, (k) => !f(k) ? 0 : 1), 1);
}
function moonbitlang$core$builtin$$Iter$all$10$(self, f) {
  return moonbitlang$core$builtin$$Eq$op_equal$75$(moonbitlang$core$builtin$$Iter$run$10$(self, (k) => !f(k) ? 0 : 1), 1);
}
function moonbitlang$core$builtin$$Iter$empty$51$() {
  return (_param5) => 1;
}
function moonbitlang$core$builtin$$Iter$singleton$51$(a) {
  return (yield_) => yield_(a);
}
function moonbitlang$core$builtin$$Iter$filter_map$334$(self, f) {
  return (yield_) => moonbitlang$core$builtin$$Iter$run$16$(self, (a) => {
    const _bind = f(a);
    if (_bind === undefined) {
      return 1;
    } else {
      const _Some = _bind;
      const _b = _Some;
      return yield_(_b);
    }
  });
}
function moonbitlang$core$builtin$$Iter$take_while$10$(self, f) {
  return (yield_) => {
    const r = { val: 1 };
    moonbitlang$core$builtin$$Iter$just_run$10$(self, (a) => {
      if (f(a)) {
        if (moonbitlang$core$builtin$$Eq$op_equal$75$(yield_(a), 1)) {
          return 1;
        } else {
          r.val = 0;
          return 0;
        }
      } else {
        return 0;
      }
    });
    return r.val;
  };
}
function moonbitlang$core$builtin$$Iter$find_first$7$(self, f) {
  const _foreach_result = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$34$ };
  self((a) => {
    if (f(a)) {
      _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$34$(a);
      return 0;
    }
    return 1;
  });
  const _tmp = _foreach_result.val;
  switch (_tmp.$tag) {
    case 0: {
      return undefined;
    }
    case 1: {
      const _break = _tmp;
      return _break._0;
    }
    case 2: {
      const _return = _tmp;
      return _return._0;
    }
    case 3: {
      return $panic();
    }
    default: {
      return $panic();
    }
  }
}
function moonbitlang$core$builtin$$Iter$to_array$16$(self) {
  const result = [];
  self((e) => {
    moonbitlang$core$array$$Array$push$16$(result, e);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$to_array$9$(self) {
  const result = [];
  self((e) => {
    moonbitlang$core$array$$Array$push$9$(result, e);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$collect$16$(self) {
  const result = [];
  self((_p) => {
    moonbitlang$core$array$$Array$push$16$(result, _p);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$collect$9$(self) {
  const result = [];
  self((_p) => {
    moonbitlang$core$array$$Array$push$9$(result, _p);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$collect$24$(self) {
  const result = [];
  self((_p) => {
    moonbitlang$core$array$$Array$push$24$(result, _p);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$collect$23$(self) {
  const result = [];
  self((_p) => {
    moonbitlang$core$array$$Array$push$23$(result, _p);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$collect$253$(self) {
  const result = [];
  self((_p) => {
    moonbitlang$core$array$$Array$push$253$(result, _p);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$collect$10$(self) {
  const result = [];
  self((_p) => {
    moonbitlang$core$array$$Array$push$10$(result, _p);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$join(self, sep) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  const first = { val: true };
  self((str) => {
    if (first.val) {
      first.val = false;
    } else {
      moonbitlang$core$builtin$$Logger$write_string$71$(buf, sep);
    }
    moonbitlang$core$builtin$$Logger$write_string$71$(buf, str);
    return 1;
  });
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$builtin$$Iter$iter$23$(self) {
  return self;
}
function moonbitlang$core$builtin$$Iter$last$16$(self) {
  const _bind = undefined;
  const _acc = { val: _bind };
  self((_p) => {
    _acc.val = _p;
    return 1;
  });
  return _acc.val;
}
function moonbitlang$core$builtin$$Iter$intersperse$23$(self, sep) {
  return (yield_) => {
    const first = { val: true };
    return moonbitlang$core$builtin$$Iter$run$23$(self, (x) => {
      if (first.val) {
        first.val = false;
        return yield_(x);
      } else {
        return moonbitlang$core$builtin$$Eq$op_equal$75$(yield_(sep), 0) ? 0 : yield_(x);
      }
    });
  };
}
function moonbitlang$core$json$$Json$array(array) {
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Array(array);
}
function moonbitlang$core$array$$Array$new$7$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$unsafe_pop$288$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$278$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$306$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$239$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$51$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$289$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$pop$288$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$288$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$278$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$278$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$306$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$306$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$239$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$239$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$51$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$51$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$289$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$289$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$drain$239$(self, begin, end) {
  return begin >= 0 && (end <= self.length && begin <= end) ? moonbitlang$core$builtin$$JSArray$splice(self, begin, end - begin | 0) : moonbitlang$core$abort$$abort$48$(`index out of bounds: the len is ${moonbitlang$core$builtin$$Show$to_string$7$(self.length)} but the index is (${moonbitlang$core$builtin$$Show$to_string$7$(begin)}, ${moonbitlang$core$builtin$$Show$to_string$7$(end)})`);
}
function moonbitlang$core$array$$ArrayView$length$16$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$43$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$24$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$26$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$28$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$30$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$32$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$34$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$36$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$38$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$40$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$9$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$307$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$50$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$289$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$op_get$24$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$24$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$op_get$26$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$26$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$op_get$28$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$28$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$op_get$30$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$30$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$op_get$32$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$32$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$op_get$34$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$34$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$op_get$36$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$36$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$op_get$38$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$38$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$op_get$40$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$40$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$op_get$43$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$43$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$op_get$50$(self, index) {
  if (index >= 0 && index < self.len) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$abort$$abort$50$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
}
function moonbitlang$core$array$$ArrayView$swap$24$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + i | 0;
    $bound_check(_tmp, _tmp$2);
    const temp = _tmp[_tmp$2];
    const _tmp$3 = self.buf;
    const _tmp$4 = self.start + i | 0;
    const _tmp$5 = self.buf;
    const _tmp$6 = self.start + j | 0;
    $bound_check(_tmp$5, _tmp$6);
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4] = _tmp$5[_tmp$6];
    const _tmp$7 = self.buf;
    const _tmp$8 = self.start + j | 0;
    $bound_check(_tmp$7, _tmp$8);
    _tmp$7[_tmp$8] = temp;
    return;
  } else {
    moonbitlang$core$abort$$abort$12$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$7$(i)}, ${moonbitlang$core$builtin$$Show$to_string$7$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$ArrayView$swap$26$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + i | 0;
    $bound_check(_tmp, _tmp$2);
    const temp = _tmp[_tmp$2];
    const _tmp$3 = self.buf;
    const _tmp$4 = self.start + i | 0;
    const _tmp$5 = self.buf;
    const _tmp$6 = self.start + j | 0;
    $bound_check(_tmp$5, _tmp$6);
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4] = _tmp$5[_tmp$6];
    const _tmp$7 = self.buf;
    const _tmp$8 = self.start + j | 0;
    $bound_check(_tmp$7, _tmp$8);
    _tmp$7[_tmp$8] = temp;
    return;
  } else {
    moonbitlang$core$abort$$abort$12$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$7$(i)}, ${moonbitlang$core$builtin$$Show$to_string$7$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$ArrayView$swap$28$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + i | 0;
    $bound_check(_tmp, _tmp$2);
    const temp = _tmp[_tmp$2];
    const _tmp$3 = self.buf;
    const _tmp$4 = self.start + i | 0;
    const _tmp$5 = self.buf;
    const _tmp$6 = self.start + j | 0;
    $bound_check(_tmp$5, _tmp$6);
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4] = _tmp$5[_tmp$6];
    const _tmp$7 = self.buf;
    const _tmp$8 = self.start + j | 0;
    $bound_check(_tmp$7, _tmp$8);
    _tmp$7[_tmp$8] = temp;
    return;
  } else {
    moonbitlang$core$abort$$abort$12$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$7$(i)}, ${moonbitlang$core$builtin$$Show$to_string$7$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$ArrayView$swap$30$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + i | 0;
    $bound_check(_tmp, _tmp$2);
    const temp = _tmp[_tmp$2];
    const _tmp$3 = self.buf;
    const _tmp$4 = self.start + i | 0;
    const _tmp$5 = self.buf;
    const _tmp$6 = self.start + j | 0;
    $bound_check(_tmp$5, _tmp$6);
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4] = _tmp$5[_tmp$6];
    const _tmp$7 = self.buf;
    const _tmp$8 = self.start + j | 0;
    $bound_check(_tmp$7, _tmp$8);
    _tmp$7[_tmp$8] = temp;
    return;
  } else {
    moonbitlang$core$abort$$abort$12$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$7$(i)}, ${moonbitlang$core$builtin$$Show$to_string$7$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$ArrayView$swap$32$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + i | 0;
    $bound_check(_tmp, _tmp$2);
    const temp = _tmp[_tmp$2];
    const _tmp$3 = self.buf;
    const _tmp$4 = self.start + i | 0;
    const _tmp$5 = self.buf;
    const _tmp$6 = self.start + j | 0;
    $bound_check(_tmp$5, _tmp$6);
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4] = _tmp$5[_tmp$6];
    const _tmp$7 = self.buf;
    const _tmp$8 = self.start + j | 0;
    $bound_check(_tmp$7, _tmp$8);
    _tmp$7[_tmp$8] = temp;
    return;
  } else {
    moonbitlang$core$abort$$abort$12$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$7$(i)}, ${moonbitlang$core$builtin$$Show$to_string$7$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$ArrayView$swap$34$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + i | 0;
    $bound_check(_tmp, _tmp$2);
    const temp = _tmp[_tmp$2];
    const _tmp$3 = self.buf;
    const _tmp$4 = self.start + i | 0;
    const _tmp$5 = self.buf;
    const _tmp$6 = self.start + j | 0;
    $bound_check(_tmp$5, _tmp$6);
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4] = _tmp$5[_tmp$6];
    const _tmp$7 = self.buf;
    const _tmp$8 = self.start + j | 0;
    $bound_check(_tmp$7, _tmp$8);
    _tmp$7[_tmp$8] = temp;
    return;
  } else {
    moonbitlang$core$abort$$abort$12$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$7$(i)}, ${moonbitlang$core$builtin$$Show$to_string$7$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$ArrayView$swap$36$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + i | 0;
    $bound_check(_tmp, _tmp$2);
    const temp = _tmp[_tmp$2];
    const _tmp$3 = self.buf;
    const _tmp$4 = self.start + i | 0;
    const _tmp$5 = self.buf;
    const _tmp$6 = self.start + j | 0;
    $bound_check(_tmp$5, _tmp$6);
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4] = _tmp$5[_tmp$6];
    const _tmp$7 = self.buf;
    const _tmp$8 = self.start + j | 0;
    $bound_check(_tmp$7, _tmp$8);
    _tmp$7[_tmp$8] = temp;
    return;
  } else {
    moonbitlang$core$abort$$abort$12$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$7$(i)}, ${moonbitlang$core$builtin$$Show$to_string$7$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$ArrayView$swap$38$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + i | 0;
    $bound_check(_tmp, _tmp$2);
    const temp = _tmp[_tmp$2];
    const _tmp$3 = self.buf;
    const _tmp$4 = self.start + i | 0;
    const _tmp$5 = self.buf;
    const _tmp$6 = self.start + j | 0;
    $bound_check(_tmp$5, _tmp$6);
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4] = _tmp$5[_tmp$6];
    const _tmp$7 = self.buf;
    const _tmp$8 = self.start + j | 0;
    $bound_check(_tmp$7, _tmp$8);
    _tmp$7[_tmp$8] = temp;
    return;
  } else {
    moonbitlang$core$abort$$abort$12$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$7$(i)}, ${moonbitlang$core$builtin$$Show$to_string$7$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$ArrayView$swap$40$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + i | 0;
    $bound_check(_tmp, _tmp$2);
    const temp = _tmp[_tmp$2];
    const _tmp$3 = self.buf;
    const _tmp$4 = self.start + i | 0;
    const _tmp$5 = self.buf;
    const _tmp$6 = self.start + j | 0;
    $bound_check(_tmp$5, _tmp$6);
    $bound_check(_tmp$3, _tmp$4);
    _tmp$3[_tmp$4] = _tmp$5[_tmp$6];
    const _tmp$7 = self.buf;
    const _tmp$8 = self.start + j | 0;
    $bound_check(_tmp$7, _tmp$8);
    _tmp$7[_tmp$8] = temp;
    return;
  } else {
    moonbitlang$core$abort$$abort$12$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$7$(i)}, ${moonbitlang$core$builtin$$Show$to_string$7$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$Array$op_as_view$16$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$13$("View index out of bounds");
}
function moonbitlang$core$array$$Array$op_as_view$9$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$42$("View index out of bounds");
}
function moonbitlang$core$array$$Array$op_as_view$238$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$46$("View index out of bounds");
}
function moonbitlang$core$array$$Array$op_as_view$239$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$49$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$24$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$24$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$25$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$26$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$26$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$27$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$28$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$28$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$29$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$30$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$30$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$31$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$32$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$32$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$33$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$34$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$34$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$35$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$36$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$36$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$37$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$38$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$38$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$39$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$40$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$40$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$abort$$abort$41$("View index out of bounds");
}
function moonbitlang$core$array$$Array$op_set$283$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$43$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$288$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$238$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$239$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$50$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$36$(dst, dst_offset, src, src_offset, len) {
  moonbitlang$core$array$$FixedArray$unsafe_blit$329$(dst, dst_offset, src, src_offset, len);
}
function moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$297$(dst, dst_offset, src, src_offset, len) {
  moonbitlang$core$array$$FixedArray$unsafe_blit$330$(dst, dst_offset, src, src_offset, len);
}
function moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$298$(dst, dst_offset, src, src_offset, len) {
  moonbitlang$core$array$$FixedArray$unsafe_blit$331$(dst, dst_offset, src, src_offset, len);
}
function moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$300$(dst, dst_offset, src, src_offset, len) {
  moonbitlang$core$array$$FixedArray$unsafe_blit$333$(dst, dst_offset, src, src_offset, len);
}
function moonbitlang$core$builtin$$Add$op_add$335$(self, other) {
  const result = new Array(self.length + other.length | 0);
  moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$36$(result, 0, self, 0, self.length);
  moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$36$(result, self.length, other, 0, other.length);
  return result;
}
function moonbitlang$core$builtin$$Add$op_add$336$(self, other) {
  const result = new Array(self.length + other.length | 0);
  moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$297$(result, 0, self, 0, self.length);
  moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$297$(result, self.length, other, 0, other.length);
  return result;
}
function moonbitlang$core$builtin$$Add$op_add$337$(self, other) {
  const result = new Array(self.length + other.length | 0);
  moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$298$(result, 0, self, 0, self.length);
  moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$298$(result, self.length, other, 0, other.length);
  return result;
}
function moonbitlang$core$builtin$$Add$op_add$338$(self, other) {
  const result = new Array(self.length + other.length | 0);
  moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$300$(result, 0, self, 0, self.length);
  moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$300$(result, self.length, other, 0, other.length);
  return result;
}
function moonbitlang$core$array$$Array$is_empty$222$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$is_empty$9$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$is_empty$36$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$is_empty$17$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$is_empty$239$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$rev_inplace$200$(self) {
  const _end810 = self.length / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < _end810) {
      const temp = self[i];
      self[i] = self[(self.length - i | 0) - 1 | 0];
      self[(self.length - i | 0) - 1 | 0] = temp;
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$rev$51$(self) {
  const arr = new Array(self.length);
  const _end804 = self.length;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < _end804) {
      arr[i] = self[(self.length - i | 0) - 1 | 0];
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$contains$9$(self, value) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      if (v === value) {
        return true;
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$array$$Array$flatten$23$(self) {
  let len = 0;
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = self[_i];
      len = len + x.length | 0;
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const res = new Array(len);
  let i = 0;
  const _len$2 = self.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const xs = self[_i];
      moonbitlang$core$array$$Array$unsafe_blit$23$(res, i, xs, 0, xs.length);
      i = i + xs.length | 0;
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return res;
}
function moonbitlang$core$json$$Json$null() {
  return $64$moonbitlang$47$core$47$builtin$46$Json$Null;
}
function moonbitlang$core$json$$Json$number(number) {
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Number(number);
}
function moonbitlang$core$json$$Json$string(string) {
  return new $64$moonbitlang$47$core$47$builtin$46$Json$String(string);
}
function moonbitlang$core$json$$Json$boolean(boolean) {
  return boolean ? $64$moonbitlang$47$core$47$builtin$46$Json$True : $64$moonbitlang$47$core$47$builtin$46$Json$False;
}
function moonbitlang$core$json$$Json$object(object) {
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Object(object);
}
function moonbitlang$core$builtin$$MyInt64$extend_i32_u(value) {
  return { hi: 0, lo: value };
}
function moonbitlang$core$uint64$$UInt64$extend_uint(value) {
  return moonbitlang$core$builtin$$MyInt64$extend_i32_u(value);
}
function moonbitlang$core$double$$Double$convert_uint64(value) {
  return moonbitlang$core$builtin$$MyInt64$convert_to_double_u(value);
}
function moonbitlang$core$int64$$Int64$reinterpret_as_double(self) {
  return moonbitlang$core$builtin$$MyInt64$reinterpret_as_double(self);
}
function moonbitlang$core$int$$Int$to_char(self) {
  _L: {
    if (self >= 0 && self <= 55295) {
      break _L;
    } else {
      if (self >= 57344 && self <= 1114111) {
        break _L;
      } else {
        return -1;
      }
    }
  }
  return self;
}
function moonbitlang$core$uint64$$UInt64$to_byte(self) {
  return moonbitlang$core$uint64$$UInt64$to_int(self) & 255;
}
function moonbitlang$core$byte$$Byte$to_int64(self) {
  return moonbitlang$core$int$$Int$to_int64(self);
}
function moonbitlang$core$builtin$$UninitializedArray$length$283$(self) {
  return self.length;
}
function moonbitlang$core$builtin$$UninitializedArray$length$289$(self) {
  return self.length;
}
function moonbitlang$core$builtin$$UninitializedArray$op_as_view$289$(self, start, end) {
  const len = moonbitlang$core$builtin$$UninitializedArray$length$289$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end;
  }
  return start >= 0 && (start <= end$2 && end$2 <= len) ? { buf: self, start: start, len: end$2 - start | 0 } : moonbitlang$core$abort$$abort$52$("View start index out of bounds");
}
function moonbitlang$core$builtin$$UninitializedArray$op_as_view$46$start$46$default$289$() {
  return 0;
}
function moonbitlang$core$builtin$$Neg$op_neg$339$(self) {
  return self.lo === 0 ? { hi: ~self.hi + 1 | 0, lo: 0 } : { hi: ~self.hi, lo: ~self.lo + 1 | 0 };
}
function moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, bhi, blo) {
  const _ahi = self.hi;
  const _alo = self.lo;
  const lo = _alo + blo | 0;
  const s = lo >> 31;
  const as_ = _alo >> 31;
  const bs = blo >> 31;
  const c = (as_ & bs | ~s & (as_ ^ bs)) & 1;
  const hi = (_ahi + bhi | 0) + c | 0;
  return { hi: hi, lo: lo };
}
function moonbitlang$core$builtin$$Add$op_add$339$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, other.hi, other.lo);
}
function moonbitlang$core$builtin$$Sub$op_sub$339$(self, other) {
  return other.lo === 0 ? { hi: self.hi - other.hi | 0, lo: self.lo } : moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, ~other.hi, ~other.lo + 1 | 0);
}
function moonbitlang$core$builtin$$Mul$op_mul$339$(self, other) {
  const _ahi = self.hi;
  const _alo = self.lo;
  const _bhi = other.hi;
  const _blo = other.lo;
  const ahi = _ahi;
  const alo = _alo;
  const bhi = _bhi;
  const blo = _blo;
  const a48 = ahi >>> 16 | 0;
  const a32 = ahi & 65535;
  const a16 = alo >>> 16 | 0;
  const a00 = alo & 65535;
  const b48 = bhi >>> 16 | 0;
  const b32 = bhi & 65535;
  const b16 = blo >>> 16 | 0;
  const b00 = blo & 65535;
  const c00 = Math.imul(a00, b00) | 0;
  const c16 = c00 >>> 16 | 0;
  const c00$2 = c00 & 65535;
  const c16$2 = (c16 >>> 0) + ((Math.imul(a16, b00) | 0) >>> 0) | 0;
  const c32 = c16$2 >>> 16 | 0;
  const c16$3 = c16$2 & 65535;
  const c16$4 = (c16$3 >>> 0) + ((Math.imul(a00, b16) | 0) >>> 0) | 0;
  const c32$2 = (c32 >>> 0) + ((c16$4 >>> 16 | 0) >>> 0) | 0;
  const c16$5 = c16$4 & 65535;
  const c32$3 = (c32$2 >>> 0) + ((Math.imul(a32, b00) | 0) >>> 0) | 0;
  const c48 = c32$3 >>> 16 | 0;
  const c32$4 = c32$3 & 65535;
  const c32$5 = (c32$4 >>> 0) + ((Math.imul(a16, b16) | 0) >>> 0) | 0;
  const c48$2 = (c48 >>> 0) + ((c32$5 >>> 16 | 0) >>> 0) | 0;
  const c32$6 = c32$5 & 65535;
  const c32$7 = (c32$6 >>> 0) + ((Math.imul(a00, b32) | 0) >>> 0) | 0;
  const c48$3 = (c48$2 >>> 0) + ((c32$7 >>> 16 | 0) >>> 0) | 0;
  const c32$8 = c32$7 & 65535;
  const c48$4 = (((((((c48$3 >>> 0) + ((Math.imul(a48, b00) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a32, b16) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a16, b32) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a00, b48) | 0) >>> 0) | 0;
  const c48$5 = c48$4 & 65535;
  return { hi: c48$5 << 16 | c32$8, lo: c16$5 << 16 | c00$2 };
}
function moonbitlang$core$builtin$$Div$op_div$339$(self, other) {
  const exports = moonbitlang$core$builtin$$get_int64_wasm_helper();
  const _ahi = self.hi;
  const _alo = self.lo;
  const _bhi = other.hi;
  const _blo = other.lo;
  const _func = exports.div_s;
  const lo = _func(_alo, _ahi, _blo, _bhi);
  const _func$2 = exports.get_high;
  const hi = _func$2();
  return { hi: hi, lo: lo };
}
function moonbitlang$core$builtin$$MyInt64$div_u(self, other) {
  const exports = moonbitlang$core$builtin$$get_int64_wasm_helper();
  const _ahi = self.hi;
  const _alo = self.lo;
  const _bhi = other.hi;
  const _blo = other.lo;
  const _func = exports.div_u;
  const lo = _func(_alo, _ahi, _blo, _bhi);
  const _func$2 = exports.get_high;
  const hi = _func$2();
  return { hi: hi, lo: lo };
}
function moonbitlang$core$builtin$$MyInt64$land(self, other) {
  return { hi: self.hi & other.hi, lo: self.lo & other.lo };
}
function moonbitlang$core$builtin$$MyInt64$lor(self, other) {
  return { hi: self.hi | other.hi, lo: self.lo | other.lo };
}
function moonbitlang$core$builtin$$MyInt64$lsl(self, shift) {
  const shift$2 = shift & 63;
  if (shift$2 === 0) {
    return self;
  } else {
    if (shift$2 < 32) {
      const _hi = self.hi;
      const _lo = self.lo;
      const hi = _hi;
      const lo = _lo;
      const hi$2 = hi << shift$2 | (lo >>> (32 - shift$2 | 0) | 0);
      const lo$2 = lo << shift$2;
      return { hi: hi$2, lo: lo$2 };
    } else {
      return { hi: self.lo << (shift$2 - 32 | 0), lo: 0 };
    }
  }
}
function moonbitlang$core$builtin$$MyInt64$lsr(self, shift) {
  const shift$2 = shift & 63;
  return shift$2 === 0 ? self : shift$2 < 32 ? { hi: self.hi >>> shift$2 | 0, lo: self.lo >>> shift$2 | self.hi << (32 - shift$2 | 0) } : { hi: 0, lo: self.hi >>> (shift$2 - 32 | 0) | 0 };
}
function moonbitlang$core$builtin$$Eq$op_equal$339$(self, other) {
  return self.hi === other.hi && self.lo === other.lo;
}
function moonbitlang$core$builtin$$Neg$op_neg$232$(self) {
  return moonbitlang$core$builtin$$Neg$op_neg$339$(self);
}
function moonbitlang$core$builtin$$Add$op_add$232$(self, other) {
  return moonbitlang$core$builtin$$Add$op_add$339$(self, other);
}
function moonbitlang$core$builtin$$Sub$op_sub$232$(self, other) {
  return moonbitlang$core$builtin$$Sub$op_sub$339$(self, other);
}
function moonbitlang$core$builtin$$Mul$op_mul$232$(self, other) {
  return moonbitlang$core$builtin$$Mul$op_mul$339$(self, other);
}
function moonbitlang$core$builtin$$Div$op_div$232$(self, other) {
  return moonbitlang$core$builtin$$Div$op_div$339$(self, other);
}
function moonbitlang$core$builtin$$BitAnd$land$232$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$land(self, other);
}
function moonbitlang$core$builtin$$BitOr$lor$232$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$lor(self, other);
}
function moonbitlang$core$builtin$$Shl$op_shl$232$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$lsl(self, other);
}
function moonbitlang$core$builtin$$Eq$op_equal$232$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$339$(self, other);
}
function moonbitlang$core$builtin$$Compare$compare$232$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$compare(self, other);
}
function moonbitlang$core$builtin$$Add$op_add$6$(self, other) {
  return moonbitlang$core$builtin$$Add$op_add$339$(self, other);
}
function moonbitlang$core$builtin$$Sub$op_sub$6$(self, other) {
  return moonbitlang$core$builtin$$Sub$op_sub$339$(self, other);
}
function moonbitlang$core$builtin$$Mul$op_mul$6$(self, other) {
  return moonbitlang$core$builtin$$Mul$op_mul$339$(self, other);
}
function moonbitlang$core$builtin$$Div$op_div$6$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$div_u(self, other);
}
function moonbitlang$core$builtin$$Compare$compare$6$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$compare_u(self, other);
}
function moonbitlang$core$builtin$$Eq$op_equal$6$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$339$(self, other);
}
function moonbitlang$core$builtin$$BitAnd$land$6$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$land(self, other);
}
function moonbitlang$core$builtin$$Shl$op_shl$6$(self, shift) {
  return moonbitlang$core$builtin$$MyInt64$lsl(self, shift);
}
function moonbitlang$core$builtin$$Shr$op_shr$6$(self, shift) {
  return moonbitlang$core$builtin$$MyInt64$lsr(self, shift);
}
function moonbitlang$core$builtin$$Show$output$312$(self, logger) {
  logger.method_0(logger.self, self);
}
function moonbitlang$core$hashset$$calc_grow_threshold(capacity) {
  return (Math.imul(capacity, 13) | 0) / 16 | 0;
}
function moonbitlang$core$hashset$$new$9$(capacity) {
  const _bind = moonbitlang$core$hashset$$calc_grow_threshold(capacity);
  const _bind$2 = $make_array_len_and_init(capacity, undefined);
  return { entries: _bind$2, size: 0, capacity: capacity, growAt: _bind };
}
function moonbitlang$core$hashset$$new$46$capacity$46$default$9$() {
  return 8;
}
function moonbitlang$core$hashset$$abs(n) {
  return n < 0 ? -n : n;
}
function moonbitlang$core$hashset$$T$index$9$(self, hash) {
  return moonbitlang$core$hashset$$abs(hash) & (self.capacity - 1 | 0);
}
function moonbitlang$core$hashset$$T$next_index$9$(self, index) {
  return index + 1 & (self.capacity - 1 | 0);
}
function moonbitlang$core$hashset$$T$add$9$(self, key) {
  if (self.capacity === 0 || self.size >= self.growAt) {
    moonbitlang$core$hashset$$T$grow$9$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  const entry = { psl: 0, hash: hash, key: key };
  let _tmp = 0;
  let _tmp$2 = moonbitlang$core$hashset$$T$index$9$(self, hash);
  let _tmp$3 = entry;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    if (_param === self.capacity) {
      $panic();
    }
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, _param$2);
    const _bind = _tmp$4[_param$2];
    if (_bind === undefined) {
      const _tmp$5 = self.entries;
      $bound_check(_tmp$5, _param$2);
      _tmp$5[_param$2] = _param$3;
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (_curr_entry.hash === _param$3.hash && _curr_entry.key === _param$3.key) {
        const _tmp$5 = self.entries;
        $bound_check(_tmp$5, _param$2);
        _tmp$5[_param$2] = _param$3;
        break;
      }
      if (_param$3.psl > _curr_entry.psl) {
        const _tmp$5 = self.entries;
        $bound_check(_tmp$5, _param$2);
        _tmp$5[_param$2] = _param$3;
        _curr_entry.psl = _curr_entry.psl + 1 | 0;
        const _tmp$6 = _param + 1 | 0;
        const _tmp$7 = moonbitlang$core$hashset$$T$next_index$9$(self, _param$2);
        _tmp = _tmp$6;
        _tmp$2 = _tmp$7;
        _tmp$3 = _curr_entry;
        continue;
      }
      _param$3.psl = _param$3.psl + 1 | 0;
      const _tmp$5 = _param + 1 | 0;
      const _tmp$6 = moonbitlang$core$hashset$$T$next_index$9$(self, _param$2);
      _tmp = _tmp$5;
      _tmp$2 = _tmp$6;
      continue;
    }
  }
}
function moonbitlang$core$hashset$$T$grow$9$(self) {
  if (self.capacity === 0) {
    self.capacity = 8;
    self.growAt = moonbitlang$core$hashset$$calc_grow_threshold(self.capacity);
    self.size = 0;
    self.entries = $make_array_len_and_init(self.capacity, undefined);
    return undefined;
  }
  const old_entries = self.entries;
  self.entries = $make_array_len_and_init(Math.imul(self.capacity, 2) | 0, undefined);
  self.capacity = Math.imul(self.capacity, 2) | 0;
  self.growAt = moonbitlang$core$hashset$$calc_grow_threshold(self.capacity);
  self.size = 0;
  const _end48 = old_entries.length;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < _end48) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        moonbitlang$core$hashset$$T$add$9$(self, _key);
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashset$$from_array$9$(arr) {
  const m = moonbitlang$core$hashset$$new$9$(moonbitlang$core$hashset$$new$46$capacity$46$default$9$());
  const _p = arr.length;
  let _tmp = 0;
  while (true) {
    const _p$2 = _tmp;
    if (_p$2 < _p) {
      const _p$3 = arr[_p$2];
      const e = _p$3;
      moonbitlang$core$hashset$$T$add$9$(m, e);
      _tmp = _p$2 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$hashset$$T$contains$9$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$74$(key);
  let _tmp = 0;
  let _tmp$2 = moonbitlang$core$hashset$$T$index$9$(self, hash);
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    if (i < self.capacity) {
      const _tmp$3 = self.entries;
      $bound_check(_tmp$3, idx);
      const _bind = _tmp$3[idx];
      if (_bind === undefined) {
        return false;
      } else {
        const _Some = _bind;
        const _entry = _Some;
        if (_entry.hash === hash && _entry.key === key) {
          return true;
        }
        if (i > _entry.psl) {
          return false;
        }
      }
      const _tmp$4 = i + 1 | 0;
      const _tmp$5 = moonbitlang$core$hashset$$T$next_index$9$(self, idx);
      _tmp = _tmp$4;
      _tmp$2 = _tmp$5;
      continue;
    } else {
      break;
    }
  }
  return false;
}
function moonbitlang$core$deque$$new$283$(capacity) {
  return { buf: new Array(capacity), len: 0, head: 0, tail: 0 };
}
function moonbitlang$core$deque$$new$289$(capacity) {
  return { buf: new Array(capacity), len: 0, head: 0, tail: 0 };
}
function moonbitlang$core$deque$$new$46$capacity$46$default$283$() {
  return 0;
}
function moonbitlang$core$deque$$new$46$capacity$46$default$289$() {
  return 0;
}
function moonbitlang$core$deque$$T$is_empty$289$(self) {
  return self.len === 0;
}
function moonbitlang$core$deque$$T$iter$289$(self) {
  return moonbitlang$core$builtin$$Iter$new$289$((yield_) => {
    if (!moonbitlang$core$deque$$T$is_empty$289$(self)) {
      const _head = self.head;
      const _buf = self.buf;
      const _len = self.len;
      const cap = moonbitlang$core$builtin$$UninitializedArray$length$289$(_buf);
      const head_len = cap - _head | 0;
      if (head_len >= _len) {
        const _end79 = _head + _len | 0;
        let _tmp = _head;
        while (true) {
          const i = _tmp;
          if (i < _end79) {
            $bound_check(_buf, i);
            const _bind = yield_(_buf[i]);
            if (_bind === 1) {
            } else {
              return 0;
            }
            _tmp = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      } else {
        let _tmp = _head;
        while (true) {
          const i = _tmp;
          if (i < cap) {
            $bound_check(_buf, i);
            const _bind = yield_(_buf[i]);
            if (_bind === 1) {
            } else {
              return 0;
            }
            _tmp = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _end89 = _len - head_len | 0;
        let _tmp$2 = 0;
        while (true) {
          const i = _tmp$2;
          if (i < _end89) {
            $bound_check(_buf, i);
            const _bind = yield_(_buf[i]);
            if (_bind === 1) {
            } else {
              return 0;
            }
            _tmp$2 = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      }
      return 1;
    } else {
      return 1;
    }
  });
}
function moonbitlang$core$deque$$T$iter2$289$(self) {
  return moonbitlang$core$builtin$$Iter2$new$294$((yield_) => {
    if (!moonbitlang$core$deque$$T$is_empty$289$(self)) {
      const _head = self.head;
      const _buf = self.buf;
      const _len = self.len;
      const cap = moonbitlang$core$builtin$$UninitializedArray$length$289$(_buf);
      const head_len = cap - _head | 0;
      let j = 0;
      if (head_len >= _len) {
        const _end57 = _head + _len | 0;
        let _tmp = _head;
        while (true) {
          const i = _tmp;
          if (i < _end57) {
            const _tmp$2 = j;
            $bound_check(_buf, i);
            const _bind = yield_(_tmp$2, _buf[i]);
            if (_bind === 1) {
              j = j + 1 | 0;
            } else {
              return 0;
            }
            _tmp = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      } else {
        let _tmp = _head;
        while (true) {
          const i = _tmp;
          if (i < cap) {
            const _tmp$2 = j;
            $bound_check(_buf, i);
            const _bind = yield_(_tmp$2, _buf[i]);
            if (_bind === 1) {
              j = j + 1 | 0;
            } else {
              return 0;
            }
            _tmp = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _end67 = _len - head_len | 0;
        let _tmp$2 = 0;
        while (true) {
          const i = _tmp$2;
          if (i < _end67) {
            const _tmp$3 = j;
            $bound_check(_buf, i);
            const _bind = yield_(_tmp$3, _buf[i]);
            if (_bind === 1) {
              j = j + 1 | 0;
            } else {
              return 0;
            }
            _tmp$2 = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      }
      return 1;
    } else {
      return 1;
    }
  });
}
function moonbitlang$core$deque$$T$copy$289$(self) {
  const len = self.len;
  const deq = { buf: new Array(len), len: len, head: 0, tail: len - 1 | 0 };
  const _bind = moonbitlang$core$deque$$T$iter2$289$(self);
  _bind((i, x) => {
    const _tmp = deq.buf;
    $bound_check(_tmp, i);
    _tmp[i] = x;
    return 1;
  });
  return deq;
}
function moonbitlang$core$deque$$T$length$283$(self) {
  return self.len;
}
function moonbitlang$core$deque$$T$length$289$(self) {
  return self.len;
}
function moonbitlang$core$deque$$T$realloc$283$(self) {
  const old_cap = self.len;
  const new_cap = old_cap === 0 ? 8 : Math.imul(old_cap, 2) | 0;
  const new_buf = new Array(new_cap);
  if (old_cap > 0) {
    if (self.tail >= self.head) {
      let _tmp = self.head;
      let _tmp$2 = 0;
      while (true) {
        const i = _tmp;
        const j = _tmp$2;
        if (i <= self.tail) {
          const _tmp$3 = self.buf;
          $bound_check(_tmp$3, i);
          $bound_check(new_buf, j);
          new_buf[j] = _tmp$3[i];
          const _tmp$4 = i + 1 | 0;
          const _tmp$5 = j + 1 | 0;
          _tmp = _tmp$4;
          _tmp$2 = _tmp$5;
          continue;
        } else {
          break;
        }
      }
    } else {
      let j = 0;
      let _tmp = self.head;
      while (true) {
        const i = _tmp;
        if (i < moonbitlang$core$builtin$$UninitializedArray$length$283$(self.buf)) {
          const _tmp$2 = j;
          const _tmp$3 = self.buf;
          $bound_check(_tmp$3, i);
          $bound_check(new_buf, _tmp$2);
          new_buf[_tmp$2] = _tmp$3[i];
          j = j + 1 | 0;
          _tmp = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      let _tmp$2 = 0;
      while (true) {
        const i = _tmp$2;
        if (i <= self.tail) {
          const _tmp$3 = j;
          const _tmp$4 = self.buf;
          $bound_check(_tmp$4, i);
          $bound_check(new_buf, _tmp$3);
          new_buf[_tmp$3] = _tmp$4[i];
          j = j + 1 | 0;
          _tmp$2 = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    }
    self.tail = self.len - 1 | 0;
  } else {
    self.tail = 0;
  }
  self.head = 0;
  self.buf = new_buf;
}
function moonbitlang$core$deque$$T$realloc$289$(self) {
  const old_cap = self.len;
  const new_cap = old_cap === 0 ? 8 : Math.imul(old_cap, 2) | 0;
  const new_buf = new Array(new_cap);
  if (old_cap > 0) {
    if (self.tail >= self.head) {
      let _tmp = self.head;
      let _tmp$2 = 0;
      while (true) {
        const i = _tmp;
        const j = _tmp$2;
        if (i <= self.tail) {
          const _tmp$3 = self.buf;
          $bound_check(_tmp$3, i);
          $bound_check(new_buf, j);
          new_buf[j] = _tmp$3[i];
          const _tmp$4 = i + 1 | 0;
          const _tmp$5 = j + 1 | 0;
          _tmp = _tmp$4;
          _tmp$2 = _tmp$5;
          continue;
        } else {
          break;
        }
      }
    } else {
      let j = 0;
      let _tmp = self.head;
      while (true) {
        const i = _tmp;
        if (i < moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf)) {
          const _tmp$2 = j;
          const _tmp$3 = self.buf;
          $bound_check(_tmp$3, i);
          $bound_check(new_buf, _tmp$2);
          new_buf[_tmp$2] = _tmp$3[i];
          j = j + 1 | 0;
          _tmp = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      let _tmp$2 = 0;
      while (true) {
        const i = _tmp$2;
        if (i <= self.tail) {
          const _tmp$3 = j;
          const _tmp$4 = self.buf;
          $bound_check(_tmp$4, i);
          $bound_check(new_buf, _tmp$3);
          new_buf[_tmp$3] = _tmp$4[i];
          j = j + 1 | 0;
          _tmp$2 = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    }
    self.tail = self.len - 1 | 0;
  } else {
    self.tail = 0;
  }
  self.head = 0;
  self.buf = new_buf;
}
function moonbitlang$core$deque$$T$front$289$(self) {
  if (self.len === 0) {
    return undefined;
  } else {
    const _tmp = self.buf;
    const _tmp$2 = self.head;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  }
}
function moonbitlang$core$deque$$T$push_front$289$(self, value) {
  if (self.len === moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf)) {
    moonbitlang$core$deque$$T$realloc$289$(self);
  }
  if (self.len !== 0) {
    self.head = ((self.head + moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf) | 0) - 1 | 0) % moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf) | 0;
  }
  const _tmp = self.buf;
  const _tmp$2 = self.head;
  $bound_check(_tmp, _tmp$2);
  _tmp[_tmp$2] = value;
  self.len = self.len + 1 | 0;
}
function moonbitlang$core$deque$$T$push_back$283$(self, value) {
  if (self.len === moonbitlang$core$builtin$$UninitializedArray$length$283$(self.buf)) {
    moonbitlang$core$deque$$T$realloc$283$(self);
  }
  if (self.len !== 0) {
    self.tail = ((self.tail + moonbitlang$core$builtin$$UninitializedArray$length$283$(self.buf) | 0) + 1 | 0) % moonbitlang$core$builtin$$UninitializedArray$length$283$(self.buf) | 0;
  }
  const _tmp = self.buf;
  const _tmp$2 = self.tail;
  $bound_check(_tmp, _tmp$2);
  _tmp[_tmp$2] = value;
  self.len = self.len + 1 | 0;
}
function moonbitlang$core$deque$$T$push_back$289$(self, value) {
  if (self.len === moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf)) {
    moonbitlang$core$deque$$T$realloc$289$(self);
  }
  if (self.len !== 0) {
    self.tail = ((self.tail + moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf) | 0) + 1 | 0) % moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf) | 0;
  }
  const _tmp = self.buf;
  const _tmp$2 = self.tail;
  $bound_check(_tmp, _tmp$2);
  _tmp[_tmp$2] = value;
  self.len = self.len + 1 | 0;
}
function moonbitlang$core$deque$$T$unsafe_pop_front$289$(self) {
  const _bind = self.len;
  switch (_bind) {
    case 0: {
      moonbitlang$core$abort$$abort$12$("The deque is empty!");
      return;
    }
    case 1: {
      const _tmp = self.buf;
      const _tmp$2 = self.head;
      $bound_check(_tmp, _tmp$2);
      _tmp[_tmp$2] = null;
      self.len = self.len - 1 | 0;
      return;
    }
    default: {
      const _tmp$3 = self.buf;
      const _tmp$4 = self.head;
      $bound_check(_tmp$3, _tmp$4);
      _tmp$3[_tmp$4] = null;
      self.head = self.head < (moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf) - 1 | 0) ? self.head + 1 | 0 : 0;
      self.len = self.len - 1 | 0;
      return;
    }
  }
}
function moonbitlang$core$deque$$T$pop_front$289$(self) {
  const _bind = self.len;
  switch (_bind) {
    case 0: {
      return undefined;
    }
    case 1: {
      const _tmp = self.buf;
      const _tmp$2 = self.head;
      $bound_check(_tmp, _tmp$2);
      const origin_head = _tmp[_tmp$2];
      const _tmp$3 = self.buf;
      const _tmp$4 = self.head;
      $bound_check(_tmp$3, _tmp$4);
      _tmp$3[_tmp$4] = null;
      self.len = self.len - 1 | 0;
      return origin_head;
    }
    default: {
      const _tmp$5 = self.buf;
      const _tmp$6 = self.head;
      $bound_check(_tmp$5, _tmp$6);
      const origin_head$2 = _tmp$5[_tmp$6];
      const _tmp$7 = self.buf;
      const _tmp$8 = self.head;
      $bound_check(_tmp$7, _tmp$8);
      _tmp$7[_tmp$8] = null;
      self.head = self.head < (moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf) - 1 | 0) ? self.head + 1 | 0 : 0;
      self.len = self.len - 1 | 0;
      return origin_head$2;
    }
  }
}
function moonbitlang$core$deque$$T$op_get$283$(self, index) {
  if (index < 0 || index >= self.len) {
    const len = self.len;
    moonbitlang$core$abort$$abort$12$(`index out of bounds: Ahe len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
  if ((self.head + index | 0) < moonbitlang$core$builtin$$UninitializedArray$length$283$(self.buf)) {
    const _tmp = self.buf;
    const _tmp$2 = self.head + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    const _tmp = self.buf;
    const _tmp$2 = (self.head + index | 0) - moonbitlang$core$builtin$$UninitializedArray$length$283$(self.buf) | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  }
}
function moonbitlang$core$deque$$T$op_get$289$(self, index) {
  if (index < 0 || index >= self.len) {
    const len = self.len;
    moonbitlang$core$abort$$abort$12$(`index out of bounds: Ahe len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
  if ((self.head + index | 0) < moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf)) {
    const _tmp = self.buf;
    const _tmp$2 = self.head + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    const _tmp = self.buf;
    const _tmp$2 = (self.head + index | 0) - moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf) | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  }
}
function moonbitlang$core$deque$$T$op_set$289$(self, index, value) {
  if (index < 0 || index >= self.len) {
    const len = self.len;
    moonbitlang$core$abort$$abort$12$(`index out of bounds: Ahe len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$7$(len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$7$(index)}`);
  }
  if ((self.head + index | 0) < moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf)) {
    const _tmp = self.buf;
    const _tmp$2 = self.head + index | 0;
    $bound_check(_tmp, _tmp$2);
    _tmp[_tmp$2] = value;
    return;
  } else {
    const _tmp = self.buf;
    const _tmp$2 = (self.head + index | 0) - moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf) | 0;
    $bound_check(_tmp, _tmp$2);
    _tmp[_tmp$2] = value;
    return;
  }
}
function moonbitlang$core$deque$$T$as_views$289$(self) {
  if (self.len !== 0) {
    const _buf = self.buf;
    const _head = self.head;
    const _len = self.len;
    const cap = moonbitlang$core$builtin$$UninitializedArray$length$289$(_buf);
    const head_len = cap - _head | 0;
    if (head_len >= _len) {
      const _tmp = moonbitlang$core$builtin$$UninitializedArray$op_as_view$289$(_buf, _head, _head + _len | 0);
      const _bind = [];
      return { _0: _tmp, _1: { buf: _bind, start: 0, len: _bind.length } };
    } else {
      return { _0: moonbitlang$core$builtin$$UninitializedArray$op_as_view$289$(_buf, _head, cap), _1: moonbitlang$core$builtin$$UninitializedArray$op_as_view$289$(_buf, moonbitlang$core$builtin$$UninitializedArray$op_as_view$46$start$46$default$289$(), _len - head_len | 0) };
    }
  } else {
    const _bind = [];
    const _tmp = { buf: _bind, start: 0, len: _bind.length };
    const _bind$2 = [];
    return { _0: _tmp, _1: { buf: _bind$2, start: 0, len: _bind$2.length } };
  }
}
function moonbitlang$core$deque$$T$clear$289$(self) {
  const _head = self.head;
  const _buf = self.buf;
  const _len = self.len;
  const cap = moonbitlang$core$builtin$$UninitializedArray$length$289$(_buf);
  const head_len = cap - _head | 0;
  if (head_len >= _len) {
    const _end209 = _head + _len | 0;
    let _tmp = _head;
    while (true) {
      const i = _tmp;
      if (i < _end209) {
        $bound_check(_buf, i);
        _buf[i] = null;
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  } else {
    let _tmp = _head;
    while (true) {
      const i = _tmp;
      if (i < cap) {
        $bound_check(_buf, i);
        _buf[i] = null;
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _end219 = _len - head_len | 0;
    let _tmp$2 = 0;
    while (true) {
      const i = _tmp$2;
      if (i < _end219) {
        $bound_check(_buf, i);
        _buf[i] = null;
        _tmp$2 = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  }
  self.len = 0;
  self.head = 0;
  self.tail = 0;
}
function moonbitlang$core$deque$$T$truncate$289$(self, len) {
  if (len >= 0 && len < self.len) {
    if (len === 0) {
      moonbitlang$core$deque$$T$clear$289$(self);
      return undefined;
    }
    const _head = self.head;
    const _buf = self.buf;
    const _bind = moonbitlang$core$deque$$T$as_views$289$(self);
    const _front = _bind._0;
    const _back = _bind._1;
    if (moonbitlang$core$array$$ArrayView$length$289$(_front) < len) {
      self.len = len;
      const start = len - moonbitlang$core$array$$ArrayView$length$289$(_front) | 0;
      self.tail = start - 1 | 0;
      const _end139 = moonbitlang$core$array$$ArrayView$length$289$(_back);
      let _tmp = start;
      while (true) {
        const i = _tmp;
        if (i < _end139) {
          $bound_check(_buf, i);
          _buf[i] = null;
          _tmp = i + 1 | 0;
          continue;
        } else {
          return;
        }
      }
    } else {
      self.len = len;
      const start = _head + len | 0;
      self.tail = start - 1 | 0;
      const _end145 = moonbitlang$core$builtin$$UninitializedArray$length$289$(self.buf);
      let _tmp = start;
      while (true) {
        const i = _tmp;
        if (i < _end145) {
          $bound_check(_buf, i);
          _buf[i] = null;
          _tmp = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const _end150 = moonbitlang$core$array$$ArrayView$length$289$(_back);
      let _tmp$2 = 0;
      while (true) {
        const i = _tmp$2;
        if (i < _end150) {
          $bound_check(_buf, i);
          _buf[i] = null;
          _tmp$2 = i + 1 | 0;
          continue;
        } else {
          return;
        }
      }
    }
  } else {
    return;
  }
}
function moonbitlang$core$deque$$T$retain$289$(self, f) {
  if (!moonbitlang$core$deque$$T$is_empty$289$(self)) {
    const _head = self.head;
    const _buf = self.buf;
    const cap = moonbitlang$core$builtin$$UninitializedArray$length$289$(_buf);
    const head_len = cap - _head | 0;
    let idx = _head;
    const _bind = moonbitlang$core$deque$$T$as_views$289$(self);
    const _front = _bind._0;
    const _back = _bind._1;
    const _len = moonbitlang$core$array$$ArrayView$length$289$(_front);
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const cur = _front.buf[_front.start + _i | 0];
        if (f(cur)) {
          const _tmp$2 = idx;
          $bound_check(_buf, _tmp$2);
          _buf[_tmp$2] = cur;
          idx = idx + 1 | 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    if (moonbitlang$core$array$$ArrayView$length$289$(_back) === 0) {
      moonbitlang$core$deque$$T$truncate$289$(self, idx - _head | 0);
      return undefined;
    }
    const _len$2 = moonbitlang$core$array$$ArrayView$length$289$(_back);
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len$2) {
        const cur = _back.buf[_back.start + _i | 0];
        if (idx === cap) {
          idx = 0;
        }
        if (f(cur)) {
          const _tmp$3 = idx;
          $bound_check(_buf, _tmp$3);
          _buf[_tmp$3] = cur;
          idx = idx + 1 | 0;
        }
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    if (idx <= (self.len - head_len | 0)) {
      moonbitlang$core$deque$$T$truncate$289$(self, idx + head_len | 0);
      return;
    } else {
      moonbitlang$core$deque$$T$truncate$289$(self, idx - _head | 0);
      return;
    }
  } else {
    return;
  }
}
function moonbitlang$core$deque$$T$to_array$283$(self) {
  if (moonbitlang$core$deque$$T$length$283$(self) === 0) {
    return [];
  } else {
    const xs = moonbitlang$core$array$$Array$make$283$(moonbitlang$core$deque$$T$length$283$(self), moonbitlang$core$deque$$T$op_get$283$(self, 0));
    const _end20 = moonbitlang$core$deque$$T$length$283$(self);
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < _end20) {
        moonbitlang$core$array$$Array$op_set$283$(xs, i, moonbitlang$core$deque$$T$op_get$283$(self, i));
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return xs;
  }
}
function moonbitlang$core$builtin$$Show$output$327$(_x_579, _x_580) {
  const _JsonDecodeError = _x_579;
  const _$42$err_payload_581 = _JsonDecodeError._0;
  _x_580.method_0(_x_580.self, "JsonDecodeError(");
  const _$42$x0_582 = _$42$err_payload_581._0;
  const _$42$x1_583 = _$42$err_payload_581._1;
  _x_580.method_0(_x_580.self, "(");
  moonbitlang$core$builtin$$Logger$write_object$230$(_x_580, _$42$x0_582);
  _x_580.method_0(_x_580.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_580, _$42$x1_583);
  _x_580.method_0(_x_580.self, ")");
  _x_580.method_0(_x_580.self, ")");
}
function moonbitlang$core$json$$offset_to_position(input, offset) {
  let line = 1;
  let column = 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < offset) {
      if (input.charCodeAt(i) === 10) {
        line = line + 1 | 0;
        column = 0;
      } else {
        column = column + 1 | 0;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { line: line, column: column };
}
function moonbitlang$core$json$$ParseContext$invalid_char$17$(ctx, shift) {
  const offset = ctx.offset + shift | 0;
  const _tmp = ctx.input;
  return new Result$Err$35$(new Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidChar(moonbitlang$core$json$$offset_to_position(ctx.input, offset), _tmp.charCodeAt(offset)));
}
function moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, shift) {
  const offset = ctx.offset + shift | 0;
  const _tmp = ctx.input;
  return new Result$Err$36$(new Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidChar(moonbitlang$core$json$$offset_to_position(ctx.input, offset), _tmp.charCodeAt(offset)));
}
function moonbitlang$core$json$$ParseContext$invalid_char$73$(ctx, shift) {
  const offset = ctx.offset + shift | 0;
  const _tmp = ctx.input;
  return new Result$Err$37$(new Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidChar(moonbitlang$core$json$$offset_to_position(ctx.input, offset), _tmp.charCodeAt(offset)));
}
function moonbitlang$core$json$$ParseContext$invalid_char$340$(ctx, shift) {
  const offset = ctx.offset + shift | 0;
  const _tmp = ctx.input;
  return new Result$Err$38$(new Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidChar(moonbitlang$core$json$$offset_to_position(ctx.input, offset), _tmp.charCodeAt(offset)));
}
function moonbitlang$core$json$$ParseContext$invalid_char$46$shift$46$default$17$() {
  return 0;
}
function moonbitlang$core$json$$ParseContext$invalid_char$46$shift$46$default$12$() {
  return 0;
}
function moonbitlang$core$json$$ParseContext$invalid_char$46$shift$46$default$73$() {
  return 0;
}
function moonbitlang$core$json$$ParseContext$read_char(ctx) {
  if (ctx.offset < ctx.end_offset) {
    const _tmp = ctx.input;
    const _tmp$2 = ctx.offset;
    const c1 = _tmp.charCodeAt(_tmp$2);
    ctx.offset = ctx.offset + 1 | 0;
    if (c1 >= 55296 && c1 <= 56319) {
      if (ctx.offset < ctx.end_offset) {
        const _tmp$3 = ctx.input;
        const _tmp$4 = ctx.offset;
        const c2 = _tmp$3.charCodeAt(_tmp$4);
        if (c2 >= 56320 && c2 <= 57343) {
          ctx.offset = ctx.offset + 1 | 0;
          const c3 = ((c1 << 10) + c2 | 0) - 56613888 | 0;
          return c3;
        }
      }
    }
    return c1;
  } else {
    return -1;
  }
}
function moonbitlang$core$json$$ParseContext$lex_hex_digits(ctx, n) {
  let r = 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < n) {
      const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
      if (_bind === -1) {
        return new Result$Err$39$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
      } else {
        const _Some = _bind;
        const _c = _Some;
        if (_c >= 65) {
          const d = ((_c & ~32) - 65 | 0) + 10 | 0;
          if (d > 15) {
            const _bind$2 = moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1);
            if (_bind$2.$tag === 1) {
              const _ok = _bind$2;
              _ok._0;
            } else {
              return _bind$2;
            }
          }
          r = r << 4 | d;
        } else {
          if (_c >= 48) {
            const d = _c - 48 | 0;
            if (d > 9) {
              const _bind$2 = moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1);
              if (_bind$2.$tag === 1) {
                const _ok = _bind$2;
                _ok._0;
              } else {
                return _bind$2;
              }
            }
            r = r << 4 | d;
          } else {
            const _bind$2 = moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1);
            if (_bind$2.$tag === 1) {
              const _ok = _bind$2;
              _ok._0;
            } else {
              return _bind$2;
            }
          }
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$39$(r);
}
function moonbitlang$core$json$$lex_string$46$flush$124$575(_env, end) {
  const ctx = _env._2;
  const buf = _env._1;
  const start = _env._0;
  if (start.val > 0 && end > start.val) {
    moonbitlang$core$builtin$$Logger$write_substring$71$(buf, ctx.input, start.val, end - start.val | 0);
    return;
  } else {
    return;
  }
}
function moonbitlang$core$json$$ParseContext$lex_string(ctx) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  const start = { val: ctx.offset };
  const _env = { _0: start, _1: buf, _2: ctx };
  _L: while (true) {
    _L$2: {
      _L$3: {
        _L$4: {
          const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
          if (_bind === -1) {
            return new Result$Err$40$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
          } else {
            const _Some = _bind;
            const _x = _Some;
            switch (_x) {
              case 34: {
                moonbitlang$core$json$$lex_string$46$flush$124$575(_env, ctx.offset - 1 | 0);
                break _L;
              }
              case 10: {
                break _L$4;
              }
              case 13: {
                break _L$4;
              }
              case 92: {
                moonbitlang$core$json$$lex_string$46$flush$124$575(_env, ctx.offset - 1 | 0);
                const _bind$2 = moonbitlang$core$json$$ParseContext$read_char(ctx);
                if (_bind$2 === -1) {
                  return new Result$Err$40$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
                } else {
                  const _Some$2 = _bind$2;
                  const _x$2 = _Some$2;
                  switch (_x$2) {
                    case 98: {
                      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 8);
                      break;
                    }
                    case 102: {
                      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 12);
                      break;
                    }
                    case 110: {
                      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 10);
                      break;
                    }
                    case 114: {
                      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 13);
                      break;
                    }
                    case 116: {
                      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 9);
                      break;
                    }
                    case 34: {
                      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 34);
                      break;
                    }
                    case 92: {
                      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 92);
                      break;
                    }
                    case 47: {
                      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 47);
                      break;
                    }
                    case 117: {
                      const _bind$3 = moonbitlang$core$json$$ParseContext$lex_hex_digits(ctx, 4);
                      let c;
                      if (_bind$3.$tag === 1) {
                        const _ok = _bind$3;
                        c = _ok._0;
                      } else {
                        return _bind$3;
                      }
                      moonbitlang$core$builtin$$Logger$write_char$71$(buf, c);
                      break;
                    }
                    default: {
                      const _bind$4 = moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1);
                      if (_bind$4.$tag === 1) {
                        const _ok = _bind$4;
                        _ok._0;
                      } else {
                        return _bind$4;
                      }
                    }
                  }
                }
                start.val = ctx.offset;
                break;
              }
              default: {
                if (_x < 32) {
                  const _bind$3 = moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1);
                  if (_bind$3.$tag === 1) {
                    const _ok = _bind$3;
                    _ok._0;
                  } else {
                    return _bind$3;
                  }
                } else {
                  break _L$2;
                }
              }
            }
          }
          break _L$3;
        }
        const _bind = moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1);
        if (_bind.$tag === 1) {
          const _ok = _bind;
          _ok._0;
        } else {
          return _bind;
        }
      }
      break _L$2;
    }
    continue;
  }
  return new Result$Ok$40$(moonbitlang$core$builtin$$StringBuilder$to_string(buf));
}
function moonbitlang$core$builtin$$Show$output$324$(self, logger) {
  switch (self.$tag) {
    case 4: {
      const _InvalidChar = self;
      const _x = _InvalidChar._0;
      const _line = _x.line;
      const _column = _x.column;
      const _c = _InvalidChar._1;
      logger.method_0(logger.self, "Invalid character ");
      logger.method_0(logger.self, moonbitlang$core$builtin$$repr$10$(_c));
      logger.method_0(logger.self, " at line ");
      moonbitlang$core$builtin$$Logger$write_object$7$(logger, _line);
      logger.method_0(logger.self, ", column ");
      moonbitlang$core$builtin$$Logger$write_object$7$(logger, _column);
      return;
    }
    case 3: {
      logger.method_0(logger.self, "Unexpected end of file");
      return;
    }
    case 2: {
      const _InvalidNumber = self;
      const _x$2 = _InvalidNumber._0;
      const _line$2 = _x$2.line;
      const _column$2 = _x$2.column;
      const _s = _InvalidNumber._1;
      logger.method_0(logger.self, "Invalid number ");
      logger.method_0(logger.self, _s);
      logger.method_0(logger.self, " at line ");
      moonbitlang$core$builtin$$Logger$write_object$7$(logger, _line$2);
      logger.method_0(logger.self, ", column ");
      moonbitlang$core$builtin$$Logger$write_object$7$(logger, _column$2);
      return;
    }
    default: {
      const _InvalidIdentEscape = self;
      const _x$3 = _InvalidIdentEscape._0;
      const _line$3 = _x$3.line;
      const _column$3 = _x$3.column;
      logger.method_0(logger.self, "Invalid escape sequence in identifier at line ");
      moonbitlang$core$builtin$$Logger$write_object$7$(logger, _line$3);
      logger.method_0(logger.self, ", column ");
      moonbitlang$core$builtin$$Logger$write_object$7$(logger, _column$3);
      return;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$17$(self, logger) {
  switch (self.$tag) {
    case 0: {
      logger.method_0(logger.self, "Null");
      return;
    }
    case 1: {
      logger.method_0(logger.self, "True");
      return;
    }
    case 2: {
      logger.method_0(logger.self, "False");
      return;
    }
    case 3: {
      const _Number = self;
      const _n = _Number._0;
      logger.method_0(logger.self, "Number(");
      moonbitlang$core$builtin$$Show$output$73$(_n, logger);
      logger.method_0(logger.self, ")");
      return;
    }
    case 4: {
      const _String = self;
      const _s = _String._0;
      logger.method_0(logger.self, "String(");
      moonbitlang$core$builtin$$Show$output$9$(_s, logger);
      logger.method_0(logger.self, ")");
      return;
    }
    case 5: {
      const _Array = self;
      const _a = _Array._0;
      logger.method_0(logger.self, "Array(");
      moonbitlang$core$builtin$$Show$output$290$(_a, logger);
      logger.method_0(logger.self, ")");
      return;
    }
    default: {
      const _Object = self;
      const _o = _Object._0;
      logger.method_0(logger.self, "Object(");
      moonbitlang$core$builtin$$Show$output$311$(_o, logger);
      logger.method_0(logger.self, ")");
      return;
    }
  }
}
function moonbitlang$core$json$$ParseContext$make(input) {
  return { offset: 0, input: input, end_offset: input.length };
}
function moonbitlang$core$json$$CharClass$of(array) {
  return array;
}
function moonbitlang$core$json$$CharClass$contains(self, c) {
  let _tmp = 0;
  let _tmp$2 = self.length;
  while (true) {
    const left = _tmp;
    const right = _tmp$2;
    if (left < right) {
      const middle = (left + right | 0) / 2 | 0;
      const _bind = moonbitlang$core$array$$Array$op_get$237$(self, middle);
      const _min = _bind._0;
      const _max = _bind._1;
      if (c < _min) {
        _tmp$2 = middle;
        continue;
      } else {
        if (c > _max) {
          _tmp = middle + 1 | 0;
          continue;
        } else {
          return true;
        }
      }
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$230$(self, logger) {
  switch (self.$tag) {
    case 0: {
      logger.method_0(logger.self, "$");
      return;
    }
    case 1: {
      const _Key = self;
      const _p = _Key._0;
      const _key = _Key._1;
      moonbitlang$core$builtin$$Logger$write_object$230$(logger, _p);
      logger.method_0(logger.self, ".");
      logger.method_0(logger.self, _key);
      return;
    }
    default: {
      const _Index = self;
      const _p$2 = _Index._0;
      const _index = _Index._1;
      moonbitlang$core$builtin$$Logger$write_object$230$(logger, _p$2);
      logger.method_0(logger.self, "[");
      moonbitlang$core$builtin$$Logger$write_object$7$(logger, _index);
      logger.method_0(logger.self, "]");
      return;
    }
  }
}
function moonbitlang$core$json$$ParseContext$lex_skip_whitespace(ctx) {
  _L: while (true) {
    _L$2: {
      _L$3: {
        const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
        if (_bind === -1) {
          break;
        } else {
          const _Some = _bind;
          const _x = _Some;
          switch (_x) {
            case 9: {
              break _L$3;
            }
            case 32: {
              break _L$3;
            }
            case 10: {
              break _L$3;
            }
            case 13: {
              break _L$3;
            }
            default: {
              if (_x > 127 && moonbitlang$core$json$$CharClass$contains(moonbitlang$core$json$$non_ascii_whitespace, _x)) {
                break _L$2;
              }
              ctx.offset = ctx.offset - 1 | 0;
              break _L;
            }
          }
        }
      }
      break _L$2;
    }
    continue;
  }
}
function moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, c) {
  if (ctx.offset < ctx.end_offset) {
    const _tmp = ctx.input;
    const _tmp$2 = ctx.offset;
    const c1 = _tmp.charCodeAt(_tmp$2);
    ctx.offset = ctx.offset + 1 | 0;
    return c !== c1 ? moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1) : new Result$Ok$36$(undefined);
  } else {
    return new Result$Err$36$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
  }
}
function moonbitlang$core$json$$ParseContext$lex_number_end(ctx, start, end) {
  const s = moonbitlang$core$string$$String$substring(ctx.input, start, end);
  let _try_err;
  _L: {
    const _bind = moonbitlang$core$strconv$$parse_double(s);
    let _tmp;
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _tmp = _ok._0;
    } else {
      const _err = _bind;
      const _tmp$2 = _err._0;
      _try_err = _tmp$2;
      break _L;
    }
    return new Result$Ok$37$(_tmp);
  }
  return new Result$Err$37$(new Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidNumber(moonbitlang$core$json$$offset_to_position(ctx.input, start), s));
}
function moonbitlang$core$json$$ParseContext$lex_decimal_exponent_integer(ctx, start) {
  while (true) {
    _L: {
      const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
      if (_bind === -1) {
        const _bind$2 = moonbitlang$core$json$$ParseContext$lex_number_end(ctx, start, ctx.offset);
        let _tmp;
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          _tmp = _ok._0;
        } else {
          return _bind$2;
        }
        return new Result$Ok$37$(_tmp);
      } else {
        const _Some = _bind;
        const _c = _Some;
        if (_c >= 48 && _c <= 57) {
          break _L;
        }
        ctx.offset = ctx.offset - 1 | 0;
        const _bind$2 = moonbitlang$core$json$$ParseContext$lex_number_end(ctx, start, ctx.offset);
        let _tmp;
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          _tmp = _ok._0;
        } else {
          return _bind$2;
        }
        return new Result$Ok$37$(_tmp);
      }
    }
    continue;
  }
}
function moonbitlang$core$json$$ParseContext$lex_decimal_exponent_sign(ctx, start) {
  const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
  if (_bind === -1) {
    return new Result$Err$37$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
  } else {
    const _Some = _bind;
    const _c = _Some;
    if (_c >= 48 && _c <= 57) {
      const _bind$2 = moonbitlang$core$json$$ParseContext$lex_decimal_exponent_integer(ctx, start);
      let _tmp;
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        _tmp = _ok._0;
      } else {
        return _bind$2;
      }
      return new Result$Ok$37$(_tmp);
    }
    ctx.offset = ctx.offset - 1 | 0;
    return moonbitlang$core$json$$ParseContext$invalid_char$73$(ctx, moonbitlang$core$json$$ParseContext$invalid_char$46$shift$46$default$73$());
  }
}
function moonbitlang$core$json$$ParseContext$lex_decimal_exponent(ctx, start) {
  _L: {
    const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
    if (_bind === -1) {
      return new Result$Err$37$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
    } else {
      const _Some = _bind;
      const _x = _Some;
      switch (_x) {
        case 43: {
          break _L;
        }
        case 45: {
          break _L;
        }
        default: {
          if (_x >= 48 && _x <= 57) {
            const _bind$2 = moonbitlang$core$json$$ParseContext$lex_decimal_exponent_integer(ctx, start);
            let _tmp;
            if (_bind$2.$tag === 1) {
              const _ok = _bind$2;
              _tmp = _ok._0;
            } else {
              return _bind$2;
            }
            return new Result$Ok$37$(_tmp);
          }
          ctx.offset = ctx.offset - 1 | 0;
          return moonbitlang$core$json$$ParseContext$invalid_char$73$(ctx, moonbitlang$core$json$$ParseContext$invalid_char$46$shift$46$default$73$());
        }
      }
    }
  }
  const _bind = moonbitlang$core$json$$ParseContext$lex_decimal_exponent_sign(ctx, start);
  let _tmp;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    _tmp = _ok._0;
  } else {
    return _bind;
  }
  return new Result$Ok$37$(_tmp);
}
function moonbitlang$core$json$$ParseContext$lex_decimal_fraction(ctx, start) {
  while (true) {
    _L: {
      _L$2: {
        const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
        if (_bind === -1) {
          const _bind$2 = moonbitlang$core$json$$ParseContext$lex_number_end(ctx, start, ctx.offset);
          let _tmp;
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            _tmp = _ok._0;
          } else {
            return _bind$2;
          }
          return new Result$Ok$37$(_tmp);
        } else {
          const _Some = _bind;
          const _x = _Some;
          switch (_x) {
            case 101: {
              break _L$2;
            }
            case 69: {
              break _L$2;
            }
            default: {
              if (_x >= 48 && _x <= 57) {
                break _L;
              }
              ctx.offset = ctx.offset - 1 | 0;
              const _bind$2 = moonbitlang$core$json$$ParseContext$lex_number_end(ctx, start, ctx.offset);
              let _tmp;
              if (_bind$2.$tag === 1) {
                const _ok = _bind$2;
                _tmp = _ok._0;
              } else {
                return _bind$2;
              }
              return new Result$Ok$37$(_tmp);
            }
          }
        }
      }
      const _bind = moonbitlang$core$json$$ParseContext$lex_decimal_exponent(ctx, start);
      let _tmp;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp = _ok._0;
      } else {
        return _bind;
      }
      return new Result$Ok$37$(_tmp);
    }
    continue;
  }
}
function moonbitlang$core$json$$ParseContext$lex_decimal_point(ctx, start) {
  const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
  if (_bind === -1) {
    return new Result$Err$37$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
  } else {
    const _Some = _bind;
    const _c = _Some;
    return _c >= 48 && _c <= 57 ? moonbitlang$core$json$$ParseContext$lex_decimal_fraction(ctx, start) : moonbitlang$core$json$$ParseContext$invalid_char$73$(ctx, -1);
  }
}
function moonbitlang$core$json$$ParseContext$lex_decimal_integer(ctx, start) {
  while (true) {
    _L: {
      _L$2: {
        const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
        if (_bind === -1) {
          const _bind$2 = moonbitlang$core$json$$ParseContext$lex_number_end(ctx, start, ctx.offset);
          let _tmp;
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            _tmp = _ok._0;
          } else {
            return _bind$2;
          }
          return new Result$Ok$37$(_tmp);
        } else {
          const _Some = _bind;
          const _x = _Some;
          switch (_x) {
            case 46: {
              const _bind$2 = moonbitlang$core$json$$ParseContext$lex_decimal_point(ctx, start);
              let _tmp;
              if (_bind$2.$tag === 1) {
                const _ok = _bind$2;
                _tmp = _ok._0;
              } else {
                return _bind$2;
              }
              return new Result$Ok$37$(_tmp);
            }
            case 101: {
              break _L$2;
            }
            case 69: {
              break _L$2;
            }
            default: {
              if (_x >= 48 && _x <= 57) {
                break _L;
              }
              ctx.offset = ctx.offset - 1 | 0;
              const _bind$3 = moonbitlang$core$json$$ParseContext$lex_number_end(ctx, start, ctx.offset);
              let _tmp$2;
              if (_bind$3.$tag === 1) {
                const _ok = _bind$3;
                _tmp$2 = _ok._0;
              } else {
                return _bind$3;
              }
              return new Result$Ok$37$(_tmp$2);
            }
          }
        }
      }
      const _bind = moonbitlang$core$json$$ParseContext$lex_decimal_exponent(ctx, start);
      let _tmp;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp = _ok._0;
      } else {
        return _bind;
      }
      return new Result$Ok$37$(_tmp);
    }
    continue;
  }
}
function moonbitlang$core$json$$ParseContext$lex_zero(ctx, start) {
  _L: {
    const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
    if (_bind === -1) {
      const _bind$2 = moonbitlang$core$json$$ParseContext$lex_number_end(ctx, start, ctx.offset);
      let _tmp;
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        _tmp = _ok._0;
      } else {
        return _bind$2;
      }
      return new Result$Ok$37$(_tmp);
    } else {
      const _Some = _bind;
      const _x = _Some;
      switch (_x) {
        case 46: {
          return moonbitlang$core$json$$ParseContext$lex_decimal_point(ctx, start);
        }
        case 101: {
          break _L;
        }
        case 69: {
          break _L;
        }
        default: {
          if (_x >= 48 && _x <= 57) {
            ctx.offset = ctx.offset - 1 | 0;
            const _bind$2 = moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, moonbitlang$core$json$$ParseContext$invalid_char$46$shift$46$default$12$());
            if (_bind$2.$tag === 1) {
              const _ok = _bind$2;
              _ok._0;
            } else {
              return _bind$2;
            }
          }
          ctx.offset = ctx.offset - 1 | 0;
          const _bind$2 = moonbitlang$core$json$$ParseContext$lex_number_end(ctx, start, ctx.offset);
          let _tmp;
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            _tmp = _ok._0;
          } else {
            return _bind$2;
          }
          return new Result$Ok$37$(_tmp);
        }
      }
    }
  }
  return moonbitlang$core$json$$ParseContext$lex_decimal_exponent(ctx, start);
}
function moonbitlang$core$json$$ParseContext$lex_value(ctx, allow_rbracket) {
  while (true) {
    _L: {
      _L$2: {
        _L$3: {
          const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
          if (_bind === -1) {
            return new Result$Err$38$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
          } else {
            const _Some = _bind;
            const _x = _Some;
            if (_x === 9) {
              break _L$3;
            } else {
              if (_x === 32) {
                break _L$3;
              } else {
                if (_x === 10) {
                  break _L$3;
                } else {
                  if (_x === 13) {
                    break _L$3;
                  } else {
                    if (_x === 123) {
                      return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$LBrace);
                    } else {
                      if (_x === 91) {
                        return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$LBracket);
                      } else {
                        if (_x === 93) {
                          if (allow_rbracket) {
                            return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$RBracket);
                          } else {
                            const _bind$2 = moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1);
                            if (_bind$2.$tag === 1) {
                              const _ok = _bind$2;
                              _ok._0;
                            } else {
                              return _bind$2;
                            }
                          }
                        } else {
                          if (_x === 110) {
                            const _bind$2 = moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, 117);
                            if (_bind$2.$tag === 1) {
                              const _ok = _bind$2;
                              _ok._0;
                            } else {
                              return _bind$2;
                            }
                            const _bind$3 = moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, 108);
                            if (_bind$3.$tag === 1) {
                              const _ok = _bind$3;
                              _ok._0;
                            } else {
                              return _bind$3;
                            }
                            const _bind$4 = moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, 108);
                            if (_bind$4.$tag === 1) {
                              const _ok = _bind$4;
                              _ok._0;
                            } else {
                              return _bind$4;
                            }
                            return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$Null);
                          } else {
                            if (_x === 116) {
                              const _bind$2 = moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, 114);
                              if (_bind$2.$tag === 1) {
                                const _ok = _bind$2;
                                _ok._0;
                              } else {
                                return _bind$2;
                              }
                              const _bind$3 = moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, 117);
                              if (_bind$3.$tag === 1) {
                                const _ok = _bind$3;
                                _ok._0;
                              } else {
                                return _bind$3;
                              }
                              const _bind$4 = moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, 101);
                              if (_bind$4.$tag === 1) {
                                const _ok = _bind$4;
                                _ok._0;
                              } else {
                                return _bind$4;
                              }
                              return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$True);
                            } else {
                              if (_x === 102) {
                                const _bind$2 = moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, 97);
                                if (_bind$2.$tag === 1) {
                                  const _ok = _bind$2;
                                  _ok._0;
                                } else {
                                  return _bind$2;
                                }
                                const _bind$3 = moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, 108);
                                if (_bind$3.$tag === 1) {
                                  const _ok = _bind$3;
                                  _ok._0;
                                } else {
                                  return _bind$3;
                                }
                                const _bind$4 = moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, 115);
                                if (_bind$4.$tag === 1) {
                                  const _ok = _bind$4;
                                  _ok._0;
                                } else {
                                  return _bind$4;
                                }
                                const _bind$5 = moonbitlang$core$json$$ParseContext$expect_ascii_char(ctx, 101);
                                if (_bind$5.$tag === 1) {
                                  const _ok = _bind$5;
                                  _ok._0;
                                } else {
                                  return _bind$5;
                                }
                                return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$False);
                              } else {
                                if (_x === 45) {
                                  const _bind$2 = moonbitlang$core$json$$ParseContext$read_char(ctx);
                                  if (_bind$2 === -1) {
                                    return new Result$Err$38$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
                                  } else {
                                    const _Some$2 = _bind$2;
                                    const _x$2 = _Some$2;
                                    if (_x$2 === 48) {
                                      const _bind$3 = moonbitlang$core$json$$ParseContext$lex_zero(ctx, ctx.offset - 2 | 0);
                                      let n;
                                      if (_bind$3.$tag === 1) {
                                        const _ok = _bind$3;
                                        n = _ok._0;
                                      } else {
                                        return _bind$3;
                                      }
                                      return new Result$Ok$38$(new $64$moonbitlang$47$core$47$json$46$Token$Number(n));
                                    } else {
                                      if (_x$2 >= 49 && _x$2 <= 57) {
                                        const _bind$3 = moonbitlang$core$json$$ParseContext$lex_decimal_integer(ctx, ctx.offset - 2 | 0);
                                        let n;
                                        if (_bind$3.$tag === 1) {
                                          const _ok = _bind$3;
                                          n = _ok._0;
                                        } else {
                                          return _bind$3;
                                        }
                                        return new Result$Ok$38$(new $64$moonbitlang$47$core$47$json$46$Token$Number(n));
                                      }
                                      const _bind$3 = moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1);
                                      if (_bind$3.$tag === 1) {
                                        const _ok = _bind$3;
                                        _ok._0;
                                      } else {
                                        return _bind$3;
                                      }
                                    }
                                  }
                                } else {
                                  if (_x === 48) {
                                    const _bind$2 = moonbitlang$core$json$$ParseContext$lex_zero(ctx, ctx.offset - 1 | 0);
                                    let n;
                                    if (_bind$2.$tag === 1) {
                                      const _ok = _bind$2;
                                      n = _ok._0;
                                    } else {
                                      return _bind$2;
                                    }
                                    return new Result$Ok$38$(new $64$moonbitlang$47$core$47$json$46$Token$Number(n));
                                  } else {
                                    if (_x >= 49 && _x <= 57) {
                                      const _bind$2 = moonbitlang$core$json$$ParseContext$lex_decimal_integer(ctx, ctx.offset - 1 | 0);
                                      let n;
                                      if (_bind$2.$tag === 1) {
                                        const _ok = _bind$2;
                                        n = _ok._0;
                                      } else {
                                        return _bind$2;
                                      }
                                      return new Result$Ok$38$(new $64$moonbitlang$47$core$47$json$46$Token$Number(n));
                                    } else {
                                      if (_x === 34) {
                                        const _bind$2 = moonbitlang$core$json$$ParseContext$lex_string(ctx);
                                        let s;
                                        if (_bind$2.$tag === 1) {
                                          const _ok = _bind$2;
                                          s = _ok._0;
                                        } else {
                                          return _bind$2;
                                        }
                                        return new Result$Ok$38$(new $64$moonbitlang$47$core$47$json$46$Token$String(s));
                                      } else {
                                        if (_x > 127 && moonbitlang$core$json$$CharClass$contains(moonbitlang$core$json$$non_ascii_whitespace, _x)) {
                                          break _L;
                                        }
                                        const _bind$2 = moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1);
                                        if (_bind$2.$tag === 1) {
                                          const _ok = _bind$2;
                                          _ok._0;
                                        } else {
                                          return _bind$2;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          break _L$2;
        }
        break _L;
      }
      break _L;
    }
    continue;
  }
}
function moonbitlang$core$json$$ParseContext$lex_after_array_value(ctx) {
  moonbitlang$core$json$$ParseContext$lex_skip_whitespace(ctx);
  const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
  if (_bind === -1) {
    return new Result$Err$38$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
  } else {
    const _Some = _bind;
    const _x = _Some;
    switch (_x) {
      case 93: {
        return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$RBracket);
      }
      case 44: {
        return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$Comma);
      }
      default: {
        return moonbitlang$core$json$$ParseContext$invalid_char$340$(ctx, -1);
      }
    }
  }
}
function moonbitlang$core$json$$ParseContext$lex_after_object_value(ctx) {
  moonbitlang$core$json$$ParseContext$lex_skip_whitespace(ctx);
  const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
  if (_bind === -1) {
    return new Result$Err$38$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
  } else {
    const _Some = _bind;
    const _x = _Some;
    switch (_x) {
      case 125: {
        return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$RBrace);
      }
      case 44: {
        return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$Comma);
      }
      default: {
        return moonbitlang$core$json$$ParseContext$invalid_char$340$(ctx, -1);
      }
    }
  }
}
function moonbitlang$core$json$$ParseContext$lex_after_property_name(ctx) {
  moonbitlang$core$json$$ParseContext$lex_skip_whitespace(ctx);
  const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
  if (_bind === -1) {
    return new Result$Err$36$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x === 58) {
      return new Result$Ok$36$(undefined);
    } else {
      return moonbitlang$core$json$$ParseContext$invalid_char$12$(ctx, -1);
    }
  }
}
function moonbitlang$core$json$$ParseContext$lex_property_name(ctx) {
  moonbitlang$core$json$$ParseContext$lex_skip_whitespace(ctx);
  const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
  if (_bind === -1) {
    return new Result$Err$38$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
  } else {
    const _Some = _bind;
    const _x = _Some;
    switch (_x) {
      case 125: {
        return new Result$Ok$38$($64$moonbitlang$47$core$47$json$46$Token$RBrace);
      }
      case 34: {
        const _bind$2 = moonbitlang$core$json$$ParseContext$lex_string(ctx);
        let s;
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          s = _ok._0;
        } else {
          return _bind$2;
        }
        return new Result$Ok$38$(new $64$moonbitlang$47$core$47$json$46$Token$String(s));
      }
      default: {
        return moonbitlang$core$json$$ParseContext$invalid_char$340$(ctx, -1);
      }
    }
  }
}
function moonbitlang$core$json$$ParseContext$lex_property_name2(ctx) {
  moonbitlang$core$json$$ParseContext$lex_skip_whitespace(ctx);
  const _bind = moonbitlang$core$json$$ParseContext$read_char(ctx);
  if (_bind === -1) {
    return new Result$Err$38$(Error$moonbitlang$47$core$47$json$46$ParseError$46$InvalidEof);
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x === 34) {
      const _bind$2 = moonbitlang$core$json$$ParseContext$lex_string(ctx);
      let s;
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        s = _ok._0;
      } else {
        return _bind$2;
      }
      return new Result$Ok$38$(new $64$moonbitlang$47$core$47$json$46$Token$String(s));
    } else {
      return moonbitlang$core$json$$ParseContext$invalid_char$340$(ctx, -1);
    }
  }
}
function moonbitlang$core$json$$ParseContext$parse_value(ctx) {
  const _bind = moonbitlang$core$json$$ParseContext$lex_value(ctx, false);
  let tok;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    tok = _ok._0;
  } else {
    return _bind;
  }
  return moonbitlang$core$json$$ParseContext$parse_value2(ctx, tok);
}
function moonbitlang$core$json$$ParseContext$parse_value2(ctx, tok) {
  _L: {
    switch (tok.$tag) {
      case 0: {
        return new Result$Ok$35$(moonbitlang$core$json$$Json$null());
      }
      case 1: {
        return new Result$Ok$35$(moonbitlang$core$json$$Json$boolean(true));
      }
      case 2: {
        return new Result$Ok$35$(moonbitlang$core$json$$Json$boolean(false));
      }
      case 3: {
        const _Number = tok;
        const _n = _Number._0;
        return new Result$Ok$35$(moonbitlang$core$json$$Json$number(_n));
      }
      case 4: {
        const _String = tok;
        const _s = _String._0;
        return new Result$Ok$35$(moonbitlang$core$json$$Json$string(_s));
      }
      case 5: {
        return moonbitlang$core$json$$ParseContext$parse_object(ctx);
      }
      case 7: {
        return moonbitlang$core$json$$ParseContext$parse_array(ctx);
      }
      case 8: {
        break _L;
      }
      case 6: {
        break _L;
      }
      default: {
        break _L;
      }
    }
  }
  return new Result$Ok$35$(moonbitlang$core$abort$$abort$17$("unreachable"));
}
function moonbitlang$core$json$$ParseContext$parse_array(ctx) {
  const vec = [];
  let _tmp;
  const _bind = moonbitlang$core$json$$ParseContext$lex_value(ctx, true);
  let _tmp$2;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    _tmp$2 = _ok._0;
  } else {
    return _bind;
  }
  let _tmp$3 = _tmp$2;
  _L: while (true) {
    const _param = _tmp$3;
    if (_param.$tag === 8) {
      _tmp = moonbitlang$core$json$$Json$array(vec);
      break;
    } else {
      const _bind$2 = moonbitlang$core$json$$ParseContext$parse_value2(ctx, _param);
      let _tmp$4;
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        _tmp$4 = _ok._0;
      } else {
        return _bind$2;
      }
      moonbitlang$core$array$$Array$push$17$(vec, _tmp$4);
      const _bind$3 = moonbitlang$core$json$$ParseContext$lex_after_array_value(ctx);
      let tok2;
      if (_bind$3.$tag === 1) {
        const _ok = _bind$3;
        tok2 = _ok._0;
      } else {
        return _bind$3;
      }
      switch (tok2.$tag) {
        case 9: {
          const _bind$4 = moonbitlang$core$json$$ParseContext$lex_value(ctx, false);
          let _tmp$5;
          if (_bind$4.$tag === 1) {
            const _ok = _bind$4;
            _tmp$5 = _ok._0;
          } else {
            return _bind$4;
          }
          _tmp$3 = _tmp$5;
          continue _L;
        }
        case 8: {
          _tmp = moonbitlang$core$json$$Json$array(vec);
          break _L;
        }
        default: {
          _tmp = moonbitlang$core$abort$$abort$17$("unreachable");
          break _L;
        }
      }
    }
  }
  return new Result$Ok$35$(_tmp);
}
function moonbitlang$core$json$$ParseContext$parse_object(ctx) {
  const map = moonbitlang$core$builtin$$Map$new$8$(moonbitlang$core$builtin$$Map$new$46$capacity$46$default$8$());
  let _tmp;
  const _bind = moonbitlang$core$json$$ParseContext$lex_property_name(ctx);
  let _tmp$2;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    _tmp$2 = _ok._0;
  } else {
    return _bind;
  }
  let _tmp$3 = _tmp$2;
  _L: while (true) {
    const _param = _tmp$3;
    switch (_param.$tag) {
      case 6: {
        _tmp = moonbitlang$core$json$$Json$object(map);
        break _L;
      }
      case 4: {
        const _String = _param;
        const _name = _String._0;
        const _bind$2 = moonbitlang$core$json$$ParseContext$lex_after_property_name(ctx);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          _ok._0;
        } else {
          return _bind$2;
        }
        const _bind$3 = moonbitlang$core$json$$ParseContext$parse_value(ctx);
        let _tmp$4;
        if (_bind$3.$tag === 1) {
          const _ok = _bind$3;
          _tmp$4 = _ok._0;
        } else {
          return _bind$3;
        }
        moonbitlang$core$builtin$$Map$op_set$8$(map, _name, _tmp$4);
        const _bind$4 = moonbitlang$core$json$$ParseContext$lex_after_object_value(ctx);
        let _bind$5;
        if (_bind$4.$tag === 1) {
          const _ok = _bind$4;
          _bind$5 = _ok._0;
        } else {
          return _bind$4;
        }
        switch (_bind$5.$tag) {
          case 9: {
            const _bind$6 = moonbitlang$core$json$$ParseContext$lex_property_name2(ctx);
            let _tmp$5;
            if (_bind$6.$tag === 1) {
              const _ok = _bind$6;
              _tmp$5 = _ok._0;
            } else {
              return _bind$6;
            }
            _tmp$3 = _tmp$5;
            continue _L;
          }
          case 6: {
            _tmp = moonbitlang$core$json$$Json$object(map);
            break _L;
          }
          default: {
            _tmp = moonbitlang$core$abort$$abort$17$("unreachable");
            break _L;
          }
        }
      }
      default: {
        _tmp = moonbitlang$core$abort$$abort$17$("unreachable");
        break _L;
      }
    }
  }
  return new Result$Ok$35$(_tmp);
}
function moonbitlang$core$json$$parse(input) {
  const ctx = moonbitlang$core$json$$ParseContext$make(input);
  const _bind = moonbitlang$core$json$$ParseContext$parse_value(ctx);
  let val;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    val = _ok._0;
  } else {
    return _bind;
  }
  moonbitlang$core$json$$ParseContext$lex_skip_whitespace(ctx);
  return ctx.offset >= ctx.end_offset ? new Result$Ok$35$(val) : moonbitlang$core$json$$ParseContext$invalid_char$17$(ctx, moonbitlang$core$json$$ParseContext$invalid_char$46$shift$46$default$17$());
}
function moonbitlang$core$json$$escape$46$to_hex_digit$124$313(i) {
  return i < 10 ? 48 + i | 0 : 97 + (i - 10 | 0) | 0;
}
function moonbitlang$core$json$$escape(str, escape_slash) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(str.length);
  const _bind = moonbitlang$core$string$$String$iter(str);
  _bind((c) => {
    switch (c) {
      case 34: {
        moonbitlang$core$builtin$$Logger$write_string$71$(buf, "\\\"");
        break;
      }
      case 92: {
        moonbitlang$core$builtin$$Logger$write_string$71$(buf, "\\\\");
        break;
      }
      case 47: {
        if (escape_slash) {
          moonbitlang$core$builtin$$Logger$write_string$71$(buf, "\\/");
        } else {
          moonbitlang$core$builtin$$Logger$write_char$71$(buf, c);
        }
        break;
      }
      case 10: {
        moonbitlang$core$builtin$$Logger$write_string$71$(buf, "\\n");
        break;
      }
      case 13: {
        moonbitlang$core$builtin$$Logger$write_string$71$(buf, "\\r");
        break;
      }
      case 8: {
        moonbitlang$core$builtin$$Logger$write_string$71$(buf, "\\b");
        break;
      }
      case 9: {
        moonbitlang$core$builtin$$Logger$write_string$71$(buf, "\\t");
        break;
      }
      default: {
        const code = c;
        if (code === 12) {
          moonbitlang$core$builtin$$Logger$write_string$71$(buf, "\\f");
        } else {
          if (code < 32) {
            moonbitlang$core$builtin$$Logger$write_string$71$(buf, "\\u00");
            moonbitlang$core$builtin$$Logger$write_char$71$(buf, moonbitlang$core$json$$escape$46$to_hex_digit$124$313(code / 16 | 0));
            moonbitlang$core$builtin$$Logger$write_char$71$(buf, moonbitlang$core$json$$escape$46$to_hex_digit$124$313(code % 16 | 0));
          } else {
            moonbitlang$core$builtin$$Logger$write_char$71$(buf, c);
          }
        }
      }
    }
    return 1;
  });
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$json$$indent_str(level, indent) {
  return indent === 0 ? "" : `\n${moonbitlang$core$string$$String$repeat(" ", Math.imul(indent, level) | 0)}`;
}
function moonbitlang$core$json$$stringify$46$stringify_inner$124$321(_env, value, level) {
  const escape_slash = _env._1;
  const indent = _env._0;
  switch (value.$tag) {
    case 6: {
      const _Object = value;
      const _members = _Object._0;
      if (moonbitlang$core$builtin$$Map$is_empty$8$(_members)) {
        return "{}";
      }
      const buf = moonbitlang$core$builtin$$StringBuilder$new(0);
      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 123);
      moonbitlang$core$builtin$$Logger$write_string$71$(buf, moonbitlang$core$json$$indent_str(level + 1 | 0, indent));
      const first = { val: true };
      const _bind = moonbitlang$core$builtin$$Map$iter2$8$(_members);
      _bind((k, v) => {
        if (first.val) {
          first.val = false;
        } else {
          moonbitlang$core$builtin$$Logger$write_char$71$(buf, 44);
          moonbitlang$core$builtin$$Logger$write_string$71$(buf, moonbitlang$core$json$$indent_str(level + 1 | 0, indent));
        }
        moonbitlang$core$builtin$$Logger$write_char$71$(buf, 34);
        moonbitlang$core$builtin$$Logger$write_string$71$(buf, moonbitlang$core$json$$escape(k, escape_slash));
        moonbitlang$core$builtin$$Logger$write_char$71$(buf, 34);
        if (indent === 0) {
          moonbitlang$core$builtin$$Logger$write_char$71$(buf, 58);
        } else {
          moonbitlang$core$builtin$$Logger$write_string$71$(buf, ": ");
        }
        moonbitlang$core$builtin$$Logger$write_string$71$(buf, moonbitlang$core$json$$stringify$46$stringify_inner$124$321(_env, v, level + 1 | 0));
        return 1;
      });
      moonbitlang$core$builtin$$Logger$write_string$71$(buf, moonbitlang$core$json$$indent_str(level, indent));
      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 125);
      return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
    }
    case 5: {
      const _Array = value;
      const _arr = _Array._0;
      if (moonbitlang$core$array$$Array$is_empty$17$(_arr)) {
        return "[]";
      }
      const buf$2 = moonbitlang$core$builtin$$StringBuilder$new(0);
      moonbitlang$core$builtin$$Logger$write_char$71$(buf$2, 91);
      moonbitlang$core$builtin$$Logger$write_string$71$(buf$2, moonbitlang$core$json$$indent_str(level + 1 | 0, indent));
      const _len = _arr.length;
      let _tmp = 0;
      while (true) {
        const _i = _tmp;
        if (_i < _len) {
          const v = _arr[_i];
          if (_i > 0) {
            moonbitlang$core$builtin$$Logger$write_char$71$(buf$2, 44);
            moonbitlang$core$builtin$$Logger$write_string$71$(buf$2, moonbitlang$core$json$$indent_str(level + 1 | 0, indent));
          }
          moonbitlang$core$builtin$$Logger$write_string$71$(buf$2, moonbitlang$core$json$$stringify$46$stringify_inner$124$321(_env, v, level + 1 | 0));
          _tmp = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$71$(buf$2, moonbitlang$core$json$$indent_str(level, indent));
      moonbitlang$core$builtin$$Logger$write_char$71$(buf$2, 93);
      return moonbitlang$core$builtin$$StringBuilder$to_string(buf$2);
    }
    case 4: {
      const _String = value;
      const _s = _String._0;
      const buf$3 = moonbitlang$core$builtin$$StringBuilder$new(0);
      moonbitlang$core$builtin$$Logger$write_char$71$(buf$3, 34);
      moonbitlang$core$builtin$$Logger$write_string$71$(buf$3, moonbitlang$core$json$$escape(_s, escape_slash));
      moonbitlang$core$builtin$$Logger$write_char$71$(buf$3, 34);
      return moonbitlang$core$builtin$$StringBuilder$to_string(buf$3);
    }
    case 3: {
      const _Number = value;
      const _n = _Number._0;
      return String(_n);
    }
    case 1: {
      return "true";
    }
    case 2: {
      return "false";
    }
    default: {
      return "null";
    }
  }
}
function moonbitlang$core$json$$Json$stringify(self, escape_slash, indent) {
  const _env = { _0: indent, _1: escape_slash };
  return moonbitlang$core$json$$stringify$46$stringify_inner$124$321(_env, self, 0);
}
function moonbitlang$core$json$$Json$stringify$46$escape_slash$46$default() {
  return false;
}
function moonbitlang$core$json$$Json$stringify$46$indent$46$default() {
  return 0;
}
function moonbitlang$core$json$$from_json$82$(json, path) {
  return moonbitlang$core$json$$FromJson$from_json$82$(json, path);
}
function moonbitlang$core$json$$from_json$46$path$46$default$82$() {
  return $64$moonbitlang$47$core$47$json$46$JsonPath$Root;
}
function moonbitlang$core$json$$decode_error$82$(path, msg) {
  return new Result$Err$41$(new Error$moonbitlang$47$core$47$json$46$JsonDecodeError$46$JsonDecodeError({ _0: path, _1: msg }));
}
function moonbitlang$core$json$$FromJson$from_json$82$(json, path) {
  switch (json.$tag) {
    case 1: {
      return new Result$Ok$41$(true);
    }
    case 2: {
      return new Result$Ok$41$(false);
    }
    default: {
      return moonbitlang$core$json$$decode_error$82$(path, "Bool::from_json: expected boolean");
    }
  }
}
function moonbitlang$core$json$$Json$as_string(self) {
  if (self.$tag === 4) {
    const _String = self;
    const _s = _String._0;
    return _s;
  } else {
    return undefined;
  }
}
function moonbitlang$core$json$$Json$as_object(self) {
  if (self.$tag === 6) {
    const _Object = self;
    const _obj = _Object._0;
    return _obj;
  } else {
    return undefined;
  }
}
function moonbitlang$core$json$$Json$value(self, key) {
  const _bind = moonbitlang$core$json$$Json$as_object(self);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _obj = _Some;
    return moonbitlang$core$builtin$$Map$get$8$(_obj, key);
  }
}
function moonbitlang$core$result$$Result$map_err$341$(self, f) {
  if (self.$tag === 1) {
    const _Ok = self;
    const _value = _Ok._0;
    return new Result$Ok$42$(_value);
  } else {
    const _Err = self;
    const _err = _Err._0;
    return new Result$Err$42$(f(_err));
  }
}
function moonbitlang$core$result$$Result$bind$342$(self, g) {
  if (self.$tag === 1) {
    const _Ok = self;
    const _value = _Ok._0;
    return g(_value);
  } else {
    const _Err = self;
    const _err = _Err._0;
    return new Result$Err$43$(_err);
  }
}
function moonbitlang$core$result$$Result$bind$343$(self, g) {
  if (self.$tag === 1) {
    const _Ok = self;
    const _value = _Ok._0;
    return g(_value);
  } else {
    const _Err = self;
    const _err = _Err._0;
    return new Result$Err$44$(_err);
  }
}
function moonbitlang$core$result$$Result$bind$344$(self, g) {
  if (self.$tag === 1) {
    const _Ok = self;
    const _value = _Ok._0;
    return g(_value);
  } else {
    const _Err = self;
    const _err = _Err._0;
    return new Result$Err$45$(_err);
  }
}
function moonbitlang$core$result$$Result$bind$345$(self, g) {
  if (self.$tag === 1) {
    const _Ok = self;
    const _value = _Ok._0;
    return g(_value);
  } else {
    const _Err = self;
    const _err = _Err._0;
    return new Result$Err$42$(_err);
  }
}
function moonbitlang$core$result$$Result$unwrap$346$(self) {
  if (self.$tag === 1) {
    const _Ok = self;
    const _x = _Ok._0;
    return _x;
  } else {
    return moonbitlang$core$abort$$abort$17$("called `Result::unwrap()` on an `Err` value");
  }
}
function moonbitlang$core$strconv$$check_underscore(str) {
  let rest;
  let rest$2;
  _L: {
    _L$2: {
      if (moonbitlang$core$string$$String$char_length_ge(str, 1, 0, str.length)) {
        const _x = moonbitlang$core$string$$String$unsafe_char_at(str, moonbitlang$core$string$$String$offset_of_nth_char(str, 0, 0, str.length));
        switch (_x) {
          case 43: {
            const _bind = moonbitlang$core$string$$String$offset_of_nth_char(str, 1, 0, str.length);
            let _tmp;
            if (_bind === undefined) {
              _tmp = str.length;
            } else {
              const _Some = _bind;
              _tmp = _Some;
            }
            const _x$2 = { str: str, start: _tmp, end: str.length };
            rest = _x$2;
            break;
          }
          case 45: {
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(str, 1, 0, str.length);
            let _tmp$2;
            if (_bind$2 === undefined) {
              _tmp$2 = str.length;
            } else {
              const _Some = _bind$2;
              _tmp$2 = _Some;
            }
            const _x$3 = { str: str, start: _tmp$2, end: str.length };
            rest = _x$3;
            break;
          }
          default: {
            rest$2 = str;
            break _L$2;
          }
        }
      } else {
        rest$2 = str;
        break _L$2;
      }
      break _L;
    }
    rest = { str: rest$2, start: 0, end: rest$2.length };
  }
  let _bind;
  let rest$3;
  _L$2: {
    _L$3: {
      let rest$4;
      _L$4: {
        _L$5: {
          let rest$5;
          _L$6: {
            _L$7: {
              let rest$6;
              _L$8: {
                if (moonbitlang$core$string$$String$char_length_ge(rest.str, 2, rest.start, rest.end)) {
                  const _x = moonbitlang$core$string$$String$unsafe_char_at(rest.str, moonbitlang$core$string$$String$offset_of_nth_char(rest.str, 0, rest.start, rest.end));
                  if (_x === 48) {
                    const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(rest.str, moonbitlang$core$string$$String$offset_of_nth_char(rest.str, 1, rest.start, rest.end));
                    switch (_x$2) {
                      case 120: {
                        const _tmp = rest.str;
                        const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(rest.str, 2, rest.start, rest.end);
                        let _tmp$2;
                        if (_bind$2 === undefined) {
                          _tmp$2 = rest.end;
                        } else {
                          const _Some = _bind$2;
                          _tmp$2 = _Some;
                        }
                        const _tmp$3 = _tmp$2;
                        const _x$3 = { str: _tmp, start: _tmp$3, end: rest.end };
                        rest$6 = _x$3;
                        break _L$8;
                      }
                      case 88: {
                        const _tmp$4 = rest.str;
                        const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(rest.str, 2, rest.start, rest.end);
                        let _tmp$5;
                        if (_bind$3 === undefined) {
                          _tmp$5 = rest.end;
                        } else {
                          const _Some = _bind$3;
                          _tmp$5 = _Some;
                        }
                        const _tmp$6 = _tmp$5;
                        const _x$4 = { str: _tmp$4, start: _tmp$6, end: rest.end };
                        rest$6 = _x$4;
                        break _L$8;
                      }
                      case 111: {
                        const _tmp$7 = rest.str;
                        const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char(rest.str, 2, rest.start, rest.end);
                        let _tmp$8;
                        if (_bind$4 === undefined) {
                          _tmp$8 = rest.end;
                        } else {
                          const _Some = _bind$4;
                          _tmp$8 = _Some;
                        }
                        const _tmp$9 = _tmp$8;
                        const _x$5 = { str: _tmp$7, start: _tmp$9, end: rest.end };
                        rest$5 = _x$5;
                        break _L$7;
                      }
                      case 79: {
                        const _tmp$10 = rest.str;
                        const _bind$5 = moonbitlang$core$string$$String$offset_of_nth_char(rest.str, 2, rest.start, rest.end);
                        let _tmp$11;
                        if (_bind$5 === undefined) {
                          _tmp$11 = rest.end;
                        } else {
                          const _Some = _bind$5;
                          _tmp$11 = _Some;
                        }
                        const _tmp$12 = _tmp$11;
                        const _x$6 = { str: _tmp$10, start: _tmp$12, end: rest.end };
                        rest$5 = _x$6;
                        break _L$7;
                      }
                      case 98: {
                        const _tmp$13 = rest.str;
                        const _bind$6 = moonbitlang$core$string$$String$offset_of_nth_char(rest.str, 2, rest.start, rest.end);
                        let _tmp$14;
                        if (_bind$6 === undefined) {
                          _tmp$14 = rest.end;
                        } else {
                          const _Some = _bind$6;
                          _tmp$14 = _Some;
                        }
                        const _tmp$15 = _tmp$14;
                        const _x$7 = { str: _tmp$13, start: _tmp$15, end: rest.end };
                        rest$4 = _x$7;
                        break _L$5;
                      }
                      case 66: {
                        const _tmp$16 = rest.str;
                        const _bind$7 = moonbitlang$core$string$$String$offset_of_nth_char(rest.str, 2, rest.start, rest.end);
                        let _tmp$17;
                        if (_bind$7 === undefined) {
                          _tmp$17 = rest.end;
                        } else {
                          const _Some = _bind$7;
                          _tmp$17 = _Some;
                        }
                        const _tmp$18 = _tmp$17;
                        const _x$8 = { str: _tmp$16, start: _tmp$18, end: rest.end };
                        rest$4 = _x$8;
                        break _L$5;
                      }
                      default: {
                        rest$3 = rest;
                        break _L$3;
                      }
                    }
                  } else {
                    rest$3 = rest;
                    break _L$3;
                  }
                } else {
                  rest$3 = rest;
                  break _L$3;
                }
              }
              _bind = { _0: rest$6, _1: true, _2: true };
              break _L$6;
            }
            _bind = { _0: rest$5, _1: true, _2: false };
          }
          break _L$4;
        }
        _bind = { _0: rest$4, _1: true, _2: false };
      }
      break _L$2;
    }
    _bind = { _0: rest$3, _1: false, _2: false };
  }
  const _rest = _bind._0;
  const _allow_underscore = _bind._1;
  const _hex = _bind._2;
  let _tmp = _rest;
  let _tmp$2 = _allow_underscore;
  let _tmp$3 = false;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    let rest$4;
    let c;
    let follow_underscore;
    _L$3: {
      if (moonbitlang$core$string$$String$char_length_eq(_param.str, 0, _param.start, _param.end)) {
        return true;
      } else {
        if (moonbitlang$core$string$$String$char_length_eq(_param.str, 1, _param.start, _param.end)) {
          const _x = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 0, _param.start, _param.end));
          if (_x === 95) {
            return false;
          } else {
            const _tmp$4 = _param.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
            let _tmp$5;
            if (_bind$2 === undefined) {
              _tmp$5 = _param.end;
            } else {
              const _Some = _bind$2;
              _tmp$5 = _Some;
            }
            const _tmp$6 = _tmp$5;
            const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param.end };
            rest$4 = _x$2;
            c = _x;
            follow_underscore = _param$3;
            break _L$3;
          }
        } else {
          const _x = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 0, _param.start, _param.end));
          if (_x === 95) {
            if (_param$2 === false) {
              return false;
            } else {
              const _tmp$4 = _param.str;
              const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
              let _tmp$5;
              if (_bind$2 === undefined) {
                _tmp$5 = _param.end;
              } else {
                const _Some = _bind$2;
                _tmp$5 = _Some;
              }
              const _tmp$6 = _tmp$5;
              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param.end };
              _tmp = _x$2;
              _tmp$2 = false;
              _tmp$3 = true;
              continue;
            }
          } else {
            const _tmp$4 = _param.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
            let _tmp$5;
            if (_bind$2 === undefined) {
              _tmp$5 = _param.end;
            } else {
              const _Some = _bind$2;
              _tmp$5 = _Some;
            }
            const _tmp$6 = _tmp$5;
            const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param.end };
            rest$4 = _x$2;
            c = _x;
            follow_underscore = _param$3;
            break _L$3;
          }
        }
      }
    }
    if (c >= 48 && c <= 57 ? true : _hex && (c >= 97 && c <= 102 ? true : c >= 65 && c <= 70)) {
      _tmp = rest$4;
      _tmp$2 = true;
      _tmp$3 = false;
      continue;
    } else {
      if (follow_underscore) {
        return false;
      } else {
        _tmp = rest$4;
        _tmp$2 = false;
        _tmp$3 = false;
        continue;
      }
    }
  }
}
function moonbitlang$core$strconv$$syntax_err$7$() {
  return new Result$Err$46$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$232$() {
  return new Result$Err$47$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$12$() {
  return new Result$Err$48$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$347$() {
  return new Result$Err$49$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$16$() {
  return new Result$Err$50$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$348$() {
  return new Result$Err$51$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$Decimal$new_priv() {
  return { digits: $make_array_len_and_init(800, moonbitlang$core$builtin$$Default$default$233$()), digits_num: 0, decimal_point: 0, negative: false, truncated: false };
}
function moonbitlang$core$strconv$$Decimal$trim(self) {
  while (true) {
    let _tmp;
    if (self.digits_num > 0) {
      const _tmp$2 = self.digits;
      const _tmp$3 = self.digits_num - 1 | 0;
      $bound_check(_tmp$2, _tmp$3);
      _tmp = moonbitlang$core$builtin$$Eq$op_equal$233$(_tmp$2[_tmp$3], 0);
    } else {
      _tmp = false;
    }
    if (_tmp) {
      self.digits_num = self.digits_num - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (self.digits_num === 0) {
    self.decimal_point = 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$strconv$$parse_decimal_from_view(str) {
  const d = moonbitlang$core$strconv$$Decimal$new_priv();
  let has_dp = false;
  let has_digits = false;
  let rest;
  _L: {
    _L$2: {
      if (moonbitlang$core$string$$String$char_length_ge(str.str, 1, str.start, str.end)) {
        const _x = moonbitlang$core$string$$String$unsafe_char_at(str.str, moonbitlang$core$string$$String$offset_of_nth_char(str.str, 0, str.start, str.end));
        switch (_x) {
          case 45: {
            const _tmp = str.str;
            const _bind = moonbitlang$core$string$$String$offset_of_nth_char(str.str, 1, str.start, str.end);
            let _tmp$2;
            if (_bind === undefined) {
              _tmp$2 = str.end;
            } else {
              const _Some = _bind;
              _tmp$2 = _Some;
            }
            const _tmp$3 = _tmp$2;
            const _x$2 = { str: _tmp, start: _tmp$3, end: str.end };
            d.negative = true;
            rest = _x$2;
            break;
          }
          case 43: {
            const _tmp$4 = str.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(str.str, 1, str.start, str.end);
            let _tmp$5;
            if (_bind$2 === undefined) {
              _tmp$5 = str.end;
            } else {
              const _Some = _bind$2;
              _tmp$5 = _Some;
            }
            const _tmp$6 = _tmp$5;
            const _x$3 = { str: _tmp$4, start: _tmp$6, end: str.end };
            rest = _x$3;
            break;
          }
          default: {
            break _L$2;
          }
        }
      } else {
        break _L$2;
      }
      break _L;
    }
    rest = str;
  }
  let rest$2;
  let _tmp = rest;
  while (true) {
    const _param = _tmp;
    if (moonbitlang$core$string$$String$char_length_ge(_param.str, 1, _param.start, _param.end)) {
      const _x = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 0, _param.start, _param.end));
      if (_x === 95) {
        const _tmp$2 = _param.str;
        const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
        let _tmp$3;
        if (_bind === undefined) {
          _tmp$3 = _param.end;
        } else {
          const _Some = _bind;
          _tmp$3 = _Some;
        }
        const _tmp$4 = _tmp$3;
        const _x$2 = { str: _tmp$2, start: _tmp$4, end: _param.end };
        _tmp = _x$2;
        continue;
      } else {
        if (_x === 46) {
          const _tmp$2 = _param.str;
          const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
          let _tmp$3;
          if (_bind === undefined) {
            _tmp$3 = _param.end;
          } else {
            const _Some = _bind;
            _tmp$3 = _Some;
          }
          const _tmp$4 = _tmp$3;
          const _x$2 = { str: _tmp$2, start: _tmp$4, end: _param.end };
          if (!has_dp) {
            has_dp = true;
            d.decimal_point = d.digits_num;
            _tmp = _x$2;
            continue;
          } else {
            const _bind$2 = moonbitlang$core$strconv$$syntax_err$16$();
            if (_bind$2.$tag === 1) {
              const _ok = _bind$2;
              rest$2 = _ok._0;
              break;
            } else {
              return _bind$2;
            }
          }
        } else {
          if (_x >= 48 && _x <= 57) {
            const _tmp$2 = _param.str;
            const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
            let _tmp$3;
            if (_bind === undefined) {
              _tmp$3 = _param.end;
            } else {
              const _Some = _bind;
              _tmp$3 = _Some;
            }
            const _tmp$4 = _tmp$3;
            const _x$2 = { str: _tmp$2, start: _tmp$4, end: _param.end };
            has_digits = true;
            if (_x === 48 && d.digits_num === 0) {
              d.decimal_point = d.decimal_point - 1 | 0;
              _tmp = _x$2;
              continue;
            }
            if (d.digits_num < d.digits.length) {
              const _tmp$5 = d.digits;
              const _tmp$6 = d.digits_num;
              $bound_check(_tmp$5, _tmp$6);
              _tmp$5[_tmp$6] = (_x - 48 | 0) & 255;
              d.digits_num = d.digits_num + 1 | 0;
            } else {
              if (_x !== 48) {
                d.truncated = true;
              }
            }
            _tmp = _x$2;
            continue;
          } else {
            rest$2 = _param;
            break;
          }
        }
      }
    } else {
      rest$2 = _param;
      break;
    }
  }
  if (has_digits) {
    if (!has_dp) {
      d.decimal_point = d.digits_num;
    }
    let rest$3;
    let rest$4;
    _L$2: {
      _L$3: {
        if (moonbitlang$core$string$$String$char_length_ge(rest$2.str, 1, rest$2.start, rest$2.end)) {
          const _x = moonbitlang$core$string$$String$unsafe_char_at(rest$2.str, moonbitlang$core$string$$String$offset_of_nth_char(rest$2.str, 0, rest$2.start, rest$2.end));
          switch (_x) {
            case 101: {
              const _tmp$2 = rest$2.str;
              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(rest$2.str, 1, rest$2.start, rest$2.end);
              let _tmp$3;
              if (_bind === undefined) {
                _tmp$3 = rest$2.end;
              } else {
                const _Some = _bind;
                _tmp$3 = _Some;
              }
              const _tmp$4 = _tmp$3;
              const _x$2 = { str: _tmp$2, start: _tmp$4, end: rest$2.end };
              rest$4 = _x$2;
              break _L$3;
            }
            case 69: {
              const _tmp$5 = rest$2.str;
              const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(rest$2.str, 1, rest$2.start, rest$2.end);
              let _tmp$6;
              if (_bind$2 === undefined) {
                _tmp$6 = rest$2.end;
              } else {
                const _Some = _bind$2;
                _tmp$6 = _Some;
              }
              const _tmp$7 = _tmp$6;
              const _x$3 = { str: _tmp$5, start: _tmp$7, end: rest$2.end };
              rest$4 = _x$3;
              break _L$3;
            }
            default: {
              rest$3 = rest$2;
            }
          }
        } else {
          rest$3 = rest$2;
        }
        break _L$2;
      }
      let exp_sign = 1;
      let rest$5;
      if (moonbitlang$core$string$$String$char_length_ge(rest$4.str, 1, rest$4.start, rest$4.end)) {
        const _x = moonbitlang$core$string$$String$unsafe_char_at(rest$4.str, moonbitlang$core$string$$String$offset_of_nth_char(rest$4.str, 0, rest$4.start, rest$4.end));
        switch (_x) {
          case 43: {
            const _tmp$2 = rest$4.str;
            const _bind = moonbitlang$core$string$$String$offset_of_nth_char(rest$4.str, 1, rest$4.start, rest$4.end);
            let _tmp$3;
            if (_bind === undefined) {
              _tmp$3 = rest$4.end;
            } else {
              const _Some = _bind;
              _tmp$3 = _Some;
            }
            const _tmp$4 = _tmp$3;
            const _x$2 = { str: _tmp$2, start: _tmp$4, end: rest$4.end };
            rest$5 = _x$2;
            break;
          }
          case 45: {
            const _tmp$5 = rest$4.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(rest$4.str, 1, rest$4.start, rest$4.end);
            let _tmp$6;
            if (_bind$2 === undefined) {
              _tmp$6 = rest$4.end;
            } else {
              const _Some = _bind$2;
              _tmp$6 = _Some;
            }
            const _tmp$7 = _tmp$6;
            const _x$3 = { str: _tmp$5, start: _tmp$7, end: rest$4.end };
            exp_sign = -1;
            rest$5 = _x$3;
            break;
          }
          default: {
            rest$5 = rest$4;
          }
        }
      } else {
        rest$5 = rest$4;
      }
      _L$4: {
        _L$5: {
          if (moonbitlang$core$string$$String$char_length_ge(rest$5.str, 1, rest$5.start, rest$5.end)) {
            const _x = moonbitlang$core$string$$String$unsafe_char_at(rest$5.str, moonbitlang$core$string$$String$offset_of_nth_char(rest$5.str, 0, rest$5.start, rest$5.end));
            if (_x >= 48 && _x <= 57) {
              let exp = 0;
              let rest$6;
              let _tmp$2 = rest$5;
              while (true) {
                const _param = _tmp$2;
                if (moonbitlang$core$string$$String$char_length_ge(_param.str, 1, _param.start, _param.end)) {
                  const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 0, _param.start, _param.end));
                  if (_x$2 === 95) {
                    const _tmp$3 = _param.str;
                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
                    let _tmp$4;
                    if (_bind === undefined) {
                      _tmp$4 = _param.end;
                    } else {
                      const _Some = _bind;
                      _tmp$4 = _Some;
                    }
                    const _tmp$5 = _tmp$4;
                    const _x$3 = { str: _tmp$3, start: _tmp$5, end: _param.end };
                    _tmp$2 = _x$3;
                    continue;
                  } else {
                    if (_x$2 >= 48 && _x$2 <= 57) {
                      const _tmp$3 = _param.str;
                      const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
                      let _tmp$4;
                      if (_bind === undefined) {
                        _tmp$4 = _param.end;
                      } else {
                        const _Some = _bind;
                        _tmp$4 = _Some;
                      }
                      const _tmp$5 = _tmp$4;
                      const _x$3 = { str: _tmp$3, start: _tmp$5, end: _param.end };
                      exp = (Math.imul(exp, 10) | 0) + (_x$2 - 48 | 0) | 0;
                      _tmp$2 = _x$3;
                      continue;
                    } else {
                      rest$6 = _param;
                      break;
                    }
                  }
                } else {
                  rest$6 = _param;
                  break;
                }
              }
              d.decimal_point = d.decimal_point + (Math.imul(exp_sign, exp) | 0) | 0;
              rest$3 = rest$6;
            } else {
              break _L$5;
            }
          } else {
            break _L$5;
          }
          break _L$4;
        }
        const _bind = moonbitlang$core$strconv$$syntax_err$16$();
        if (_bind.$tag === 1) {
          const _ok = _bind;
          rest$3 = _ok._0;
        } else {
          return _bind;
        }
      }
    }
    if (moonbitlang$core$string$$String$char_length_eq(rest$3.str, 0, rest$3.start, rest$3.end)) {
      moonbitlang$core$strconv$$Decimal$trim(d);
      return new Result$Ok$51$(d);
    } else {
      return moonbitlang$core$strconv$$syntax_err$348$();
    }
  } else {
    return moonbitlang$core$strconv$$syntax_err$348$();
  }
}
function moonbitlang$core$strconv$$parse_decimal_priv(str) {
  const _arg = moonbitlang$core$string$$String$view$46$start_offset$46$default();
  const _arg$2 = moonbitlang$core$string$$String$view$46$end_offset$46$default(str);
  return moonbitlang$core$strconv$$parse_decimal_from_view(moonbitlang$core$string$$String$view(str, _arg, _arg$2));
}
function moonbitlang$core$strconv$$slice(s, start, end) {
  return { string: s, start: start, end: end };
}
function moonbitlang$core$strconv$$full_slice(s) {
  return moonbitlang$core$strconv$$slice(s, 0, s.length);
}
function moonbitlang$core$strconv$$StringSlice$length(self) {
  return self.end - self.start | 0;
}
function moonbitlang$core$strconv$$StringSlice$op_get(self, index) {
  const _tmp = self.string;
  const _tmp$2 = self.start + index | 0;
  return _tmp.charCodeAt(_tmp$2);
}
function moonbitlang$core$strconv$$StringSlice$first_is(self, c) {
  return moonbitlang$core$strconv$$StringSlice$length(self) > 0 && moonbitlang$core$strconv$$StringSlice$op_get(self, 0) === c;
}
function moonbitlang$core$strconv$$lower(c) {
  return 65 <= c && c <= 90 ? (c + 97 | 0) - 65 | 0 : c;
}
function moonbitlang$core$strconv$$StringSlice$prefix_eq_ignore_case(self, s2) {
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < s2.length && i < moonbitlang$core$strconv$$StringSlice$length(self)) {
      const c1 = moonbitlang$core$strconv$$StringSlice$op_get(self, i);
      const c2 = s2.charCodeAt(i);
      if (moonbitlang$core$strconv$$lower(c1) !== moonbitlang$core$strconv$$lower(c2)) {
        return false;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$strconv$$StringSlice$step_1_unchecked(self) {
  return { string: self.string, start: self.start + 1 | 0, end: self.end };
}
function moonbitlang$core$strconv$$StringSlice$subfix_unchecked(self, start) {
  return { string: self.string, start: self.start + start | 0, end: self.end };
}
function moonbitlang$core$strconv$$parse_inf_nan$46$parse_inf_rest$124$9(s) {
  return moonbitlang$core$strconv$$StringSlice$length(s) >= 8 && moonbitlang$core$strconv$$StringSlice$prefix_eq_ignore_case(moonbitlang$core$strconv$$StringSlice$subfix_unchecked(s, 3), "inity") ? 8 : 3;
}
function moonbitlang$core$strconv$$parse_inf_nan(s) {
  const s$2 = moonbitlang$core$strconv$$full_slice(s);
  if (moonbitlang$core$strconv$$StringSlice$length(s$2) >= 3) {
    if (moonbitlang$core$strconv$$StringSlice$prefix_eq_ignore_case(s$2, "nan")) {
      return { _0: moonbitlang$core$double$$not_a_number, _1: 3 };
    } else {
      if (moonbitlang$core$strconv$$StringSlice$prefix_eq_ignore_case(s$2, "inf")) {
        return { _0: moonbitlang$core$double$$infinity, _1: moonbitlang$core$strconv$$parse_inf_nan$46$parse_inf_rest$124$9(s$2) };
      } else {
        if (moonbitlang$core$strconv$$StringSlice$length(s$2) >= 4) {
          if (moonbitlang$core$strconv$$StringSlice$first_is(s$2, 43)) {
            const s$3 = moonbitlang$core$strconv$$StringSlice$step_1_unchecked(s$2);
            if (moonbitlang$core$strconv$$StringSlice$prefix_eq_ignore_case(s$3, "nan")) {
              return { _0: moonbitlang$core$double$$not_a_number, _1: 4 };
            } else {
              if (moonbitlang$core$strconv$$StringSlice$prefix_eq_ignore_case(s$3, "inf")) {
                return { _0: moonbitlang$core$double$$infinity, _1: 1 + moonbitlang$core$strconv$$parse_inf_nan$46$parse_inf_rest$124$9(s$3) | 0 };
              }
            }
          } else {
            if (moonbitlang$core$strconv$$StringSlice$first_is(s$2, 45)) {
              const s$3 = moonbitlang$core$strconv$$StringSlice$step_1_unchecked(s$2);
              if (moonbitlang$core$strconv$$StringSlice$prefix_eq_ignore_case(s$3, "nan")) {
                return { _0: moonbitlang$core$double$$not_a_number, _1: 4 };
              } else {
                if (moonbitlang$core$strconv$$StringSlice$prefix_eq_ignore_case(s$3, "inf")) {
                  return { _0: moonbitlang$core$double$$neg_infinity, _1: 1 + moonbitlang$core$strconv$$parse_inf_nan$46$parse_inf_rest$124$9(s$3) | 0 };
                }
              }
            }
          }
        }
      }
    }
  }
  return undefined;
}
function moonbitlang$core$strconv$$is_digit(c) {
  return c >= 48 && c <= 57;
}
function moonbitlang$core$strconv$$to_digit(c) {
  return c - 48 | 0;
}
function moonbitlang$core$strconv$$StringSlice$fold_digits$6$(self, init, f) {
  let ret = init;
  let len = 0;
  const _end377 = moonbitlang$core$strconv$$StringSlice$length(self);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < _end377) {
      if (!(moonbitlang$core$strconv$$is_digit(moonbitlang$core$strconv$$StringSlice$op_get(self, i)) || moonbitlang$core$strconv$$StringSlice$op_get(self, i) === 95)) {
        return { _0: moonbitlang$core$strconv$$StringSlice$subfix_unchecked(self, i), _1: ret, _2: len };
      }
      if (moonbitlang$core$strconv$$StringSlice$op_get(self, i) !== 95) {
        len = len + 1 | 0;
        ret = f(moonbitlang$core$strconv$$to_digit(moonbitlang$core$strconv$$StringSlice$op_get(self, i)), ret);
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: moonbitlang$core$strconv$$StringSlice$subfix_unchecked(self, moonbitlang$core$strconv$$StringSlice$length(self)), _1: ret, _2: len };
}
function moonbitlang$core$strconv$$StringSlice$fold_digits$232$(self, init, f) {
  let ret = init;
  let len = 0;
  const _end377 = moonbitlang$core$strconv$$StringSlice$length(self);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < _end377) {
      if (!(moonbitlang$core$strconv$$is_digit(moonbitlang$core$strconv$$StringSlice$op_get(self, i)) || moonbitlang$core$strconv$$StringSlice$op_get(self, i) === 95)) {
        return { _0: moonbitlang$core$strconv$$StringSlice$subfix_unchecked(self, i), _1: ret, _2: len };
      }
      if (moonbitlang$core$strconv$$StringSlice$op_get(self, i) !== 95) {
        len = len + 1 | 0;
        ret = f(moonbitlang$core$strconv$$to_digit(moonbitlang$core$strconv$$StringSlice$op_get(self, i)), ret);
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: moonbitlang$core$strconv$$StringSlice$subfix_unchecked(self, moonbitlang$core$strconv$$StringSlice$length(self)), _1: ret, _2: len };
}
function moonbitlang$core$strconv$$parse_digits(s, x) {
  return moonbitlang$core$strconv$$StringSlice$fold_digits$6$(s, x, (digit, acc) => moonbitlang$core$builtin$$Add$op_add$6$(moonbitlang$core$builtin$$Mul$op_mul$6$(acc, $10L), moonbitlang$core$uint64$$UInt64$extend_uint(digit)));
}
function moonbitlang$core$strconv$$StringSlice$first_is_digit(self) {
  return moonbitlang$core$strconv$$StringSlice$length(self) > 0 && moonbitlang$core$strconv$$is_digit(moonbitlang$core$strconv$$StringSlice$op_get(self, 0));
}
function moonbitlang$core$strconv$$StringSlice$first_is_either(self, c1, c2) {
  return moonbitlang$core$strconv$$StringSlice$length(self) > 0 && (moonbitlang$core$strconv$$StringSlice$op_get(self, 0) === c1 || moonbitlang$core$strconv$$StringSlice$op_get(self, 0) === c2);
}
function moonbitlang$core$strconv$$StringSlice$step(self, step) {
  let step$2 = step;
  let start = self.start;
  while (true) {
    if (start < self.end && step$2 > 0) {
      const _tmp = self.string;
      const _tmp$2 = start;
      if (_tmp.charCodeAt(_tmp$2) !== 95) {
        step$2 = step$2 - 1 | 0;
      }
      start = start + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return step$2 === 0 ? moonbitlang$core$strconv$$StringSlice$subfix_unchecked(self, start - self.start | 0) : undefined;
}
function moonbitlang$core$strconv$$parse_scientific(s) {
  const _bind = moonbitlang$core$strconv$$StringSlice$step(s, 1);
  let s$2;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _s = _Some;
    s$2 = _s;
  }
  let neg_exp = false;
  if (moonbitlang$core$strconv$$StringSlice$first_is_either(s$2, 45, 43)) {
    neg_exp = moonbitlang$core$strconv$$StringSlice$op_get(s$2, 0) === 45;
    s$2 = moonbitlang$core$strconv$$StringSlice$step_1_unchecked(s$2);
  }
  if (moonbitlang$core$strconv$$StringSlice$first_is_digit(s$2)) {
    const _bind$2 = moonbitlang$core$strconv$$StringSlice$fold_digits$232$(s$2, moonbitlang$core$strconv$$parse_scientific$46$exp_num$124$48, (digit, exp_num) => moonbitlang$core$builtin$$op_lt$232$(exp_num, $65536L) ? moonbitlang$core$builtin$$Add$op_add$232$(moonbitlang$core$builtin$$Mul$op_mul$232$($10L, exp_num), moonbitlang$core$int$$Int$to_int64(digit)) : exp_num);
    const _s = _bind$2._0;
    const _exp_num = _bind$2._1;
    return neg_exp ? { _0: _s, _1: moonbitlang$core$builtin$$Neg$op_neg$232$(_exp_num) } : { _0: _s, _1: _exp_num };
  } else {
    return undefined;
  }
}
function moonbitlang$core$strconv$$try_parse_19digits(s, x) {
  let x$2 = x;
  let s$2 = s;
  let len = 0;
  while (true) {
    if (moonbitlang$core$builtin$$op_lt$6$(x$2, moonbitlang$core$strconv$$min_19digit_int) && moonbitlang$core$strconv$$StringSlice$first_is_digit(s$2) || moonbitlang$core$strconv$$StringSlice$first_is(s$2, 95)) {
      if (moonbitlang$core$strconv$$StringSlice$first_is(s$2, 95)) {
        s$2 = moonbitlang$core$strconv$$StringSlice$step_1_unchecked(s$2);
      }
      len = len + 1 | 0;
      x$2 = moonbitlang$core$builtin$$Add$op_add$6$(moonbitlang$core$builtin$$Mul$op_mul$6$(x$2, $10L), moonbitlang$core$uint64$$UInt64$extend_uint(moonbitlang$core$strconv$$to_digit(moonbitlang$core$strconv$$StringSlice$op_get(s$2, 0))));
      s$2 = moonbitlang$core$strconv$$StringSlice$step_1_unchecked(s$2);
      continue;
    } else {
      break;
    }
  }
  return { _0: s$2, _1: x$2, _2: len };
}
function moonbitlang$core$strconv$$StringSlice$is_empty(self) {
  return self.start === self.end;
}
function moonbitlang$core$strconv$$parse_number(s) {
  let s$2 = moonbitlang$core$strconv$$full_slice(s);
  const start = s$2;
  let negative = false;
  if (moonbitlang$core$strconv$$StringSlice$first_is(s$2, 45)) {
    negative = true;
    s$2 = moonbitlang$core$strconv$$StringSlice$step_1_unchecked(s$2);
  } else {
    if (moonbitlang$core$strconv$$StringSlice$first_is(s$2, 43)) {
      s$2 = moonbitlang$core$strconv$$StringSlice$step_1_unchecked(s$2);
    }
  }
  if (moonbitlang$core$strconv$$StringSlice$is_empty(s$2)) {
    return undefined;
  }
  const _bind = moonbitlang$core$strconv$$parse_digits(s$2, $0L);
  const _s = _bind._0;
  const _mantissa = _bind._1;
  const _consumed = _bind._2;
  let mantissa = _mantissa;
  let s$3 = _s;
  let n_digits = _consumed;
  let n_after_dot = 0;
  let exponent = $0L;
  if (moonbitlang$core$strconv$$StringSlice$first_is(s$3, 46)) {
    s$3 = moonbitlang$core$strconv$$StringSlice$step_1_unchecked(s$3);
    const _bind$2 = moonbitlang$core$strconv$$parse_digits(s$3, mantissa);
    const _new_s = _bind$2._0;
    const _new_mantissa = _bind$2._1;
    const _consumed_digit = _bind$2._2;
    s$3 = _new_s;
    mantissa = _new_mantissa;
    n_after_dot = _consumed_digit;
    exponent = moonbitlang$core$builtin$$Neg$op_neg$232$(moonbitlang$core$int$$Int$to_int64(n_after_dot));
  }
  n_digits = n_digits + n_after_dot | 0;
  if (n_digits === 0) {
    return undefined;
  }
  if (moonbitlang$core$strconv$$StringSlice$first_is_either(s$3, 101, 69)) {
    const _bind$2 = moonbitlang$core$strconv$$parse_scientific(s$3);
    let _bind$3;
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some = _bind$2;
      const _res = _Some;
      _bind$3 = _res;
    }
    const _new_s = _bind$3._0;
    const _exp_number = _bind$3._1;
    s$3 = _new_s;
    exponent = moonbitlang$core$builtin$$Add$op_add$232$(exponent, _exp_number);
  }
  const len = moonbitlang$core$strconv$$StringSlice$length(start) - moonbitlang$core$strconv$$StringSlice$length(s$3) | 0;
  if (n_digits <= 19) {
    return { _0: { exponent: exponent, mantissa: mantissa, negative: negative, many_digits: false }, _1: len };
  }
  n_digits = n_digits - 19 | 0;
  let many_digits = false;
  let p = start;
  while (true) {
    if (moonbitlang$core$strconv$$StringSlice$first_is_either(p, 48, 46)) {
      n_digits = n_digits - ((moonbitlang$core$strconv$$StringSlice$op_get(p, 0) - 46 | 0) / 2 | 0) | 0;
      p = moonbitlang$core$strconv$$StringSlice$step_1_unchecked(p);
      continue;
    } else {
      break;
    }
  }
  let mantissa$2 = mantissa;
  if (n_digits > 0) {
    many_digits = true;
    mantissa$2 = $0L;
    const _bind$2 = moonbitlang$core$strconv$$try_parse_19digits(start, mantissa$2);
    const _s$2 = _bind$2._0;
    const _new_mantissa = _bind$2._1;
    const _consumed_digit = _bind$2._2;
    mantissa$2 = _new_mantissa;
    let _tmp;
    if (moonbitlang$core$builtin$$op_ge$6$(mantissa$2, moonbitlang$core$strconv$$min_19digit_int)) {
      _tmp = _consumed_digit;
    } else {
      const _bind$3 = moonbitlang$core$strconv$$StringSlice$step(_s$2, 1);
      let s$4;
      if (_bind$3 === undefined) {
        return undefined;
      } else {
        const _Some = _bind$3;
        const _s$3 = _Some;
        s$4 = _s$3;
      }
      const _bind$4 = moonbitlang$core$strconv$$try_parse_19digits(s$4, mantissa$2);
      const _new_mantissa$2 = _bind$4._1;
      const _consumed_digit$2 = _bind$4._2;
      mantissa$2 = _new_mantissa$2;
      _tmp = _consumed_digit$2;
    }
    exponent = moonbitlang$core$int$$Int$to_int64(_tmp);
    exponent = moonbitlang$core$builtin$$Add$op_add$232$(exponent, moonbitlang$core$strconv$$parse_number$46$exp_number$124$29);
  }
  return { _0: { exponent: exponent, mantissa: mantissa$2, negative: negative, many_digits: many_digits }, _1: len };
}
function moonbitlang$core$strconv$$assemble_bits(mantissa, exponent, negative) {
  const biased_exp = exponent - moonbitlang$core$strconv$$double_info.bias | 0;
  let bits = moonbitlang$core$builtin$$BitAnd$land$232$(mantissa, moonbitlang$core$builtin$$Sub$op_sub$232$(moonbitlang$core$builtin$$Shl$op_shl$232$($1L, moonbitlang$core$strconv$$double_info.mantissa_bits), $1L));
  const exp_bits = moonbitlang$core$int$$Int$to_int64(biased_exp & ((1 << moonbitlang$core$strconv$$double_info.exponent_bits) - 1 | 0));
  bits = moonbitlang$core$builtin$$BitOr$lor$232$(bits, moonbitlang$core$builtin$$Shl$op_shl$232$(exp_bits, moonbitlang$core$strconv$$double_info.mantissa_bits));
  if (negative) {
    bits = moonbitlang$core$builtin$$BitOr$lor$232$(bits, moonbitlang$core$builtin$$Shl$op_shl$232$(moonbitlang$core$builtin$$Shl$op_shl$232$($1L, moonbitlang$core$strconv$$double_info.mantissa_bits), moonbitlang$core$strconv$$double_info.exponent_bits));
  }
  return bits;
}
function moonbitlang$core$strconv$$range_err$12$() {
  return new Result$Err$48$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$range_err_str));
}
function moonbitlang$core$strconv$$range_err$232$() {
  return new Result$Err$47$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$range_err_str));
}
function moonbitlang$core$strconv$$Decimal$should_round_up(self, d) {
  if (d < 0 || d >= self.digits_num) {
    return false;
  }
  let _tmp;
  const _tmp$2 = self.digits;
  $bound_check(_tmp$2, d);
  if (_tmp$2[d] === 5) {
    _tmp = (d + 1 | 0) === self.digits_num;
  } else {
    _tmp = false;
  }
  if (_tmp) {
    if (self.truncated) {
      return true;
    }
    let _tmp$3;
    if (d > 0) {
      const _tmp$4 = self.digits;
      const _tmp$5 = d - 1 | 0;
      $bound_check(_tmp$4, _tmp$5);
      _tmp$3 = (_tmp$4[_tmp$5] % 2 | 0) !== 0;
    } else {
      _tmp$3 = false;
    }
    return _tmp$3;
  }
  const _tmp$3 = self.digits;
  $bound_check(_tmp$3, d);
  return _tmp$3[d] >= 5;
}
function moonbitlang$core$strconv$$Decimal$rounded_integer(self) {
  if (self.decimal_point > 20) {
    return $_1L;
  }
  let n = $0L;
  let i = 0;
  while (true) {
    if (i < self.decimal_point && i < self.digits_num) {
      const _tmp = moonbitlang$core$builtin$$Mul$op_mul$232$(n, $10L);
      const _tmp$2 = self.digits;
      const _tmp$3 = i;
      $bound_check(_tmp$2, _tmp$3);
      n = moonbitlang$core$builtin$$Add$op_add$232$(_tmp, moonbitlang$core$byte$$Byte$to_int64(_tmp$2[_tmp$3]));
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    if (i < self.decimal_point) {
      n = moonbitlang$core$builtin$$Mul$op_mul$232$(n, $10L);
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (moonbitlang$core$strconv$$Decimal$should_round_up(self, self.decimal_point)) {
    n = moonbitlang$core$builtin$$Add$op_add$232$(n, $1L);
  }
  return n;
}
function moonbitlang$core$strconv$$Decimal$new_digits(self, s) {
  const new_digits = moonbitlang$core$array$$Array$op_get$241$(moonbitlang$core$strconv$$left_shift_cheats, s)._0;
  const cheat_num = moonbitlang$core$array$$Array$op_get$241$(moonbitlang$core$strconv$$left_shift_cheats, s)._1;
  let less = false;
  const _end268 = cheat_num.length;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < _end268) {
      if (i >= self.digits_num) {
        less = true;
        break;
      }
      const d = cheat_num.charCodeAt(i) - 48 | 0;
      const _tmp$2 = self.digits;
      $bound_check(_tmp$2, i);
      if (_tmp$2[i] !== d) {
        const _tmp$3 = self.digits;
        $bound_check(_tmp$3, i);
        less = _tmp$3[i] < d;
        break;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return less ? new_digits - 1 | 0 : new_digits;
}
function moonbitlang$core$strconv$$Decimal$left_shift(self, s) {
  const new_digits = moonbitlang$core$strconv$$Decimal$new_digits(self, s);
  let read_index = self.digits_num;
  let write_index = self.digits_num + new_digits | 0;
  let acc = $0L;
  read_index = read_index - 1 | 0;
  while (true) {
    if (read_index >= 0) {
      const _tmp = self.digits;
      const _tmp$2 = read_index;
      $bound_check(_tmp, _tmp$2);
      const d = moonbitlang$core$byte$$Byte$to_int64(_tmp[_tmp$2]);
      acc = moonbitlang$core$builtin$$Add$op_add$232$(acc, moonbitlang$core$builtin$$Shl$op_shl$232$(d, s));
      const quo = moonbitlang$core$builtin$$Div$op_div$232$(acc, $10L);
      const rem = moonbitlang$core$int64$$Int64$to_int(moonbitlang$core$builtin$$Sub$op_sub$232$(acc, moonbitlang$core$builtin$$Mul$op_mul$232$(quo, $10L)));
      write_index = write_index - 1 | 0;
      if (write_index < self.digits.length) {
        const _tmp$3 = self.digits;
        const _tmp$4 = write_index;
        $bound_check(_tmp$3, _tmp$4);
        _tmp$3[_tmp$4] = rem & 255;
      } else {
        if (rem !== 0) {
          self.truncated = true;
        }
      }
      acc = quo;
      read_index = read_index - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    if (moonbitlang$core$builtin$$op_gt$232$(acc, $0L)) {
      const quo = moonbitlang$core$builtin$$Div$op_div$232$(acc, $10L);
      const rem = moonbitlang$core$int64$$Int64$to_int(moonbitlang$core$builtin$$Sub$op_sub$232$(acc, moonbitlang$core$builtin$$Mul$op_mul$232$($10L, quo)));
      write_index = write_index - 1 | 0;
      if (write_index < self.digits.length) {
        const _tmp = self.digits;
        const _tmp$2 = write_index;
        $bound_check(_tmp, _tmp$2);
        _tmp[_tmp$2] = rem & 255;
      } else {
        if (rem !== 0) {
          self.truncated = true;
        }
      }
      acc = quo;
      continue;
    } else {
      break;
    }
  }
  self.digits_num = self.digits_num + new_digits | 0;
  if (self.digits_num > self.digits.length) {
    self.digits_num = self.digits.length;
  }
  self.decimal_point = self.decimal_point + new_digits | 0;
  moonbitlang$core$strconv$$Decimal$trim(self);
}
function moonbitlang$core$strconv$$Decimal$right_shift(self, s) {
  let read_index = 0;
  let write_index = 0;
  let acc = $0L;
  while (true) {
    if (moonbitlang$core$builtin$$Eq$op_equal$6$(moonbitlang$core$builtin$$Shr$op_shr$6$(acc, s), $0L)) {
      if (read_index >= self.digits_num) {
        while (true) {
          if (moonbitlang$core$builtin$$Eq$op_equal$6$(moonbitlang$core$builtin$$Shr$op_shr$6$(acc, s), $0L)) {
            acc = moonbitlang$core$builtin$$Mul$op_mul$6$(acc, $10L);
            read_index = read_index + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        break;
      }
      const _tmp = self.digits;
      const _tmp$2 = read_index;
      $bound_check(_tmp, _tmp$2);
      const d = _tmp[_tmp$2];
      acc = moonbitlang$core$builtin$$Add$op_add$6$(moonbitlang$core$builtin$$Mul$op_mul$6$(acc, $10L), moonbitlang$core$byte$$Byte$to_int64(d));
      read_index = read_index + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  self.decimal_point = self.decimal_point - (read_index - 1 | 0) | 0;
  const mask = moonbitlang$core$builtin$$Sub$op_sub$6$(moonbitlang$core$builtin$$Shl$op_shl$6$($1L, s), $1L);
  while (true) {
    if (read_index < self.digits_num) {
      const out = moonbitlang$core$builtin$$Shr$op_shr$6$(acc, s);
      const _tmp = self.digits;
      const _tmp$2 = write_index;
      $bound_check(_tmp, _tmp$2);
      _tmp[_tmp$2] = moonbitlang$core$uint64$$UInt64$to_byte(out);
      write_index = write_index + 1 | 0;
      acc = moonbitlang$core$builtin$$BitAnd$land$6$(acc, mask);
      const _tmp$3 = self.digits;
      const _tmp$4 = read_index;
      $bound_check(_tmp$3, _tmp$4);
      const d = _tmp$3[_tmp$4];
      acc = moonbitlang$core$builtin$$Add$op_add$6$(moonbitlang$core$builtin$$Mul$op_mul$6$(acc, $10L), moonbitlang$core$byte$$Byte$to_int64(d));
      read_index = read_index + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    if (moonbitlang$core$builtin$$op_gt$6$(acc, $0L)) {
      const out = moonbitlang$core$builtin$$Shr$op_shr$6$(acc, s);
      if (write_index < self.digits.length) {
        const _tmp = self.digits;
        const _tmp$2 = write_index;
        $bound_check(_tmp, _tmp$2);
        _tmp[_tmp$2] = moonbitlang$core$uint64$$UInt64$to_byte(out);
        write_index = write_index + 1 | 0;
      } else {
        if (moonbitlang$core$builtin$$op_gt$6$(out, $0L)) {
          self.truncated = true;
        }
      }
      acc = moonbitlang$core$builtin$$BitAnd$land$6$(acc, mask);
      acc = moonbitlang$core$builtin$$Mul$op_mul$6$(acc, $10L);
      continue;
    } else {
      break;
    }
  }
  self.digits_num = write_index;
  moonbitlang$core$strconv$$Decimal$trim(self);
}
function moonbitlang$core$strconv$$Decimal$shift_priv(self, s) {
  if (self.digits_num === 0) {
    return undefined;
  }
  let s$2 = s;
  if (s$2 > 0) {
    while (true) {
      if (s$2 > 59) {
        moonbitlang$core$strconv$$Decimal$left_shift(self, 59);
        s$2 = s$2 - 59 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$strconv$$Decimal$left_shift(self, s$2);
  }
  if (s$2 < 0) {
    while (true) {
      if (s$2 < -59) {
        moonbitlang$core$strconv$$Decimal$right_shift(self, 59);
        s$2 = s$2 + 59 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$strconv$$Decimal$right_shift(self, -s$2);
    return;
  } else {
    return;
  }
}
function moonbitlang$core$strconv$$Decimal$to_double_priv(self) {
  let exponent = 0;
  let mantissa = $0L;
  if (self.digits_num === 0 || self.decimal_point < -330) {
    mantissa = $0L;
    exponent = moonbitlang$core$strconv$$double_info.bias;
    const bits = moonbitlang$core$strconv$$assemble_bits(mantissa, exponent, self.negative);
    return new Result$Ok$52$(moonbitlang$core$int64$$Int64$reinterpret_as_double(bits));
  }
  if (self.decimal_point > 310) {
    const _bind = moonbitlang$core$strconv$$range_err$12$();
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  while (true) {
    if (self.decimal_point > 0) {
      let n = 0;
      if (self.decimal_point >= moonbitlang$core$strconv$$powtab.length) {
        n = 60;
      } else {
        n = moonbitlang$core$array$$Array$op_get$7$(moonbitlang$core$strconv$$powtab, self.decimal_point);
      }
      moonbitlang$core$strconv$$Decimal$shift_priv(self, -n);
      exponent = exponent + n | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    let _tmp;
    if (self.decimal_point < 0) {
      _tmp = true;
    } else {
      let _tmp$2;
      if (self.decimal_point === 0) {
        const _tmp$3 = self.digits;
        $bound_check(_tmp$3, 0);
        _tmp$2 = _tmp$3[0] < 5;
      } else {
        _tmp$2 = false;
      }
      _tmp = _tmp$2;
    }
    if (_tmp) {
      let n = 0;
      if (-self.decimal_point >= moonbitlang$core$strconv$$powtab.length) {
        n = 60;
      } else {
        n = moonbitlang$core$array$$Array$op_get$7$(moonbitlang$core$strconv$$powtab, -self.decimal_point);
      }
      moonbitlang$core$strconv$$Decimal$shift_priv(self, n);
      exponent = exponent - n | 0;
      continue;
    } else {
      break;
    }
  }
  exponent = exponent - 1 | 0;
  if (exponent < (moonbitlang$core$strconv$$double_info.bias + 1 | 0)) {
    const n = (moonbitlang$core$strconv$$double_info.bias + 1 | 0) - exponent | 0;
    moonbitlang$core$strconv$$Decimal$shift_priv(self, -n);
    exponent = exponent + n | 0;
  }
  if ((exponent - moonbitlang$core$strconv$$double_info.bias | 0) >= ((1 << moonbitlang$core$strconv$$double_info.exponent_bits) - 1 | 0)) {
    const _bind = moonbitlang$core$strconv$$range_err$12$();
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  moonbitlang$core$strconv$$Decimal$shift_priv(self, moonbitlang$core$strconv$$double_info.mantissa_bits + 1 | 0);
  mantissa = moonbitlang$core$strconv$$Decimal$rounded_integer(self);
  if (moonbitlang$core$builtin$$Eq$op_equal$232$(mantissa, moonbitlang$core$builtin$$Shl$op_shl$232$($2L, moonbitlang$core$strconv$$double_info.mantissa_bits))) {
    mantissa = moonbitlang$core$builtin$$Shl$op_shl$232$(mantissa, 1);
    exponent = exponent + 1 | 0;
    if ((exponent - moonbitlang$core$strconv$$double_info.bias | 0) >= ((1 << moonbitlang$core$strconv$$double_info.exponent_bits) - 1 | 0)) {
      const _bind = moonbitlang$core$strconv$$range_err$12$();
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        return _bind;
      }
    }
  }
  if (moonbitlang$core$builtin$$Eq$op_equal$232$(moonbitlang$core$builtin$$BitAnd$land$232$(mantissa, moonbitlang$core$builtin$$Shl$op_shl$232$($1L, moonbitlang$core$strconv$$double_info.mantissa_bits)), $0L)) {
    exponent = moonbitlang$core$strconv$$double_info.bias;
  }
  const bits = moonbitlang$core$strconv$$assemble_bits(mantissa, exponent, self.negative);
  return new Result$Ok$52$(moonbitlang$core$int64$$Int64$reinterpret_as_double(bits));
}
function moonbitlang$core$strconv$$checked_mul(a, b) {
  if (moonbitlang$core$builtin$$Eq$op_equal$6$(a, $0L) || moonbitlang$core$builtin$$Eq$op_equal$6$(b, $0L)) {
    return $0L;
  }
  if (moonbitlang$core$builtin$$Eq$op_equal$6$(a, $1L)) {
    return b;
  }
  if (moonbitlang$core$builtin$$Eq$op_equal$6$(b, $1L)) {
    return a;
  }
  if (moonbitlang$core$builtin$$op_lt$6$(b, $0L) || moonbitlang$core$builtin$$op_lt$6$(a, $0L)) {
    return undefined;
  }
  const r = moonbitlang$core$builtin$$Div$op_div$6$(moonbitlang$core$uint64$$max_value, b);
  const q = moonbitlang$core$builtin$$Div$op_div$6$($1L, b);
  if (moonbitlang$core$builtin$$op_lt$6$(moonbitlang$core$builtin$$Add$op_add$6$(moonbitlang$core$builtin$$Add$op_add$6$(r, r), q), a)) {
    return undefined;
  }
  return moonbitlang$core$builtin$$Mul$op_mul$6$(a, b);
}
function moonbitlang$core$strconv$$pow10_fast_path(exponent) {
  return moonbitlang$core$array$$Array$op_get$73$(moonbitlang$core$strconv$$table, exponent & 31);
}
function moonbitlang$core$strconv$$Number$is_fast_path(self) {
  return moonbitlang$core$builtin$$op_le$232$(moonbitlang$core$strconv$$min_exponent_fast_path, self.exponent) && (moonbitlang$core$builtin$$op_le$232$(self.exponent, moonbitlang$core$strconv$$max_exponent_disguised_fast_path) && (moonbitlang$core$builtin$$op_le$6$(self.mantissa, moonbitlang$core$strconv$$max_mantissa_fast_path) && !self.many_digits));
}
function moonbitlang$core$strconv$$Number$try_fast_path(self) {
  if (moonbitlang$core$strconv$$Number$is_fast_path(self)) {
    let value;
    if (moonbitlang$core$builtin$$op_le$232$(self.exponent, moonbitlang$core$strconv$$max_exponent_fast_path)) {
      const value$2 = moonbitlang$core$double$$Double$convert_uint64(self.mantissa);
      value = moonbitlang$core$builtin$$op_lt$232$(self.exponent, $0L) ? value$2 / moonbitlang$core$strconv$$pow10_fast_path(-moonbitlang$core$int64$$Int64$to_int(self.exponent)) : value$2 * moonbitlang$core$strconv$$pow10_fast_path(moonbitlang$core$int64$$Int64$to_int(self.exponent));
    } else {
      const shift = moonbitlang$core$builtin$$Sub$op_sub$232$(self.exponent, moonbitlang$core$strconv$$max_exponent_fast_path);
      const _bind = moonbitlang$core$strconv$$checked_mul(self.mantissa, moonbitlang$core$array$$Array$op_get$6$(moonbitlang$core$strconv$$int_pow10, moonbitlang$core$int64$$Int64$to_int(shift)));
      let mantissa;
      if (_bind === undefined) {
        return Option$None$53$;
      } else {
        const _Some = _bind;
        const _m = _Some;
        mantissa = _m;
      }
      if (moonbitlang$core$builtin$$op_gt$6$(mantissa, moonbitlang$core$strconv$$max_mantissa_fast_path)) {
        return Option$None$53$;
      }
      value = moonbitlang$core$double$$Double$convert_uint64(mantissa) * moonbitlang$core$strconv$$pow10_fast_path(moonbitlang$core$int64$$Int64$to_int(moonbitlang$core$strconv$$max_exponent_fast_path));
    }
    if (self.negative) {
      value = -value;
    }
    return new Option$Some$53$(value);
  } else {
    return Option$None$53$;
  }
}
function moonbitlang$core$strconv$$parse_double(str) {
  if (str.length === 0) {
    const _bind = moonbitlang$core$strconv$$syntax_err$12$();
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  if (!moonbitlang$core$strconv$$check_underscore(str)) {
    const _bind = moonbitlang$core$strconv$$syntax_err$12$();
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  const _bind = moonbitlang$core$strconv$$parse_number(str);
  let _bind$2;
  if (_bind === undefined) {
    const _bind$3 = moonbitlang$core$strconv$$parse_inf_nan(str);
    if (_bind$3 === undefined) {
      const _bind$4 = moonbitlang$core$strconv$$syntax_err$347$();
      if (_bind$4.$tag === 1) {
        const _ok = _bind$4;
        _bind$2 = _ok._0;
      } else {
        return _bind$4;
      }
    } else {
      const _Some = _bind$3;
      const _x = _Some;
      const _num = _x._0;
      const _consumed = _x._1;
      if (str.length !== _consumed) {
        const _bind$4 = moonbitlang$core$strconv$$syntax_err$347$();
        if (_bind$4.$tag === 1) {
          const _ok = _bind$4;
          _bind$2 = _ok._0;
        } else {
          return _bind$4;
        }
      } else {
        return new Result$Ok$52$(_num);
      }
    }
  } else {
    const _Some = _bind;
    const _r = _Some;
    _bind$2 = _r;
  }
  const _num = _bind$2._0;
  const _consumed = _bind$2._1;
  if (str.length !== _consumed) {
    const _bind$3 = moonbitlang$core$strconv$$syntax_err$12$();
    if (_bind$3.$tag === 1) {
      const _ok = _bind$3;
      _ok._0;
    } else {
      return _bind$3;
    }
  }
  const _bind$3 = moonbitlang$core$strconv$$Number$try_fast_path(_num);
  if (_bind$3.$tag === 1) {
    const _Some = _bind$3;
    const _value = _Some._0;
    return new Result$Ok$52$(_value);
  } else {
    const _bind$4 = moonbitlang$core$strconv$$parse_decimal_priv(str);
    let ret;
    if (_bind$4.$tag === 1) {
      const _ok = _bind$4;
      ret = _ok._0;
    } else {
      return _bind$4;
    }
    return moonbitlang$core$strconv$$Decimal$to_double_priv(ret);
  }
}
function moonbitlang$core$strconv$$base_err$349$() {
  return new Result$Err$54$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$base_err_str));
}
function moonbitlang$core$strconv$$check_and_consume_base(view, base) {
  if (base === 0) {
    _L: {
      let rest;
      _L$2: {
        let rest$2;
        _L$3: {
          let rest$3;
          _L$4: {
            if (moonbitlang$core$string$$String$char_length_ge(view.str, 2, view.start, view.end)) {
              const _x = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char(view.str, 0, view.start, view.end));
              if (_x === 48) {
                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char(view.str, 1, view.start, view.end));
                switch (_x$2) {
                  case 120: {
                    const _tmp = view.str;
                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$2;
                    if (_bind === undefined) {
                      _tmp$2 = view.end;
                    } else {
                      const _Some = _bind;
                      _tmp$2 = _Some;
                    }
                    const _tmp$3 = _tmp$2;
                    const _x$3 = { str: _tmp, start: _tmp$3, end: view.end };
                    rest$3 = _x$3;
                    break _L$4;
                  }
                  case 88: {
                    const _tmp$4 = view.str;
                    const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$5;
                    if (_bind$2 === undefined) {
                      _tmp$5 = view.end;
                    } else {
                      const _Some = _bind$2;
                      _tmp$5 = _Some;
                    }
                    const _tmp$6 = _tmp$5;
                    const _x$4 = { str: _tmp$4, start: _tmp$6, end: view.end };
                    rest$3 = _x$4;
                    break _L$4;
                  }
                  case 111: {
                    const _tmp$7 = view.str;
                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$8;
                    if (_bind$3 === undefined) {
                      _tmp$8 = view.end;
                    } else {
                      const _Some = _bind$3;
                      _tmp$8 = _Some;
                    }
                    const _tmp$9 = _tmp$8;
                    const _x$5 = { str: _tmp$7, start: _tmp$9, end: view.end };
                    rest$2 = _x$5;
                    break _L$3;
                  }
                  case 79: {
                    const _tmp$10 = view.str;
                    const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$11;
                    if (_bind$4 === undefined) {
                      _tmp$11 = view.end;
                    } else {
                      const _Some = _bind$4;
                      _tmp$11 = _Some;
                    }
                    const _tmp$12 = _tmp$11;
                    const _x$6 = { str: _tmp$10, start: _tmp$12, end: view.end };
                    rest$2 = _x$6;
                    break _L$3;
                  }
                  case 98: {
                    const _tmp$13 = view.str;
                    const _bind$5 = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$14;
                    if (_bind$5 === undefined) {
                      _tmp$14 = view.end;
                    } else {
                      const _Some = _bind$5;
                      _tmp$14 = _Some;
                    }
                    const _tmp$15 = _tmp$14;
                    const _x$7 = { str: _tmp$13, start: _tmp$15, end: view.end };
                    rest = _x$7;
                    break _L$2;
                  }
                  case 66: {
                    const _tmp$16 = view.str;
                    const _bind$6 = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$17;
                    if (_bind$6 === undefined) {
                      _tmp$17 = view.end;
                    } else {
                      const _Some = _bind$6;
                      _tmp$17 = _Some;
                    }
                    const _tmp$18 = _tmp$17;
                    const _x$8 = { str: _tmp$16, start: _tmp$18, end: view.end };
                    rest = _x$8;
                    break _L$2;
                  }
                  default: {
                    break _L;
                  }
                }
              } else {
                break _L;
              }
            } else {
              break _L;
            }
          }
          return new Result$Ok$54$({ _0: 16, _1: rest$3, _2: true });
        }
        return new Result$Ok$54$({ _0: 8, _1: rest$2, _2: true });
      }
      return new Result$Ok$54$({ _0: 2, _1: rest, _2: true });
    }
    return new Result$Ok$54$({ _0: 10, _1: view, _2: false });
  } else {
    _L: {
      let rest;
      _L$2: {
        let rest$2;
        _L$3: {
          let rest$3;
          _L$4: {
            if (moonbitlang$core$string$$String$char_length_ge(view.str, 2, view.start, view.end)) {
              const _x = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char(view.str, 0, view.start, view.end));
              if (_x === 48) {
                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char(view.str, 1, view.start, view.end));
                switch (_x$2) {
                  case 120: {
                    const _tmp = view.str;
                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$2;
                    if (_bind === undefined) {
                      _tmp$2 = view.end;
                    } else {
                      const _Some = _bind;
                      _tmp$2 = _Some;
                    }
                    const _tmp$3 = _tmp$2;
                    const _x$3 = { str: _tmp, start: _tmp$3, end: view.end };
                    if (base === 16) {
                      rest$3 = _x$3;
                      break _L$4;
                    } else {
                      break _L;
                    }
                  }
                  case 88: {
                    const _tmp$4 = view.str;
                    const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$5;
                    if (_bind$2 === undefined) {
                      _tmp$5 = view.end;
                    } else {
                      const _Some = _bind$2;
                      _tmp$5 = _Some;
                    }
                    const _tmp$6 = _tmp$5;
                    const _x$4 = { str: _tmp$4, start: _tmp$6, end: view.end };
                    if (base === 16) {
                      rest$3 = _x$4;
                      break _L$4;
                    } else {
                      break _L;
                    }
                  }
                  case 111: {
                    const _tmp$7 = view.str;
                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$8;
                    if (_bind$3 === undefined) {
                      _tmp$8 = view.end;
                    } else {
                      const _Some = _bind$3;
                      _tmp$8 = _Some;
                    }
                    const _tmp$9 = _tmp$8;
                    const _x$5 = { str: _tmp$7, start: _tmp$9, end: view.end };
                    if (base === 8) {
                      rest$2 = _x$5;
                      break _L$3;
                    } else {
                      break _L;
                    }
                  }
                  case 79: {
                    const _tmp$10 = view.str;
                    const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$11;
                    if (_bind$4 === undefined) {
                      _tmp$11 = view.end;
                    } else {
                      const _Some = _bind$4;
                      _tmp$11 = _Some;
                    }
                    const _tmp$12 = _tmp$11;
                    const _x$6 = { str: _tmp$10, start: _tmp$12, end: view.end };
                    if (base === 8) {
                      rest$2 = _x$6;
                      break _L$3;
                    } else {
                      break _L;
                    }
                  }
                  case 98: {
                    const _tmp$13 = view.str;
                    const _bind$5 = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$14;
                    if (_bind$5 === undefined) {
                      _tmp$14 = view.end;
                    } else {
                      const _Some = _bind$5;
                      _tmp$14 = _Some;
                    }
                    const _tmp$15 = _tmp$14;
                    const _x$7 = { str: _tmp$13, start: _tmp$15, end: view.end };
                    if (base === 2) {
                      rest = _x$7;
                      break _L$2;
                    } else {
                      break _L;
                    }
                  }
                  case 66: {
                    const _tmp$16 = view.str;
                    const _bind$6 = moonbitlang$core$string$$String$offset_of_nth_char(view.str, 2, view.start, view.end);
                    let _tmp$17;
                    if (_bind$6 === undefined) {
                      _tmp$17 = view.end;
                    } else {
                      const _Some = _bind$6;
                      _tmp$17 = _Some;
                    }
                    const _tmp$18 = _tmp$17;
                    const _x$8 = { str: _tmp$16, start: _tmp$18, end: view.end };
                    if (base === 2) {
                      rest = _x$8;
                      break _L$2;
                    } else {
                      break _L;
                    }
                  }
                  default: {
                    break _L;
                  }
                }
              } else {
                break _L;
              }
            } else {
              break _L;
            }
          }
          return new Result$Ok$54$({ _0: 16, _1: rest$3, _2: true });
        }
        return new Result$Ok$54$({ _0: 8, _1: rest$2, _2: true });
      }
      return new Result$Ok$54$({ _0: 2, _1: rest, _2: true });
    }
    return base >= 2 && base <= 36 ? new Result$Ok$54$({ _0: base, _1: view, _2: false }) : moonbitlang$core$strconv$$base_err$349$();
  }
}
function moonbitlang$core$strconv$$overflow_threshold(base, neg) {
  return !neg ? (base === 10 ? moonbitlang$core$builtin$$Add$op_add$232$(moonbitlang$core$builtin$$Div$op_div$232$($9223372036854775807L, $10L), $1L) : base === 16 ? moonbitlang$core$builtin$$Add$op_add$232$(moonbitlang$core$builtin$$Div$op_div$232$($9223372036854775807L, $16L), $1L) : moonbitlang$core$builtin$$Add$op_add$232$(moonbitlang$core$builtin$$Div$op_div$232$($9223372036854775807L, moonbitlang$core$int$$Int$to_int64(base)), $1L)) : base === 10 ? moonbitlang$core$builtin$$Div$op_div$232$($_9223372036854775808L, $10L) : base === 16 ? moonbitlang$core$builtin$$Div$op_div$232$($_9223372036854775808L, $16L) : moonbitlang$core$builtin$$Div$op_div$232$($_9223372036854775808L, moonbitlang$core$int$$Int$to_int64(base));
}
function moonbitlang$core$strconv$$parse_int64(str, base) {
  if (moonbitlang$core$builtin$$op_notequal$9$(str, "")) {
    let _bind;
    let rest;
    _L: {
      _L$2: {
        const _arg = moonbitlang$core$string$$String$view$46$start_offset$46$default();
        const _arg$2 = moonbitlang$core$string$$String$view$46$end_offset$46$default(str);
        const _bind$2 = moonbitlang$core$string$$String$view(str, _arg, _arg$2);
        if (moonbitlang$core$string$$String$char_length_ge(_bind$2.str, 1, _bind$2.start, _bind$2.end)) {
          const _x = moonbitlang$core$string$$String$unsafe_char_at(_bind$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_bind$2.str, 0, _bind$2.start, _bind$2.end));
          switch (_x) {
            case 43: {
              const _tmp = _bind$2.str;
              const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_bind$2.str, 1, _bind$2.start, _bind$2.end);
              let _tmp$2;
              if (_bind$3 === undefined) {
                _tmp$2 = _bind$2.end;
              } else {
                const _Some = _bind$3;
                _tmp$2 = _Some;
              }
              const _tmp$3 = _tmp$2;
              const _x$2 = { str: _tmp, start: _tmp$3, end: _bind$2.end };
              _bind = { _0: false, _1: _x$2 };
              break;
            }
            case 45: {
              const _tmp$4 = _bind$2.str;
              const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char(_bind$2.str, 1, _bind$2.start, _bind$2.end);
              let _tmp$5;
              if (_bind$4 === undefined) {
                _tmp$5 = _bind$2.end;
              } else {
                const _Some = _bind$4;
                _tmp$5 = _Some;
              }
              const _tmp$6 = _tmp$5;
              const _x$3 = { str: _tmp$4, start: _tmp$6, end: _bind$2.end };
              _bind = { _0: true, _1: _x$3 };
              break;
            }
            default: {
              rest = _bind$2;
              break _L$2;
            }
          }
        } else {
          rest = _bind$2;
          break _L$2;
        }
        break _L;
      }
      _bind = { _0: false, _1: rest };
    }
    const _neg = _bind._0;
    const _rest = _bind._1;
    const _bind$2 = moonbitlang$core$strconv$$check_and_consume_base(_rest, base);
    let _bind$3;
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _bind$3 = _ok._0;
    } else {
      return _bind$2;
    }
    const _num_base = _bind$3._0;
    const _rest$2 = _bind$3._1;
    const _allow_underscore = _bind$3._2;
    const overflow_threshold = moonbitlang$core$strconv$$overflow_threshold(_num_base, _neg);
    let has_digit;
    if (moonbitlang$core$string$$String$char_length_ge(_rest$2.str, 1, _rest$2.start, _rest$2.end)) {
      const _x = moonbitlang$core$string$$String$unsafe_char_at(_rest$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_rest$2.str, 0, _rest$2.start, _rest$2.end));
      if (_x >= 48 && _x <= 57) {
        has_digit = true;
      } else {
        if (_x >= 97 && _x <= 122) {
          has_digit = true;
        } else {
          if (_x >= 65 && _x <= 90) {
            has_digit = true;
          } else {
            if (moonbitlang$core$string$$String$char_length_ge(_rest$2.str, 2, _rest$2.start, _rest$2.end)) {
              if (_x === 95) {
                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_rest$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_rest$2.str, 1, _rest$2.start, _rest$2.end));
                has_digit = _x$2 >= 48 && _x$2 <= 57 ? true : _x$2 >= 97 && _x$2 <= 122 ? true : _x$2 >= 65 && _x$2 <= 90;
              } else {
                has_digit = false;
              }
            } else {
              has_digit = false;
            }
          }
        }
      }
    } else {
      has_digit = false;
    }
    if (has_digit) {
      let _tmp;
      let _tmp$2 = _rest$2;
      let _tmp$3 = $0L;
      let _tmp$4 = _allow_underscore;
      while (true) {
        const _param = _tmp$2;
        const _param$2 = _tmp$3;
        const _param$3 = _tmp$4;
        let acc;
        let rest$2;
        let c;
        _L$2: {
          if (moonbitlang$core$string$$String$char_length_eq(_param.str, 1, _param.start, _param.end)) {
            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 0, _param.start, _param.end));
            if (_x === 95) {
              const _bind$4 = moonbitlang$core$strconv$$syntax_err$232$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            } else {
              const _tmp$5 = _param.str;
              const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
              let _tmp$6;
              if (_bind$4 === undefined) {
                _tmp$6 = _param.end;
              } else {
                const _Some = _bind$4;
                _tmp$6 = _Some;
              }
              const _tmp$7 = _tmp$6;
              const _x$2 = { str: _tmp$5, start: _tmp$7, end: _param.end };
              acc = _param$2;
              rest$2 = _x$2;
              c = _x;
              break _L$2;
            }
          } else {
            if (moonbitlang$core$string$$String$char_length_ge(_param.str, 1, _param.start, _param.end)) {
              const _x = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 0, _param.start, _param.end));
              if (_x === 95) {
                if (_param$3 === false) {
                  const _bind$4 = moonbitlang$core$strconv$$syntax_err$232$();
                  if (_bind$4.$tag === 1) {
                    const _ok = _bind$4;
                    _tmp = _ok._0;
                    break;
                  } else {
                    return _bind$4;
                  }
                } else {
                  const _tmp$5 = _param.str;
                  const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
                  let _tmp$6;
                  if (_bind$4 === undefined) {
                    _tmp$6 = _param.end;
                  } else {
                    const _Some = _bind$4;
                    _tmp$6 = _Some;
                  }
                  const _tmp$7 = _tmp$6;
                  const _x$2 = { str: _tmp$5, start: _tmp$7, end: _param.end };
                  _tmp$2 = _x$2;
                  _tmp$4 = false;
                  continue;
                }
              } else {
                const _tmp$5 = _param.str;
                const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char(_param.str, 1, _param.start, _param.end);
                let _tmp$6;
                if (_bind$4 === undefined) {
                  _tmp$6 = _param.end;
                } else {
                  const _Some = _bind$4;
                  _tmp$6 = _Some;
                }
                const _tmp$7 = _tmp$6;
                const _x$2 = { str: _tmp$5, start: _tmp$7, end: _param.end };
                acc = _param$2;
                rest$2 = _x$2;
                c = _x;
                break _L$2;
              }
            } else {
              _tmp = _param$2;
              break;
            }
          }
        }
        const c$2 = c;
        let d;
        if (c$2 >= 48 && c$2 <= 57) {
          d = c$2 - 48 | 0;
        } else {
          if (c$2 >= 97 && c$2 <= 122) {
            d = c$2 + -87 | 0;
          } else {
            if (c$2 >= 65 && c$2 <= 90) {
              d = c$2 + -55 | 0;
            } else {
              const _bind$4 = moonbitlang$core$strconv$$syntax_err$7$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                d = _ok._0;
              } else {
                return _bind$4;
              }
            }
          }
        }
        if (d < _num_base) {
          if (_neg) {
            if (moonbitlang$core$builtin$$op_ge$232$(acc, overflow_threshold)) {
              const next_acc = moonbitlang$core$builtin$$Sub$op_sub$232$(moonbitlang$core$builtin$$Mul$op_mul$232$(acc, moonbitlang$core$int$$Int$to_int64(_num_base)), moonbitlang$core$int$$Int$to_int64(d));
              if (moonbitlang$core$builtin$$op_le$232$(next_acc, acc)) {
                _tmp$2 = rest$2;
                _tmp$3 = next_acc;
                _tmp$4 = true;
                continue;
              } else {
                const _bind$4 = moonbitlang$core$strconv$$range_err$232$();
                if (_bind$4.$tag === 1) {
                  const _ok = _bind$4;
                  _tmp = _ok._0;
                  break;
                } else {
                  return _bind$4;
                }
              }
            } else {
              const _bind$4 = moonbitlang$core$strconv$$range_err$232$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            }
          } else {
            if (moonbitlang$core$builtin$$op_lt$232$(acc, overflow_threshold)) {
              const next_acc = moonbitlang$core$builtin$$Add$op_add$232$(moonbitlang$core$builtin$$Mul$op_mul$232$(acc, moonbitlang$core$int$$Int$to_int64(_num_base)), moonbitlang$core$int$$Int$to_int64(d));
              if (moonbitlang$core$builtin$$op_ge$232$(next_acc, acc)) {
                _tmp$2 = rest$2;
                _tmp$3 = next_acc;
                _tmp$4 = true;
                continue;
              } else {
                const _bind$4 = moonbitlang$core$strconv$$range_err$232$();
                if (_bind$4.$tag === 1) {
                  const _ok = _bind$4;
                  _tmp = _ok._0;
                  break;
                } else {
                  return _bind$4;
                }
              }
            } else {
              const _bind$4 = moonbitlang$core$strconv$$range_err$232$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            }
          }
        } else {
          const _bind$4 = moonbitlang$core$strconv$$syntax_err$232$();
          if (_bind$4.$tag === 1) {
            const _ok = _bind$4;
            _tmp = _ok._0;
            break;
          } else {
            return _bind$4;
          }
        }
      }
      return new Result$Ok$47$(_tmp);
    } else {
      return moonbitlang$core$strconv$$syntax_err$232$();
    }
  } else {
    return moonbitlang$core$strconv$$syntax_err$232$();
  }
}
function moonbitlang$core$strconv$$parse_int(str, base) {
  const _bind = moonbitlang$core$strconv$$parse_int64(str, base);
  let n;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    n = _ok._0;
  } else {
    return _bind;
  }
  if (moonbitlang$core$builtin$$op_lt$232$(n, moonbitlang$core$int$$Int$to_int64(-2147483648)) || moonbitlang$core$builtin$$op_gt$232$(n, moonbitlang$core$int$$Int$to_int64(2147483647))) {
    const _bind$2 = moonbitlang$core$strconv$$range_err$12$();
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _ok._0;
    } else {
      return _bind$2;
    }
  }
  return new Result$Ok$46$(moonbitlang$core$int64$$Int64$to_int(n));
}
function moonbitlang$core$strconv$$parse_int$46$base$46$default() {
  return 0;
}
function moonbitlang$core$builtin$$Show$output$328$(self, logger) {
  const _StrConvError = self;
  const _err = _StrConvError._0;
  logger.method_0(logger.self, _err);
}
function moonbitlang$core$array$$minimum(x, y) {
  return x > y ? y : x;
}
function moonbitlang$core$array$$get_limit(len) {
  let len$2 = len;
  let limit = 0;
  while (true) {
    if (len$2 > 0) {
      len$2 = len$2 / 2 | 0;
      limit = limit + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return limit;
}
function moonbitlang$core$array$$bubble_sort_by$24$(arr, cmp) {
  const _end581 = moonbitlang$core$array$$ArrayView$length$24$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end581) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$24$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$24$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$24$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$bubble_sort_by$26$(arr, cmp) {
  const _end581 = moonbitlang$core$array$$ArrayView$length$26$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end581) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$26$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$26$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$bubble_sort_by$28$(arr, cmp) {
  const _end581 = moonbitlang$core$array$$ArrayView$length$28$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end581) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$28$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$28$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$28$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$bubble_sort_by$30$(arr, cmp) {
  const _end581 = moonbitlang$core$array$$ArrayView$length$30$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end581) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$30$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$30$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$30$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$bubble_sort_by$32$(arr, cmp) {
  const _end581 = moonbitlang$core$array$$ArrayView$length$32$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end581) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$32$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$32$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$32$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$bubble_sort_by$34$(arr, cmp) {
  const _end581 = moonbitlang$core$array$$ArrayView$length$34$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end581) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$34$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$34$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$34$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$bubble_sort_by$36$(arr, cmp) {
  const _end581 = moonbitlang$core$array$$ArrayView$length$36$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end581) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$36$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$36$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$36$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$bubble_sort_by$38$(arr, cmp) {
  const _end581 = moonbitlang$core$array$$ArrayView$length$38$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end581) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$38$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$38$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$38$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$bubble_sort_by$40$(arr, cmp) {
  const _end581 = moonbitlang$core$array$$ArrayView$length$40$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end581) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$40$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$40$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$40$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$24$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$24$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$24$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$24$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$26$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$26$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$26$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$26$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$28$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$28$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$28$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$28$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$30$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$30$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$30$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$30$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$32$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$32$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$32$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$32$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$34$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$34$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$34$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$34$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$36$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$36$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$36$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$36$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$38$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$38$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$38$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$38$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$40$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$40$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$40$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$40$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4582(_env, a, b) {
  const cmp = _env._2;
  const arr = _env._1;
  const swaps = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$24$(arr, a), moonbitlang$core$array$$ArrayView$op_get$24$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$24$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4583(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4582(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4582(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4582(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot_by$24$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$24$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr, _2: cmp };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4583(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4583(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4583(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4583(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$24$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4602(_env, a, b) {
  const cmp = _env._2;
  const arr = _env._1;
  const swaps = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, a), moonbitlang$core$array$$ArrayView$op_get$26$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$26$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4603(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4602(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4602(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4602(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot_by$26$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$26$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr, _2: cmp };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4603(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4603(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4603(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4603(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$26$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4622(_env, a, b) {
  const cmp = _env._2;
  const arr = _env._1;
  const swaps = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$28$(arr, a), moonbitlang$core$array$$ArrayView$op_get$28$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$28$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4623(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4622(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4622(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4622(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot_by$28$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$28$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr, _2: cmp };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4623(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4623(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4623(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4623(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$28$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4642(_env, a, b) {
  const cmp = _env._2;
  const arr = _env._1;
  const swaps = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$30$(arr, a), moonbitlang$core$array$$ArrayView$op_get$30$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$30$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4643(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4642(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4642(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4642(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot_by$30$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$30$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr, _2: cmp };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4643(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4643(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4643(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4643(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$30$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4662(_env, a, b) {
  const cmp = _env._2;
  const arr = _env._1;
  const swaps = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$32$(arr, a), moonbitlang$core$array$$ArrayView$op_get$32$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$32$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4663(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4662(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4662(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4662(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot_by$32$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$32$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr, _2: cmp };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4663(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4663(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4663(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4663(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$32$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4682(_env, a, b) {
  const cmp = _env._2;
  const arr = _env._1;
  const swaps = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$34$(arr, a), moonbitlang$core$array$$ArrayView$op_get$34$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$34$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4683(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4682(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4682(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4682(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot_by$34$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$34$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr, _2: cmp };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4683(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4683(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4683(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4683(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$34$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4702(_env, a, b) {
  const cmp = _env._2;
  const arr = _env._1;
  const swaps = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$36$(arr, a), moonbitlang$core$array$$ArrayView$op_get$36$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$36$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4703(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4702(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4702(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4702(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot_by$36$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$36$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr, _2: cmp };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4703(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4703(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4703(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4703(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$36$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4722(_env, a, b) {
  const cmp = _env._2;
  const arr = _env._1;
  const swaps = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$38$(arr, a), moonbitlang$core$array$$ArrayView$op_get$38$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$38$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4723(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4722(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4722(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4722(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot_by$38$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$38$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr, _2: cmp };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4723(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4723(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4723(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4723(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$38$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4742(_env, a, b) {
  const cmp = _env._2;
  const arr = _env._1;
  const swaps = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$40$(arr, a), moonbitlang$core$array$$ArrayView$op_get$40$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$40$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4743(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4742(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4742(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$4742(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot_by$40$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$40$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr, _2: cmp };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4743(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4743(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4743(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$4743(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$40$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$sift_down_by$24$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$24$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$24$(arr, child), moonbitlang$core$array$$ArrayView$op_get$24$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$24$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$24$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$24$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$sift_down_by$26$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$26$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, child), moonbitlang$core$array$$ArrayView$op_get$26$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$26$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$26$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$sift_down_by$28$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$28$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$28$(arr, child), moonbitlang$core$array$$ArrayView$op_get$28$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$28$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$28$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$28$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$sift_down_by$30$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$30$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$30$(arr, child), moonbitlang$core$array$$ArrayView$op_get$30$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$30$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$30$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$30$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$sift_down_by$32$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$32$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$32$(arr, child), moonbitlang$core$array$$ArrayView$op_get$32$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$32$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$32$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$32$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$sift_down_by$34$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$34$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$34$(arr, child), moonbitlang$core$array$$ArrayView$op_get$34$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$34$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$34$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$34$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$sift_down_by$36$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$36$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$36$(arr, child), moonbitlang$core$array$$ArrayView$op_get$36$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$36$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$36$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$36$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$sift_down_by$38$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$38$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$38$(arr, child), moonbitlang$core$array$$ArrayView$op_get$38$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$38$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$38$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$38$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$sift_down_by$40$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$40$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$40$(arr, child), moonbitlang$core$array$$ArrayView$op_get$40$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$40$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$40$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$40$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$24$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$24$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$24$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$24$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$24$(moonbitlang$core$array$$ArrayView$op_as_view$24$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$26$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$26$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$26$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$26$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$26$(moonbitlang$core$array$$ArrayView$op_as_view$26$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$28$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$28$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$28$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$28$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$28$(moonbitlang$core$array$$ArrayView$op_as_view$28$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$30$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$30$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$30$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$30$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$30$(moonbitlang$core$array$$ArrayView$op_as_view$30$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$32$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$32$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$32$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$32$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$32$(moonbitlang$core$array$$ArrayView$op_as_view$32$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$34$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$34$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$34$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$34$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$34$(moonbitlang$core$array$$ArrayView$op_as_view$34$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$36$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$36$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$36$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$36$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$36$(moonbitlang$core$array$$ArrayView$op_as_view$36$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$38$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$38$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$38$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$38$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$38$(moonbitlang$core$array$$ArrayView$op_as_view$38$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$40$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$40$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$40$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$40$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$40$(moonbitlang$core$array$$ArrayView$op_as_view$40$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$partition_by$24$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$24$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$24$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$24$(arr, moonbitlang$core$array$$ArrayView$length$24$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end574 = moonbitlang$core$array$$ArrayView$length$24$(arr) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end574) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$24$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$24$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$24$(arr, i, moonbitlang$core$array$$ArrayView$length$24$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$partition_by$26$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$26$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$26$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$26$(arr, moonbitlang$core$array$$ArrayView$length$26$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end574 = moonbitlang$core$array$$ArrayView$length$26$(arr) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end574) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$26$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$26$(arr, i, moonbitlang$core$array$$ArrayView$length$26$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$partition_by$28$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$28$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$28$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$28$(arr, moonbitlang$core$array$$ArrayView$length$28$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end574 = moonbitlang$core$array$$ArrayView$length$28$(arr) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end574) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$28$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$28$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$28$(arr, i, moonbitlang$core$array$$ArrayView$length$28$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$partition_by$30$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$30$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$30$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$30$(arr, moonbitlang$core$array$$ArrayView$length$30$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end574 = moonbitlang$core$array$$ArrayView$length$30$(arr) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end574) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$30$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$30$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$30$(arr, i, moonbitlang$core$array$$ArrayView$length$30$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$partition_by$32$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$32$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$32$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$32$(arr, moonbitlang$core$array$$ArrayView$length$32$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end574 = moonbitlang$core$array$$ArrayView$length$32$(arr) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end574) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$32$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$32$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$32$(arr, i, moonbitlang$core$array$$ArrayView$length$32$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$partition_by$34$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$34$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$34$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$34$(arr, moonbitlang$core$array$$ArrayView$length$34$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end574 = moonbitlang$core$array$$ArrayView$length$34$(arr) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end574) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$34$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$34$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$34$(arr, i, moonbitlang$core$array$$ArrayView$length$34$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$partition_by$36$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$36$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$36$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$36$(arr, moonbitlang$core$array$$ArrayView$length$36$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end574 = moonbitlang$core$array$$ArrayView$length$36$(arr) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end574) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$36$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$36$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$36$(arr, i, moonbitlang$core$array$$ArrayView$length$36$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$partition_by$38$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$38$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$38$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$38$(arr, moonbitlang$core$array$$ArrayView$length$38$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end574 = moonbitlang$core$array$$ArrayView$length$38$(arr) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end574) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$38$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$38$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$38$(arr, i, moonbitlang$core$array$$ArrayView$length$38$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$partition_by$40$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$40$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$40$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$40$(arr, moonbitlang$core$array$$ArrayView$length$40$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end574 = moonbitlang$core$array$$ArrayView$length$40$(arr) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end574) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$40$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$40$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$40$(arr, i, moonbitlang$core$array$$ArrayView$length$40$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$try_bubble_sort_by$24$(arr, cmp) {
  let tries = 0;
  const _end591 = moonbitlang$core$array$$ArrayView$length$24$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end591) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$24$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$24$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$24$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$try_bubble_sort_by$26$(arr, cmp) {
  let tries = 0;
  const _end591 = moonbitlang$core$array$$ArrayView$length$26$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end591) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$26$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$26$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$try_bubble_sort_by$28$(arr, cmp) {
  let tries = 0;
  const _end591 = moonbitlang$core$array$$ArrayView$length$28$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end591) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$28$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$28$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$28$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$try_bubble_sort_by$30$(arr, cmp) {
  let tries = 0;
  const _end591 = moonbitlang$core$array$$ArrayView$length$30$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end591) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$30$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$30$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$30$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$try_bubble_sort_by$32$(arr, cmp) {
  let tries = 0;
  const _end591 = moonbitlang$core$array$$ArrayView$length$32$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end591) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$32$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$32$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$32$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$try_bubble_sort_by$34$(arr, cmp) {
  let tries = 0;
  const _end591 = moonbitlang$core$array$$ArrayView$length$34$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end591) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$34$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$34$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$34$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$try_bubble_sort_by$36$(arr, cmp) {
  let tries = 0;
  const _end591 = moonbitlang$core$array$$ArrayView$length$36$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end591) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$36$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$36$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$36$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$try_bubble_sort_by$38$(arr, cmp) {
  let tries = 0;
  const _end591 = moonbitlang$core$array$$ArrayView$length$38$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end591) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$38$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$38$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$38$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$try_bubble_sort_by$40$(arr, cmp) {
  let tries = 0;
  const _end591 = moonbitlang$core$array$$ArrayView$length$40$(arr);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end591) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$40$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$40$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$40$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$quick_sort_by$24$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$24$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$24$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$24$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$24$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$24$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$24$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    balanced = moonbitlang$core$array$$minimum(_pivot, len - _pivot | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$24$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$24$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$24$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$24$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$24$(arr$2, _pivot + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$24$(left) < moonbitlang$core$array$$ArrayView$length$24$(right)) {
      moonbitlang$core$array$$quick_sort_by$24$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$24$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$24$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$24$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$quick_sort_by$26$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$26$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$26$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$26$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$26$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$26$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$26$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    balanced = moonbitlang$core$array$$minimum(_pivot, len - _pivot | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$26$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$26$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$26$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$26$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$26$(arr$2, _pivot + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$26$(left) < moonbitlang$core$array$$ArrayView$length$26$(right)) {
      moonbitlang$core$array$$quick_sort_by$26$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$26$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$26$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$26$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$quick_sort_by$28$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$28$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$28$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$28$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$28$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$28$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$28$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    balanced = moonbitlang$core$array$$minimum(_pivot, len - _pivot | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$28$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$28$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$28$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$28$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$28$(arr$2, _pivot + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$28$(left) < moonbitlang$core$array$$ArrayView$length$28$(right)) {
      moonbitlang$core$array$$quick_sort_by$28$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$28$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$28$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$28$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$quick_sort_by$30$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$30$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$30$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$30$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$30$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$30$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$30$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    balanced = moonbitlang$core$array$$minimum(_pivot, len - _pivot | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$30$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$30$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$30$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$30$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$30$(arr$2, _pivot + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$30$(left) < moonbitlang$core$array$$ArrayView$length$30$(right)) {
      moonbitlang$core$array$$quick_sort_by$30$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$30$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$30$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$30$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$quick_sort_by$32$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$32$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$32$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$32$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$32$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$32$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$32$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    balanced = moonbitlang$core$array$$minimum(_pivot, len - _pivot | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$32$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$32$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$32$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$32$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$32$(arr$2, _pivot + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$32$(left) < moonbitlang$core$array$$ArrayView$length$32$(right)) {
      moonbitlang$core$array$$quick_sort_by$32$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$32$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$32$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$32$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$quick_sort_by$34$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$34$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$34$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$34$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$34$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$34$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$34$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    balanced = moonbitlang$core$array$$minimum(_pivot, len - _pivot | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$34$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$34$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$34$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$34$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$34$(arr$2, _pivot + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$34$(left) < moonbitlang$core$array$$ArrayView$length$34$(right)) {
      moonbitlang$core$array$$quick_sort_by$34$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$34$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$34$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$34$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$quick_sort_by$36$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$36$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$36$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$36$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$36$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$36$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$36$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    balanced = moonbitlang$core$array$$minimum(_pivot, len - _pivot | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$36$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$36$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$36$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$36$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$36$(arr$2, _pivot + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$36$(left) < moonbitlang$core$array$$ArrayView$length$36$(right)) {
      moonbitlang$core$array$$quick_sort_by$36$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$36$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$36$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$36$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$quick_sort_by$38$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$38$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$38$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$38$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$38$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$38$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$38$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    balanced = moonbitlang$core$array$$minimum(_pivot, len - _pivot | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$38$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$38$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$38$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$38$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$38$(arr$2, _pivot + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$38$(left) < moonbitlang$core$array$$ArrayView$length$38$(right)) {
      moonbitlang$core$array$$quick_sort_by$38$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$38$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$38$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$38$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$quick_sort_by$40$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$40$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$40$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$40$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$40$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$40$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$40$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    balanced = moonbitlang$core$array$$minimum(_pivot, len - _pivot | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$40$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$ArrayView$op_get$40$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$40$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$40$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$40$(arr$2, _pivot + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$40$(left) < moonbitlang$core$array$$ArrayView$length$40$(right)) {
      moonbitlang$core$array$$quick_sort_by$40$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$40$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$40$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$40$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$Array$sort_by$24$(self, cmp) {
  moonbitlang$core$array$$quick_sort_by$24$({ buf: self, start: 0, len: self.length }, cmp, undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$Array$sort_by$26$(self, cmp) {
  moonbitlang$core$array$$quick_sort_by$26$({ buf: self, start: 0, len: self.length }, cmp, undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$Array$sort_by$28$(self, cmp) {
  moonbitlang$core$array$$quick_sort_by$28$({ buf: self, start: 0, len: self.length }, cmp, undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$Array$sort_by$30$(self, cmp) {
  moonbitlang$core$array$$quick_sort_by$30$({ buf: self, start: 0, len: self.length }, cmp, undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$Array$sort_by$32$(self, cmp) {
  moonbitlang$core$array$$quick_sort_by$32$({ buf: self, start: 0, len: self.length }, cmp, undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$Array$sort_by$34$(self, cmp) {
  moonbitlang$core$array$$quick_sort_by$34$({ buf: self, start: 0, len: self.length }, cmp, undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$Array$sort_by$36$(self, cmp) {
  moonbitlang$core$array$$quick_sort_by$36$({ buf: self, start: 0, len: self.length }, cmp, undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$Array$sort_by$38$(self, cmp) {
  moonbitlang$core$array$$quick_sort_by$38$({ buf: self, start: 0, len: self.length }, cmp, undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$Array$sort_by$40$(self, cmp) {
  moonbitlang$core$array$$quick_sort_by$40$({ buf: self, start: 0, len: self.length }, cmp, undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$ArrayView$iter$16$(self) {
  return moonbitlang$core$builtin$$Iter$new$16$((yield_) => {
    const _len = moonbitlang$core$array$$ArrayView$length$16$(self);
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self.buf[self.start + _i | 0];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$makei$43$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = moonbitlang$core$array$$Array$make$43$(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        moonbitlang$core$array$$Array$op_set$43$(array, i, value(i));
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$ArrayView$map$350$(self, f) {
  if (moonbitlang$core$array$$ArrayView$length$43$(self) === 0) {
    return [];
  }
  return moonbitlang$core$array$$Array$makei$43$(moonbitlang$core$array$$ArrayView$length$43$(self), (i) => f(moonbitlang$core$array$$ArrayView$op_get$43$(self, i)));
}
function moonbitlang$core$array$$Array$push_iter$36$(self, iter) {
  iter((x) => {
    moonbitlang$core$array$$Array$push$36$(self, x);
    return 1;
  });
}
function moonbitlang$core$array$$Array$push_iter$23$(self, iter) {
  iter((x) => {
    moonbitlang$core$array$$Array$push$23$(self, x);
    return 1;
  });
}
function moonbitlang$core$array$$Array$push_iter$288$(self, iter) {
  iter((x) => {
    moonbitlang$core$array$$Array$push$288$(self, x);
    return 1;
  });
}
function moonbitlang$core$array$$Array$push_iter$51$(self, iter) {
  iter((x) => {
    moonbitlang$core$array$$Array$push$51$(self, x);
    return 1;
  });
}
function moonbitlang$core$array$$Array$filter_map$351$(self, f) {
  const result = [];
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = self[_i];
      const _bind = f(x);
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        moonbitlang$core$array$$Array$push$36$(result, _x);
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return result;
}
function moonbitlang$core$array$$Array$filter_map$352$(self, f) {
  const result = [];
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = self[_i];
      const _bind = f(x);
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        moonbitlang$core$array$$Array$push$38$(result, _x);
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return result;
}
function moonbitlang$core$array$$Array$last$288$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const _last = self[self.length - 1 | 0];
    return _last;
  }
}
function moonbitlang$core$array$$Array$last$238$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const _last = self[self.length - 1 | 0];
    return _last;
  }
}
function moonbitlang$core$array$$Array$last$278$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const _last = self[self.length - 1 | 0];
    return _last;
  }
}
function moonbitlang$core$array$$Array$last$93$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const _last = self[self.length - 1 | 0];
    return _last;
  }
}
function moonbitlang$core$array$$Array$last$198$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const _last = self[self.length - 1 | 0];
    return _last;
  }
}
function moonbitlang$core$array$$Array$last$306$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const _last = self[self.length - 1 | 0];
    return _last;
  }
}
function moonbitlang$core$array$$Array$last$239$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const _last = self[self.length - 1 | 0];
    return _last;
  }
}
function moonbitlang$core$array$$Array$last$108$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const _last = self[self.length - 1 | 0];
    return _last;
  }
}
function moonbitlang$core$array$$Array$last$307$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const _last = self[self.length - 1 | 0];
    return _last;
  }
}
function moonbitlang$core$array$$Array$join(self, separator) {
  return moonbitlang$core$string$$concat(self, separator);
}
function moonbitlang$core$math$$maximum$7$(x, y) {
  return x > y ? x : y;
}
function moonbitlang$core$math$$minimum$7$(x, y) {
  return x > y ? y : x;
}
function moonbitlang$core$immut$sorted_set$$T$size$22$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Node = self;
    const _size = _Node._2;
    return _size;
  }
}
function moonbitlang$core$immut$sorted_set$$T$size$9$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Node = self;
    const _size = _Node._2;
    return _size;
  }
}
function moonbitlang$core$immut$sorted_set$$create$22$(left, value, right) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$55$(left, right, (moonbitlang$core$immut$sorted_set$$T$size$22$(left) + moonbitlang$core$immut$sorted_set$$T$size$22$(right) | 0) + 1 | 0, value);
}
function moonbitlang$core$immut$sorted_set$$create$9$(left, value, right) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$56$(left, right, (moonbitlang$core$immut$sorted_set$$T$size$9$(left) + moonbitlang$core$immut$sorted_set$$T$size$9$(right) | 0) + 1 | 0, value);
}
function moonbitlang$core$immut$sorted_set$$balance$22$(left, value, right) {
  const left_size = moonbitlang$core$immut$sorted_set$$T$size$22$(left);
  const right_size = moonbitlang$core$immut$sorted_set$$T$size$22$(right);
  if ((left_size + right_size | 0) < 2) {
    return moonbitlang$core$immut$sorted_set$$create$22$(left, value, right);
  } else {
    if (left_size > (Math.imul(right_size, 5) | 0)) {
      if (left.$tag === 0) {
        return moonbitlang$core$abort$$abort$18$("balance: left is empty.");
      } else {
        const _Node = left;
        const _ll = _Node._0;
        const _lv = _Node._3;
        const _lr = _Node._1;
        if (moonbitlang$core$immut$sorted_set$$T$size$22$(_ll) >= moonbitlang$core$immut$sorted_set$$T$size$22$(_lr)) {
          return moonbitlang$core$immut$sorted_set$$create$22$(_ll, _lv, moonbitlang$core$immut$sorted_set$$create$22$(_lr, value, right));
        } else {
          if (_lr.$tag === 0) {
            return moonbitlang$core$abort$$abort$18$("balance: right left.right is empty.");
          } else {
            const _Node$2 = _lr;
            const _lrl = _Node$2._0;
            const _lrv = _Node$2._3;
            const _lrr = _Node$2._1;
            return moonbitlang$core$immut$sorted_set$$create$22$(moonbitlang$core$immut$sorted_set$$create$22$(_ll, _lv, _lrl), _lrv, moonbitlang$core$immut$sorted_set$$create$22$(_lrr, value, right));
          }
        }
      }
    } else {
      if (right_size > (Math.imul(left_size, 5) | 0)) {
        if (right.$tag === 0) {
          return moonbitlang$core$abort$$abort$18$("balance: right is empty");
        } else {
          const _Node = right;
          const _rl = _Node._0;
          const _rv = _Node._3;
          const _rr = _Node._1;
          if (moonbitlang$core$immut$sorted_set$$T$size$22$(_rr) >= moonbitlang$core$immut$sorted_set$$T$size$22$(_rl)) {
            return moonbitlang$core$immut$sorted_set$$create$22$(moonbitlang$core$immut$sorted_set$$create$22$(left, value, _rl), _rv, _rr);
          } else {
            if (_rl.$tag === 0) {
              return moonbitlang$core$abort$$abort$18$("balance: right.left is empty");
            } else {
              const _Node$2 = _rl;
              const _rll = _Node$2._0;
              const _rlv = _Node$2._3;
              const _rlr = _Node$2._1;
              return moonbitlang$core$immut$sorted_set$$create$22$(moonbitlang$core$immut$sorted_set$$create$22$(left, value, _rll), _rlv, moonbitlang$core$immut$sorted_set$$create$22$(_rlr, _rv, _rr));
            }
          }
        }
      } else {
        return moonbitlang$core$immut$sorted_set$$create$22$(left, value, right);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$balance$9$(left, value, right) {
  const left_size = moonbitlang$core$immut$sorted_set$$T$size$9$(left);
  const right_size = moonbitlang$core$immut$sorted_set$$T$size$9$(right);
  if ((left_size + right_size | 0) < 2) {
    return moonbitlang$core$immut$sorted_set$$create$9$(left, value, right);
  } else {
    if (left_size > (Math.imul(right_size, 5) | 0)) {
      if (left.$tag === 0) {
        return moonbitlang$core$abort$$abort$21$("balance: left is empty.");
      } else {
        const _Node = left;
        const _ll = _Node._0;
        const _lv = _Node._3;
        const _lr = _Node._1;
        if (moonbitlang$core$immut$sorted_set$$T$size$9$(_ll) >= moonbitlang$core$immut$sorted_set$$T$size$9$(_lr)) {
          return moonbitlang$core$immut$sorted_set$$create$9$(_ll, _lv, moonbitlang$core$immut$sorted_set$$create$9$(_lr, value, right));
        } else {
          if (_lr.$tag === 0) {
            return moonbitlang$core$abort$$abort$21$("balance: right left.right is empty.");
          } else {
            const _Node$2 = _lr;
            const _lrl = _Node$2._0;
            const _lrv = _Node$2._3;
            const _lrr = _Node$2._1;
            return moonbitlang$core$immut$sorted_set$$create$9$(moonbitlang$core$immut$sorted_set$$create$9$(_ll, _lv, _lrl), _lrv, moonbitlang$core$immut$sorted_set$$create$9$(_lrr, value, right));
          }
        }
      }
    } else {
      if (right_size > (Math.imul(left_size, 5) | 0)) {
        if (right.$tag === 0) {
          return moonbitlang$core$abort$$abort$21$("balance: right is empty");
        } else {
          const _Node = right;
          const _rl = _Node._0;
          const _rv = _Node._3;
          const _rr = _Node._1;
          if (moonbitlang$core$immut$sorted_set$$T$size$9$(_rr) >= moonbitlang$core$immut$sorted_set$$T$size$9$(_rl)) {
            return moonbitlang$core$immut$sorted_set$$create$9$(moonbitlang$core$immut$sorted_set$$create$9$(left, value, _rl), _rv, _rr);
          } else {
            if (_rl.$tag === 0) {
              return moonbitlang$core$abort$$abort$21$("balance: right.left is empty");
            } else {
              const _Node$2 = _rl;
              const _rll = _Node$2._0;
              const _rlv = _Node$2._3;
              const _rlr = _Node$2._1;
              return moonbitlang$core$immut$sorted_set$$create$9$(moonbitlang$core$immut$sorted_set$$create$9$(left, value, _rll), _rlv, moonbitlang$core$immut$sorted_set$$create$9$(_rlr, _rv, _rr));
            }
          }
        }
      } else {
        return moonbitlang$core$immut$sorted_set$$create$9$(left, value, right);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$add$22$(self, value) {
  if (self.$tag === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$55$($64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$55$, $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$55$, 1, value);
  } else {
    const _Node = self;
    const _left = _Node._0;
    const _right = _Node._1;
    const _node_value = _Node._3;
    const compare_result = moonbitlang$core$builtin$$Compare$compare$22$(value, _node_value);
    if (compare_result === 0) {
      return self;
    } else {
      if (compare_result < 0) {
        const ll = moonbitlang$core$immut$sorted_set$$T$add$22$(_left, value);
        return _left === ll ? self : moonbitlang$core$immut$sorted_set$$balance$22$(ll, _node_value, _right);
      } else {
        const rr = moonbitlang$core$immut$sorted_set$$T$add$22$(_right, value);
        return _right === rr ? self : moonbitlang$core$immut$sorted_set$$balance$22$(_left, _node_value, rr);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$add$9$(self, value) {
  if (self.$tag === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$56$($64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$56$, $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$56$, 1, value);
  } else {
    const _Node = self;
    const _left = _Node._0;
    const _right = _Node._1;
    const _node_value = _Node._3;
    const compare_result = moonbitlang$core$builtin$$Compare$compare$9$(value, _node_value);
    if (compare_result === 0) {
      return self;
    } else {
      if (compare_result < 0) {
        const ll = moonbitlang$core$immut$sorted_set$$T$add$9$(_left, value);
        return _left === ll ? self : moonbitlang$core$immut$sorted_set$$balance$9$(ll, _node_value, _right);
      } else {
        const rr = moonbitlang$core$immut$sorted_set$$T$add$9$(_right, value);
        return _right === rr ? self : moonbitlang$core$immut$sorted_set$$balance$9$(_left, _node_value, rr);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$new$22$() {
  return $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$55$;
}
function moonbitlang$core$immut$sorted_set$$new$9$() {
  return $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$56$;
}
function moonbitlang$core$immut$sorted_set$$T$remove_min$22$(self) {
  if (self.$tag === 0) {
    return moonbitlang$core$abort$$abort$18$("remove_min: empty ImmutableSet");
  } else {
    const _Node = self;
    const _left = _Node._0;
    const _right = _Node._1;
    const _value = _Node._3;
    if (_left.$tag === 0) {
      return _right;
    } else {
      return moonbitlang$core$immut$sorted_set$$balance$22$(moonbitlang$core$immut$sorted_set$$T$remove_min$22$(_left), _value, _right);
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$remove_min$9$(self) {
  if (self.$tag === 0) {
    return moonbitlang$core$abort$$abort$21$("remove_min: empty ImmutableSet");
  } else {
    const _Node = self;
    const _left = _Node._0;
    const _right = _Node._1;
    const _value = _Node._3;
    if (_left.$tag === 0) {
      return _right;
    } else {
      return moonbitlang$core$immut$sorted_set$$balance$9$(moonbitlang$core$immut$sorted_set$$T$remove_min$9$(_left), _value, _right);
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$min$22$(self) {
  let _tmp = self;
  while (true) {
    const self$2 = _tmp;
    if (self$2.$tag === 0) {
      return moonbitlang$core$abort$$abort$22$("min: there are no values in sorted_set.");
    } else {
      const _Node = self$2;
      const _left = _Node._0;
      const _value = _Node._3;
      if (_left.$tag === 0) {
        return _value;
      } else {
        _tmp = _left;
        continue;
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$min$9$(self) {
  let _tmp = self;
  while (true) {
    const self$2 = _tmp;
    if (self$2.$tag === 0) {
      return moonbitlang$core$abort$$abort$9$("min: there are no values in sorted_set.");
    } else {
      const _Node = self$2;
      const _left = _Node._0;
      const _value = _Node._3;
      if (_left.$tag === 0) {
        return _value;
      } else {
        _tmp = _left;
        continue;
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$merge$22$(self, other) {
  if (self.$tag === 0) {
    return other;
  } else {
    if (other.$tag === 0) {
      return self;
    } else {
      return moonbitlang$core$immut$sorted_set$$balance$22$(self, moonbitlang$core$immut$sorted_set$$T$min$22$(other), moonbitlang$core$immut$sorted_set$$T$remove_min$22$(other));
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$merge$9$(self, other) {
  if (self.$tag === 0) {
    return other;
  } else {
    if (other.$tag === 0) {
      return self;
    } else {
      return moonbitlang$core$immut$sorted_set$$balance$9$(self, moonbitlang$core$immut$sorted_set$$T$min$9$(other), moonbitlang$core$immut$sorted_set$$T$remove_min$9$(other));
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$remove$22$(self, value) {
  if (self.$tag === 0) {
    return $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$55$;
  } else {
    const _Node = self;
    const _left = _Node._0;
    const _right = _Node._1;
    const _node_value = _Node._3;
    const compare_result = moonbitlang$core$builtin$$Compare$compare$22$(value, _node_value);
    if (compare_result === 0) {
      return moonbitlang$core$immut$sorted_set$$T$merge$22$(_left, _right);
    } else {
      if (compare_result < 0) {
        const new_left = moonbitlang$core$immut$sorted_set$$T$remove$22$(_left, value);
        return _left === new_left ? self : moonbitlang$core$immut$sorted_set$$balance$22$(new_left, _node_value, _right);
      } else {
        const new_right = moonbitlang$core$immut$sorted_set$$T$remove$22$(_right, value);
        return _right === new_right ? self : moonbitlang$core$immut$sorted_set$$balance$22$(_left, _node_value, new_right);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$remove$9$(self, value) {
  if (self.$tag === 0) {
    return $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$56$;
  } else {
    const _Node = self;
    const _left = _Node._0;
    const _right = _Node._1;
    const _node_value = _Node._3;
    const compare_result = moonbitlang$core$builtin$$Compare$compare$9$(value, _node_value);
    if (compare_result === 0) {
      return moonbitlang$core$immut$sorted_set$$T$merge$9$(_left, _right);
    } else {
      if (compare_result < 0) {
        const new_left = moonbitlang$core$immut$sorted_set$$T$remove$9$(_left, value);
        return _left === new_left ? self : moonbitlang$core$immut$sorted_set$$balance$9$(new_left, _node_value, _right);
      } else {
        const new_right = moonbitlang$core$immut$sorted_set$$T$remove$9$(_right, value);
        return _right === new_right ? self : moonbitlang$core$immut$sorted_set$$balance$9$(_left, _node_value, new_right);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$contains$22$(self, value) {
  let _tmp = self;
  let _tmp$2 = value;
  while (true) {
    const self$2 = _tmp;
    const value$2 = _tmp$2;
    if (self$2.$tag === 0) {
      return false;
    } else {
      const _Node = self$2;
      const _left = _Node._0;
      const _right = _Node._1;
      const _node_value = _Node._3;
      const compare_result = moonbitlang$core$builtin$$Compare$compare$22$(value$2, _node_value);
      if (compare_result === 0) {
        return true;
      } else {
        _tmp = compare_result < 0 ? _left : _right;
        continue;
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$contains$9$(self, value) {
  let _tmp = self;
  let _tmp$2 = value;
  while (true) {
    const self$2 = _tmp;
    const value$2 = _tmp$2;
    if (self$2.$tag === 0) {
      return false;
    } else {
      const _Node = self$2;
      const _left = _Node._0;
      const _right = _Node._1;
      const _node_value = _Node._3;
      const compare_result = moonbitlang$core$builtin$$Compare$compare$9$(value$2, _node_value);
      if (compare_result === 0) {
        return true;
      } else {
        _tmp = compare_result < 0 ? _left : _right;
        continue;
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$T$size$291$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Tree = self;
    return _Tree._2;
  }
}
function moonbitlang$core$immut$sorted_map$$make_tree$291$(key, value, l, r) {
  const size = (moonbitlang$core$immut$sorted_map$$T$size$291$(l) + moonbitlang$core$immut$sorted_map$$T$size$291$(r) | 0) + 1 | 0;
  return new $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$57$(key, value, size, l, r);
}
function moonbitlang$core$immut$sorted_map$$balance$291$(key, value, l, r) {
  const ln = moonbitlang$core$immut$sorted_map$$T$size$291$(l);
  const rn = moonbitlang$core$immut$sorted_map$$T$size$291$(r);
  if ((ln + rn | 0) < 2) {
    return moonbitlang$core$immut$sorted_map$$make_tree$291$(key, value, l, r);
  } else {
    if (rn > (Math.imul(5, ln) | 0)) {
      if (r.$tag === 1) {
        const _Tree = r;
        const _rl = _Tree._3;
        const _rr = _Tree._4;
        const rln = moonbitlang$core$immut$sorted_map$$T$size$291$(_rl);
        const rrn = moonbitlang$core$immut$sorted_map$$T$size$291$(_rr);
        if (rln < rrn) {
          if (r.$tag === 1) {
            const _Tree$2 = r;
            const _k2 = _Tree$2._0;
            const _v2 = _Tree$2._1;
            const _y = _Tree$2._3;
            const _z = _Tree$2._4;
            return moonbitlang$core$immut$sorted_map$$make_tree$291$(_k2, _v2, moonbitlang$core$immut$sorted_map$$make_tree$291$(key, value, l, _y), _z);
          } else {
            return $panic();
          }
        } else {
          _L: {
            if (r.$tag === 1) {
              const _Tree$2 = r;
              const _k3 = _Tree$2._0;
              const _v3 = _Tree$2._1;
              const _x = _Tree$2._3;
              if (_x.$tag === 1) {
                const _Tree$3 = _x;
                const _k2 = _Tree$3._0;
                const _v2 = _Tree$3._1;
                const _y1 = _Tree$3._3;
                const _y2 = _Tree$3._4;
                const _z = _Tree$2._4;
                return moonbitlang$core$immut$sorted_map$$make_tree$291$(_k2, _v2, moonbitlang$core$immut$sorted_map$$make_tree$291$(key, value, l, _y1), moonbitlang$core$immut$sorted_map$$make_tree$291$(_k3, _v3, _y2, _z));
              } else {
                break _L;
              }
            } else {
              break _L;
            }
          }
          return $panic();
        }
      } else {
        return $panic();
      }
    } else {
      if (ln > (Math.imul(5, rn) | 0)) {
        if (l.$tag === 1) {
          const _Tree = l;
          const _ll = _Tree._3;
          const _lr = _Tree._4;
          const lln = moonbitlang$core$immut$sorted_map$$T$size$291$(_ll);
          const lrn = moonbitlang$core$immut$sorted_map$$T$size$291$(_lr);
          if (lrn < lln) {
            if (l.$tag === 1) {
              const _Tree$2 = l;
              const _k1 = _Tree$2._0;
              const _v1 = _Tree$2._1;
              const _x = _Tree$2._3;
              const _y = _Tree$2._4;
              return moonbitlang$core$immut$sorted_map$$make_tree$291$(_k1, _v1, _x, moonbitlang$core$immut$sorted_map$$make_tree$291$(key, value, _y, r));
            } else {
              return $panic();
            }
          } else {
            _L: {
              if (l.$tag === 1) {
                const _Tree$2 = l;
                const _k1 = _Tree$2._0;
                const _v1 = _Tree$2._1;
                const _x = _Tree$2._3;
                const _x$2 = _Tree$2._4;
                if (_x$2.$tag === 1) {
                  const _Tree$3 = _x$2;
                  const _k2 = _Tree$3._0;
                  const _v2 = _Tree$3._1;
                  const _y1 = _Tree$3._3;
                  const _y2 = _Tree$3._4;
                  return moonbitlang$core$immut$sorted_map$$make_tree$291$(_k2, _v2, moonbitlang$core$immut$sorted_map$$make_tree$291$(_k1, _v1, _x, _y1), moonbitlang$core$immut$sorted_map$$make_tree$291$(key, value, _y2, r));
                } else {
                  break _L;
                }
              } else {
                break _L;
              }
            }
            return $panic();
          }
        } else {
          return $panic();
        }
      } else {
        return moonbitlang$core$immut$sorted_map$$make_tree$291$(key, value, l, r);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$singleton$291$(key, value) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$57$(key, value, 1, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$57$, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$57$);
}
function moonbitlang$core$immut$sorted_map$$T$add$291$(self, key, value) {
  if (self.$tag === 0) {
    return moonbitlang$core$immut$sorted_map$$singleton$291$(key, value);
  } else {
    const _Tree = self;
    const _k = _Tree._0;
    const _v = _Tree._1;
    const _l = _Tree._3;
    const _r = _Tree._4;
    const c = moonbitlang$core$builtin$$Compare$compare$9$(key, _k);
    return c === 0 ? moonbitlang$core$immut$sorted_map$$make_tree$291$(_k, value, _l, _r) : c < 0 ? moonbitlang$core$immut$sorted_map$$balance$291$(_k, _v, moonbitlang$core$immut$sorted_map$$T$add$291$(_l, key, value), _r) : moonbitlang$core$immut$sorted_map$$balance$291$(_k, _v, _l, moonbitlang$core$immut$sorted_map$$T$add$291$(_r, key, value));
  }
}
function moonbitlang$core$immut$sorted_map$$from_array$291$(array) {
  let _tmp = 0;
  let _tmp$2 = $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$57$;
  while (true) {
    const i = _tmp;
    const mp = _tmp$2;
    if (i < array.length) {
      const _bind = moonbitlang$core$array$$Array$op_get$236$(array, i);
      const _k = _bind._0;
      const _v = _bind._1;
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = moonbitlang$core$immut$sorted_map$$T$add$291$(mp, _k, _v);
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    } else {
      return mp;
    }
  }
}
function moonbitlang$core$immut$sorted_map$$T$iter$291$(self) {
  return moonbitlang$core$builtin$$Iter$new$236$((yield_) => {
    if (self.$tag === 0) {
      return 1;
    } else {
      const _Tree = self;
      const _k = _Tree._0;
      const _value = _Tree._1;
      const _l = _Tree._3;
      const _r = _Tree._4;
      return moonbitlang$core$builtin$$Eq$op_equal$75$(moonbitlang$core$builtin$$Iter$run$236$(moonbitlang$core$immut$sorted_map$$T$iter$291$(_l), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$75$(yield_({ _0: _k, _1: _value }), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$75$(moonbitlang$core$builtin$$Iter$run$236$(moonbitlang$core$immut$sorted_map$$T$iter$291$(_r), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$immut$sorted_map$$T$is_empty$291$(self) {
  return moonbitlang$core$immut$sorted_map$$T$size$291$(self) === 0;
}
function moonbitlang$core$immut$sorted_map$$T$get$291$(self, key) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (_param.$tag === 0) {
      return undefined;
    } else {
      const _Tree = _param;
      const _k = _Tree._0;
      const _value = _Tree._1;
      const _l = _Tree._3;
      const _r = _Tree._4;
      const c = moonbitlang$core$builtin$$Compare$compare$9$(key, _k);
      if (c === 0) {
        return _value;
      } else {
        if (c < 0) {
          _tmp = _l;
          continue;
        } else {
          _tmp = _r;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$T$iter2$291$(self) {
  return moonbitlang$core$builtin$$Iter2$new$291$((yield_) => {
    if (self.$tag === 0) {
      return 1;
    } else {
      const _Tree = self;
      const _k = _Tree._0;
      const _value = _Tree._1;
      const _l = _Tree._3;
      const _r = _Tree._4;
      return moonbitlang$core$builtin$$Eq$op_equal$75$(moonbitlang$core$builtin$$Iter2$run$291$(moonbitlang$core$immut$sorted_map$$T$iter2$291$(_l), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$75$(yield_(_k, _value), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$75$(moonbitlang$core$builtin$$Iter2$run$291$(moonbitlang$core$immut$sorted_map$$T$iter2$291$(_r), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$immut$sorted_map$$T$elems$291$(self) {
  const _bind = moonbitlang$core$immut$sorted_map$$T$iter$291$(self);
  return moonbitlang$core$builtin$$Iter$collect$253$((_p) => _bind((_p$2) => {
    const _v = _p$2._1;
    return _p(_v);
  }));
}
function moonbitlang$core$immut$list$$T$rev_concat$305$(self, other) {
  let _tmp = self;
  let _tmp$2 = other;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if (_param.$tag === 0) {
      return _param$2;
    } else {
      const _Cons = _param;
      const _head = _Cons._0;
      const _tail = _Cons._1;
      const _tmp$3 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(_head, _param$2);
      _tmp = _tail;
      _tmp$2 = _tmp$3;
      continue;
    }
  }
}
function moonbitlang$core$immut$list$$T$rev_concat$10$(self, other) {
  let _tmp = self;
  let _tmp$2 = other;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if (_param.$tag === 0) {
      return _param$2;
    } else {
      const _Cons = _param;
      const _head = _Cons._0;
      const _tail = _Cons._1;
      const _tmp$3 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(_head, _param$2);
      _tmp = _tail;
      _tmp$2 = _tmp$3;
      continue;
    }
  }
}
function moonbitlang$core$immut$list$$T$rev$305$(self) {
  return moonbitlang$core$immut$list$$T$rev_concat$305$(self, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$58$);
}
function moonbitlang$core$immut$list$$T$rev$10$(self) {
  return moonbitlang$core$immut$list$$T$rev_concat$10$(self, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$);
}
function moonbitlang$core$immut$list$$T$iter$10$(self) {
  return moonbitlang$core$builtin$$Iter$new$10$((yield_) => {
    let _tmp = self;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        return 1;
      } else {
        const _Cons = _param;
        const _head = _Cons._0;
        const _tail = _Cons._1;
        if (moonbitlang$core$builtin$$Eq$op_equal$75$(yield_(_head), 0)) {
          return 0;
        }
        _tmp = _tail;
        continue;
      }
    }
  });
}
function moonbitlang$core$immut$list$$T$map$353$(self, f) {
  if (self.$tag === 0) {
    return $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$60$;
  } else {
    const _Cons = self;
    const _head = _Cons._0;
    const _tail = _Cons._1;
    return new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$60$(f(_head), moonbitlang$core$immut$list$$T$map$353$(_tail, f));
  }
}
function moonbitlang$core$immut$list$$T$to_array$23$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    const _xs = _Cons._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _Cons$2 = _param;
        const _x$2 = _Cons$2._0;
        const _xs$2 = _Cons$2._1;
        moonbitlang$core$array$$Array$push$23$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$immut$list$$T$to_array$305$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    const _xs = _Cons._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _Cons$2 = _param;
        const _x$2 = _Cons$2._0;
        const _xs$2 = _Cons$2._1;
        moonbitlang$core$array$$Array$push$305$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$bool$$Bool$to_int(self) {
  return self ? 1 : 0;
}
function moonbitlang$core$builtin$$Show$output$174$(self, logger) {
  logger.method_0(logger.self, Error$$to_string(self));
}
function moonbitlang$core$builtin$$Hash$hash$10$(self) {
  return self;
}
function moonbitlang$core$builtin$$Hash$hash_combine$10$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_char(hasher, self);
}
function moonbitlang$core$char$$Char$is_ascii(self) {
  return self >= 0 && self <= 127;
}
function moonbitlang$core$char$$Char$is_ascii_alphabetic(self) {
  return self >= 65 && self <= 90 ? true : self >= 97 && self <= 122;
}
function moonbitlang$core$char$$Char$is_ascii_digit(self) {
  return self >= 48 && self <= 57;
}
function moonbitlang$core$char$$Char$is_ascii_hexdigit(self) {
  return self >= 48 && self <= 57 ? true : self >= 65 && self <= 70 ? true : self >= 97 && self <= 102;
}
function moonbitlang$core$char$$Char$is_ascii_lowercase(self) {
  return self >= 97 && self <= 122;
}
function moonbitlang$core$char$$Char$is_ascii_uppercase(self) {
  return self >= 65 && self <= 90;
}
function moonbitlang$core$ref$$Ref$new$7$(x) {
  return { val: x };
}
function moonbitlang$core$ref$$Ref$new$354$(x) {
  return { val: x };
}
function moonbitlang$core$ref$$Ref$new$355$(x) {
  return { val: x };
}
function moonbitlang$core$ref$$Ref$new$356$(x) {
  return { val: x };
}
function moonbitlang$core$ref$$Ref$map$357$(self, f) {
  return { val: f(self.val) };
}
function moonbitlang$core$ref$$Ref$map$358$(self, f) {
  return { val: f(self.val) };
}
function moonbitlang$core$builtin$$Eq$op_equal$359$(_x_111, _x_112) {
  switch (_x_111.$tag) {
    case 0: {
      if (_x_112.$tag === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_112.$tag === 1) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      const _Other = _x_111;
      const _$42$x0_113 = _Other._0;
      if (_x_112.$tag === 2) {
        const _Other$2 = _x_112;
        const _$42$y0_114 = _Other$2._0;
        return _$42$x0_113 === _$42$y0_114;
      } else {
        return false;
      }
    }
  }
}
function Yoorkin$rabbit$45$tea$url$$Url$to_string(self) {
  const _bind = self.protocol;
  let protocol;
  switch (_bind.$tag) {
    case 0: {
      protocol = "http";
      break;
    }
    case 1: {
      protocol = "https";
      break;
    }
    default: {
      protocol = $panic();
    }
  }
  const _bind$2 = self.port;
  let port;
  if (_bind$2 === undefined) {
    port = "";
  } else {
    const _Some = _bind$2;
    const _p = _Some;
    port = `:${moonbitlang$core$builtin$$Show$to_string$7$(_p)}`;
  }
  const _bind$3 = self.query;
  let query;
  if (_bind$3 === undefined) {
    query = "";
  } else {
    const _Some = _bind$3;
    const _q = _Some;
    query = `?${moonbitlang$core$builtin$$Show$to_string$9$(_q)}`;
  }
  const _bind$4 = self.fragment;
  let fragment;
  if (_bind$4 === undefined) {
    fragment = "";
  } else {
    const _Some = _bind$4;
    const _f = _Some;
    fragment = `#${moonbitlang$core$builtin$$Show$to_string$9$(_f)}`;
  }
  return `${moonbitlang$core$builtin$$Show$to_string$9$(protocol)}://${moonbitlang$core$builtin$$Show$to_string$9$(self.host)}${moonbitlang$core$builtin$$Show$to_string$9$(port)}/${moonbitlang$core$builtin$$Show$to_string$9$(self.path)}${moonbitlang$core$builtin$$Show$to_string$9$(query)}${moonbitlang$core$builtin$$Show$to_string$9$(fragment)}`;
}
function Yoorkin$rabbit$45$tea$url$$parse(url) {
  let _bind;
  let x;
  let remain;
  _L: {
    _L$2: {
      const _bind$2 = moonbitlang$core$builtin$$Iter$collect$16$(moonbitlang$core$string$$String$split(url, { str: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$320, start: 0, end: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$320.length }));
      if (_bind$2.length === 2) {
        const _x = _bind$2[0];
        if (moonbitlang$core$string$$String$char_length_eq(_x.str, 4, _x.start, _x.end)) {
          const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 0, _x.start, _x.end));
          if (_x$2 === 104) {
            const _x$3 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 1, _x.start, _x.end));
            if (_x$3 === 116) {
              const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 2, _x.start, _x.end));
              if (_x$4 === 116) {
                const _x$5 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 3, _x.start, _x.end));
                if (_x$5 === 112) {
                  const _remain = _bind$2[1];
                  _bind = { _0: $64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Http, _1: _remain };
                } else {
                  const _remain = _bind$2[1];
                  x = _x;
                  remain = _remain;
                  break _L$2;
                }
              } else {
                const _remain = _bind$2[1];
                x = _x;
                remain = _remain;
                break _L$2;
              }
            } else {
              const _remain = _bind$2[1];
              x = _x;
              remain = _remain;
              break _L$2;
            }
          } else {
            const _remain = _bind$2[1];
            x = _x;
            remain = _remain;
            break _L$2;
          }
        } else {
          if (moonbitlang$core$string$$String$char_length_eq(_x.str, 5, _x.start, _x.end)) {
            const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 0, _x.start, _x.end));
            if (_x$2 === 104) {
              const _x$3 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 1, _x.start, _x.end));
              if (_x$3 === 116) {
                const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 2, _x.start, _x.end));
                if (_x$4 === 116) {
                  const _x$5 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 3, _x.start, _x.end));
                  if (_x$5 === 112) {
                    const _x$6 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 4, _x.start, _x.end));
                    if (_x$6 === 115) {
                      const _remain = _bind$2[1];
                      _bind = { _0: $64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Https, _1: _remain };
                    } else {
                      const _remain = _bind$2[1];
                      x = _x;
                      remain = _remain;
                      break _L$2;
                    }
                  } else {
                    const _remain = _bind$2[1];
                    x = _x;
                    remain = _remain;
                    break _L$2;
                  }
                } else {
                  const _remain = _bind$2[1];
                  x = _x;
                  remain = _remain;
                  break _L$2;
                }
              } else {
                const _remain = _bind$2[1];
                x = _x;
                remain = _remain;
                break _L$2;
              }
            } else {
              const _remain = _bind$2[1];
              x = _x;
              remain = _remain;
              break _L$2;
            }
          } else {
            const _remain = _bind$2[1];
            x = _x;
            remain = _remain;
            break _L$2;
          }
        }
      } else {
        if (_bind$2.length === 1) {
          const _remain = _bind$2[0];
          _bind = { _0: new $64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Other(""), _1: _remain };
        } else {
          const _bind$3 = moonbitlang$core$builtin$$fail$242$("Invalid protocol", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/.mooncakes/Yoorkin/rabbit-tea/src/url/url.mbt:64:10-64:35");
          if (_bind$3.$tag === 1) {
            const _ok = _bind$3;
            _bind = _ok._0;
          } else {
            return _bind$3;
          }
        }
      }
      break _L;
    }
    _bind = { _0: new $64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Other(moonbitlang$core$builtin$$Show$to_string$16$(x)), _1: remain };
  }
  const _protocol = _bind._0;
  const _remain = _bind._1;
  const _bind$2 = moonbitlang$core$builtin$$Iter$collect$16$(moonbitlang$core$string$$StringView$split(_remain, { str: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$305, start: 0, end: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$305.length }));
  let _bind$3;
  if (_bind$2.length === 2) {
    const _mid = _bind$2[0];
    const _remain$2 = _bind$2[1];
    _bind$3 = { _0: _mid, _1: _remain$2 };
  } else {
    if (_bind$2.length === 1) {
      const _mid = _bind$2[0];
      _bind$3 = { _0: _mid, _1: { str: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$302, start: 0, end: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$302.length } };
    } else {
      const _bind$4 = moonbitlang$core$builtin$$fail$244$("Invalid host", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/.mooncakes/Yoorkin/rabbit-tea/src/url/url.mbt:69:10-69:31");
      if (_bind$4.$tag === 1) {
        const _ok = _bind$4;
        _bind$3 = _ok._0;
      } else {
        return _bind$4;
      }
    }
  }
  const _mid = _bind$3._0;
  const _query_and_fragment = _bind$3._1;
  const _bind$4 = moonbitlang$core$builtin$$Iter$collect$16$(moonbitlang$core$string$$StringView$split(_mid, { str: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$289, start: 0, end: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$289.length }));
  let _bind$5;
  if (_bind$4.length === 2) {
    const _mid$2 = _bind$4[0];
    const _fragment = _bind$4[1];
    _bind$5 = { _0: _mid$2, _1: _fragment };
  } else {
    if (_bind$4.length === 1) {
      const _mid$2 = _bind$4[0];
      _bind$5 = { _0: _mid$2, _1: undefined };
    } else {
      const _bind$6 = moonbitlang$core$builtin$$fail$245$("Invalid fragment", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/.mooncakes/Yoorkin/rabbit-tea/src/url/url.mbt:74:10-74:35");
      if (_bind$6.$tag === 1) {
        const _ok = _bind$6;
        _bind$5 = _ok._0;
      } else {
        return _bind$6;
      }
    }
  }
  const _mid_part = _bind$5._0;
  const _fragment1 = _bind$5._1;
  const _bind$6 = moonbitlang$core$builtin$$Iter$collect$16$(moonbitlang$core$string$$StringView$split(_mid_part, { str: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$274, start: 0, end: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$274.length }));
  let _bind$7;
  if (_bind$6.length === 1) {
    const _mid$2 = _bind$6[0];
    _bind$7 = { _0: _mid$2, _1: "" };
  } else {
    if (_bind$6.length >= 1) {
      const _mid$2 = _bind$6[0];
      const _x = moonbitlang$core$array$$Array$op_as_view$16$(_bind$6, 1, _bind$6.length);
      const _bind$8 = moonbitlang$core$array$$ArrayView$iter$16$(_x);
      _bind$7 = { _0: _mid$2, _1: moonbitlang$core$builtin$$Iter$join((_p) => _bind$8((_p$2) => _p(moonbitlang$core$builtin$$Show$to_string$16$(_p$2))), "/") };
    } else {
      const _bind$8 = moonbitlang$core$builtin$$fail$246$("Invalid host", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/.mooncakes/Yoorkin/rabbit-tea/src/url/url.mbt:80:10-80:31");
      if (_bind$8.$tag === 1) {
        const _ok = _bind$8;
        _bind$7 = _ok._0;
      } else {
        return _bind$8;
      }
    }
  }
  const _mid$2 = _bind$7._0;
  const _path = _bind$7._1;
  const _bind$8 = moonbitlang$core$builtin$$Iter$collect$16$(moonbitlang$core$string$$StringView$split(_mid$2, { str: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$256, start: 0, end: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$256.length }));
  let _bind$9;
  if (_bind$8.length === 2) {
    const _host = _bind$8[0];
    const _port = _bind$8[1];
    let port;
    let _try_err;
    _L$2: {
      _L$3: {
        const _bind$10 = moonbitlang$core$strconv$$parse_int(moonbitlang$core$builtin$$Show$to_string$16$(_port), moonbitlang$core$strconv$$parse_int$46$base$46$default());
        let _bind$11;
        if (_bind$10.$tag === 1) {
          const _ok = _bind$10;
          _bind$11 = _ok._0;
        } else {
          const _err = _bind$10;
          const _tmp = _err._0;
          _try_err = _tmp;
          break _L$3;
        }
        port = _bind$11;
        break _L$2;
      }
      port = undefined;
    }
    _bind$9 = { _0: moonbitlang$core$builtin$$Show$to_string$16$(_host), _1: port };
  } else {
    if (_bind$8.length === 1) {
      const _host = _bind$8[0];
      _bind$9 = { _0: moonbitlang$core$builtin$$Show$to_string$16$(_host), _1: undefined };
    } else {
      const _bind$10 = moonbitlang$core$builtin$$fail$247$("Invalid host", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/.mooncakes/Yoorkin/rabbit-tea/src/url/url.mbt:94:10-94:31");
      if (_bind$10.$tag === 1) {
        const _ok = _bind$10;
        _bind$9 = _ok._0;
      } else {
        return _bind$10;
      }
    }
  }
  const _host = _bind$9._0;
  const _port = _bind$9._1;
  const _bind$10 = moonbitlang$core$builtin$$Iter$collect$16$(moonbitlang$core$string$$StringView$split(_query_and_fragment, { str: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$233, start: 0, end: Yoorkin$rabbit$45$tea$url$$parse$46$42$bind$124$233.length }));
  let _bind$11;
  if (_bind$10.length === 2) {
    const _query = _bind$10[0];
    const _fragment = _bind$10[1];
    _bind$11 = { _0: moonbitlang$core$builtin$$Show$to_string$16$(_query), _1: _fragment };
  } else {
    if (_bind$10.length === 1) {
      const _query = _bind$10[0];
      _bind$11 = moonbitlang$core$string$$StringView$is_empty(_query) ? { _0: undefined, _1: undefined } : { _0: moonbitlang$core$builtin$$Show$to_string$16$(_query), _1: undefined };
    } else {
      if (_bind$10.length === 0) {
        _bind$11 = { _0: undefined, _1: undefined };
      } else {
        const _bind$12 = moonbitlang$core$builtin$$fail$248$("Invalid query", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/.mooncakes/Yoorkin/rabbit-tea/src/url/url.mbt:105:10-105:32");
        if (_bind$12.$tag === 1) {
          const _ok = _bind$12;
          _bind$11 = _ok._0;
        } else {
          return _bind$12;
        }
      }
    }
  }
  const _query = _bind$11._0;
  const _fragment2 = _bind$11._1;
  let fragment;
  if (_fragment1 === undefined) {
    if (_fragment2 === undefined) {
      fragment = undefined;
    } else {
      const _Some = _fragment2;
      const _f = _Some;
      fragment = moonbitlang$core$builtin$$Show$to_string$16$(_f);
    }
  } else {
    const _Some = _fragment1;
    const _f1 = _Some;
    if (_fragment2 === undefined) {
      fragment = moonbitlang$core$builtin$$Show$to_string$16$(_f1);
    } else {
      const _Some$2 = _fragment2;
      const _f2 = _Some$2;
      fragment = `${moonbitlang$core$builtin$$Show$to_string$16$(_f1)}#${moonbitlang$core$builtin$$Show$to_string$16$(_f2)}`;
    }
  }
  return new Result$Ok$61$({ protocol: _protocol, host: _host, port: _port, path: _path, query: _query, fragment: fragment });
}
function rami3l$js$45$ffi$js$$Nullable$to_option$266$(self) {
  return !rami3l$js$45$ffi$js$$Value$is_null(self) ? new Option$Some$62$(self) : Option$None$62$;
}
function rami3l$js$45$ffi$js$$Nullable$to_option$267$(self) {
  return !rami3l$js$45$ffi$js$$Value$is_null(self) ? new Option$Some$63$(self) : Option$None$63$;
}
function rami3l$js$45$ffi$js$$Nullable$to_option$268$(self) {
  return !rami3l$js$45$ffi$js$$Value$is_null(self) ? new Option$Some$64$(self) : Option$None$64$;
}
function rami3l$js$45$ffi$js$$Nullable$to_option$270$(self) {
  return !rami3l$js$45$ffi$js$$Value$is_null(self) ? new Option$Some$65$(self) : Option$None$65$;
}
function rami3l$js$45$ffi$js$$Nullable$to_option$272$(self) {
  return !rami3l$js$45$ffi$js$$Value$is_null(self) ? new Option$Some$66$(self) : Option$None$66$;
}
function rami3l$js$45$ffi$js$$Nullable$to_option$360$(self) {
  return !rami3l$js$45$ffi$js$$Value$is_null(self) ? new Option$Some$67$(self) : Option$None$67$;
}
function rami3l$js$45$ffi$js$$Nullable$to_option$273$(self) {
  return !rami3l$js$45$ffi$js$$Value$is_null(self) ? new Option$Some$68$(self) : Option$None$68$;
}
function rami3l$js$45$ffi$js$$Nullable$to_option$274$(self) {
  return !rami3l$js$45$ffi$js$$Value$is_null(self) ? new Option$Some$69$(self) : Option$None$69$;
}
function rami3l$js$45$ffi$js$$Optional$undefined$9$() {
  return rami3l$js$45$ffi$js$$Value$undefined();
}
function rami3l$js$45$ffi$js$$Optional$from_option$9$(value) {
  if (value === undefined) {
    return rami3l$js$45$ffi$js$$Optional$undefined$9$();
  } else {
    const _Some = value;
    const _v = _Some;
    return _v;
  }
}
function moonbitlang$core$builtin$$Show$output$229$(self, logger) {
  logger.method_0(logger.self, rami3l$js$45$ffi$js$$Value$to_string(self));
}
function rami3l$js$45$ffi$js$$Promise$wait(self, _cont, _err_cont) {
  rami3l$js$45$ffi$js$$Promise$wait_ffi(self, _cont, (e) => {
    _err_cont(new Error$rami3l$47$js$45$ffi$47$js$46$Error_$46$Error_(e));
  });
}
function rami3l$js$45$ffi$js$$Error_$cause(self) {
  const _Error_ = self;
  const _inner = _Error_._0;
  const cause = rami3l$js$45$ffi$js$$Error_$cause_ffi(_inner);
  return !rami3l$js$45$ffi$js$$Value$is_undefined(cause) ? new Option$Some$70$(cause) : Option$None$70$;
}
function moonbitlang$core$builtin$$Show$output$325$(self, logger) {
  logger.method_0(logger.self, "@js.Error: ");
  const _Error_ = self;
  const _inner = _Error_._0;
  moonbitlang$core$builtin$$Logger$write_object$229$(logger, _inner);
  const _bind = rami3l$js$45$ffi$js$$Error_$cause(self);
  if (_bind.$tag === 1) {
    const _Some = _bind;
    const _cause_inner = _Some._0;
    logger.method_0(logger.self, "\n  caused by:\n");
    moonbitlang$core$builtin$$Logger$write_object$229$(logger, _cause_inner);
    return;
  } else {
    return;
  }
}
function Yoorkin$rabbit$45$tea$cmd$$Events$new$361$(on_url_changed, on_url_request, on_update) {
  return { on_url_changed: on_url_changed, on_url_request: on_url_request, on_update: on_update };
}
function Yoorkin$rabbit$45$tea$cmd$$Events$trigger_url_changed$361$(self, url) {
  const _func = self.on_url_changed;
  _func(url);
}
function Yoorkin$rabbit$45$tea$cmd$$Events$trigger_url_changed$362$(self, url) {
  const _func = self.on_url_changed;
  _func(url);
}
function Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(self, msg) {
  const _func = self.on_update;
  _func(msg);
}
function Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$363$(self, msg) {
  const _func = self.on_update;
  _func(msg);
}
function Yoorkin$rabbit$45$tea$cmd$$Cmd$map$364$(self, f) {
  return (events) => {
    const predef = { on_url_changed: events.on_url_changed, on_url_request: events.on_url_request, on_update: (msg) => {
      const _func = events.on_update;
      _func(f(msg));
    } };
    const _f = self;
    _f(predef);
  };
}
function Yoorkin$rabbit$45$tea$cmd$$Cmd$map$365$(self, f) {
  return (events) => {
    const predef = { on_url_changed: events.on_url_changed, on_url_request: events.on_url_request, on_update: (msg) => {
      const _func = events.on_update;
      _func(f(msg));
    } };
    const _f = self;
    _f(predef);
  };
}
function Yoorkin$rabbit$45$tea$cmd$$none$361$() {
  return (_param1) => {
  };
}
function Yoorkin$rabbit$45$tea$cmd$$none$363$() {
  return (_param1) => {
  };
}
function Yoorkin$rabbit$45$tea$cmd$$none$362$() {
  return (_param1) => {
  };
}
function Yoorkin$rabbit$45$tea$cmd$$batch$362$(xs) {
  return (events) => {
    const _p = xs.length;
    let _tmp = 0;
    while (true) {
      const _p$2 = _tmp;
      if (_p$2 < _p) {
        const _p$3 = xs[_p$2];
        const _param2 = _p$3;
        const _f = _param2;
        _f(events);
        _tmp = _p$2 + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  };
}
function Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$launch$366$(self, cmd) {
  const f = cmd;
  f(moonbitlang$core$option$$Option$unwrap$265$(self.predefined));
}
function Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$get_on_url_request$366$(self) {
  return self.on_url_request;
}
function Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(self, message) {
  const _func = self.update;
  const _bind = _func(message, self.model);
  const _cmd = _bind._0;
  const _model = _bind._1;
  self.model = _model;
  const _func$2 = self.view;
  const view = _func$2(self.model);
  const _func$3 = self.after_update;
  _func$3(view);
  Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$launch$366$(self, _cmd);
}
function Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$new$367$(model, update, view, after_update, url_changed, url_request) {
  const sandbox = { model: model, update: update, view: view, after_update: after_update, on_url_changed: url_changed, on_url_request: url_request, predefined: undefined };
  let on_url_changed;
  if (url_changed === undefined) {
    on_url_changed = (_x) => {
    };
  } else {
    const _Some = url_changed;
    const _f = _Some;
    on_url_changed = (url) => {
      Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(sandbox, _f(url));
    };
  }
  let on_url_request;
  if (url_request === undefined) {
    on_url_request = (_x) => {
    };
  } else {
    const _Some = url_request;
    const _f = _Some;
    on_url_request = (url) => {
      Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(sandbox, _f(url));
    };
  }
  Yoorkin$rabbit$45$tea$dom$$EventTarget$add_event_listener(Yoorkin$rabbit$45$tea$dom$$Window$to_event_target(Yoorkin$rabbit$45$tea$dom$$window()), "popstate", (_event) => {
    const _bind = Yoorkin$rabbit$45$tea$url$$parse(Yoorkin$rabbit$45$tea$dom$$Window$current_url(Yoorkin$rabbit$45$tea$dom$$window()));
    if (_bind.$tag === 1) {
      const _Ok = _bind;
      const _url = _Ok._0;
      on_url_changed(_url);
      return;
    } else {
      $panic();
      return;
    }
  });
  sandbox.predefined = Yoorkin$rabbit$45$tea$cmd$$Events$new$361$(on_url_changed, on_url_request, (msg) => {
    Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(sandbox, msg);
  });
  return sandbox;
}
function moonbitlang$core$builtin$$Eq$op_equal$234$(_x_33, _x_34) {
  switch (_x_33.$tag) {
    case 0: {
      const _Boolean = _x_33;
      const _$42$x0_35 = _Boolean._0;
      if (_x_34.$tag === 0) {
        const _Boolean$2 = _x_34;
        const _$42$y0_36 = _Boolean$2._0;
        return _$42$x0_35 === _$42$y0_36;
      } else {
        return false;
      }
    }
    case 1: {
      const _Integer = _x_33;
      const _$42$x0_37 = _Integer._0;
      if (_x_34.$tag === 1) {
        const _Integer$2 = _x_34;
        const _$42$y0_38 = _Integer$2._0;
        return _$42$x0_37 === _$42$y0_38;
      } else {
        return false;
      }
    }
    case 2: {
      const _Floating = _x_33;
      const _$42$x0_39 = _Floating._0;
      if (_x_34.$tag === 2) {
        const _Floating$2 = _x_34;
        const _$42$y0_40 = _Floating$2._0;
        return _$42$x0_39 === _$42$y0_40;
      } else {
        return false;
      }
    }
    default: {
      const _String = _x_33;
      const _$42$x0_41 = _String._0;
      if (_x_34.$tag === 3) {
        const _String$2 = _x_34;
        const _$42$y0_42 = _String$2._0;
        return _$42$x0_41 === _$42$y0_42;
      } else {
        return false;
      }
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$Handler$map$365$(self, f) {
  switch (self.$tag) {
    case 0: {
      const _Normal = self;
      const _msg = _Normal._0;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Normal$71$(f(_msg));
    }
    case 1: {
      const _HandleEvent = self;
      const _g = _HandleEvent._0;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$71$((event) => f(_g(event)));
    }
    default: {
      const _Custom = self;
      const _msg$2 = _Custom._0;
      const _stop_propagation = _Custom._1;
      const _prevent_default = _Custom._2;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Custom$71$(f(_msg$2), _stop_propagation, _prevent_default);
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$Handler$map$364$(self, f) {
  switch (self.$tag) {
    case 0: {
      const _Normal = self;
      const _msg = _Normal._0;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Normal$71$(f(_msg));
    }
    case 1: {
      const _HandleEvent = self;
      const _g = _HandleEvent._0;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$71$((event) => f(_g(event)));
    }
    default: {
      const _Custom = self;
      const _msg$2 = _Custom._0;
      const _stop_propagation = _Custom._1;
      const _prevent_default = _Custom._2;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Custom$71$(f(_msg$2), _stop_propagation, _prevent_default);
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$Attribute$map$365$(self, f) {
  const _x = self;
  const _key = _x._0;
  const _value = _x._1;
  let value;
  switch (_value.$tag) {
    case 0: {
      const _AttrEvent = _value;
      const _handler = _AttrEvent._0;
      value = new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$71$(Yoorkin$rabbit$45$tea$internal$vdom$$Handler$map$365$(_handler, f));
      break;
    }
    case 1: {
      const _AttrStyle = _value;
      const _value$2 = _AttrStyle._0;
      value = new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrStyle$71$(_value$2);
      break;
    }
    case 2: {
      const _AttrString = _value;
      const _value$3 = _AttrString._0;
      value = new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$71$(_value$3);
      break;
    }
    default: {
      const _AttrProperty = _value;
      const _value$4 = _AttrProperty._0;
      value = new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$71$(_value$4);
    }
  }
  return { _0: _key, _1: value };
}
function Yoorkin$rabbit$45$tea$internal$vdom$$Attribute$map$364$(self, f) {
  const _x = self;
  const _key = _x._0;
  const _value = _x._1;
  let value;
  switch (_value.$tag) {
    case 0: {
      const _AttrEvent = _value;
      const _handler = _AttrEvent._0;
      value = new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$71$(Yoorkin$rabbit$45$tea$internal$vdom$$Handler$map$364$(_handler, f));
      break;
    }
    case 1: {
      const _AttrStyle = _value;
      const _value$2 = _AttrStyle._0;
      value = new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrStyle$71$(_value$2);
      break;
    }
    case 2: {
      const _AttrString = _value;
      const _value$3 = _AttrString._0;
      value = new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$71$(_value$3);
      break;
    }
    default: {
      const _AttrProperty = _value;
      const _value$4 = _AttrProperty._0;
      value = new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$71$(_value$4);
    }
  }
  return { _0: _key, _1: value };
}
function Yoorkin$rabbit$45$tea$internal$vdom$$Node$map$365$(self, f) {
  switch (self.$tag) {
    case 0: {
      const _Node = self;
      const _tag = _Node._0;
      const _attrs = _Node._1;
      const _childrens = _Node._2;
      const _listeners = _Node._3;
      const _p = new Array(_attrs.length);
      const _p$2 = _attrs.length;
      let _tmp = 0;
      while (true) {
        const _p$3 = _tmp;
        if (_p$3 < _p$2) {
          const _p$4 = _attrs[_p$3];
          const x = _p$4;
          _p[_p$3] = Yoorkin$rabbit$45$tea$internal$vdom$$Attribute$map$365$(x, f);
          _tmp = _p$3 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const attrs = _p;
      const _p$3 = new Array(_childrens.length);
      const _p$4 = _childrens.length;
      let _tmp$2 = 0;
      while (true) {
        const _p$5 = _tmp$2;
        if (_p$5 < _p$4) {
          const _p$6 = _childrens[_p$5];
          const x = _p$6;
          _p$3[_p$5] = Yoorkin$rabbit$45$tea$internal$vdom$$Node$map$365$(x, f);
          _tmp$2 = _p$5 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const childrens = _p$3;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$71$(_tag, attrs, childrens, _listeners);
    }
    case 1: {
      const _ExternalNode = self;
      const _node = _ExternalNode._0;
      const _attrs$2 = _ExternalNode._1;
      const _width = _ExternalNode._2;
      const _height = _ExternalNode._3;
      const attrs$2 = moonbitlang$core$ref$$Ref$map$357$(_attrs$2, (opt) => moonbitlang$core$option$$Option$map$54$(opt, (attrs$3) => {
        const _p$5 = new Array(attrs$3.length);
        const _p$6 = attrs$3.length;
        let _tmp$3 = 0;
        while (true) {
          const _p$7 = _tmp$3;
          if (_p$7 < _p$6) {
            const _p$8 = attrs$3[_p$7];
            const x = _p$8;
            _p$5[_p$7] = Yoorkin$rabbit$45$tea$internal$vdom$$Attribute$map$365$(x, f);
            _tmp$3 = _p$7 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return _p$5;
      }));
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$ExternalNode$71$(_node, attrs$2, _width, _height);
    }
    case 2: {
      const _Text = self;
      const _value = _Text._0;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$71$(_value);
    }
    default: {
      return $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Nothing$71$;
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$Node$map$364$(self, f) {
  switch (self.$tag) {
    case 0: {
      const _Node = self;
      const _tag = _Node._0;
      const _attrs = _Node._1;
      const _childrens = _Node._2;
      const _listeners = _Node._3;
      const _p = new Array(_attrs.length);
      const _p$2 = _attrs.length;
      let _tmp = 0;
      while (true) {
        const _p$3 = _tmp;
        if (_p$3 < _p$2) {
          const _p$4 = _attrs[_p$3];
          const x = _p$4;
          _p[_p$3] = Yoorkin$rabbit$45$tea$internal$vdom$$Attribute$map$364$(x, f);
          _tmp = _p$3 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const attrs = _p;
      const _p$3 = new Array(_childrens.length);
      const _p$4 = _childrens.length;
      let _tmp$2 = 0;
      while (true) {
        const _p$5 = _tmp$2;
        if (_p$5 < _p$4) {
          const _p$6 = _childrens[_p$5];
          const x = _p$6;
          _p$3[_p$5] = Yoorkin$rabbit$45$tea$internal$vdom$$Node$map$364$(x, f);
          _tmp$2 = _p$5 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const childrens = _p$3;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$71$(_tag, attrs, childrens, _listeners);
    }
    case 1: {
      const _ExternalNode = self;
      const _node = _ExternalNode._0;
      const _attrs$2 = _ExternalNode._1;
      const _width = _ExternalNode._2;
      const _height = _ExternalNode._3;
      const attrs$2 = moonbitlang$core$ref$$Ref$map$358$(_attrs$2, (opt) => moonbitlang$core$option$$Option$map$55$(opt, (attrs$3) => {
        const _p$5 = new Array(attrs$3.length);
        const _p$6 = attrs$3.length;
        let _tmp$3 = 0;
        while (true) {
          const _p$7 = _tmp$3;
          if (_p$7 < _p$6) {
            const _p$8 = attrs$3[_p$7];
            const x = _p$8;
            _p$5[_p$7] = Yoorkin$rabbit$45$tea$internal$vdom$$Attribute$map$364$(x, f);
            _tmp$3 = _p$7 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return _p$5;
      }));
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$ExternalNode$71$(_node, attrs$2, _width, _height);
    }
    case 2: {
      const _Text = self;
      const _value = _Text._0;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$71$(_value);
    }
    default: {
      return $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Nothing$71$;
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$node$361$(tag, attrs, childrens) {
  return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$71$(tag, attrs, childrens, []);
}
function Yoorkin$rabbit$45$tea$internal$vdom$$node$362$(tag, attrs, childrens) {
  return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$72$(tag, attrs, childrens, []);
}
function Yoorkin$rabbit$45$tea$internal$vdom$$node$363$(tag, attrs, childrens) {
  return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$73$(tag, attrs, childrens, []);
}
function Yoorkin$rabbit$45$tea$internal$vdom$$link$362$(attrs, childrens, escape) {
  const tag = escape ? "RABBIT-TEA-ESCAPED-LINK" : "a";
  return Yoorkin$rabbit$45$tea$internal$vdom$$node$362$(tag, attrs, childrens);
}
function Yoorkin$rabbit$45$tea$internal$vdom$$link$361$(attrs, childrens, escape) {
  const tag = escape ? "RABBIT-TEA-ESCAPED-LINK" : "a";
  return Yoorkin$rabbit$45$tea$internal$vdom$$node$361$(tag, attrs, childrens);
}
function Yoorkin$rabbit$45$tea$internal$vdom$$link$363$(attrs, childrens, escape) {
  const tag = escape ? "RABBIT-TEA-ESCAPED-LINK" : "a";
  return Yoorkin$rabbit$45$tea$internal$vdom$$node$363$(tag, attrs, childrens);
}
function Yoorkin$rabbit$45$tea$internal$vdom$$text$362$(value) {
  return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$72$(value);
}
function Yoorkin$rabbit$45$tea$internal$vdom$$text$361$(value) {
  return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$71$(value);
}
function Yoorkin$rabbit$45$tea$internal$vdom$$text$363$(value) {
  return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$73$(value);
}
function Yoorkin$rabbit$45$tea$internal$vdom$$nothing$363$() {
  return $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Nothing$73$;
}
function Yoorkin$rabbit$45$tea$internal$vdom$$nothing$362$() {
  return $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Nothing$72$;
}
function Yoorkin$rabbit$45$tea$internal$vdom$$is_same_type$361$(x, y) {
  switch (x.$tag) {
    case 0: {
      if (y.$tag === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (y.$tag === 2) {
        return true;
      } else {
        return false;
      }
    }
    case 3: {
      if (y.$tag === 3) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (y.$tag === 1) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$on$362$(event, handler) {
  return { _0: event, _1: new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$72$(handler) };
}
function Yoorkin$rabbit$45$tea$internal$vdom$$on$363$(event, handler) {
  return { _0: event, _1: new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$73$(handler) };
}
function Yoorkin$rabbit$45$tea$internal$vdom$$on$361$(event, handler) {
  return { _0: event, _1: new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$71$(handler) };
}
function Yoorkin$rabbit$45$tea$internal$vdom$$attribute$362$(key, value) {
  return { _0: key, _1: new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$72$(value) };
}
function Yoorkin$rabbit$45$tea$internal$vdom$$attribute$361$(key, value) {
  return { _0: key, _1: new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$71$(value) };
}
function Yoorkin$rabbit$45$tea$internal$vdom$$attribute$363$(key, value) {
  return { _0: key, _1: new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$73$(value) };
}
function Yoorkin$rabbit$45$tea$internal$vdom$$property$362$(key, value) {
  return { _0: key, _1: new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$72$(value) };
}
function Yoorkin$rabbit$45$tea$internal$vdom$$property$363$(key, value) {
  return { _0: key, _1: new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$73$(value) };
}
function Yoorkin$rabbit$45$tea$internal$vdom$$variant_to_js_value(value) {
  switch (value.$tag) {
    case 3: {
      const _String = value;
      const _value = _String._0;
      return _value;
    }
    case 2: {
      const _Floating = value;
      const _value$2 = _Floating._0;
      return _value$2;
    }
    case 1: {
      const _Integer = value;
      const _value$3 = _Integer._0;
      return _value$3;
    }
    default: {
      const _Boolean = value;
      const _value$4 = _Boolean._0;
      return _value$4;
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$to_node$46$attach_attrs$47$6028(sandbox, attrs, element, generated_listeners) {
  const _p = attrs.length;
  let _tmp = 0;
  while (true) {
    const _p$2 = _tmp;
    if (_p$2 < _p) {
      const _p$3 = attrs[_p$2];
      const _param1 = _p$3;
      const _x = _param1;
      const _event = _x._0;
      const _x$2 = _x._1;
      switch (_x$2.$tag) {
        case 0: {
          const _AttrEvent = _x$2;
          const _handler = _AttrEvent._0;
          let listener;
          switch (_handler.$tag) {
            case 0: {
              const _Normal = _handler;
              const _msg = _Normal._0;
              listener = (_event$2) => {
                Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(sandbox, _msg);
              };
              break;
            }
            case 1: {
              const _HandleEvent = _handler;
              const _f = _HandleEvent._0;
              listener = (event) => {
                Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(sandbox, _f(event));
              };
              break;
            }
            default: {
              const _Custom = _handler;
              const _msg$2 = _Custom._0;
              const _stop_propagation = _Custom._1;
              const _prevent_default = _Custom._2;
              listener = (event) => {
                if (_stop_propagation) {
                  Yoorkin$rabbit$45$tea$dom$$Event$stop_propagation(event);
                }
                if (_prevent_default) {
                  Yoorkin$rabbit$45$tea$dom$$Event$prevent_default(event);
                }
                Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(sandbox, _msg$2);
              };
            }
          }
          Yoorkin$rabbit$45$tea$dom$$EventTarget$add_event_listener(Yoorkin$rabbit$45$tea$dom$$Node$to_event_target(Yoorkin$rabbit$45$tea$dom$$Element$to_node(element)), _event, listener);
          moonbitlang$core$array$$Array$push$295$(generated_listeners, { _0: _event, _1: listener });
          break;
        }
        case 2: {
          const _AttrString = _x$2;
          const _value = _AttrString._0;
          Yoorkin$rabbit$45$tea$dom$$Element$set_attribute(element, _event, _value);
          break;
        }
        case 1: {
          const _AttrStyle = _x$2;
          const _value$2 = _AttrStyle._0;
          Yoorkin$rabbit$45$tea$dom$$HTMLElement$set_style(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(element), _event, _value$2);
          break;
        }
        default: {
          const _AttrProperty = _x$2;
          const _value$3 = _AttrProperty._0;
          Yoorkin$rabbit$45$tea$dom$$Element$set_property(element, _event, Yoorkin$rabbit$45$tea$internal$vdom$$variant_to_js_value(_value$3));
        }
      }
      _tmp = _p$2 + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$Node$to_node$366$(self, sandbox) {
  switch (self.$tag) {
    case 0: {
      const _Node = self;
      const _tag = _Node._0;
      const _attrs = _Node._1;
      const _childrens = _Node._2;
      const _listeners = _Node._3;
      let element;
      _L: {
        _L$2: {
          _L$3: {
            _L$4: {
              const _bind = Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$get_on_url_request$366$(sandbox);
              if (_bind === undefined) {
                if (_tag === "RABBIT-TEA-ESCAPED-LINK") {
                  break _L$4;
                } else {
                  break _L$2;
                }
              } else {
                const _Some = _bind;
                const _url_request = _Some;
                switch (_tag) {
                  case "a": {
                    const element$2 = Yoorkin$rabbit$45$tea$dom$$Document$create_element(Yoorkin$rabbit$45$tea$dom$$document(), _tag);
                    Yoorkin$rabbit$45$tea$internal$vdom$$to_node$46$attach_attrs$47$6028(sandbox, _attrs, element$2, _listeners);
                    Yoorkin$rabbit$45$tea$dom$$EventTarget$add_event_listener(Yoorkin$rabbit$45$tea$dom$$Node$to_event_target(Yoorkin$rabbit$45$tea$dom$$Element$to_node(element$2)), "click", (event) => {
                      Yoorkin$rabbit$45$tea$dom$$Event$prevent_default(event);
                      const href = Yoorkin$rabbit$45$tea$dom$$Element$get_property(element$2, "href");
                      const _bind$2 = Yoorkin$rabbit$45$tea$url$$parse(Yoorkin$rabbit$45$tea$dom$$Window$current_url(Yoorkin$rabbit$45$tea$dom$$window()));
                      if (_bind$2.$tag === 1) {
                        const _Ok = _bind$2;
                        const _curr = _Ok._0;
                        const _bind$3 = Yoorkin$rabbit$45$tea$url$$parse(href);
                        if (_bind$3.$tag === 1) {
                          const _Ok$2 = _bind$3;
                          const _next = _Ok$2._0;
                          const request = moonbitlang$core$builtin$$Eq$op_equal$359$(_curr.protocol, _next.protocol) && (_curr.host === _next.host && moonbitlang$core$builtin$$Eq$op_equal$70$(_curr.port, _next.port)) ? new $64$Yoorkin$47$rabbit$45$tea$47$url$46$UrlRequest$Internal(_next) : new $64$Yoorkin$47$rabbit$45$tea$47$url$46$UrlRequest$External(href);
                          Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(sandbox, _url_request(request));
                          return;
                        } else {
                          $panic();
                          return;
                        }
                      } else {
                        $panic();
                        return;
                      }
                    });
                    element = element$2;
                    break;
                  }
                  case "RABBIT-TEA-ESCAPED-LINK": {
                    break _L$4;
                  }
                  default: {
                    break _L$2;
                  }
                }
              }
              break _L$3;
            }
            const element$2 = Yoorkin$rabbit$45$tea$dom$$Document$create_element(Yoorkin$rabbit$45$tea$dom$$document(), "a");
            Yoorkin$rabbit$45$tea$internal$vdom$$to_node$46$attach_attrs$47$6028(sandbox, _attrs, element$2, _listeners);
            element = element$2;
          }
          break _L;
        }
        const element$2 = Yoorkin$rabbit$45$tea$dom$$Document$create_element(Yoorkin$rabbit$45$tea$dom$$document(), _tag);
        Yoorkin$rabbit$45$tea$internal$vdom$$to_node$46$attach_attrs$47$6028(sandbox, _attrs, element$2, _listeners);
        element = element$2;
      }
      const _len = _childrens.length;
      let _tmp = 0;
      while (true) {
        const _i = _tmp;
        if (_i < _len) {
          const child = _childrens[_i];
          Yoorkin$rabbit$45$tea$dom$$Node$append_child(Yoorkin$rabbit$45$tea$dom$$Element$to_node(element), Yoorkin$rabbit$45$tea$internal$vdom$$Node$to_node$366$(child, sandbox));
          _tmp = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return Yoorkin$rabbit$45$tea$dom$$Element$to_node(element);
    }
    case 1: {
      const _ExternalNode = self;
      const _node = _ExternalNode._0;
      const _attrs$2 = _ExternalNode._1;
      const _width = _ExternalNode._2;
      const _height = _ExternalNode._3;
      const _bind = _attrs$2.val;
      if (_bind.$tag === 1) {
        const _Some = _bind;
        const _xs = _Some._0;
        Yoorkin$rabbit$45$tea$internal$vdom$$to_node$46$attach_attrs$47$6028(sandbox, _xs, moonbitlang$core$option$$Option$unwrap$266$(rami3l$js$45$ffi$js$$Nullable$to_option$266$(Yoorkin$rabbit$45$tea$dom$$Node$to_element(_node))), []);
        _attrs$2.val = Option$None$0$;
      }
      const element$2 = Yoorkin$rabbit$45$tea$dom$$Document$create_element(Yoorkin$rabbit$45$tea$dom$$document(), "div");
      Yoorkin$rabbit$45$tea$dom$$HTMLElement$set_style(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(element$2), "width", moonbitlang$core$int$$Int$to_string(_width, moonbitlang$core$int$$Int$to_string$46$radix$46$default()));
      Yoorkin$rabbit$45$tea$dom$$HTMLElement$set_style(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(element$2), "height", moonbitlang$core$int$$Int$to_string(_height, moonbitlang$core$int$$Int$to_string$46$radix$46$default()));
      Yoorkin$rabbit$45$tea$dom$$Element$append_children(element$2, moonbitlang$core$option$$Option$unwrap$266$(rami3l$js$45$ffi$js$$Nullable$to_option$266$(Yoorkin$rabbit$45$tea$dom$$Node$to_element(_node))));
      return Yoorkin$rabbit$45$tea$dom$$Element$to_node(element$2);
    }
    case 2: {
      const _Text = self;
      const _value = _Text._0;
      return Yoorkin$rabbit$45$tea$dom$$Element$to_node(Yoorkin$rabbit$45$tea$dom$$Document$create_text_node(Yoorkin$rabbit$45$tea$dom$$document(), _value));
    }
    default: {
      return Yoorkin$rabbit$45$tea$dom$$Element$to_node(Yoorkin$rabbit$45$tea$dom$$Document$create_text_node(Yoorkin$rabbit$45$tea$dom$$document(), ""));
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$attrs_diff$361$(old, new_, listeners) {
  const _bind = moonbitlang$core$array$$Array$iter$286$(old);
  const old_map = moonbitlang$core$builtin$$Map$from_iter$293$((_p) => _bind((_p$2) => _p(_p$2)));
  const _bind$2 = moonbitlang$core$array$$Array$iter$286$(new_);
  const new_map = moonbitlang$core$builtin$$Map$from_iter$293$((_p) => _bind$2((_p$2) => _p(_p$2)));
  const result = [];
  const _len = listeners.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = listeners[_i];
      moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$EventRemove$71$(x._0, x._1));
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _bind$3 = moonbitlang$core$builtin$$Map$iter2$293$(old_map);
  _bind$3((key, value) => {
    switch (value.$tag) {
      case 0: {
        break;
      }
      case 1: {
        const _AttrStyle = value;
        const _value = _AttrStyle._0;
        if (moonbitlang$core$builtin$$Map$contains$293$(new_map, key)) {
          const _bind$4 = moonbitlang$core$option$$Option$unwrap$271$(moonbitlang$core$builtin$$Map$get$293$(new_map, key));
          if (_bind$4.$tag === 1) {
            const _AttrStyle$2 = _bind$4;
            const _value_new = _AttrStyle$2._0;
            if (moonbitlang$core$builtin$$op_notequal$9$(_value, _value_new)) {
              moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleAdd$71$(key, _value_new));
            }
          } else {
            $panic();
          }
        } else {
          moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleRemove$71$(key));
        }
        break;
      }
      case 2: {
        const _AttrString = value;
        const _value$2 = _AttrString._0;
        if (moonbitlang$core$builtin$$Map$contains$293$(new_map, key)) {
          const _bind$4 = moonbitlang$core$option$$Option$unwrap$271$(moonbitlang$core$builtin$$Map$get$293$(new_map, key));
          if (_bind$4.$tag === 2) {
            const _AttrString$2 = _bind$4;
            const _value_new = _AttrString$2._0;
            if (moonbitlang$core$builtin$$op_notequal$9$(_value$2, _value_new)) {
              moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrAdd$71$(key, _value_new));
            }
          } else {
            $panic();
          }
        } else {
          moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrRemove$71$(key));
        }
        break;
      }
      default: {
        const _AttrProperty = value;
        const _value$3 = _AttrProperty._0;
        if (moonbitlang$core$builtin$$Map$contains$293$(new_map, key)) {
          const _bind$4 = moonbitlang$core$option$$Option$unwrap$271$(moonbitlang$core$builtin$$Map$get$293$(new_map, key));
          if (_bind$4.$tag === 3) {
            const _AttrProperty$2 = _bind$4;
            const _value_new = _AttrProperty$2._0;
            if (moonbitlang$core$builtin$$op_notequal$234$(_value$3, _value_new)) {
              moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyAdd$71$(key, _value_new));
            }
          } else {
            $panic();
          }
        } else {
          moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyRemove$71$(key));
        }
      }
    }
    return 1;
  });
  const _bind$4 = moonbitlang$core$builtin$$Map$iter2$293$(new_map);
  _bind$4((key, value) => {
    switch (value.$tag) {
      case 0: {
        const _AttrEvent = value;
        const _handler = _AttrEvent._0;
        moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$EventAdd$71$(key, _handler));
        break;
      }
      case 1: {
        const _AttrStyle = value;
        const _value = _AttrStyle._0;
        if (!moonbitlang$core$builtin$$Map$contains$293$(old_map, key)) {
          moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleAdd$71$(key, _value));
        }
        break;
      }
      case 2: {
        const _AttrString = value;
        const _value$2 = _AttrString._0;
        if (!moonbitlang$core$builtin$$Map$contains$293$(old_map, key)) {
          moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrAdd$71$(key, _value$2));
        }
        break;
      }
      default: {
        const _AttrProperty = value;
        const _value$3 = _AttrProperty._0;
        if (!moonbitlang$core$builtin$$Map$contains$293$(old_map, key)) {
          moonbitlang$core$array$$Array$push$301$(result, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyAdd$71$(key, _value$3));
        }
      }
    }
    return 1;
  });
  return result;
}
function Yoorkin$rabbit$45$tea$internal$vdom$$do_diff$361$(old, new_) {
  let childrens_old;
  if (old.$tag === 0) {
    const _Node = old;
    const _childrens = _Node._2;
    childrens_old = _childrens;
  } else {
    childrens_old = moonbitlang$core$abort$$abort$15$("old is not a node or fragment");
  }
  let childrens_new;
  if (new_.$tag === 0) {
    const _Node = new_;
    const _childrens = _Node._2;
    childrens_new = _childrens;
  } else {
    childrens_new = moonbitlang$core$abort$$abort$15$("new is not a node or fragment");
  }
  return childrens_old.length === 0 && childrens_new.length === 0 ? [] : Yoorkin$rabbit$45$tea$internal$vdom$$diff_without_key$361$(childrens_old, childrens_new);
}
function Yoorkin$rabbit$45$tea$internal$vdom$$diff_without_key$46$aux$47$6150(xs, ys, patches, index) {
  let _tmp = xs;
  let _tmp$2 = ys;
  let _tmp$3 = patches;
  let _tmp$4 = index;
  while (true) {
    const xs$2 = _tmp;
    const ys$2 = _tmp$2;
    const patches$2 = _tmp$3;
    const index$2 = _tmp$4;
    if (xs$2.len === 0) {
      if (ys$2.len === 0) {
        return;
      } else {
        moonbitlang$core$array$$Array$push$303$(patches$2, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Append$71$(moonbitlang$core$array$$ArrayView$map$350$(ys$2, (x) => x)));
        return;
      }
    } else {
      if (ys$2.len === 0) {
        moonbitlang$core$array$$Array$push$303$(patches$2, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Drop$71$(index$2, moonbitlang$core$array$$ArrayView$length$43$(xs$2)));
        return;
      } else {
        const _x = xs$2.buf[xs$2.start];
        const _tmp$5 = xs$2.buf;
        const _tmp$6 = 1 + xs$2.start | 0;
        const _some = xs$2.len;
        const _x$2 = { buf: _tmp$5, start: _tmp$6, len: _some - 1 | 0 };
        const _y = ys$2.buf[ys$2.start];
        const _tmp$7 = ys$2.buf;
        const _tmp$8 = 1 + ys$2.start | 0;
        const _some$2 = ys$2.len;
        const _x$3 = { buf: _tmp$7, start: _tmp$8, len: _some$2 - 1 | 0 };
        if (Yoorkin$rabbit$45$tea$internal$vdom$$is_same_type$361$(_x, _y)) {
          switch (_x.$tag) {
            case 0: {
              const _Node = _x;
              const _taga = _Node._0;
              const _xattrs = _Node._1;
              const _listeners = _Node._3;
              if (_y.$tag === 0) {
                const _Node$2 = _y;
                const _tagb = _Node$2._0;
                const _yattrs = _Node$2._1;
                const _new_listeners = _Node$2._3;
                if (_taga === _tagb) {
                  const attrs_patches = Yoorkin$rabbit$45$tea$internal$vdom$$attrs_diff$361$(_xattrs, _yattrs, _listeners);
                  const childs_patches = Yoorkin$rabbit$45$tea$internal$vdom$$do_diff$361$(_x, _y);
                  if (attrs_patches.length > 0 || childs_patches.length > 0) {
                    moonbitlang$core$array$$Array$push$303$(patches$2, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Update$71$(new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateNode$71$(index$2, attrs_patches, childs_patches, _new_listeners)));
                  }
                } else {
                  moonbitlang$core$array$$Array$push$303$(patches$2, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Replace$71$(index$2, _y));
                }
              }
              break;
            }
            case 1: {
              if (_y.$tag === 1) {
                moonbitlang$core$array$$Array$push$303$(patches$2, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Replace$71$(index$2, _y));
              }
              break;
            }
            case 2: {
              const _Text = _x;
              const _value_a = _Text._0;
              if (_y.$tag === 2) {
                const _Text$2 = _y;
                const _value_b = _Text$2._0;
                if (moonbitlang$core$builtin$$op_notequal$9$(_value_a, _value_b)) {
                  moonbitlang$core$array$$Array$push$303$(patches$2, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Update$71$(new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateText$71$(index$2, _value_b)));
                }
              }
              break;
            }
          }
        } else {
          moonbitlang$core$array$$Array$push$303$(patches$2, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Replace$71$(index$2, _y));
        }
        const _tmp$9 = index$2 + 1 | 0;
        _tmp = _x$2;
        _tmp$2 = _x$3;
        _tmp$4 = _tmp$9;
        continue;
      }
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$diff_without_key$361$(old, new_) {
  const patches = [];
  Yoorkin$rabbit$45$tea$internal$vdom$$diff_without_key$46$aux$47$6150({ buf: old, start: 0, len: old.length }, { buf: new_, start: 0, len: new_.length }, patches, 0);
  return patches;
}
function Yoorkin$rabbit$45$tea$internal$vdom$$diff$361$(root_old, root_new) {
  if (root_old.$tag === 0) {
    const _Node = root_old;
    const _attrs_old = _Node._1;
    const _listeners = _Node._3;
    if (root_new.$tag === 0) {
      const _Node$2 = root_new;
      const _attrs_new = _Node$2._1;
      return new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Update$71$(new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateNode$71$(0, Yoorkin$rabbit$45$tea$internal$vdom$$attrs_diff$361$(_attrs_old, _attrs_new, _listeners), Yoorkin$rabbit$45$tea$internal$vdom$$do_diff$361$(root_old, root_new), []));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$patch$46$aux$47$6191(sandbox, patches, current) {
  switch (patches.$tag) {
    case 0: {
      const _Drop = patches;
      const _index = _Drop._0;
      const _length = _Drop._1;
      let _tmp = 0;
      while (true) {
        const i = _tmp;
        if (i < _length) {
          Yoorkin$rabbit$45$tea$dom$$Node$remove_child(current, Yoorkin$rabbit$45$tea$dom$$Node$nth_child(current, _index));
          _tmp = i + 1 | 0;
          continue;
        } else {
          return;
        }
      }
    }
    case 1: {
      const _Remove = patches;
      const _index$2 = _Remove._0;
      Yoorkin$rabbit$45$tea$dom$$Node$remove_child(current, Yoorkin$rabbit$45$tea$dom$$Node$nth_child(current, _index$2));
      return;
    }
    case 2: {
      const _Replace = patches;
      const _index$3 = _Replace._0;
      const _node = _Replace._1;
      Yoorkin$rabbit$45$tea$dom$$Node$replace_child(current, Yoorkin$rabbit$45$tea$internal$vdom$$Node$to_node$366$(_node, sandbox), Yoorkin$rabbit$45$tea$dom$$Node$nth_child(current, _index$3));
      return;
    }
    case 3: {
      const _InsertBefore = patches;
      const _index$4 = _InsertBefore._0;
      const _node$2 = _InsertBefore._1;
      if (Yoorkin$rabbit$45$tea$dom$$Node$count_child(current) === 0) {
        Yoorkin$rabbit$45$tea$dom$$Node$append_child(current, Yoorkin$rabbit$45$tea$internal$vdom$$Node$to_node$366$(_node$2, sandbox));
        return;
      } else {
        Yoorkin$rabbit$45$tea$dom$$Node$insert_before(current, Yoorkin$rabbit$45$tea$internal$vdom$$Node$to_node$366$(_node$2, sandbox), Yoorkin$rabbit$45$tea$dom$$Node$nth_child(current, _index$4));
        return;
      }
    }
    case 4: {
      const _Append = patches;
      const _nodes = _Append._0;
      const _len = _nodes.length;
      let _tmp$2 = 0;
      while (true) {
        const _i = _tmp$2;
        if (_i < _len) {
          const node = _nodes[_i];
          Yoorkin$rabbit$45$tea$dom$$Node$append_child(current, Yoorkin$rabbit$45$tea$internal$vdom$$Node$to_node$366$(node, sandbox));
          _tmp$2 = _i + 1 | 0;
          continue;
        } else {
          return;
        }
      }
    }
    default: {
      const _Update = patches;
      const _update = _Update._0;
      if (_update.$tag === 0) {
        const _UpdateNode = _update;
        const _index$5 = _UpdateNode._0;
        const _attrs_patches = _UpdateNode._1;
        const _childs_patches = _UpdateNode._2;
        const _new_listeners = _UpdateNode._3;
        const node = Yoorkin$rabbit$45$tea$dom$$Node$nth_child(current, _index$5);
        const element = Yoorkin$rabbit$45$tea$dom$$Node$to_element(node);
        const _len$2 = _attrs_patches.length;
        let _tmp$3 = 0;
        while (true) {
          const _i = _tmp$3;
          if (_i < _len$2) {
            const patch = _attrs_patches[_i];
            switch (patch.$tag) {
              case 0: {
                const _AttrRemove = patch;
                const _key = _AttrRemove._0;
                Yoorkin$rabbit$45$tea$dom$$Element$remove_attribute(element, _key);
                break;
              }
              case 1: {
                const _AttrAdd = patch;
                const _key$2 = _AttrAdd._0;
                const _value = _AttrAdd._1;
                Yoorkin$rabbit$45$tea$dom$$Element$set_attribute(element, _key$2, _value);
                break;
              }
              case 2: {
                const _StyleAdd = patch;
                const _key$3 = _StyleAdd._0;
                const _value$2 = _StyleAdd._1;
                Yoorkin$rabbit$45$tea$dom$$HTMLElement$set_style(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(element), _key$3, _value$2);
                break;
              }
              case 3: {
                const _StyleRemove = patch;
                const _key$4 = _StyleRemove._0;
                Yoorkin$rabbit$45$tea$dom$$HTMLElement$remove_style(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(element), _key$4);
                break;
              }
              case 4: {
                const _PropertyAdd = patch;
                const _key$5 = _PropertyAdd._0;
                const _value$3 = _PropertyAdd._1;
                Yoorkin$rabbit$45$tea$dom$$Element$set_property(element, _key$5, Yoorkin$rabbit$45$tea$internal$vdom$$variant_to_js_value(_value$3));
                break;
              }
              case 5: {
                const _PropertyRemove = patch;
                const _key$6 = _PropertyRemove._0;
                Yoorkin$rabbit$45$tea$dom$$Element$remove_property(element, _key$6);
                break;
              }
              case 6: {
                const _EventRemove = patch;
                const _key$7 = _EventRemove._0;
                const _listener = _EventRemove._1;
                Yoorkin$rabbit$45$tea$dom$$EventTarget$remove_event_listener(Yoorkin$rabbit$45$tea$dom$$Node$to_event_target(Yoorkin$rabbit$45$tea$dom$$Element$to_node(element)), _key$7, _listener);
                break;
              }
              default: {
                const _EventAdd = patch;
                const _key$8 = _EventAdd._0;
                const _handler = _EventAdd._1;
                let listener;
                switch (_handler.$tag) {
                  case 0: {
                    const _Normal = _handler;
                    const _msg = _Normal._0;
                    listener = (_event) => {
                      Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(sandbox, _msg);
                    };
                    break;
                  }
                  case 1: {
                    const _HandleEvent = _handler;
                    const _f = _HandleEvent._0;
                    listener = (event) => {
                      Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(sandbox, _f(event));
                    };
                    break;
                  }
                  default: {
                    const _Custom = _handler;
                    const _msg$2 = _Custom._0;
                    const _stop_propagation = _Custom._1;
                    const _prevent_default = _Custom._2;
                    listener = (event) => {
                      if (_stop_propagation) {
                        Yoorkin$rabbit$45$tea$dom$$Event$stop_propagation(event);
                      }
                      if (_prevent_default) {
                        Yoorkin$rabbit$45$tea$dom$$Event$prevent_default(event);
                      }
                      Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$update$366$(sandbox, _msg$2);
                    };
                  }
                }
                Yoorkin$rabbit$45$tea$dom$$EventTarget$add_event_listener(Yoorkin$rabbit$45$tea$dom$$Node$to_event_target(Yoorkin$rabbit$45$tea$dom$$Element$to_node(element)), _key$8, listener);
                moonbitlang$core$array$$Array$push$295$(_new_listeners, { _0: _key$8, _1: listener });
              }
            }
            _tmp$3 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _len$3 = _childs_patches.length;
        let _tmp$4 = 0;
        while (true) {
          const _i = _tmp$4;
          if (_i < _len$3) {
            const patch = _childs_patches[_i];
            Yoorkin$rabbit$45$tea$internal$vdom$$patch$46$aux$47$6191(sandbox, patch, node);
            _tmp$4 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      } else {
        const _UpdateText = _update;
        const _index$5 = _UpdateText._0;
        const _value = _UpdateText._1;
        const text_node = Yoorkin$rabbit$45$tea$dom$$Document$create_text_node(Yoorkin$rabbit$45$tea$dom$$document(), _value);
        Yoorkin$rabbit$45$tea$dom$$Node$replace_child(current, Yoorkin$rabbit$45$tea$dom$$Element$to_node(text_node), Yoorkin$rabbit$45$tea$dom$$Node$nth_child(current, _index$5));
        return;
      }
    }
  }
}
function Yoorkin$rabbit$45$tea$internal$vdom$$Node$patch$366$(self, old, sandbox, mount) {
  const patches = Yoorkin$rabbit$45$tea$internal$vdom$$diff$361$(old, self);
  const root = Yoorkin$rabbit$45$tea$dom$$Element$to_node(Yoorkin$rabbit$45$tea$dom$$Document$get_element_by_id(Yoorkin$rabbit$45$tea$dom$$document(), mount));
  Yoorkin$rabbit$45$tea$internal$vdom$$patch$46$aux$47$6191(sandbox, patches, root);
}
function Yoorkin$rabbit$45$tea$html$$T$map$365$(self, f) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$Node$map$365$(self, f);
}
function Yoorkin$rabbit$45$tea$html$$T$map$364$(self, f) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$Node$map$364$(self, f);
}
function Yoorkin$rabbit$45$tea$html$$node$361$(tag, attributes, childrens) {
  const _p = new Array(attributes.length);
  const _p$2 = attributes.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = attributes[_p$3];
      const x = _p$4;
      _p[_p$3] = x;
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _p$3 = new Array(childrens.length);
  const _p$4 = childrens.length;
  let _tmp$2 = 0;
  while (true) {
    const _p$5 = _tmp$2;
    if (_p$5 < _p$4) {
      const _p$6 = childrens[_p$5];
      const x = _p$6;
      _p$3[_p$5] = x;
      _tmp$2 = _p$5 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return Yoorkin$rabbit$45$tea$internal$vdom$$node$361$(tag, _p, _p$3);
}
function Yoorkin$rabbit$45$tea$html$$node$363$(tag, attributes, childrens) {
  const _p = new Array(attributes.length);
  const _p$2 = attributes.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = attributes[_p$3];
      const x = _p$4;
      _p[_p$3] = x;
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _p$3 = new Array(childrens.length);
  const _p$4 = childrens.length;
  let _tmp$2 = 0;
  while (true) {
    const _p$5 = _tmp$2;
    if (_p$5 < _p$4) {
      const _p$6 = childrens[_p$5];
      const x = _p$6;
      _p$3[_p$5] = x;
      _tmp$2 = _p$5 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return Yoorkin$rabbit$45$tea$internal$vdom$$node$363$(tag, _p, _p$3);
}
function Yoorkin$rabbit$45$tea$html$$node$362$(tag, attributes, childrens) {
  const _p = new Array(attributes.length);
  const _p$2 = attributes.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = attributes[_p$3];
      const x = _p$4;
      _p[_p$3] = x;
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _p$3 = new Array(childrens.length);
  const _p$4 = childrens.length;
  let _tmp$2 = 0;
  while (true) {
    const _p$5 = _tmp$2;
    if (_p$5 < _p$4) {
      const _p$6 = childrens[_p$5];
      const x = _p$6;
      _p$3[_p$5] = x;
      _tmp$2 = _p$5 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return Yoorkin$rabbit$45$tea$internal$vdom$$node$362$(tag, _p, _p$3);
}
function Yoorkin$rabbit$45$tea$html$$T$to_virtual_dom$361$(self) {
  return Yoorkin$rabbit$45$tea$html$$node$361$("root", [], [self]);
}
function Yoorkin$rabbit$45$tea$html$$attribute$362$(key, value) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$attribute$362$(key, value);
}
function Yoorkin$rabbit$45$tea$html$$attribute$363$(key, value) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$attribute$363$(key, value);
}
function Yoorkin$rabbit$45$tea$html$$attribute$361$(key, value) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$attribute$361$(key, value);
}
function Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, tag, attributes, childrens) {
  const attrs = [];
  if (style.length > 0) {
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("style", moonbitlang$core$array$$Array$join(style, ";")));
  }
  if (class_ === undefined) {
  } else {
    const _Some = class_;
    const _class = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("class", _class));
  }
  if (id === undefined) {
  } else {
    const _Some = id;
    const _id = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("id", _id));
  }
  return Yoorkin$rabbit$45$tea$html$$node$363$(tag, moonbitlang$core$builtin$$Add$op_add$336$(attributes, attrs), childrens);
}
function Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, tag, attributes, childrens) {
  const attrs = [];
  if (style.length > 0) {
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("style", moonbitlang$core$array$$Array$join(style, ";")));
  }
  if (class_ === undefined) {
  } else {
    const _Some = class_;
    const _class = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("class", _class));
  }
  if (id === undefined) {
  } else {
    const _Some = id;
    const _id = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("id", _id));
  }
  return Yoorkin$rabbit$45$tea$html$$node$362$(tag, moonbitlang$core$builtin$$Add$op_add$337$(attributes, attrs), childrens);
}
function Yoorkin$rabbit$45$tea$html$$common_node$361$(style, id, class_, tag, attributes, childrens) {
  const attrs = [];
  if (style.length > 0) {
    moonbitlang$core$array$$Array$push$300$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$361$("style", moonbitlang$core$array$$Array$join(style, ";")));
  }
  if (class_ === undefined) {
  } else {
    const _Some = class_;
    const _class = _Some;
    moonbitlang$core$array$$Array$push$300$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$361$("class", _class));
  }
  if (id === undefined) {
  } else {
    const _Some = id;
    const _id = _Some;
    moonbitlang$core$array$$Array$push$300$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$361$("id", _id));
  }
  return Yoorkin$rabbit$45$tea$html$$node$361$(tag, moonbitlang$core$builtin$$Add$op_add$338$(attributes, attrs), childrens);
}
function Yoorkin$rabbit$45$tea$html$$nothing$363$() {
  return Yoorkin$rabbit$45$tea$internal$vdom$$nothing$363$();
}
function Yoorkin$rabbit$45$tea$html$$nothing$362$() {
  return Yoorkin$rabbit$45$tea$internal$vdom$$nothing$362$();
}
function Yoorkin$rabbit$45$tea$html$$on_mouse$363$(event, msg) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$on$363$(event, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$73$((event$2) => msg(moonbitlang$core$option$$Option$unwrap$273$(rami3l$js$45$ffi$js$$Nullable$to_option$273$(Yoorkin$rabbit$45$tea$dom$$UIEvent$to_mouse_event(moonbitlang$core$option$$Option$unwrap$274$(rami3l$js$45$ffi$js$$Nullable$to_option$274$(Yoorkin$rabbit$45$tea$dom$$Event$to_ui_event(event$2)))))))));
}
function Yoorkin$rabbit$45$tea$html$$on_mouse$362$(event, msg) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$on$362$(event, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$72$((event$2) => msg(moonbitlang$core$option$$Option$unwrap$273$(rami3l$js$45$ffi$js$$Nullable$to_option$273$(Yoorkin$rabbit$45$tea$dom$$UIEvent$to_mouse_event(moonbitlang$core$option$$Option$unwrap$274$(rami3l$js$45$ffi$js$$Nullable$to_option$274$(Yoorkin$rabbit$45$tea$dom$$Event$to_ui_event(event$2)))))))));
}
function Yoorkin$rabbit$45$tea$html$$on_mouse$361$(event, msg) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$on$361$(event, new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$71$((event$2) => msg(moonbitlang$core$option$$Option$unwrap$273$(rami3l$js$45$ffi$js$$Nullable$to_option$273$(Yoorkin$rabbit$45$tea$dom$$UIEvent$to_mouse_event(moonbitlang$core$option$$Option$unwrap$274$(rami3l$js$45$ffi$js$$Nullable$to_option$274$(Yoorkin$rabbit$45$tea$dom$$Event$to_ui_event(event$2)))))))));
}
function Yoorkin$rabbit$45$tea$html$$on_click$363$(msg) {
  return Yoorkin$rabbit$45$tea$html$$on_mouse$363$("click", msg);
}
function Yoorkin$rabbit$45$tea$html$$on_click$362$(msg) {
  return Yoorkin$rabbit$45$tea$html$$on_mouse$362$("click", msg);
}
function Yoorkin$rabbit$45$tea$html$$on_click$361$(msg) {
  return Yoorkin$rabbit$45$tea$html$$on_mouse$361$("click", msg);
}
function Yoorkin$rabbit$45$tea$html$$button$362$(style, id, class_, click, childrens) {
  const attrs = [];
  if (click === undefined) {
  } else {
    const _Some = click;
    const _click = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$on_click$362$((_discard_) => _click));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "button", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$button$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$h1$361$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$361$(style, id, class_, "h1", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$h1$363$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, "h1", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$h1$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "h1", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$361$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$h2$363$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, "h2", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$h2$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "h2", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$h2$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$h2$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$h3$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "h3", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$h3$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$h4$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "h4", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$h4$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$h5$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "h5", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$h5$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$div$363$(style, id, class_, click, childrens) {
  const attrs = [];
  if (click === undefined) {
  } else {
    const _Some = click;
    const _click = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$on_click$363$((_discard_) => _click));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, "div", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$div$362$(style, id, class_, click, childrens) {
  const attrs = [];
  if (click === undefined) {
  } else {
    const _Some = click;
    const _click = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$on_click$362$((_discard_) => _click));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "div", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$div$361$(style, id, class_, click, childrens) {
  const attrs = [];
  if (click === undefined) {
  } else {
    const _Some = click;
    const _click = _Some;
    moonbitlang$core$array$$Array$push$300$(attrs, Yoorkin$rabbit$45$tea$html$$on_click$361$((_discard_) => _click));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$361$(style, id, class_, "div", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$361$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$p$361$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$361$(style, id, class_, "p", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$p$363$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, "p", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$p$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "p", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$361$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$hr$363$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, "hr", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$hr$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "hr", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$hr$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$hr$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$hr$46$childrens$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$hr$46$childrens$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$pre$363$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, "pre", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$pre$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "pre", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$pre$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$pre$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$blockquote$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "blockquote", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$blockquote$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$span$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "span", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$span$363$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, "span", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$Target$to_string(self) {
  if (self === 0) {
    return "_self";
  } else {
    return "_blank";
  }
}
function Yoorkin$rabbit$45$tea$html$$a$362$(style, id, class_, href, target, childrens, escape) {
  const attrs = [Yoorkin$rabbit$45$tea$internal$vdom$$attribute$362$("href", href), Yoorkin$rabbit$45$tea$internal$vdom$$attribute$362$("target", Yoorkin$rabbit$45$tea$html$$Target$to_string(target))];
  if (style.length > 0) {
    moonbitlang$core$array$$Array$push$299$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$attribute$362$("style", moonbitlang$core$array$$Array$join(style, ";")));
  }
  if (class_ === undefined) {
  } else {
    const _Some = class_;
    const _class = _Some;
    moonbitlang$core$array$$Array$push$299$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$attribute$362$("class", _class));
  }
  if (id === undefined) {
  } else {
    const _Some = id;
    const _id = _Some;
    moonbitlang$core$array$$Array$push$299$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$attribute$362$("id", _id));
  }
  const _p = new Array(childrens.length);
  const _p$2 = childrens.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = childrens[_p$3];
      const x = _p$4;
      _p[_p$3] = x;
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return Yoorkin$rabbit$45$tea$internal$vdom$$link$362$(attrs, _p, escape);
}
function Yoorkin$rabbit$45$tea$html$$a$361$(style, id, class_, href, target, childrens, escape) {
  const attrs = [Yoorkin$rabbit$45$tea$internal$vdom$$attribute$361$("href", href), Yoorkin$rabbit$45$tea$internal$vdom$$attribute$361$("target", Yoorkin$rabbit$45$tea$html$$Target$to_string(target))];
  if (style.length > 0) {
    moonbitlang$core$array$$Array$push$286$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$attribute$361$("style", moonbitlang$core$array$$Array$join(style, ";")));
  }
  if (class_ === undefined) {
  } else {
    const _Some = class_;
    const _class = _Some;
    moonbitlang$core$array$$Array$push$286$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$attribute$361$("class", _class));
  }
  if (id === undefined) {
  } else {
    const _Some = id;
    const _id = _Some;
    moonbitlang$core$array$$Array$push$286$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$attribute$361$("id", _id));
  }
  const _p = new Array(childrens.length);
  const _p$2 = childrens.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = childrens[_p$3];
      const x = _p$4;
      _p[_p$3] = x;
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return Yoorkin$rabbit$45$tea$internal$vdom$$link$361$(attrs, _p, escape);
}
function Yoorkin$rabbit$45$tea$html$$a$363$(style, id, class_, href, target, childrens, escape) {
  const attrs = [Yoorkin$rabbit$45$tea$internal$vdom$$attribute$363$("href", href), Yoorkin$rabbit$45$tea$internal$vdom$$attribute$363$("target", Yoorkin$rabbit$45$tea$html$$Target$to_string(target))];
  if (style.length > 0) {
    moonbitlang$core$array$$Array$push$302$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$attribute$363$("style", moonbitlang$core$array$$Array$join(style, ";")));
  }
  if (class_ === undefined) {
  } else {
    const _Some = class_;
    const _class = _Some;
    moonbitlang$core$array$$Array$push$302$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$attribute$363$("class", _class));
  }
  if (id === undefined) {
  } else {
    const _Some = id;
    const _id = _Some;
    moonbitlang$core$array$$Array$push$302$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$attribute$363$("id", _id));
  }
  const _p = new Array(childrens.length);
  const _p$2 = childrens.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = childrens[_p$3];
      const x = _p$4;
      _p[_p$3] = x;
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return Yoorkin$rabbit$45$tea$internal$vdom$$link$363$(attrs, _p, escape);
}
function Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$361$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$() {
  return 0;
}
function Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$361$() {
  return 0;
}
function Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$363$() {
  return 0;
}
function Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$() {
  return false;
}
function Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$361$() {
  return false;
}
function Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$363$() {
  return false;
}
function Yoorkin$rabbit$45$tea$html$$code$363$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, "code", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$code$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "code", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$code$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$code$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$em$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "em", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$em$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$strong$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "strong", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$strong$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$text$362$(str) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$text$362$(str);
}
function Yoorkin$rabbit$45$tea$html$$text$361$(str) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$text$361$(str);
}
function Yoorkin$rabbit$45$tea$html$$text$363$(str) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$text$363$(str);
}
function Yoorkin$rabbit$45$tea$html$$ul$362$(style, id, class_, click, childrens) {
  const attrs = [];
  if (click === undefined) {
  } else {
    const _Some = click;
    const _click = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$on_click$362$((_discard_) => _click));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "ul", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$ul$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$ol$362$(style, reversed, start, id, class_, childrens) {
  const attrs = [];
  if (reversed === -1) {
  } else {
    const _Some = reversed;
    const _reversed = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("reversed", moonbitlang$core$builtin$$Show$to_string$323$(_reversed)));
  }
  if (start === undefined) {
  } else {
    const _Some = start;
    const _start = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("start", moonbitlang$core$int$$Int$to_string(_start, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "ol", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$ol$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$li$362$(style, value, id, class_, click, childrens) {
  const attrs = [];
  if (click === undefined) {
  } else {
    const _Some = click;
    const _click = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$on_click$362$((_discard_) => _click));
  }
  if (value === undefined) {
  } else {
    const _Some = value;
    const _value = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("value", moonbitlang$core$int$$Int$to_string(_value, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "li", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$li$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$img$362$(style, id, class_, src, alt, title, width, height, border, childrens) {
  const attrs = [];
  if (src === undefined) {
  } else {
    const _Some = src;
    const _src = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("src", _src));
  }
  if (alt === undefined) {
  } else {
    const _Some = alt;
    const _alt = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("alt", _alt));
  }
  if (title === undefined) {
  } else {
    const _Some = title;
    const _title = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("title", _title));
  }
  if (width === undefined) {
  } else {
    const _Some = width;
    const _width = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("width", moonbitlang$core$int$$Int$to_string(_width, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (height === undefined) {
  } else {
    const _Some = height;
    const _height = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("height", moonbitlang$core$int$$Int$to_string(_height, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (border === undefined) {
  } else {
    const _Some = border;
    const _border = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("border", moonbitlang$core$int$$Int$to_string(_border, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "img", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$img$363$(style, id, class_, src, alt, title, width, height, border, childrens) {
  const attrs = [];
  if (src === undefined) {
  } else {
    const _Some = src;
    const _src = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("src", _src));
  }
  if (alt === undefined) {
  } else {
    const _Some = alt;
    const _alt = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("alt", _alt));
  }
  if (title === undefined) {
  } else {
    const _Some = title;
    const _title = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("title", _title));
  }
  if (width === undefined) {
  } else {
    const _Some = width;
    const _width = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("width", moonbitlang$core$int$$Int$to_string(_width, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (height === undefined) {
  } else {
    const _Some = height;
    const _height = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("height", moonbitlang$core$int$$Int$to_string(_height, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (border === undefined) {
  } else {
    const _Some = border;
    const _border = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("border", moonbitlang$core$int$$Int$to_string(_border, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, "img", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$br$362$(style, id, class_) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "br", [], []);
}
function Yoorkin$rabbit$45$tea$html$$br$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$on_change$362$(msg) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$on$362$("change", new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$72$((event) => {
    const html_element = moonbitlang$core$option$$Option$unwrap$268$(rami3l$js$45$ffi$js$$Nullable$to_option$268$(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(moonbitlang$core$option$$Option$unwrap$266$(rami3l$js$45$ffi$js$$Nullable$to_option$266$(Yoorkin$rabbit$45$tea$dom$$Node$to_element(moonbitlang$core$option$$Option$unwrap$270$(rami3l$js$45$ffi$js$$Nullable$to_option$270$(Yoorkin$rabbit$45$tea$dom$$EventTarget$to_node(Yoorkin$rabbit$45$tea$dom$$Event$target(event))))))))));
    const _bind = rami3l$js$45$ffi$js$$Nullable$to_option$272$(Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_input_element(html_element));
    let value;
    if (_bind.$tag === 1) {
      const _Some = _bind;
      const _x = _Some._0;
      value = Yoorkin$rabbit$45$tea$dom$$HTMLInputElement$value(_x);
    } else {
      const _bind$2 = rami3l$js$45$ffi$js$$Nullable$to_option$360$(Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_select_element(html_element));
      if (_bind$2.$tag === 1) {
        const _Some = _bind$2;
        const _x = _Some._0;
        value = Yoorkin$rabbit$45$tea$dom$$HTMLSelectElement$value(_x);
      } else {
        value = $panic();
      }
    }
    return msg(value);
  }));
}
function Yoorkin$rabbit$45$tea$html$$on_change$363$(msg) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$on$363$("change", new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$73$((event) => {
    const html_element = moonbitlang$core$option$$Option$unwrap$268$(rami3l$js$45$ffi$js$$Nullable$to_option$268$(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(moonbitlang$core$option$$Option$unwrap$266$(rami3l$js$45$ffi$js$$Nullable$to_option$266$(Yoorkin$rabbit$45$tea$dom$$Node$to_element(moonbitlang$core$option$$Option$unwrap$270$(rami3l$js$45$ffi$js$$Nullable$to_option$270$(Yoorkin$rabbit$45$tea$dom$$EventTarget$to_node(Yoorkin$rabbit$45$tea$dom$$Event$target(event))))))))));
    const _bind = rami3l$js$45$ffi$js$$Nullable$to_option$272$(Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_input_element(html_element));
    let value;
    if (_bind.$tag === 1) {
      const _Some = _bind;
      const _x = _Some._0;
      value = Yoorkin$rabbit$45$tea$dom$$HTMLInputElement$value(_x);
    } else {
      const _bind$2 = rami3l$js$45$ffi$js$$Nullable$to_option$360$(Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_select_element(html_element));
      if (_bind$2.$tag === 1) {
        const _Some = _bind$2;
        const _x = _Some._0;
        value = Yoorkin$rabbit$45$tea$dom$$HTMLSelectElement$value(_x);
      } else {
        value = $panic();
      }
    }
    return msg(value);
  }));
}
function Yoorkin$rabbit$45$tea$html$$on_input$362$(msg) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$on$362$("input", new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$72$((event) => {
    const value = Yoorkin$rabbit$45$tea$dom$$HTMLInputElement$value(moonbitlang$core$option$$Option$unwrap$272$(rami3l$js$45$ffi$js$$Nullable$to_option$272$(Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_input_element(moonbitlang$core$option$$Option$unwrap$268$(rami3l$js$45$ffi$js$$Nullable$to_option$268$(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(moonbitlang$core$option$$Option$unwrap$266$(rami3l$js$45$ffi$js$$Nullable$to_option$266$(Yoorkin$rabbit$45$tea$dom$$Node$to_element(moonbitlang$core$option$$Option$unwrap$270$(rami3l$js$45$ffi$js$$Nullable$to_option$270$(Yoorkin$rabbit$45$tea$dom$$EventTarget$to_node(Yoorkin$rabbit$45$tea$dom$$Event$target(event))))))))))))));
    return msg(value);
  }));
}
function Yoorkin$rabbit$45$tea$html$$on_input$363$(msg) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$on$363$("input", new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$73$((event) => {
    const value = Yoorkin$rabbit$45$tea$dom$$HTMLInputElement$value(moonbitlang$core$option$$Option$unwrap$272$(rami3l$js$45$ffi$js$$Nullable$to_option$272$(Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_input_element(moonbitlang$core$option$$Option$unwrap$268$(rami3l$js$45$ffi$js$$Nullable$to_option$268$(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(moonbitlang$core$option$$Option$unwrap$266$(rami3l$js$45$ffi$js$$Nullable$to_option$266$(Yoorkin$rabbit$45$tea$dom$$Node$to_element(moonbitlang$core$option$$Option$unwrap$270$(rami3l$js$45$ffi$js$$Nullable$to_option$270$(Yoorkin$rabbit$45$tea$dom$$EventTarget$to_node(Yoorkin$rabbit$45$tea$dom$$Event$target(event))))))))))))));
    return msg(value);
  }));
}
function Yoorkin$rabbit$45$tea$html$$property$362$(key, value) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$property$362$(key, value);
}
function Yoorkin$rabbit$45$tea$html$$property$363$(key, value) {
  return Yoorkin$rabbit$45$tea$internal$vdom$$property$363$(key, value);
}
function Yoorkin$rabbit$45$tea$html$$input$362$(input_type, name, value, checked, read_only, multiple, accept, placeholder, auto_complete, style, max, min, step, maxlength, minlength, pattern, size, width, height, id, class_, childrens, change, input) {
  let input_type$2;
  switch (input_type) {
    case 0: {
      input_type$2 = "button";
      break;
    }
    case 1: {
      input_type$2 = "checkbox";
      break;
    }
    case 2: {
      input_type$2 = "color";
      break;
    }
    case 3: {
      input_type$2 = "date";
      break;
    }
    case 4: {
      input_type$2 = "datetime-local";
      break;
    }
    case 5: {
      input_type$2 = "email";
      break;
    }
    case 6: {
      input_type$2 = "file";
      break;
    }
    case 7: {
      input_type$2 = "hidden";
      break;
    }
    case 8: {
      input_type$2 = "image";
      break;
    }
    case 9: {
      input_type$2 = "month";
      break;
    }
    case 10: {
      input_type$2 = "number";
      break;
    }
    case 11: {
      input_type$2 = "password";
      break;
    }
    case 12: {
      input_type$2 = "radio";
      break;
    }
    case 13: {
      input_type$2 = "range";
      break;
    }
    case 14: {
      input_type$2 = "reset";
      break;
    }
    case 15: {
      input_type$2 = "search";
      break;
    }
    case 16: {
      input_type$2 = "submit";
      break;
    }
    case 17: {
      input_type$2 = "tel";
      break;
    }
    case 18: {
      input_type$2 = "text";
      break;
    }
    case 19: {
      input_type$2 = "time";
      break;
    }
    case 20: {
      input_type$2 = "url";
      break;
    }
    default: {
      input_type$2 = "week";
    }
  }
  let auto_complete$2;
  if (auto_complete === undefined) {
    auto_complete$2 = "off";
  } else {
    const _Some = auto_complete;
    const _x = _Some;
    if (_x === 0) {
      auto_complete$2 = "on";
    } else {
      auto_complete$2 = "off";
    }
  }
  const attrs = [];
  moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("type", input_type$2));
  moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("autocomplete", auto_complete$2));
  if (name === undefined) {
  } else {
    const _Some = name;
    const _name = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("name", _name));
  }
  if (value === undefined) {
  } else {
    const _Some = value;
    const _value = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$property$362$("value", new $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$String(_value)));
  }
  if (checked === -1) {
  } else {
    const _Some = checked;
    const _checked = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$property$362$("checked", new $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Boolean(_checked)));
  }
  if (read_only === -1) {
  } else {
    const _Some = read_only;
    const _read_only = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$property$362$("readonly", new $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Boolean(_read_only)));
  }
  if (multiple === -1) {
  } else {
    const _Some = multiple;
    const _multiple = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$property$362$("multiple", new $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Boolean(_multiple)));
  }
  if (accept === undefined) {
  } else {
    const _Some = accept;
    const _accept = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("accept", _accept));
  }
  if (max === undefined) {
  } else {
    const _Some = max;
    const _max = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("max", moonbitlang$core$int$$Int$to_string(_max, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (min === undefined) {
  } else {
    const _Some = min;
    const _min = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("min", moonbitlang$core$int$$Int$to_string(_min, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (step === undefined) {
  } else {
    const _Some = step;
    const _step = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("step", moonbitlang$core$int$$Int$to_string(_step, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (maxlength === undefined) {
  } else {
    const _Some = maxlength;
    const _maxlength = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("maxlength", moonbitlang$core$int$$Int$to_string(_maxlength, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (minlength === undefined) {
  } else {
    const _Some = minlength;
    const _minlength = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("minlength", moonbitlang$core$int$$Int$to_string(_minlength, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (pattern === undefined) {
  } else {
    const _Some = pattern;
    const _pattern = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("pattern", _pattern));
  }
  if (size === undefined) {
  } else {
    const _Some = size;
    const _size = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("size", moonbitlang$core$int$$Int$to_string(_size, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (width === undefined) {
  } else {
    const _Some = width;
    const _width = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("width", moonbitlang$core$int$$Int$to_string(_width, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (height === undefined) {
  } else {
    const _Some = height;
    const _height = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("height", moonbitlang$core$int$$Int$to_string(_height, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (placeholder === undefined) {
  } else {
    const _Some = placeholder;
    const _placeholder = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("placeholder", _placeholder));
  }
  if (change === undefined) {
  } else {
    const _Some = change;
    const _to_msg = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$on_change$362$(_to_msg));
  }
  if (input === undefined) {
  } else {
    const _Some = input;
    const _to_msg = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$on_input$362$(_to_msg));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "input", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$input$363$(input_type, name, value, checked, read_only, multiple, accept, placeholder, auto_complete, style, max, min, step, maxlength, minlength, pattern, size, width, height, id, class_, childrens, change, input) {
  let input_type$2;
  switch (input_type) {
    case 0: {
      input_type$2 = "button";
      break;
    }
    case 1: {
      input_type$2 = "checkbox";
      break;
    }
    case 2: {
      input_type$2 = "color";
      break;
    }
    case 3: {
      input_type$2 = "date";
      break;
    }
    case 4: {
      input_type$2 = "datetime-local";
      break;
    }
    case 5: {
      input_type$2 = "email";
      break;
    }
    case 6: {
      input_type$2 = "file";
      break;
    }
    case 7: {
      input_type$2 = "hidden";
      break;
    }
    case 8: {
      input_type$2 = "image";
      break;
    }
    case 9: {
      input_type$2 = "month";
      break;
    }
    case 10: {
      input_type$2 = "number";
      break;
    }
    case 11: {
      input_type$2 = "password";
      break;
    }
    case 12: {
      input_type$2 = "radio";
      break;
    }
    case 13: {
      input_type$2 = "range";
      break;
    }
    case 14: {
      input_type$2 = "reset";
      break;
    }
    case 15: {
      input_type$2 = "search";
      break;
    }
    case 16: {
      input_type$2 = "submit";
      break;
    }
    case 17: {
      input_type$2 = "tel";
      break;
    }
    case 18: {
      input_type$2 = "text";
      break;
    }
    case 19: {
      input_type$2 = "time";
      break;
    }
    case 20: {
      input_type$2 = "url";
      break;
    }
    default: {
      input_type$2 = "week";
    }
  }
  let auto_complete$2;
  if (auto_complete === undefined) {
    auto_complete$2 = "off";
  } else {
    const _Some = auto_complete;
    const _x = _Some;
    if (_x === 0) {
      auto_complete$2 = "on";
    } else {
      auto_complete$2 = "off";
    }
  }
  const attrs = [];
  moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("type", input_type$2));
  moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("autocomplete", auto_complete$2));
  if (name === undefined) {
  } else {
    const _Some = name;
    const _name = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("name", _name));
  }
  if (value === undefined) {
  } else {
    const _Some = value;
    const _value = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$property$363$("value", new $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$String(_value)));
  }
  if (checked === -1) {
  } else {
    const _Some = checked;
    const _checked = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$property$363$("checked", new $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Boolean(_checked)));
  }
  if (read_only === -1) {
  } else {
    const _Some = read_only;
    const _read_only = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$property$363$("readonly", new $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Boolean(_read_only)));
  }
  if (multiple === -1) {
  } else {
    const _Some = multiple;
    const _multiple = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$property$363$("multiple", new $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Boolean(_multiple)));
  }
  if (accept === undefined) {
  } else {
    const _Some = accept;
    const _accept = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("accept", _accept));
  }
  if (max === undefined) {
  } else {
    const _Some = max;
    const _max = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("max", moonbitlang$core$int$$Int$to_string(_max, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (min === undefined) {
  } else {
    const _Some = min;
    const _min = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("min", moonbitlang$core$int$$Int$to_string(_min, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (step === undefined) {
  } else {
    const _Some = step;
    const _step = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("step", moonbitlang$core$int$$Int$to_string(_step, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (maxlength === undefined) {
  } else {
    const _Some = maxlength;
    const _maxlength = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("maxlength", moonbitlang$core$int$$Int$to_string(_maxlength, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (minlength === undefined) {
  } else {
    const _Some = minlength;
    const _minlength = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("minlength", moonbitlang$core$int$$Int$to_string(_minlength, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (pattern === undefined) {
  } else {
    const _Some = pattern;
    const _pattern = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("pattern", _pattern));
  }
  if (size === undefined) {
  } else {
    const _Some = size;
    const _size = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("size", moonbitlang$core$int$$Int$to_string(_size, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (width === undefined) {
  } else {
    const _Some = width;
    const _width = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("width", moonbitlang$core$int$$Int$to_string(_width, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (height === undefined) {
  } else {
    const _Some = height;
    const _height = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("height", moonbitlang$core$int$$Int$to_string(_height, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (placeholder === undefined) {
  } else {
    const _Some = placeholder;
    const _placeholder = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$363$("placeholder", _placeholder));
  }
  if (change === undefined) {
  } else {
    const _Some = change;
    const _to_msg = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$on_change$363$(_to_msg));
  }
  if (input === undefined) {
  } else {
    const _Some = input;
    const _to_msg = _Some;
    moonbitlang$core$array$$Array$push$297$(attrs, Yoorkin$rabbit$45$tea$html$$on_input$363$(_to_msg));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$363$(style, id, class_, "input", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$input$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$input$46$style$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$input$46$childrens$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$input$46$childrens$46$default$363$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$table$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "table", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$table$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$tbody$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "tbody", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$tbody$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$col$362$(style, id, span, class_, childrens) {
  const attrs = [];
  if (span === undefined) {
  } else {
    const _Some = span;
    const _span = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("span", moonbitlang$core$int$$Int$to_string(_span, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "col", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$col$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$colgroup$362$(style, id, span, class_, childrens) {
  const attrs = [];
  if (span === undefined) {
  } else {
    const _Some = span;
    const _span = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("span", moonbitlang$core$int$$Int$to_string(_span, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "colgroup", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$colgroup$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$tr$362$(style, id, class_, childrens) {
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "tr", [], childrens);
}
function Yoorkin$rabbit$45$tea$html$$tr$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$td$362$(style, id, colspan, rowspan, headers, class_, childrens) {
  const attrs = [];
  if (colspan === undefined) {
  } else {
    const _Some = colspan;
    const _colspan = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("colspan", moonbitlang$core$int$$Int$to_string(_colspan, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (rowspan === undefined) {
  } else {
    const _Some = rowspan;
    const _rowspan = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("rowspan", moonbitlang$core$int$$Int$to_string(_rowspan, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (headers === undefined) {
  } else {
    const _Some = headers;
    const _headers = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("headers", _headers));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "td", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$td$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$th$362$(style, id, abbr, colspan, rowspan, headers, scope, class_, childrens) {
  const attrs = [];
  if (colspan === undefined) {
  } else {
    const _Some = colspan;
    const _colspan = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("colspan", moonbitlang$core$int$$Int$to_string(_colspan, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (rowspan === undefined) {
  } else {
    const _Some = rowspan;
    const _rowspan = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("rowspan", moonbitlang$core$int$$Int$to_string(_rowspan, moonbitlang$core$int$$Int$to_string$46$radix$46$default())));
  }
  if (headers === undefined) {
  } else {
    const _Some = headers;
    const _headers = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("headers", _headers));
  }
  if (abbr === undefined) {
  } else {
    const _Some = abbr;
    const _abbr = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("abbr", _abbr));
  }
  if (scope === undefined) {
  } else {
    const _Some = scope;
    const _scope = _Some;
    let _tmp;
    switch (_scope) {
      case 0: {
        _tmp = "row";
        break;
      }
      case 1: {
        _tmp = "col";
        break;
      }
      case 2: {
        _tmp = "rowgroup";
        break;
      }
      default: {
        _tmp = "colgroup";
      }
    }
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$attribute$362$("scope", _tmp));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "th", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$th$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$html$$dialog$362$(style, id, class_, open, close, cancel, childrens) {
  const attrs = [];
  if (open === -1) {
  } else {
    const _Some = open;
    const _open = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$html$$property$362$("open", new $64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Boolean(_open)));
  }
  if (close === undefined) {
  } else {
    const _Some = close;
    const _close = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$on$362$("close", new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$72$((event) => {
      const html_element = moonbitlang$core$option$$Option$unwrap$267$(rami3l$js$45$ffi$js$$Nullable$to_option$267$(Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_dialog_element(moonbitlang$core$option$$Option$unwrap$268$(rami3l$js$45$ffi$js$$Nullable$to_option$268$(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(moonbitlang$core$option$$Option$unwrap$266$(rami3l$js$45$ffi$js$$Nullable$to_option$266$(Yoorkin$rabbit$45$tea$dom$$Node$to_element(moonbitlang$core$option$$Option$unwrap$270$(rami3l$js$45$ffi$js$$Nullable$to_option$270$(Yoorkin$rabbit$45$tea$dom$$EventTarget$to_node(Yoorkin$rabbit$45$tea$dom$$Event$target(event)))))))))))));
      return _close(Yoorkin$rabbit$45$tea$dom$$HTMLDialogElement$return_value(html_element));
    })));
  }
  if (cancel === undefined) {
  } else {
    const _Some = cancel;
    const _cancel = _Some;
    moonbitlang$core$array$$Array$push$298$(attrs, Yoorkin$rabbit$45$tea$internal$vdom$$on$362$("cancel", new $64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$72$((event) => {
      Yoorkin$rabbit$45$tea$dom$$Event$prevent_default(event);
      return _cancel;
    })));
  }
  return Yoorkin$rabbit$45$tea$html$$common_node$362$(style, id, class_, "dialog", attrs, childrens);
}
function Yoorkin$rabbit$45$tea$html$$dialog$46$style$46$default$362$() {
  return [];
}
function Yoorkin$rabbit$45$tea$$application$368$(initialize, update, view, url_changed, url_request, mount) {
  Yoorkin$rabbit$45$tea$dom$$Element$set_inner_html(Yoorkin$rabbit$45$tea$dom$$Document$get_element_by_id(Yoorkin$rabbit$45$tea$dom$$document(), mount), "<div></div>");
  const sandbox = { val: undefined };
  const curr_dom = { val: Yoorkin$rabbit$45$tea$internal$vdom$$node$361$("div", [], []) };
  const after_update = (html) => {
    const _bind = sandbox.val;
    if (_bind === undefined) {
      $panic();
      return;
    } else {
      const _Some = _bind;
      const _sandbox = _Some;
      const new_dom = Yoorkin$rabbit$45$tea$html$$T$to_virtual_dom$361$(html);
      Yoorkin$rabbit$45$tea$internal$vdom$$Node$patch$366$(new_dom, curr_dom.val, _sandbox, mount);
      curr_dom.val = new_dom;
      return;
    }
  };
  const _bind = Yoorkin$rabbit$45$tea$url$$parse(Yoorkin$rabbit$45$tea$dom$$Window$current_url(Yoorkin$rabbit$45$tea$dom$$window()));
  if (_bind.$tag === 1) {
    const _Ok = _bind;
    const _url = _Ok._0;
    const _bind$2 = initialize(_url);
    const _cmd = _bind$2._0;
    const _model = _bind$2._1;
    sandbox.val = Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$new$367$(_model, update, view, after_update, url_changed, url_request);
    Yoorkin$rabbit$45$tea$internal$browser$$Sandbox$launch$366$(moonbitlang$core$option$$Option$unwrap$264$(sandbox.val), _cmd);
    return;
  } else {
    $panic();
    return;
  }
}
function Yoorkin$rabbit$45$tea$$application$46$mount$46$default$368$() {
  return "app";
}
function Yoorkin$rabbit$45$tea$nav$$load$361$(url) {
  return (_discard_) => {
    Yoorkin$rabbit$45$tea$dom$$Window$load_url(Yoorkin$rabbit$45$tea$dom$$window(), url);
  };
}
function Yoorkin$rabbit$45$tea$nav$$push_url$361$(url) {
  return (events) => {
    Yoorkin$rabbit$45$tea$dom$$Window$push_url(Yoorkin$rabbit$45$tea$dom$$window(), url);
    const _bind = Yoorkin$rabbit$45$tea$url$$parse(Yoorkin$rabbit$45$tea$dom$$Window$current_url(Yoorkin$rabbit$45$tea$dom$$window()));
    if (_bind.$tag === 1) {
      const _Ok = _bind;
      const _url = _Ok._0;
      Yoorkin$rabbit$45$tea$cmd$$Events$trigger_url_changed$361$(events, _url);
      return;
    } else {
      $panic();
      return;
    }
  };
}
function Yoorkin$rabbit$45$tea$nav$$push_url$362$(url) {
  return (events) => {
    Yoorkin$rabbit$45$tea$dom$$Window$push_url(Yoorkin$rabbit$45$tea$dom$$window(), url);
    const _bind = Yoorkin$rabbit$45$tea$url$$parse(Yoorkin$rabbit$45$tea$dom$$Window$current_url(Yoorkin$rabbit$45$tea$dom$$window()));
    if (_bind.$tag === 1) {
      const _Ok = _bind;
      const _url = _Ok._0;
      Yoorkin$rabbit$45$tea$cmd$$Events$trigger_url_changed$362$(events, _url);
      return;
    } else {
      $panic();
      return;
    }
  };
}
function Yoorkin$rabbit$45$tea$nav$$scroll_to$362$(element) {
  return (_discard_) => {
    const _bind = rami3l$js$45$ffi$js$$Nullable$to_option$266$(Yoorkin$rabbit$45$tea$dom$$Document$get_element_by_id(Yoorkin$rabbit$45$tea$dom$$document(), element));
    if (_bind.$tag === 1) {
      const _Some = _bind;
      const _e = _Some._0;
      Yoorkin$rabbit$45$tea$dom$$Element$scroll_into_view(_e);
      return;
    } else {
      return;
    }
  };
}
function rami3l$cmark$char$$html_named_entity(name) {
  return moonbitlang$core$option$$Option$bind$53$(moonbitlang$core$json$$Json$value(rami3l$cmark$char$$html_named_entities, name), moonbitlang$core$json$$Json$as_string);
}
function rami3l$cmark$char$$is_high_surrogate(ord) {
  return 55296 <= ord && ord <= 56319;
}
function rami3l$cmark$char$$is_low_surrogate(ord) {
  return 56320 <= ord && ord <= 57343;
}
function rami3l$cmark$char$$code_point_at(s, idx) {
  $bound_check(s, idx);
  const fst = s.charCodeAt(idx);
  if (rami3l$cmark$char$$is_high_surrogate(fst) && idx < (s.length - 1 | 0)) {
    const _tmp = idx + 1 | 0;
    $bound_check(s, _tmp);
    const snd = s.charCodeAt(_tmp);
    if (rami3l$cmark$char$$is_low_surrogate(snd)) {
      return (((Math.imul(fst - 55296 | 0, 1024) | 0) + snd | 0) - 56320 | 0) + 65536 | 0;
    }
  }
  return fst;
}
function rami3l$cmark$char$$at(s, idx) {
  return rami3l$cmark$char$$code_point_at(s, idx);
}
function rami3l$cmark$char$$from_int_checked(ord) {
  if (ord >= 1114112 || 55296 <= ord && ord < 57344) {
    return -1;
  }
  return ord;
}
function rami3l$cmark$char$$at_checked(s, idx) {
  const cp = rami3l$cmark$char$$code_point_at(s, idx);
  const _bind = rami3l$cmark$char$$from_int_checked(cp);
  if (_bind === -1) {
    return new Result$Err$74$(cp);
  } else {
    const _Some = _bind;
    const _c = _Some;
    return new Result$Ok$74$(_c);
  }
}
function rami3l$cmark$char$$sub_includes(affix, s, first, last) {
  const len_a = affix.length;
  const len_s = (last - first | 0) + 1 | 0;
  if (len_a > len_s) {
    return false;
  }
  const max_idx_a = len_a - 1 | 0;
  const max_idx_s = first + (len_s - len_a | 0) | 0;
  let _tmp = first;
  let _tmp$2 = 0;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if (_param > max_idx_s) {
      return false;
    }
    if (_param$2 > max_idx_a) {
      return true;
    }
    if (_param$2 > 0) {
      $bound_check(affix, _param$2);
      const _tmp$3 = affix.charCodeAt(_param$2);
      const _tmp$4 = _param + _param$2 | 0;
      $bound_check(s, _tmp$4);
      if (_tmp$3 === s.charCodeAt(_tmp$4)) {
        _tmp$2 = _param$2 + 1 | 0;
        continue;
      } else {
        const _tmp$5 = _param + 1 | 0;
        _tmp = _tmp$5;
        _tmp$2 = 0;
        continue;
      }
    }
    $bound_check(affix, 0);
    const _tmp$3 = affix.charCodeAt(0);
    $bound_check(s, _param);
    if (_tmp$3 === s.charCodeAt(_param)) {
      _tmp$2 = 1;
      continue;
    } else {
      const _tmp$4 = _param + 1 | 0;
      _tmp = _tmp$4;
      _tmp$2 = 0;
      continue;
    }
  }
}
function rami3l$cmark$char$$prev_char(s, first, before) {
  if (before <= first) {
    return 32;
  }
  let k;
  let _tmp = before - 1 | 0;
  while (true) {
    const start = _tmp;
    if (first <= start) {
      _L: {
        _L$2: {
          $bound_check(s, start);
          const _bind = s.charCodeAt(start);
          if (_bind >= 0 && _bind <= 127) {
            break _L$2;
          } else {
            if (_bind >= 194 && _bind <= 223) {
              break _L$2;
            } else {
              if (_bind >= 224 && _bind <= 239) {
                break _L$2;
              } else {
                if (_bind >= 240 && _bind <= 244) {
                  break _L$2;
                }
              }
            }
          }
          break _L;
        }
        k = start;
        break;
      }
    } else {
      k = first;
      break;
    }
    _tmp = start - 1 | 0;
    continue;
  }
  return rami3l$cmark$char$$at(s, k);
}
function rami3l$cmark$char$$next_char(s, last, after) {
  if (after >= last) {
    return 32;
  }
  return rami3l$cmark$char$$at(s, after + 1 | 0);
}
function rami3l$cmark$char$$length_utf16(ch) {
  const ch$2 = ch;
  return ch$2 < 65536 ? 1 : 2;
}
function rami3l$cmark$char$$utf_16_clean_raw$46$pad_it$124$141(_env) {
  const buf = _env._1;
  const pad = _env._0;
  let _tmp = 0;
  while (true) {
    const _ = _tmp;
    if (_ < pad) {
      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 32);
      _tmp = _ + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function rami3l$cmark$char$$utf_16_clean_raw$46$flush$124$155(_env, last, start, k) {
  const s = _env._1;
  const buf = _env._0;
  if (start <= last) {
    moonbitlang$core$builtin$$Logger$write_substring$71$(buf, s, start, k - start | 0);
    return;
  } else {
    return;
  }
}
function rami3l$cmark$char$$utf_16_clean_raw$46$clean$124$142(_env, last, first, dirty) {
  const s = _env._1;
  const buf = _env._0;
  const _env$2 = { _0: buf, _1: s };
  rami3l$cmark$char$$utf_16_clean_raw$46$flush$124$155(_env$2, last, first, dirty);
  let _tmp = last;
  let _tmp$2 = dirty;
  let _tmp$3 = dirty;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    if (_param$3 > _param) {
      rami3l$cmark$char$$utf_16_clean_raw$46$flush$124$155(_env$2, _param, _param$2, _param$3);
      return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
    }
    $bound_check(s, _param$3);
    if (s.charCodeAt(_param$3) === 0) {
      const next = _param$3 + 1 | 0;
      rami3l$cmark$char$$utf_16_clean_raw$46$flush$124$155(_env$2, _param, _param$2, _param$3);
      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 65533);
      _tmp$2 = next;
      _tmp$3 = next;
      continue;
    }
    $bound_check(s, _param$3);
    if (moonbitlang$core$char$$Char$is_ascii(s.charCodeAt(_param$3))) {
      _tmp$3 = _param$3 + 1 | 0;
      continue;
    }
    const _bind = rami3l$cmark$char$$at_checked(s, _param$3);
    if (_bind.$tag === 1) {
      const _Ok = _bind;
      const _d = _Ok._0;
      const next = _param$3 + rami3l$cmark$char$$length_utf16(_d) | 0;
      _tmp$3 = next;
      continue;
    } else {
      const _Err = _bind;
      const _d = _Err._0;
      const next = _param$3 + rami3l$cmark$char$$length_utf16(_d) | 0;
      rami3l$cmark$char$$utf_16_clean_raw$46$flush$124$155(_env$2, _param, _param$2, _param$3);
      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 65533);
      _tmp$2 = next;
      _tmp$3 = next;
      continue;
    }
  }
}
function rami3l$cmark$char$$utf_16_clean_raw(pad, buf, s, first, last) {
  const _env = { _0: pad, _1: buf };
  const _env$2 = { _0: buf, _1: s };
  if (first > last) {
    if (pad === 0) {
      return "";
    }
    moonbitlang$core$builtin$$StringBuilder$reset(buf);
    rami3l$cmark$char$$utf_16_clean_raw$46$pad_it$124$141(_env);
    return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
  }
  const max = s.length - 1 | 0;
  const last$2 = moonbitlang$core$math$$minimum$7$(last, max);
  const first$2 = moonbitlang$core$math$$maximum$7$(first, 0);
  if (pad === 0) {
    let _tmp;
    let _tmp$2 = last$2;
    let _tmp$3 = first$2;
    let _tmp$4 = first$2;
    while (true) {
      const _param = _tmp$2;
      const _param$2 = _tmp$3;
      const _param$3 = _tmp$4;
      if (_param$3 > _param) {
        _tmp = moonbitlang$core$string$$String$substring(s, _param$2, _param + 1 | 0);
        break;
      } else {
        $bound_check(s, _param$3);
        if (s.charCodeAt(_param$3) === 0) {
          moonbitlang$core$builtin$$StringBuilder$reset(buf);
          _tmp = rami3l$cmark$char$$utf_16_clean_raw$46$clean$124$142(_env$2, _param, _param$2, _param$3);
          break;
        } else {
          $bound_check(s, _param$3);
          if (moonbitlang$core$char$$Char$is_ascii(s.charCodeAt(_param$3))) {
            _tmp$4 = _param$3 + 1 | 0;
            continue;
          } else {
            const _bind = rami3l$cmark$char$$at_checked(s, _param$3);
            if (_bind.$tag === 1) {
              const _Ok = _bind;
              const _d = _Ok._0;
              const next = _param$3 + rami3l$cmark$char$$length_utf16(_d) | 0;
              _tmp$4 = next;
              continue;
            } else {
              moonbitlang$core$builtin$$StringBuilder$reset(buf);
              _tmp = rami3l$cmark$char$$utf_16_clean_raw$46$clean$124$142(_env$2, _param, _param$2, _param$3);
              break;
            }
          }
        }
      }
    }
    return _tmp;
  }
  moonbitlang$core$builtin$$StringBuilder$reset(buf);
  rami3l$cmark$char$$utf_16_clean_raw$46$pad_it$124$141(_env);
  return rami3l$cmark$char$$utf_16_clean_raw$46$clean$124$142(_env$2, last$2, first$2, first$2);
}
function rami3l$cmark$char$$utf_16_clean_raw$46$pad$46$default() {
  return 0;
}
function rami3l$cmark$char$$ascii_digit_to_int(c) {
  return moonbitlang$core$char$$Char$is_ascii_digit(c) ? c - 48 | 0 : $panic();
}
function rami3l$cmark$char$$ascii_hexdigit_to_int(c) {
  return c >= 48 && c <= 57 ? c - 48 | 0 : c >= 65 && c <= 70 ? (c - 65 | 0) + 10 | 0 : c >= 97 && c <= 102 ? (c - 97 | 0) + 10 | 0 : $panic();
}
function rami3l$cmark$char$$flush(buf, s, last, start, k) {
  if (start <= last) {
    moonbitlang$core$builtin$$Logger$write_substring$71$(buf, s, start, k - start | 0);
    return;
  } else {
    return;
  }
}
function rami3l$cmark$char$$is_ascii_alphanum(c) {
  return moonbitlang$core$char$$Char$is_ascii_alphabetic(c) || moonbitlang$core$char$$Char$is_ascii_digit(c);
}
function rami3l$cmark$char$$is_ascii_punctuation(c) {
  return c >= 33 && c <= 47 ? true : c >= 58 && c <= 64 ? true : c >= 91 && c <= 96 ? true : c >= 123 && c <= 126;
}
function rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$flush$124$28(_env, last, start, k) {
  const s = _env._1;
  const buf = _env._0;
  rami3l$cmark$char$$flush(buf, s, last, start, k);
}
function rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$try_entity_hex$124$29(_env, last, start, num_start, k, u) {
  const s = _env._3;
  const _env$2 = _env._2;
  const buf = _env._1;
  let _tmp = last;
  let _tmp$2 = start;
  let _tmp$3 = num_start;
  let _tmp$4 = k;
  let _tmp$5 = u;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _param$5 = _tmp$5;
    if (_param$4 > _param || _param$4 > (_param$3 + 6 | 0)) {
      return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, _param$2, _param$4);
    }
    $bound_check(s, _param$4);
    const _bind = s.charCodeAt(_param$4);
    if (_bind === 59) {
      const next = _param$4 + 1 | 0;
      if (_param$4 === _param$3) {
        return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, _param$2, next);
      }
      let u$2;
      _L: {
        _L$2: {
          const _bind$2 = rami3l$cmark$char$$from_int_checked(_param$5);
          if (_bind$2 === -1) {
            break _L$2;
          } else {
            const _Some = _bind$2;
            const _x = _Some;
            if (_x === 0) {
              break _L$2;
            } else {
              u$2 = _x;
            }
          }
          break _L;
        }
        u$2 = 65533;
      }
      rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$flush$124$28(_env$2, _param, _param$2, _param$3 - 3 | 0);
      moonbitlang$core$builtin$$Logger$write_char$71$(buf, u$2);
      return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, next, next);
    } else {
      if (moonbitlang$core$char$$Char$is_ascii_hexdigit(_bind)) {
        const u$2 = (Math.imul(_param$5, 16) | 0) + rami3l$cmark$char$$ascii_hexdigit_to_int(_bind) | 0;
        const _tmp$6 = _param$4 + 1 | 0;
        _tmp$4 = _tmp$6;
        _tmp$5 = u$2;
        continue;
      } else {
        return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, _param$2, _param$4);
      }
    }
  }
}
function rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, last, start, k) {
  const s = _env._3;
  const _env$2 = _env._2;
  const buf = _env._1;
  const do_unesc = _env._0;
  let _tmp = last;
  let _tmp$2 = start;
  let _tmp$3 = k;
  _L: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    if (_param$3 > _param) {
      rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$flush$124$28(_env$2, _param, _param$2, _param$3);
      return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
    }
    const next = _param$3 + 1 | 0;
    let b;
    _L$2: {
      $bound_check(s, _param$3);
      const _bind = s.charCodeAt(_param$3);
      switch (_bind) {
        case 0: {
          rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$flush$124$28(_env$2, _param, _param$2, _param$3);
          moonbitlang$core$builtin$$Logger$write_char$71$(buf, 65533);
          _tmp$2 = next;
          _tmp$3 = next;
          continue _L;
        }
        case 92: {
          if (do_unesc === true) {
            if (next > _param) {
              _tmp$3 = next;
              continue _L;
            }
            $bound_check(s, next);
            const nc = s.charCodeAt(next);
            if (!rami3l$cmark$char$$is_ascii_punctuation(nc)) {
              _tmp$3 = next;
              continue _L;
            }
            const next1 = next + 1 | 0;
            rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$flush$124$28(_env$2, _param, _param$2, _param$3);
            moonbitlang$core$builtin$$Logger$write_char$71$(buf, nc);
            _tmp$2 = next1;
            _tmp$3 = next1;
            continue _L;
          } else {
            b = _bind;
            break _L$2;
          }
        }
        case 38: {
          if ((_param$3 + 2 | 0) > _param) {
            _tmp$3 = next;
            continue _L;
          }
          $bound_check(s, next);
          const _bind$2 = s.charCodeAt(next);
          if (_bind$2 === 35) {
            const next$2 = next + 1 | 0;
            _L$3: {
              $bound_check(s, next$2);
              const _bind$3 = s.charCodeAt(next$2);
              switch (_bind$3) {
                case 120: {
                  break _L$3;
                }
                case 88: {
                  break _L$3;
                }
                default: {
                  if (moonbitlang$core$char$$Char$is_ascii_digit(_bind$3)) {
                    return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$try_entity_dec$124$30(_env, _param, _param$2, next$2, next$2, 0);
                  }
                  _tmp$3 = next$2;
                  continue _L;
                }
              }
            }
            const next$3 = next$2 + 1 | 0;
            return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$try_entity_hex$124$29(_env, _param, _param$2, next$3, next$3, 0);
          } else {
            if (moonbitlang$core$char$$Char$is_ascii_alphabetic(_bind$2)) {
              return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$try_entity_named$124$31(_env, _param, _param$2, next, next);
            }
            _tmp$3 = next;
            continue _L;
          }
        }
        default: {
          b = _bind;
          break _L$2;
        }
      }
    }
    if (moonbitlang$core$char$$Char$is_ascii(b)) {
      _tmp$3 = next;
      continue;
    }
    const _bind = rami3l$cmark$char$$at_checked(s, _param$3);
    if (_bind.$tag === 1) {
      const _Ok = _bind;
      const _d = _Ok._0;
      const next$2 = _param$3 + rami3l$cmark$char$$length_utf16(_d) | 0;
      _tmp$3 = next$2;
      continue;
    } else {
      const _Err = _bind;
      const _d = _Err._0;
      const next$2 = _param$3 + rami3l$cmark$char$$length_utf16(_d) | 0;
      rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$flush$124$28(_env$2, _param, _param$2, _param$3);
      moonbitlang$core$builtin$$Logger$write_char$71$(buf, 65533);
      _tmp$2 = next$2;
      _tmp$3 = next$2;
      continue;
    }
  }
}
function rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$try_entity_dec$124$30(_env, last, start, num_start, k, u) {
  const s = _env._3;
  const _env$2 = _env._2;
  const buf = _env._1;
  let _tmp = last;
  let _tmp$2 = start;
  let _tmp$3 = num_start;
  let _tmp$4 = k;
  let _tmp$5 = u;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _param$5 = _tmp$5;
    if (_param$4 > _param || _param$4 > (_param$3 + 7 | 0)) {
      return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, _param$2, _param$4);
    }
    $bound_check(s, _param$4);
    const _bind = s.charCodeAt(_param$4);
    if (_bind === 59) {
      const next = _param$4 + 1 | 0;
      if (_param$4 === _param$3) {
        return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, _param$2, next);
      }
      let u$2;
      _L: {
        _L$2: {
          const _bind$2 = rami3l$cmark$char$$from_int_checked(_param$5);
          if (_bind$2 === -1) {
            break _L$2;
          } else {
            const _Some = _bind$2;
            const _x = _Some;
            if (_x === 0) {
              break _L$2;
            } else {
              u$2 = _x;
            }
          }
          break _L;
        }
        u$2 = 65533;
      }
      rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$flush$124$28(_env$2, _param, _param$2, _param$3 - 2 | 0);
      moonbitlang$core$builtin$$Logger$write_char$71$(buf, u$2);
      return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, next, next);
    } else {
      if (moonbitlang$core$char$$Char$is_ascii_digit(_bind)) {
        const u$2 = (Math.imul(_param$5, 10) | 0) + rami3l$cmark$char$$ascii_digit_to_int(_bind) | 0;
        const _tmp$6 = _param$4 + 1 | 0;
        _tmp$4 = _tmp$6;
        _tmp$5 = u$2;
        continue;
      } else {
        return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, _param$2, _param$4);
      }
    }
  }
}
function rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$try_entity_named$124$31(_env, last, start, name_start, k) {
  const s = _env._3;
  const _env$2 = _env._2;
  const buf = _env._1;
  let _tmp = last;
  let _tmp$2 = start;
  let _tmp$3 = name_start;
  let _tmp$4 = k;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    if (_param$4 > _param) {
      return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, _param$2, _param$4);
    }
    $bound_check(s, _param$4);
    const _bind = s.charCodeAt(_param$4);
    if (_bind === 59) {
      const name = moonbitlang$core$string$$String$substring(s, _param$3, _param$4);
      const _bind$2 = rami3l$cmark$char$$html_named_entity(name);
      if (_bind$2 === undefined) {
        return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, _param$2, _param$4 + 1 | 0);
      } else {
        const _Some = _bind$2;
        const _e = _Some;
        const next = _param$4 + 1 | 0;
        rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$flush$124$28(_env$2, _param, _param$2, _param$3 - 1 | 0);
        moonbitlang$core$builtin$$Logger$write_string$71$(buf, _e);
        return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, next, next);
      }
    } else {
      if (rami3l$cmark$char$$is_ascii_alphanum(_bind)) {
        _tmp$4 = _param$4 + 1 | 0;
        continue;
      } else {
        return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env, _param, _param$2, _param$4);
      }
    }
  }
}
function rami3l$cmark$char$$_utf_16_clean_unesc_unref(do_unesc, buf, s, first, last) {
  const _env = { _0: buf, _1: s };
  const _env$2 = { _0: do_unesc, _1: buf, _2: _env, _3: s };
  if (first > last) {
    return "";
  }
  const max = s.length - 1 | 0;
  const last$2 = moonbitlang$core$math$$minimum$7$(last, max);
  const first$2 = moonbitlang$core$math$$maximum$7$(first, 0);
  let _tmp = last$2;
  let _tmp$2 = first$2;
  let _tmp$3 = first$2;
  _L: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    if (_param$3 > _param) {
      return moonbitlang$core$string$$String$substring(s, first$2, ((first$2 + _param | 0) - _param$2 | 0) + 1 | 0);
    }
    let b;
    _L$2: {
      _L$3: {
        $bound_check(s, _param$3);
        const _bind = s.charCodeAt(_param$3);
        switch (_bind) {
          case 92: {
            if (do_unesc === true) {
              break _L$3;
            } else {
              b = _bind;
              break _L$2;
            }
          }
          case 38: {
            break _L$3;
          }
          case 0: {
            break _L$3;
          }
          default: {
            b = _bind;
            break _L$2;
          }
        }
      }
      moonbitlang$core$builtin$$StringBuilder$reset(buf);
      return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env$2, _param, _param$2, _param$3);
    }
    if (moonbitlang$core$char$$Char$is_ascii(b)) {
      _tmp$3 = _param$3 + 1 | 0;
      continue;
    }
    const _bind = rami3l$cmark$char$$at_checked(s, _param$3);
    if (_bind.$tag === 1) {
      const _Ok = _bind;
      const _d = _Ok._0;
      const next = _param$3 + rami3l$cmark$char$$length_utf16(_d) | 0;
      _tmp$3 = next;
      continue;
    } else {
      moonbitlang$core$builtin$$StringBuilder$reset(buf);
      return rami3l$cmark$char$$_utf_16_clean_unesc_unref$46$resolve$124$32(_env$2, _param, _param$2, _param$3);
    }
  }
}
function rami3l$cmark$char$$utf_16_clean_unesc_unref(buf, s, first, last) {
  return rami3l$cmark$char$$_utf_16_clean_unesc_unref(true, buf, s, first, last);
}
function rami3l$cmark$char$$utf_16_clean_unref(buf, s, first, last) {
  return rami3l$cmark$char$$_utf_16_clean_unesc_unref(false, buf, s, first, last);
}
function rami3l$cmark$char$$to_ascii_lower(c) {
  return moonbitlang$core$char$$Char$is_ascii_uppercase(c) ? c + 32 | 0 : c;
}
function rami3l$cmark$char$$is_ascii_blank(c) {
  switch (c) {
    case 32: {
      return true;
    }
    case 9: {
      return true;
    }
    default: {
      return false;
    }
  }
}
function rami3l$cmark$char$$is_ascii_whitespace(c) {
  return c === 32 ? true : c >= 10 && c <= 13;
}
function rami3l$cmark$char$$is_ascii_control(c) {
  return c >= 0 && c <= 31 ? true : c === 127;
}
function rami3l$cmark$char$$length_utf8(ch) {
  const ch$2 = ch;
  return ch$2 < 128 ? 1 : ch$2 < 2048 ? 2 : ch$2 < 65536 ? 3 : ch$2 < 1114112 ? 4 : moonbitlang$core$abort$$abort$7$("invalid rune");
}
function moonbitlang$core$builtin$$Eq$op_equal$239$(_x_1025, _x_1026) {
  return moonbitlang$core$builtin$$Eq$op_equal$173$(_x_1025.pos, _x_1026.pos) && _x_1025.first === _x_1026.first && _x_1025.last === _x_1026.last;
}
function moonbitlang$core$builtin$$Show$output$152$(_x_975, _x_976) {
  _x_976.method_0(_x_976.self, "{");
  _x_976.method_0(_x_976.self, "file: ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_976, _x_975.file);
  _x_976.method_0(_x_976.self, ", ");
  _x_976.method_0(_x_976.self, "first_byte: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_976, _x_975.first_byte);
  _x_976.method_0(_x_976.self, ", ");
  _x_976.method_0(_x_976.self, "last_byte: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_976, _x_975.last_byte);
  _x_976.method_0(_x_976.self, ", ");
  _x_976.method_0(_x_976.self, "first_line: ");
  moonbitlang$core$builtin$$Logger$write_object$172$(_x_976, _x_975.first_line);
  _x_976.method_0(_x_976.self, ", ");
  _x_976.method_0(_x_976.self, "last_line: ");
  moonbitlang$core$builtin$$Logger$write_object$172$(_x_976, _x_975.last_line);
  _x_976.method_0(_x_976.self, "}");
}
function moonbitlang$core$builtin$$Show$output$183$(_x_772, _x_773) {
  if (_x_772.$tag === 0) {
    const _Unordered = _x_772;
    const _$42$arg_774 = _Unordered._0;
    _x_773.method_0(_x_773.self, "Unordered(");
    moonbitlang$core$builtin$$Logger$write_object$10$(_x_773, _$42$arg_774);
    _x_773.method_0(_x_773.self, ")");
    return;
  } else {
    const _Ordered = _x_772;
    const _$42$arg_775 = _Ordered._0;
    const _$42$arg_776 = _Ordered._1;
    _x_773.method_0(_x_773.self, "Ordered(");
    moonbitlang$core$builtin$$Logger$write_object$7$(_x_773, _$42$arg_775);
    _x_773.method_0(_x_773.self, ", ");
    moonbitlang$core$builtin$$Logger$write_object$10$(_x_773, _$42$arg_776);
    _x_773.method_0(_x_773.self, ")");
    return;
  }
}
function rami3l$cmark$cmark_base$$run_of(char, s, last, start) {
  let _tmp = char;
  let _tmp$2 = s;
  let _tmp$3 = last;
  let _tmp$4 = start;
  while (true) {
    const char$2 = _tmp;
    const s$2 = _tmp$2;
    const last$2 = _tmp$3;
    const start$2 = _tmp$4;
    let _tmp$5;
    if (start$2 > last$2) {
      _tmp$5 = true;
    } else {
      $bound_check(s$2, start$2);
      _tmp$5 = s$2.charCodeAt(start$2) !== char$2;
    }
    if (_tmp$5) {
      return start$2 - 1 | 0;
    }
    _tmp$4 = start$2 + 1 | 0;
    continue;
  }
}
function rami3l$cmark$cmark_base$$first_non_blank(s, last, start) {
  let _tmp = start;
  while (true) {
    const k = _tmp;
    if (k <= last) {
      $bound_check(s, k);
      if (rami3l$cmark$char$$is_ascii_blank(s.charCodeAt(k))) {
      } else {
        return k;
      }
      _tmp = k + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return last + 1 | 0;
}
function rami3l$cmark$cmark_base$$first_non_blank_in_span(s, span) {
  return rami3l$cmark$cmark_base$$first_non_blank(s, span.last, span.first);
}
function rami3l$cmark$cmark_base$$last_non_blank(s, first, start) {
  let _tmp = s;
  let _tmp$2 = first;
  let _tmp$3 = start;
  _L: while (true) {
    const s$2 = _tmp;
    const first$2 = _tmp$2;
    const start$2 = _tmp$3;
    if (start$2 < first$2) {
      return first$2 - 1 | 0;
    }
    _L$2: {
      $bound_check(s$2, start$2);
      const _bind = s$2.charCodeAt(start$2);
      switch (_bind) {
        case 32: {
          break _L$2;
        }
        case 9: {
          break _L$2;
        }
        default: {
          return start$2;
        }
      }
    }
    _tmp$3 = start$2 - 1 | 0;
    continue;
  }
}
function rami3l$cmark$cmark_base$$rev_drop_spaces(s, first, start) {
  let _tmp = s;
  let _tmp$2 = first;
  let _tmp$3 = start;
  while (true) {
    const s$2 = _tmp;
    const first$2 = _tmp$2;
    const start$2 = _tmp$3;
    if (start$2 < first$2) {
      return first$2 - 1 | 0;
    }
    $bound_check(s$2, start$2);
    const _bind = s$2.charCodeAt(start$2);
    if (_bind === 32) {
      _tmp$3 = start$2 - 1 | 0;
      continue;
    } else {
      return start$2;
    }
  }
}
function rami3l$cmark$cmark_base$$push_span(line, first, last, spans) {
  if (spans.length >= 1) {
    const _x = spans[spans.length - 1 | 0];
    const _start = _x.start;
    const _x$2 = _x.span;
    const _pos = _x$2.pos;
    const _first = _x$2.first;
    if (line.pos._0 === _pos._0) {
      moonbitlang$core$array$$Array$op_set$50$(spans, spans.length - 1 | 0, { start: _start, span: { pos: line.pos, first: _first, last: last } });
      return undefined;
    }
  }
  moonbitlang$core$array$$Array$push$50$(spans, { start: line.first, span: { pos: line.pos, first: first, last: last } });
}
function rami3l$cmark$cmark_base$$accept_to$355$(char, next_line, s, lines, line, spans, after) {
  let _tmp = lines;
  let _tmp$2 = line;
  let _tmp$3 = after;
  let _tmp$4 = after + 1 | 0;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    if (_param$4 > _param$2.last) {
      const _bind = next_line(_param);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _new_line = _Some;
        rami3l$cmark$cmark_base$$push_span(_param$2, _param$3, _param$2.last, spans);
        const start = rami3l$cmark$cmark_base$$first_non_blank_in_span(s, _new_line);
        _tmp$2 = _new_line;
        _tmp$3 = start;
        _tmp$4 = start;
        continue;
      }
    }
    $bound_check(s, _param$4);
    if (s.charCodeAt(_param$4) === char) {
      rami3l$cmark$cmark_base$$push_span(_param$2, _param$3, _param$4, spans);
      return { _0: _param$2, _1: _param$4 };
    }
    _tmp$4 = _param$4 + 1 | 0;
    continue;
  }
}
function rami3l$cmark$cmark_base$$accept_to$12$(char, next_line, s, lines, line, spans, after) {
  let _tmp = lines;
  let _tmp$2 = line;
  let _tmp$3 = after;
  let _tmp$4 = after + 1 | 0;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    if (_param$4 > _param$2.last) {
      const _bind = next_line(_param);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _new_line = _Some;
        rami3l$cmark$cmark_base$$push_span(_param$2, _param$3, _param$2.last, spans);
        const start = rami3l$cmark$cmark_base$$first_non_blank_in_span(s, _new_line);
        _tmp$2 = _new_line;
        _tmp$3 = start;
        _tmp$4 = start;
        continue;
      }
    }
    $bound_check(s, _param$4);
    if (s.charCodeAt(_param$4) === char) {
      rami3l$cmark$cmark_base$$push_span(_param$2, _param$3, _param$4, spans);
      return { _0: _param$2, _1: _param$4 };
    }
    _tmp$4 = _param$4 + 1 | 0;
    continue;
  }
}
function rami3l$cmark$cmark_base$$accept_upto$369$(char, next_line, s, lines, line, spans, after) {
  const start = after + 1 | 0;
  let _tmp = char;
  let _tmp$2 = next_line;
  let _tmp$3 = s;
  let _tmp$4 = lines;
  let _tmp$5 = line;
  let _tmp$6 = false;
  let _tmp$7 = start;
  let _tmp$8 = spans;
  let _tmp$9 = start;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _param$5 = _tmp$5;
    const _param$6 = _tmp$6;
    const _param$7 = _tmp$7;
    const _param$8 = _tmp$8;
    const _param$9 = _tmp$9;
    if (_param$9 > _param$5.last) {
      const _bind = _param$2(_param$4);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _newline = _Some;
        if (_newline.first > _newline.last) {
          return undefined;
        }
        rami3l$cmark$cmark_base$$push_span(_param$5, _param$7, _param$5.last, _param$8);
        const start$2 = rami3l$cmark$cmark_base$$first_non_blank_in_span(_param$3, _newline);
        _tmp$5 = _newline;
        _tmp$6 = false;
        _tmp$7 = start$2;
        _tmp$9 = start$2;
        continue;
      }
    } else {
      let _tmp$10;
      $bound_check(_param$3, _param$9);
      if (_param$3.charCodeAt(_param$9) === _param) {
        _tmp$10 = !_param$6;
      } else {
        _tmp$10 = false;
      }
      if (_tmp$10) {
        rami3l$cmark$cmark_base$$push_span(_param$5, _param$7, _param$9 - 1 | 0, _param$8);
        return { _0: _param$5, _1: _param$9 };
      }
      let prev_bslash;
      $bound_check(_param$3, _param$9);
      if (_param$3.charCodeAt(_param$9) === 92) {
        prev_bslash = !_param$6;
      } else {
        prev_bslash = false;
      }
      const _tmp$11 = _param$9 + 1 | 0;
      _tmp$6 = prev_bslash;
      _tmp$9 = _tmp$11;
      continue;
    }
  }
}
function rami3l$cmark$cmark_base$$accept_upto$355$(char, next_line, s, lines, line, spans, after) {
  const start = after + 1 | 0;
  let _tmp = char;
  let _tmp$2 = next_line;
  let _tmp$3 = s;
  let _tmp$4 = lines;
  let _tmp$5 = line;
  let _tmp$6 = false;
  let _tmp$7 = start;
  let _tmp$8 = spans;
  let _tmp$9 = start;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _param$5 = _tmp$5;
    const _param$6 = _tmp$6;
    const _param$7 = _tmp$7;
    const _param$8 = _tmp$8;
    const _param$9 = _tmp$9;
    if (_param$9 > _param$5.last) {
      const _bind = _param$2(_param$4);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _newline = _Some;
        if (_newline.first > _newline.last) {
          return undefined;
        }
        rami3l$cmark$cmark_base$$push_span(_param$5, _param$7, _param$5.last, _param$8);
        const start$2 = rami3l$cmark$cmark_base$$first_non_blank_in_span(_param$3, _newline);
        _tmp$5 = _newline;
        _tmp$6 = false;
        _tmp$7 = start$2;
        _tmp$9 = start$2;
        continue;
      }
    } else {
      let _tmp$10;
      $bound_check(_param$3, _param$9);
      if (_param$3.charCodeAt(_param$9) === _param) {
        _tmp$10 = !_param$6;
      } else {
        _tmp$10 = false;
      }
      if (_tmp$10) {
        rami3l$cmark$cmark_base$$push_span(_param$5, _param$7, _param$9 - 1 | 0, _param$8);
        return { _0: _param$5, _1: _param$9 };
      }
      let prev_bslash;
      $bound_check(_param$3, _param$9);
      if (_param$3.charCodeAt(_param$9) === 92) {
        prev_bslash = !_param$6;
      } else {
        prev_bslash = false;
      }
      const _tmp$11 = _param$9 + 1 | 0;
      _tmp$6 = prev_bslash;
      _tmp$9 = _tmp$11;
      continue;
    }
  }
}
function rami3l$cmark$cmark_base$$first_non_blank_over_nl$369$(next_line, s, lines, line, start) {
  const nb = rami3l$cmark$cmark_base$$first_non_blank(s, line.last, start);
  if (nb <= line.last) {
    return new $64$rami3l$47$cmark$47$cmark_base$46$NextLineResult$ThisLine(nb);
  }
  const _bind = next_line(lines);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _new_line = _Some;
    const nb$2 = rami3l$cmark$cmark_base$$first_non_blank_in_span(s, _new_line);
    if (nb$2 > _new_line.last) {
      return undefined;
    }
    return new $64$rami3l$47$cmark$47$cmark_base$46$NextLineResult$NextLine(_new_line, nb$2);
  }
}
function rami3l$cmark$cmark_base$$first_non_blank_over_nl$12$(next_line, s, lines, line, start) {
  const nb = rami3l$cmark$cmark_base$$first_non_blank(s, line.last, start);
  if (nb <= line.last) {
    return new $64$rami3l$47$cmark$47$cmark_base$46$NextLineResult$ThisLine(nb);
  }
  const _bind = next_line(lines);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _new_line = _Some;
    const nb$2 = rami3l$cmark$cmark_base$$first_non_blank_in_span(s, _new_line);
    if (nb$2 > _new_line.last) {
      return undefined;
    }
    return new $64$rami3l$47$cmark$47$cmark_base$46$NextLineResult$NextLine(_new_line, nb$2);
  }
}
function rami3l$cmark$cmark_base$$first_non_blank_over_nl$355$(next_line, s, lines, line, start) {
  const nb = rami3l$cmark$cmark_base$$first_non_blank(s, line.last, start);
  if (nb <= line.last) {
    return new $64$rami3l$47$cmark$47$cmark_base$46$NextLineResult$ThisLine(nb);
  }
  const _bind = next_line(lines);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _new_line = _Some;
    const nb$2 = rami3l$cmark$cmark_base$$first_non_blank_in_span(s, _new_line);
    if (nb$2 > _new_line.last) {
      return undefined;
    }
    return new $64$rami3l$47$cmark$47$cmark_base$46$NextLineResult$NextLine(_new_line, nb$2);
  }
}
function rami3l$cmark$cmark_base$$first_non_blank_over_nl1$12$(next_line, s, lines, line, spans, start) {
  const _bind = rami3l$cmark$cmark_base$$first_non_blank_over_nl$12$(next_line, s, lines, line, start);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x.$tag === 0) {
      const _ThisLine = _x;
      const _nb = _ThisLine._0;
      const line$2 = { pos: line.pos, first: start, last: line.last };
      rami3l$cmark$cmark_base$$push_span(line$2, start, _nb - 1 | 0, spans);
      return { _0: line$2, _1: _nb - 1 | 0 };
    } else {
      const _NextLine = _x;
      const _new_line = _NextLine._0;
      const _nb = _NextLine._1;
      const _bind$2 = line.pos;
      const _bind$3 = line.last;
      const line$2 = { pos: _bind$2, first: start, last: _bind$3 };
      rami3l$cmark$cmark_base$$push_span(line$2, start, _bind$3, spans);
      return { _0: _new_line, _1: _nb - 1 | 0 };
    }
  }
}
function rami3l$cmark$cmark_base$$first_non_blank_over_nl1$355$(next_line, s, lines, line, spans, start) {
  const _bind = rami3l$cmark$cmark_base$$first_non_blank_over_nl$355$(next_line, s, lines, line, start);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x.$tag === 0) {
      const _ThisLine = _x;
      const _nb = _ThisLine._0;
      const line$2 = { pos: line.pos, first: start, last: line.last };
      rami3l$cmark$cmark_base$$push_span(line$2, start, _nb - 1 | 0, spans);
      return { _0: line$2, _1: _nb - 1 | 0 };
    } else {
      const _NextLine = _x;
      const _new_line = _NextLine._0;
      const _nb = _NextLine._1;
      const _bind$2 = line.pos;
      const _bind$3 = line.last;
      const line$2 = { pos: _bind$2, first: start, last: _bind$3 };
      rami3l$cmark$cmark_base$$push_span(line$2, start, _bind$3, spans);
      return { _0: _new_line, _1: _nb - 1 | 0 };
    }
  }
}
function rami3l$cmark$cmark_base$$first_non_escaped_char(c, s, last, start) {
  let _tmp = start;
  while (true) {
    const _param = _tmp;
    let _tmp$2;
    if (_param > last) {
      _tmp$2 = true;
    } else {
      let _tmp$3;
      $bound_check(s, _param);
      if (s.charCodeAt(_param) === c) {
        let _tmp$4;
        if (_param === start) {
          _tmp$4 = true;
        } else {
          const _tmp$5 = _param - 1 | 0;
          $bound_check(s, _tmp$5);
          _tmp$4 = s.charCodeAt(_tmp$5) !== 92;
        }
        _tmp$3 = _tmp$4;
      } else {
        _tmp$3 = false;
      }
      _tmp$2 = _tmp$3;
    }
    if (_tmp$2) {
      return _param;
    }
    _tmp = _param + 1 | 0;
    continue;
  }
}
function rami3l$cmark$cmark_base$$ListType$is_same_type(self, other) {
  let c0;
  let c1;
  _L: {
    if (self.$tag === 1) {
      const _Ordered = self;
      const _c0 = _Ordered._1;
      if (other.$tag === 1) {
        const _Ordered$2 = other;
        const _c1 = _Ordered$2._1;
        c0 = _c0;
        c1 = _c1;
        break _L;
      } else {
        return false;
      }
    } else {
      const _Unordered = self;
      const _c0 = _Unordered._0;
      if (other.$tag === 0) {
        const _Unordered$2 = other;
        const _c1 = _Unordered$2._0;
        c0 = _c0;
        c1 = _c1;
        break _L;
      } else {
        return false;
      }
    }
  }
  return c0 === c1;
}
function rami3l$cmark$cmark_base$$LineType$thematic_break(s, last, start) {
  if (start > last) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
  _L: {
    $bound_check(s, start);
    const _bind = s.charCodeAt(start);
    switch (_bind) {
      case 45: {
        break _L;
      }
      case 95: {
        break _L;
      }
      case 42: {
        break _L;
      }
      default: {
        return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
      }
    }
  }
  let _tmp = s;
  let _tmp$2 = last;
  let _tmp$3 = 1;
  let _tmp$4 = start;
  let _tmp$5 = start + 1 | 0;
  _L$2: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _param$5 = _tmp$5;
    if (_param$5 > _param$2) {
      return _param$3 < 3 ? $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch : new $64$rami3l$47$cmark$47$cmark_base$46$LineType$ThematicBreakLine(_param$4);
    } else {
      $bound_check(_param, _param$5);
      const _tmp$6 = _param.charCodeAt(_param$5);
      $bound_check(_param, _param$4);
      if (_tmp$6 === _param.charCodeAt(_param$4)) {
        const _tmp$7 = _param$3 + 1 | 0;
        const _tmp$8 = _param$5 + 1 | 0;
        _tmp$3 = _tmp$7;
        _tmp$4 = _param$5;
        _tmp$5 = _tmp$8;
        continue;
      } else {
        _L$3: {
          $bound_check(_param, _param$5);
          const _bind = _param.charCodeAt(_param$5);
          switch (_bind) {
            case 32: {
              break _L$3;
            }
            case 9: {
              break _L$3;
            }
            default: {
              return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
            }
          }
        }
        _tmp$5 = _param$5 + 1 | 0;
        continue;
      }
    }
  }
}
function rami3l$cmark$cmark_base$$atx_heading$46$find_end$124$533(s, last, k) {
  const after_blank = rami3l$cmark$cmark_base$$first_non_blank(s, last, k + 1 | 0);
  let _tmp;
  if (after_blank > last) {
    _tmp = true;
  } else {
    $bound_check(s, after_blank);
    _tmp = s.charCodeAt(after_blank) !== 35;
  }
  if (_tmp) {
    return after_blank;
  }
  const k$2 = after_blank + 1 | 0;
  let after_hash;
  let _tmp$2 = k$2;
  while (true) {
    const k$3 = _tmp$2;
    let _tmp$3;
    if (k$3 <= last) {
      $bound_check(s, k$3);
      _tmp$3 = s.charCodeAt(k$3) === 35;
    } else {
      _tmp$3 = false;
    }
    if (_tmp$3) {
      _tmp$2 = k$3 + 1 | 0;
      continue;
    } else {
      after_hash = k$3;
      break;
    }
  }
  const after_blank$2 = rami3l$cmark$cmark_base$$first_non_blank(s, last, after_hash);
  if (after_blank$2 > last || after_blank$2 === after_hash) {
    return after_blank$2;
  }
  return after_blank$2 - 1 | 0;
}
function rami3l$cmark$cmark_base$$atx_heading$46$content$124$534(s, last, k) {
  let _tmp = s;
  let _tmp$2 = last;
  let _tmp$3 = k;
  _L: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    if (_param$3 <= _param$2) {
      _L$2: {
        $bound_check(_param, _param$3);
        const _bind = _param.charCodeAt(_param$3);
        switch (_bind) {
          case 32: {
            break _L$2;
          }
          case 9: {
            break _L$2;
          }
          default: {
            _tmp$3 = _param$3 + 1 | 0;
            continue _L;
          }
        }
      }
      const end1 = rami3l$cmark$cmark_base$$atx_heading$46$find_end$124$533(_param, _param$2, _param$3);
      if (end1 <= _param$2) {
        _tmp$3 = end1;
        continue;
      } else {
        return _param$3 - 1 | 0;
      }
    } else {
      return _param$3 - 1 | 0;
    }
  }
}
function rami3l$cmark$cmark_base$$LineType$atx_heading(s, last, start) {
  let s$2;
  let last$2;
  let acc;
  let k;
  _L: {
    let _tmp;
    if (start > last) {
      _tmp = true;
    } else {
      $bound_check(s, start);
      _tmp = s.charCodeAt(start) !== 35;
    }
    if (_tmp) {
      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
    }
    const _tmp$2 = start + 1 | 0;
    s$2 = s;
    last$2 = last;
    acc = 1;
    k = _tmp$2;
    break _L;
  }
  let _tmp = s$2;
  let _tmp$2 = last$2;
  let _tmp$3 = acc;
  let _tmp$4 = k;
  while (true) {
    const s$3 = _tmp;
    const last$3 = _tmp$2;
    const acc$2 = _tmp$3;
    const k$2 = _tmp$4;
    if (k$2 > last$3) {
      return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$AtxHeadingLine(acc$2, k$2, k$2, last$3);
    }
    $bound_check(s$3, k$2);
    if (s$3.charCodeAt(k$2) === 35) {
      if (acc$2 < 6) {
        const _tmp$5 = acc$2 + 1 | 0;
        const _tmp$6 = k$2 + 1 | 0;
        _tmp$3 = _tmp$5;
        _tmp$4 = _tmp$6;
        continue;
      } else {
        return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
      }
    }
    const first = rami3l$cmark$cmark_base$$first_non_blank(s$3, last$3, k$2);
    if (first > last$3) {
      return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$AtxHeadingLine(acc$2, k$2, last$3 + 1 | 0, last$3);
    }
    if (first === k$2) {
      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
    }
    let last$4;
    $bound_check(s$3, first);
    if (s$3.charCodeAt(first) !== 35) {
      last$4 = rami3l$cmark$cmark_base$$atx_heading$46$content$124$534(s$3, last$3, first + 1 | 0);
    } else {
      const end1 = rami3l$cmark$cmark_base$$atx_heading$46$find_end$124$533(s$3, last$3, first - 1 | 0);
      last$4 = end1 > last$3 ? first - 1 | 0 : rami3l$cmark$cmark_base$$atx_heading$46$content$124$534(s$3, last$3, end1);
    }
    return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$AtxHeadingLine(acc$2, k$2, first, last$4);
  }
}
function rami3l$cmark$cmark_base$$setext_heading_underline$46$level$124$522(c) {
  return c === 61 ? 1 : 2;
}
function rami3l$cmark$cmark_base$$LineType$setext_heading_underline(s, last, start) {
  let s$2;
  let last$2;
  let start$2;
  let k;
  _L: {
    if (start > last) {
      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
    }
    let _tmp;
    $bound_check(s, start);
    if (s.charCodeAt(start) !== 45) {
      $bound_check(s, start);
      _tmp = s.charCodeAt(start) !== 61;
    } else {
      _tmp = false;
    }
    if (_tmp) {
      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
    }
    const _tmp$2 = start + 1 | 0;
    s$2 = s;
    last$2 = last;
    start$2 = start;
    k = _tmp$2;
    break _L;
  }
  let _tmp = s$2;
  let _tmp$2 = last$2;
  let _tmp$3 = start$2;
  let _tmp$4 = k;
  while (true) {
    const s$3 = _tmp;
    const last$3 = _tmp$2;
    const start$3 = _tmp$3;
    const k$2 = _tmp$4;
    if (k$2 > last$3) {
      $bound_check(s$3, start$3);
      return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$SetextUnderlineLine(rami3l$cmark$cmark_base$$setext_heading_underline$46$level$124$522(s$3.charCodeAt(start$3)), k$2 - 1 | 0);
    }
    $bound_check(s$3, k$2);
    const _tmp$5 = s$3.charCodeAt(k$2);
    $bound_check(s$3, start$3);
    if (_tmp$5 === s$3.charCodeAt(start$3)) {
      _tmp$4 = k$2 + 1 | 0;
      continue;
    }
    let _tmp$6;
    $bound_check(s$3, k$2);
    if (s$3.charCodeAt(k$2) !== 32) {
      $bound_check(s$3, k$2);
      _tmp$6 = s$3.charCodeAt(k$2) !== 9;
    } else {
      _tmp$6 = false;
    }
    if (_tmp$6) {
      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
    }
    const end_blank = rami3l$cmark$cmark_base$$first_non_blank(s$3, last$3, k$2 + 1 | 0);
    if (end_blank > last$3) {
      $bound_check(s$3, start$3);
      return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$SetextUnderlineLine(rami3l$cmark$cmark_base$$setext_heading_underline$46$level$124$522(s$3.charCodeAt(start$3)), k$2 - 1 | 0);
    }
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
}
function rami3l$cmark$cmark_base$$fenced_code_block_start$46$info$124$485(s, last, nobt, info_first, k) {
  let _tmp = s;
  let _tmp$2 = last;
  let _tmp$3 = nobt;
  let _tmp$4 = info_first;
  let _tmp$5 = k;
  _L: while (true) {
    const s$2 = _tmp;
    const last$2 = _tmp$2;
    const nobt$2 = _tmp$3;
    const info_first$2 = _tmp$4;
    const k$2 = _tmp$5;
    if (k$2 <= last$2) {
      let _tmp$6;
      if (nobt$2) {
        $bound_check(s$2, k$2);
        _tmp$6 = s$2.charCodeAt(k$2) === 96;
      } else {
        _tmp$6 = false;
      }
      if (!_tmp$6) {
        _L$2: {
          $bound_check(s$2, k$2);
          const _bind = s$2.charCodeAt(k$2);
          switch (_bind) {
            case 32: {
              break _L$2;
            }
            case 9: {
              break _L$2;
            }
            default: {
              _tmp$5 = k$2 + 1 | 0;
              continue _L;
            }
          }
        }
        const after_blank = rami3l$cmark$cmark_base$$first_non_blank(s$2, last$2, k$2);
        if (after_blank <= last$2) {
          _tmp$5 = after_blank;
          continue;
        } else {
          return { _0: info_first$2, _1: k$2 - 1 | 0 };
        }
      } else {
        return undefined;
      }
    } else {
      return { _0: info_first$2, _1: last$2 };
    }
  }
}
function rami3l$cmark$cmark_base$$LineType$fenced_code_block_start(s, last, start) {
  if (start > last) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
  let _tmp = s;
  let _tmp$2 = start;
  let _tmp$3 = last;
  let _tmp$4 = start;
  _L: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    if (_param$4 <= _param$3) {
      let _tmp$5;
      if (((_param$4 - _param$2 | 0) + 1 | 0) < 4) {
        $bound_check(_param, _param$4);
        _tmp$5 = _param.charCodeAt(_param$4) === 32;
      } else {
        _tmp$5 = false;
      }
      if (_tmp$5) {
        _tmp$4 = _param$4 + 1 | 0;
        continue;
      }
      _L$2: {
        $bound_check(_param, _param$4);
        const _bind = _param.charCodeAt(_param$4);
        switch (_bind) {
          case 126: {
            break _L$2;
          }
          case 96: {
            break _L$2;
          }
          default: {
            return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
          }
        }
      }
      const k = _param$4 + 1 | 0;
      let _tmp$6;
      let _tmp$7 = _param;
      let _tmp$8 = _param$3;
      let _tmp$9 = _param$4;
      let _tmp$10 = k;
      while (true) {
        const _param$5 = _tmp$7;
        const _param$6 = _tmp$8;
        const _param$7 = _tmp$9;
        const _param$8 = _tmp$10;
        let _tmp$11;
        if (_param$8 <= _param$6) {
          $bound_check(_param$5, _param$8);
          const _tmp$12 = _param$5.charCodeAt(_param$8);
          $bound_check(_param$5, _param$7);
          _tmp$11 = _tmp$12 === _param$5.charCodeAt(_param$7);
        } else {
          _tmp$11 = false;
        }
        if (_tmp$11) {
          _tmp$10 = _param$8 + 1 | 0;
          continue;
        }
        const fence_last = _param$8 - 1 | 0;
        const fcount = (fence_last - _param$7 | 0) + 1 | 0;
        if (fcount >= 3) {
          const after_blank = rami3l$cmark$cmark_base$$first_non_blank(_param$5, _param$6, _param$8);
          let info;
          if (after_blank > _param$6) {
            info = undefined;
          } else {
            $bound_check(_param$5, _param$7);
            const _bind = rami3l$cmark$cmark_base$$fenced_code_block_start$46$info$124$485(_param$5, _param$6, _param$5.charCodeAt(_param$7) === 96, after_blank, after_blank);
            if (_bind === undefined) {
              _tmp$6 = undefined;
              break;
            } else {
              const _Some = _bind;
              const _i = _Some;
              info = _i;
            }
          }
          _tmp$6 = new $64$rami3l$47$cmark$47$cmark_base$46$LineType$FencedCodeBlockLine(_param$7, fence_last, info);
          break;
        } else {
          _tmp$6 = $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
          break;
        }
      }
      const _tmp$11 = _tmp$6;
      return moonbitlang$core$option$$Option$or$68$(_tmp$11, $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch);
    } else {
      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
    }
  }
}
function rami3l$cmark$cmark_base$$FencedCodeBlockContinue$new(s, fence, last, start) {
  if (start > last) {
    return $64$rami3l$47$cmark$47$cmark_base$46$FencedCodeBlockContinue$Code;
  }
  const _fc = fence._0;
  const _fcount = fence._1;
  let _tmp = s;
  let _tmp$2 = start;
  let _tmp$3 = last;
  let _tmp$4 = start;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    if (_param$4 > _param$3) {
      return $64$rami3l$47$cmark$47$cmark_base$46$FencedCodeBlockContinue$Code;
    }
    let _tmp$5;
    if (((_param$4 - _param$2 | 0) + 1 | 0) < 4) {
      $bound_check(_param, _param$4);
      _tmp$5 = _param.charCodeAt(_param$4) === 32;
    } else {
      _tmp$5 = false;
    }
    if (_tmp$5) {
      _tmp$4 = _param$4 + 1 | 0;
      continue;
    }
    $bound_check(_param, _param$4);
    if (_param.charCodeAt(_param$4) !== _fc) {
      return $64$rami3l$47$cmark$47$cmark_base$46$FencedCodeBlockContinue$Code;
    }
    const k = _param$4 + 1 | 0;
    let _tmp$6;
    let _tmp$7 = _param;
    let _tmp$8 = _param$3;
    let _tmp$9 = _param$4;
    let _tmp$10 = k;
    while (true) {
      const _param$5 = _tmp$7;
      const _param$6 = _tmp$8;
      const _param$7 = _tmp$9;
      const _param$8 = _tmp$10;
      let _tmp$11;
      if (_param$8 <= _param$6) {
        $bound_check(_param$5, _param$8);
        _tmp$11 = _param$5.charCodeAt(_param$8) === _fc;
      } else {
        _tmp$11 = false;
      }
      if (_tmp$11) {
        _tmp$10 = _param$8 + 1 | 0;
        continue;
      }
      const fence_last = _param$8 - 1 | 0;
      if (((fence_last - _param$7 | 0) + 1 | 0) >= _fcount) {
        const after_blank = rami3l$cmark$cmark_base$$first_non_blank(_param$5, _param$6, _param$8);
        _tmp$6 = after_blank > _param$6 ? new $64$rami3l$47$cmark$47$cmark_base$46$FencedCodeBlockContinue$Close(_param$7, fence_last) : undefined;
        break;
      } else {
        _tmp$6 = undefined;
        break;
      }
    }
    const _tmp$11 = _tmp$6;
    return moonbitlang$core$option$$Option$or$67$(_tmp$11, $64$rami3l$47$cmark$47$cmark_base$46$FencedCodeBlockContinue$Code);
  }
}
function rami3l$cmark$cmark_base$$LineType$html_block_start_5(s, last, start) {
  const next = start + 3 | 0;
  if ((start + 8 | 0) > last || !moonbitlang$core$string$$String$starts_with(moonbitlang$core$string$$String$substring(s, next, undefined), rami3l$cmark$cmark_base$$html_block_start_5$46$sub$124$452)) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
  return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine(new $64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndStr("]]>"));
}
function rami3l$cmark$cmark_base$$LineType$html_block_start_2(s, last, start) {
  const next = start + 3 | 0;
  let _tmp;
  if (next > last) {
    _tmp = true;
  } else {
    $bound_check(s, next);
    _tmp = s.charCodeAt(next) !== 45;
  }
  if (_tmp) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
  return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine(new $64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndStr("-->"));
}
function rami3l$cmark$cmark_base$$attribute_name(s, last, start) {
  let _tmp;
  if (start > last) {
    _tmp = true;
  } else {
    $bound_check(s, start);
    const c = s.charCodeAt(start);
    let _tmp$2;
    switch (c) {
      case 95: {
        _tmp$2 = true;
        break;
      }
      case 58: {
        _tmp$2 = true;
        break;
      }
      default: {
        _tmp$2 = rami3l$cmark$char$$is_ascii_alphanum(c);
      }
    }
    _tmp = !_tmp$2;
  }
  if (_tmp) {
    return undefined;
  }
  let _tmp$2 = s;
  let _tmp$3 = last;
  let _tmp$4 = start + 1 | 0;
  while (true) {
    const _param = _tmp$2;
    const _param$2 = _tmp$3;
    const _param$3 = _tmp$4;
    let _tmp$5;
    if (_param$3 > _param$2) {
      _tmp$5 = true;
    } else {
      $bound_check(_param, _param$3);
      const c = _param.charCodeAt(_param$3);
      let _tmp$6;
      switch (c) {
        case 46: {
          _tmp$6 = true;
          break;
        }
        case 95: {
          _tmp$6 = true;
          break;
        }
        case 58: {
          _tmp$6 = true;
          break;
        }
        case 45: {
          _tmp$6 = true;
          break;
        }
        default: {
          _tmp$6 = rami3l$cmark$char$$is_ascii_alphanum(c);
        }
      }
      _tmp$5 = !_tmp$6;
    }
    if (_tmp$5) {
      return _param$3 - 1 | 0;
    }
    _tmp$4 = _param$3 + 1 | 0;
    continue;
  }
}
function rami3l$cmark$cmark_base$$attribute_value$12$(next_line, s, lines, line, spans, start) {
  if (start > line.last) {
    return undefined;
  }
  $bound_check(s, start);
  const c = s.charCodeAt(start);
  _L: {
    _L$2: {
      switch (c) {
        case 34: {
          break _L$2;
        }
        case 39: {
          break _L$2;
        }
      }
      break _L;
    }
    return rami3l$cmark$cmark_base$$accept_to$12$(c, next_line, s, lines, line, spans, start);
  }
  let _tmp = s;
  let _tmp$2 = line.last;
  let _tmp$3 = start + 1 | 0;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    let _tmp$4;
    if (_param$3 <= _param$2) {
      $bound_check(_param, _param$3);
      const c$2 = _param.charCodeAt(_param$3);
      let _tmp$5;
      switch (c$2) {
        case 32: {
          _tmp$5 = true;
          break;
        }
        case 9: {
          _tmp$5 = true;
          break;
        }
        case 34: {
          _tmp$5 = true;
          break;
        }
        case 39: {
          _tmp$5 = true;
          break;
        }
        case 61: {
          _tmp$5 = true;
          break;
        }
        case 60: {
          _tmp$5 = true;
          break;
        }
        case 62: {
          _tmp$5 = true;
          break;
        }
        case 96: {
          _tmp$5 = true;
          break;
        }
        default: {
          _tmp$5 = false;
        }
      }
      _tmp$4 = !_tmp$5;
    } else {
      _tmp$4 = false;
    }
    if (_tmp$4) {
      _tmp$3 = _param$3 + 1 | 0;
      continue;
    }
    const last = _param$3 - 1 | 0;
    rami3l$cmark$cmark_base$$push_span(line, start, last, spans);
    return { _0: line, _1: last };
  }
}
function rami3l$cmark$cmark_base$$attribute_value$355$(next_line, s, lines, line, spans, start) {
  if (start > line.last) {
    return undefined;
  }
  $bound_check(s, start);
  const c = s.charCodeAt(start);
  _L: {
    _L$2: {
      switch (c) {
        case 34: {
          break _L$2;
        }
        case 39: {
          break _L$2;
        }
      }
      break _L;
    }
    return rami3l$cmark$cmark_base$$accept_to$355$(c, next_line, s, lines, line, spans, start);
  }
  let _tmp = s;
  let _tmp$2 = line.last;
  let _tmp$3 = start + 1 | 0;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    let _tmp$4;
    if (_param$3 <= _param$2) {
      $bound_check(_param, _param$3);
      const c$2 = _param.charCodeAt(_param$3);
      let _tmp$5;
      switch (c$2) {
        case 32: {
          _tmp$5 = true;
          break;
        }
        case 9: {
          _tmp$5 = true;
          break;
        }
        case 34: {
          _tmp$5 = true;
          break;
        }
        case 39: {
          _tmp$5 = true;
          break;
        }
        case 61: {
          _tmp$5 = true;
          break;
        }
        case 60: {
          _tmp$5 = true;
          break;
        }
        case 62: {
          _tmp$5 = true;
          break;
        }
        case 96: {
          _tmp$5 = true;
          break;
        }
        default: {
          _tmp$5 = false;
        }
      }
      _tmp$4 = !_tmp$5;
    } else {
      _tmp$4 = false;
    }
    if (_tmp$4) {
      _tmp$3 = _param$3 + 1 | 0;
      continue;
    }
    const last = _param$3 - 1 | 0;
    rami3l$cmark$cmark_base$$push_span(line, start, last, spans);
    return { _0: line, _1: last };
  }
}
function rami3l$cmark$cmark_base$$attribute$12$(next_line, s, lines, line, spans, start) {
  const _bind = rami3l$cmark$cmark_base$$attribute_name(s, line.last, start);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _end_name = _Some;
    rami3l$cmark$cmark_base$$push_span(line, start, _end_name, spans.val);
    const start$2 = _end_name + 1 | 0;
    const _bind$2 = rami3l$cmark$cmark_base$$first_non_blank_over_nl1$12$(next_line, s, lines, line, spans.val, start$2);
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some$2 = _bind$2;
      const _x = _Some$2;
      const _line1 = _x._0;
      const _last_blank = _x._1;
      const nb = _last_blank + 1 | 0;
      $bound_check(s, nb);
      if (s.charCodeAt(nb) !== 61) {
        return { _0: line, _1: _end_name };
      }
      rami3l$cmark$cmark_base$$push_span(_line1, nb, nb, spans.val);
      const start$3 = nb + 1 | 0;
      const _bind$3 = rami3l$cmark$cmark_base$$first_non_blank_over_nl1$12$(next_line, s, lines, _line1, spans.val, start$3);
      if (_bind$3 === undefined) {
        return undefined;
      } else {
        const _Some$3 = _bind$3;
        const _x$2 = _Some$3;
        const _line = _x$2._0;
        const _last_blank$2 = _x$2._1;
        const start$4 = _last_blank$2 + 1 | 0;
        return rami3l$cmark$cmark_base$$attribute_value$12$(next_line, s, lines, _line, spans.val, start$4);
      }
    }
  }
}
function rami3l$cmark$cmark_base$$attribute$355$(next_line, s, lines, line, spans, start) {
  const _bind = rami3l$cmark$cmark_base$$attribute_name(s, line.last, start);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _end_name = _Some;
    rami3l$cmark$cmark_base$$push_span(line, start, _end_name, spans.val);
    const start$2 = _end_name + 1 | 0;
    const _bind$2 = rami3l$cmark$cmark_base$$first_non_blank_over_nl1$355$(next_line, s, lines, line, spans.val, start$2);
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some$2 = _bind$2;
      const _x = _Some$2;
      const _line1 = _x._0;
      const _last_blank = _x._1;
      const nb = _last_blank + 1 | 0;
      $bound_check(s, nb);
      if (s.charCodeAt(nb) !== 61) {
        return { _0: line, _1: _end_name };
      }
      rami3l$cmark$cmark_base$$push_span(_line1, nb, nb, spans.val);
      const start$3 = nb + 1 | 0;
      const _bind$3 = rami3l$cmark$cmark_base$$first_non_blank_over_nl1$355$(next_line, s, lines, _line1, spans.val, start$3);
      if (_bind$3 === undefined) {
        return undefined;
      } else {
        const _Some$3 = _bind$3;
        const _x$2 = _Some$3;
        const _line = _x$2._0;
        const _last_blank$2 = _x$2._1;
        const start$4 = _last_blank$2 + 1 | 0;
        return rami3l$cmark$cmark_base$$attribute_value$355$(next_line, s, lines, _line, spans.val, start$4);
      }
    }
  }
}
function rami3l$cmark$cmark_base$$tag_name(s, last, start) {
  let _tmp = s;
  let _tmp$2 = last;
  let _tmp$3 = start + 1 | 0;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    let _tmp$4;
    if (_param$3 <= _param$2) {
      let _tmp$5;
      $bound_check(_param, _param$3);
      if (rami3l$cmark$char$$is_ascii_alphanum(_param.charCodeAt(_param$3))) {
        _tmp$5 = true;
      } else {
        $bound_check(_param, _param$3);
        _tmp$5 = _param.charCodeAt(_param$3) === 45;
      }
      _tmp$4 = _tmp$5;
    } else {
      _tmp$4 = false;
    }
    if (_tmp$4) {
      _tmp$3 = _param$3 + 1 | 0;
      continue;
    } else {
      return _param$3 - 1 | 0;
    }
  }
}
function rami3l$cmark$cmark_base$$open_tag$12$(next_line, s, lines, line, start) {
  const _bind = rami3l$cmark$cmark_base$$tag_name(s, line.last, start + 1 | 0);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _tag_name_end = _Some;
    const start$2 = _tag_name_end + 1 | 0;
    const span = { pos: line.pos, first: start, last: _tag_name_end };
    const spans = moonbitlang$core$ref$$Ref$new$356$([{ start: start, span: span }]);
    let _tmp = lines;
    let _tmp$2 = line;
    let _tmp$3 = start$2;
    _L: while (true) {
      const _param = _tmp;
      const _param$2 = _tmp$2;
      const _param$3 = _tmp$3;
      const _bind$2 = rami3l$cmark$cmark_base$$first_non_blank_over_nl1$12$(next_line, s, _param, _param$2, spans.val, _param$3);
      if (_bind$2 === undefined) {
        return undefined;
      } else {
        const _Some$2 = _bind$2;
        const _x = _Some$2;
        const _line = _x._0;
        const _last_blank = _x._1;
        const next = _last_blank + 1 | 0;
        $bound_check(s, next);
        const _bind$3 = s.charCodeAt(next);
        switch (_bind$3) {
          case 62: {
            rami3l$cmark$cmark_base$$push_span(_line, next, next, spans.val);
            return { _0: _line, _1: spans.val, _2: next };
          }
          case 47: {
            const last = next + 1 | 0;
            let _tmp$4;
            if (last > _line.last) {
              _tmp$4 = true;
            } else {
              $bound_check(s, last);
              _tmp$4 = s.charCodeAt(last) !== 62;
            }
            if (_tmp$4) {
              return undefined;
            }
            rami3l$cmark$cmark_base$$push_span(_line, next, last, spans.val);
            return { _0: _line, _1: spans.val, _2: last };
          }
          default: {
            if (next === _param$3) {
              return undefined;
            }
            const _bind$4 = rami3l$cmark$cmark_base$$attribute$12$(next_line, s, _param, _line, spans, next);
            if (_bind$4 === undefined) {
              return undefined;
            } else {
              const _Some$3 = _bind$4;
              const _x$2 = _Some$3;
              const _line$2 = _x$2._0;
              const _last = _x$2._1;
              const _tmp$5 = _last + 1 | 0;
              _tmp$2 = _line$2;
              _tmp$3 = _tmp$5;
              continue _L;
            }
          }
        }
      }
    }
  }
}
function rami3l$cmark$cmark_base$$open_tag$355$(next_line, s, lines, line, start) {
  const _bind = rami3l$cmark$cmark_base$$tag_name(s, line.last, start + 1 | 0);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _tag_name_end = _Some;
    const start$2 = _tag_name_end + 1 | 0;
    const span = { pos: line.pos, first: start, last: _tag_name_end };
    const spans = moonbitlang$core$ref$$Ref$new$356$([{ start: start, span: span }]);
    let _tmp = lines;
    let _tmp$2 = line;
    let _tmp$3 = start$2;
    _L: while (true) {
      const _param = _tmp;
      const _param$2 = _tmp$2;
      const _param$3 = _tmp$3;
      const _bind$2 = rami3l$cmark$cmark_base$$first_non_blank_over_nl1$355$(next_line, s, _param, _param$2, spans.val, _param$3);
      if (_bind$2 === undefined) {
        return undefined;
      } else {
        const _Some$2 = _bind$2;
        const _x = _Some$2;
        const _line = _x._0;
        const _last_blank = _x._1;
        const next = _last_blank + 1 | 0;
        $bound_check(s, next);
        const _bind$3 = s.charCodeAt(next);
        switch (_bind$3) {
          case 62: {
            rami3l$cmark$cmark_base$$push_span(_line, next, next, spans.val);
            return { _0: _line, _1: spans.val, _2: next };
          }
          case 47: {
            const last = next + 1 | 0;
            let _tmp$4;
            if (last > _line.last) {
              _tmp$4 = true;
            } else {
              $bound_check(s, last);
              _tmp$4 = s.charCodeAt(last) !== 62;
            }
            if (_tmp$4) {
              return undefined;
            }
            rami3l$cmark$cmark_base$$push_span(_line, next, last, spans.val);
            return { _0: _line, _1: spans.val, _2: last };
          }
          default: {
            if (next === _param$3) {
              return undefined;
            }
            const _bind$4 = rami3l$cmark$cmark_base$$attribute$355$(next_line, s, _param, _line, spans, next);
            if (_bind$4 === undefined) {
              return undefined;
            } else {
              const _Some$3 = _bind$4;
              const _x$2 = _Some$3;
              const _line$2 = _x$2._0;
              const _last = _x$2._1;
              const _tmp$5 = _last + 1 | 0;
              _tmp$2 = _line$2;
              _tmp$3 = _tmp$5;
              continue _L;
            }
          }
        }
      }
    }
  }
}
function rami3l$cmark$cmark_base$$LineType$html_block_start_7_open_tag(s, last, start) {
  const line = { pos: rami3l$cmark$cmark_base$$line_pos_none, first: start, last: last };
  const _bind = rami3l$cmark$cmark_base$$open_tag$12$((_x) => undefined, s, undefined, line, start);
  if (_bind === undefined) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _tag_end = _x._2;
    const next = rami3l$cmark$cmark_base$$first_non_blank(s, last, _tag_end + 1 | 0);
    return next > last ? new $64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine($64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndBlank7) : $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
}
function rami3l$cmark$cmark_base$$closing_tag$12$(next_line, s, lines, line, start) {
  const _bind = rami3l$cmark$cmark_base$$tag_name(s, line.last, start + 2 | 0);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _tag_name_end = _Some;
    const span = { pos: line.pos, first: start, last: _tag_name_end };
    const spans = moonbitlang$core$ref$$Ref$new$356$([{ start: start, span: span }]);
    const start$2 = _tag_name_end + 1 | 0;
    const _bind$2 = rami3l$cmark$cmark_base$$first_non_blank_over_nl1$12$(next_line, s, lines, line, spans.val, start$2);
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some$2 = _bind$2;
      const _x = _Some$2;
      const _line = _x._0;
      const _last_blank = _x._1;
      const last = _last_blank + 1 | 0;
      $bound_check(s, last);
      if (s.charCodeAt(last) !== 62) {
        return undefined;
      }
      rami3l$cmark$cmark_base$$push_span(_line, last, last, spans.val);
      return { _0: _line, _1: spans.val, _2: last };
    }
  }
}
function rami3l$cmark$cmark_base$$closing_tag$355$(next_line, s, lines, line, start) {
  const _bind = rami3l$cmark$cmark_base$$tag_name(s, line.last, start + 2 | 0);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _tag_name_end = _Some;
    const span = { pos: line.pos, first: start, last: _tag_name_end };
    const spans = moonbitlang$core$ref$$Ref$new$356$([{ start: start, span: span }]);
    const start$2 = _tag_name_end + 1 | 0;
    const _bind$2 = rami3l$cmark$cmark_base$$first_non_blank_over_nl1$355$(next_line, s, lines, line, spans.val, start$2);
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some$2 = _bind$2;
      const _x = _Some$2;
      const _line = _x._0;
      const _last_blank = _x._1;
      const last = _last_blank + 1 | 0;
      $bound_check(s, last);
      if (s.charCodeAt(last) !== 62) {
        return undefined;
      }
      rami3l$cmark$cmark_base$$push_span(_line, last, last, spans.val);
      return { _0: _line, _1: spans.val, _2: last };
    }
  }
}
function rami3l$cmark$cmark_base$$LineType$html_block_start_7_close_tag(s, last, start) {
  const line = { pos: rami3l$cmark$cmark_base$$line_pos_none, first: start, last: last };
  const _bind = rami3l$cmark$cmark_base$$closing_tag$12$((_x) => undefined, s, undefined, line, start);
  if (_bind === undefined) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _tag_end = _x._2;
    const next = rami3l$cmark$cmark_base$$first_non_blank(s, last, _tag_end + 1 | 0);
    return next > last ? new $64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine($64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndBlank7) : $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
}
function rami3l$cmark$cmark_base$$LineType$html_block_start(s, last, start) {
  const next = start + 1 | 0;
  let _tmp;
  if (next > last) {
    _tmp = true;
  } else {
    $bound_check(s, start);
    _tmp = s.charCodeAt(start) !== 60;
  }
  if (_tmp) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
  $bound_check(s, next);
  const _bind = s.charCodeAt(next);
  switch (_bind) {
    case 63: {
      return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine(new $64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndStr("?>"));
    }
    case 33: {
      const next$2 = next + 1 | 0;
      if (next$2 > last) {
        return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
      }
      $bound_check(s, next$2);
      const _bind$2 = s.charCodeAt(next$2);
      switch (_bind$2) {
        case 91: {
          return rami3l$cmark$cmark_base$$LineType$html_block_start_5(s, last, start);
        }
        case 45: {
          return rami3l$cmark$cmark_base$$LineType$html_block_start_2(s, last, start);
        }
        default: {
          return moonbitlang$core$char$$Char$is_ascii_alphabetic(_bind$2) ? new $64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine(new $64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndStr(">")) : $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
        }
      }
    }
    default: {
      if (moonbitlang$core$char$$Char$is_ascii_alphabetic(_bind) || _bind === 47) {
        const tag_first = _bind === 47 ? next + 1 | 0 : next;
        let tag_last;
        let _tmp$2 = s;
        let _tmp$3 = last;
        let _tmp$4 = tag_first;
        while (true) {
          const _param = _tmp$2;
          const _param$2 = _tmp$3;
          const _param$3 = _tmp$4;
          let _tmp$5;
          if (_param$3 > _param$2) {
            _tmp$5 = true;
          } else {
            $bound_check(_param, _param$3);
            _tmp$5 = !moonbitlang$core$char$$Char$is_ascii_alphabetic(_param.charCodeAt(_param$3));
          }
          if (_tmp$5) {
            tag_last = _param$3 - 1 | 0;
            break;
          }
          _tmp$4 = _param$3 + 1 | 0;
          continue;
        }
        const tag = moonbitlang$core$string$$String$to_lower(moonbitlang$core$string$$String$substring(s, tag_first, tag_last + 1 | 0));
        const n = tag_last + 1 | 0;
        let is_open_end;
        if (n > last) {
          is_open_end = true;
        } else {
          $bound_check(s, n);
          const _bind$3 = s.charCodeAt(n);
          let _tmp$5;
          switch (_bind$3) {
            case 32: {
              _tmp$5 = true;
              break;
            }
            case 9: {
              _tmp$5 = true;
              break;
            }
            case 62: {
              _tmp$5 = true;
              break;
            }
            default: {
              _tmp$5 = false;
            }
          }
          is_open_end = _tmp$5;
        }
        const is_open_close_end = is_open_end || (tag_last + 2 | 0) <= last && moonbitlang$core$string$$String$substring(s, tag_last + 1 | 0, tag_last + 3 | 0) === "/>";
        return _bind !== 47 ? (moonbitlang$core$set$$Set$contains$9$(rami3l$cmark$cmark_base$$html_start_cond_1_set, tag) && is_open_end ? new $64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine($64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndCond1) : moonbitlang$core$set$$Set$contains$9$(rami3l$cmark$cmark_base$$html_start_cond_6_set, tag) && is_open_close_end ? new $64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine($64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndBlank) : rami3l$cmark$cmark_base$$LineType$html_block_start_7_open_tag(s, last, start)) : moonbitlang$core$set$$Set$contains$9$(rami3l$cmark$cmark_base$$html_start_cond_6_set, tag) && is_open_close_end ? new $64$rami3l$47$cmark$47$cmark_base$46$LineType$HtmlBlockLine($64$rami3l$47$cmark$47$cmark_base$46$HtmlBlockEndCond$EndBlank) : rami3l$cmark$cmark_base$$LineType$html_block_start_7_close_tag(s, last, start);
      } else {
        return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
      }
    }
  }
}
function rami3l$cmark$cmark_base$$LineType$html_block_end_cond_1(s, last, start) {
  const lower_s = moonbitlang$core$string$$String$to_lower(s);
  let _tmp = last;
  let _tmp$2 = start;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if ((_param$2 + 3 | 0) <= _param) {
      let _tmp$3;
      $bound_check(s, _param$2);
      if (s.charCodeAt(_param$2) === 60) {
        const _tmp$4 = _param$2 + 1 | 0;
        $bound_check(s, _tmp$4);
        _tmp$3 = s.charCodeAt(_tmp$4) === 47;
      } else {
        _tmp$3 = false;
      }
      if (_tmp$3) {
        const next = _param$2 + 2 | 0;
        const lower_s_sub = moonbitlang$core$string$$String$substring(lower_s, next, undefined);
        $bound_check(s, next);
        const _bind = s.charCodeAt(next);
        let is_end_tag;
        switch (_bind) {
          case 112: {
            is_end_tag = moonbitlang$core$string$$String$starts_with(lower_s_sub, "pre>");
            break;
          }
          case 115: {
            const _tmp$4 = _param$2 + 3 | 0;
            $bound_check(s, _tmp$4);
            if (s.charCodeAt(_tmp$4) === 116) {
              is_end_tag = moonbitlang$core$string$$String$starts_with(lower_s_sub, "style>");
            } else {
              is_end_tag = moonbitlang$core$string$$String$starts_with(lower_s_sub, "script>");
            }
            break;
          }
          case 116: {
            is_end_tag = moonbitlang$core$string$$String$starts_with(lower_s_sub, "textarea>");
            break;
          }
          default: {
            is_end_tag = false;
          }
        }
        if (!is_end_tag) {
          _tmp$2 = _param$2 + 1 | 0;
          continue;
        } else {
          return true;
        }
      } else {
        _tmp$2 = _param$2 + 1 | 0;
        continue;
      }
    } else {
      return false;
    }
  }
}
function rami3l$cmark$cmark_base$$LineType$html_block_end(s, end_cond, last, start) {
  _L: {
    switch (end_cond.$tag) {
      case 0: {
        const _EndStr = end_cond;
        const _str = _EndStr._0;
        return rami3l$cmark$char$$sub_includes(_str, s, start, last);
      }
      case 1: {
        return rami3l$cmark$cmark_base$$LineType$html_block_end_cond_1(s, last, start);
      }
      case 2: {
        break _L;
      }
      default: {
        break _L;
      }
    }
  }
  return rami3l$cmark$cmark_base$$first_non_blank(s, last, start) === (last + 1 | 0);
}
function rami3l$cmark$cmark_base$$LineType$ext_table_row(s, last, start) {
  let _tmp;
  if (start <= last) {
    $bound_check(s, start);
    _tmp = s.charCodeAt(start) === 124;
  } else {
    _tmp = false;
  }
  if (_tmp) {
    const first = start + 1 | 0;
    const last_nb = rami3l$cmark$cmark_base$$last_non_blank(s, first, last);
    const before = last_nb - 1 | 0;
    let _tmp$2;
    if (last_nb >= first) {
      $bound_check(s, last_nb);
      _tmp$2 = s.charCodeAt(last_nb) === 124;
    } else {
      _tmp$2 = false;
    }
    if (_tmp$2) {
      let _tmp$3;
      if (before < first) {
        _tmp$3 = true;
      } else {
        $bound_check(s, before);
        _tmp$3 = s.charCodeAt(before) !== 92;
      }
      if (_tmp$3) {
        return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$ExtTableRow(last_nb);
      } else {
        return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
      }
    } else {
      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
    }
  } else {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
}
function rami3l$cmark$cmark_base$$link_label$12$(buf, next_line, s, lines, line, start) {
  let _tmp;
  if (start > line.last) {
    _tmp = true;
  } else {
    $bound_check(s, start);
    _tmp = s.charCodeAt(start) !== 91;
  }
  if (_tmp) {
    return undefined;
  }
  const start$2 = start + 1 | 0;
  moonbitlang$core$builtin$$StringBuilder$reset(buf);
  const acc = [];
  let _tmp$2 = buf;
  let _tmp$3 = next_line;
  let _tmp$4 = s;
  let _tmp$5 = lines;
  let _tmp$6 = line;
  let _tmp$7 = 0;
  let _tmp$8 = start$2;
  let _tmp$9 = 0;
  let _tmp$10 = start$2;
  _L: while (true) {
    const _param = _tmp$2;
    const _param$2 = _tmp$3;
    const _param$3 = _tmp$4;
    const _param$4 = _tmp$5;
    const _param$5 = _tmp$6;
    const _param$6 = _tmp$7;
    const _param$7 = _tmp$8;
    const _param$8 = _tmp$9;
    const _param$9 = _tmp$10;
    if (_param$9 > _param$5.last) {
      const _bind = _param$2(_param$4);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _newline = _Some;
        if (_newline.first === _newline.last) {
          return undefined;
        }
        rami3l$cmark$cmark_base$$push_span(_param$5, _param$7, _param$5.last, acc);
        const start$3 = rami3l$cmark$cmark_base$$first_non_blank_in_span(_param$3, _newline);
        if (!moonbitlang$core$builtin$$StringBuilder$is_empty(_param)) {
          moonbitlang$core$builtin$$Logger$write_char$71$(_param, 32);
        }
        _tmp$6 = _newline;
        _tmp$7 = 0;
        _tmp$8 = start$3;
        _tmp$10 = start$3;
        continue;
      }
    }
    if (_param$8 > 999) {
      return undefined;
    }
    let prev;
    _L$2: {
      _L$3: {
        $bound_check(_param$3, _param$9);
        const _bind = _param$3.charCodeAt(_param$9);
        switch (_bind) {
          case 92: {
            if (_param$6 === 92) {
              moonbitlang$core$builtin$$Logger$write_char$71$(_param, 92);
              const _tmp$11 = _param$8 + 1 | 0;
              const _tmp$12 = _param$9 + 1 | 0;
              _tmp$7 = 0;
              _tmp$9 = _tmp$11;
              _tmp$10 = _tmp$12;
              continue _L;
            }
            break;
          }
          case 93: {
            if (_param$6 === 92) {
            } else {
              const key = moonbitlang$core$builtin$$StringBuilder$to_string(_param);
              if (moonbitlang$core$builtin$$Iter$all$10$(moonbitlang$core$string$$String$iter(key), rami3l$cmark$char$$is_ascii_whitespace)) {
                return undefined;
              }
              rami3l$cmark$cmark_base$$push_span(_param$5, _param$7, _param$9 - 1 | 0, acc);
              return { _0: _param$5, _1: acc, _2: _param$9, _3: key };
            }
            break;
          }
          case 91: {
            if (_param$6 === 92) {
            } else {
              return undefined;
            }
            break;
          }
          case 32: {
            prev = _bind;
            break _L$3;
          }
          case 9: {
            prev = _bind;
            break _L$3;
          }
        }
        break _L$2;
      }
      const _tmp$11 = _param$8 + 1 | 0;
      const _tmp$12 = _param$9 + 1 | 0;
      _tmp$7 = prev;
      _tmp$9 = _tmp$11;
      _tmp$10 = _tmp$12;
      continue;
    }
    if (rami3l$cmark$char$$is_ascii_blank(_param$6) && !moonbitlang$core$builtin$$StringBuilder$is_empty(_param)) {
      moonbitlang$core$builtin$$Logger$write_char$71$(_param, 32);
    }
    let u = rami3l$cmark$char$$at(_param$3, _param$9);
    if (u === 0) {
      u = rami3l$cmark$char$$rep;
    }
    const k1 = _param$9 + rami3l$cmark$char$$length_utf8(u) | 0;
    moonbitlang$core$builtin$$Logger$write_char$71$(_param, rami3l$cmark$char$$to_ascii_lower(u));
    $bound_check(_param$3, _param$9);
    const prev$2 = _param$3.charCodeAt(_param$9);
    const _tmp$11 = _param$8 + 1 | 0;
    _tmp$7 = prev$2;
    _tmp$9 = _tmp$11;
    _tmp$10 = k1;
    continue;
  }
}
function rami3l$cmark$cmark_base$$link_label$369$(buf, next_line, s, lines, line, start) {
  let _tmp;
  if (start > line.last) {
    _tmp = true;
  } else {
    $bound_check(s, start);
    _tmp = s.charCodeAt(start) !== 91;
  }
  if (_tmp) {
    return undefined;
  }
  const start$2 = start + 1 | 0;
  moonbitlang$core$builtin$$StringBuilder$reset(buf);
  const acc = [];
  let _tmp$2 = buf;
  let _tmp$3 = next_line;
  let _tmp$4 = s;
  let _tmp$5 = lines;
  let _tmp$6 = line;
  let _tmp$7 = 0;
  let _tmp$8 = start$2;
  let _tmp$9 = 0;
  let _tmp$10 = start$2;
  _L: while (true) {
    const _param = _tmp$2;
    const _param$2 = _tmp$3;
    const _param$3 = _tmp$4;
    const _param$4 = _tmp$5;
    const _param$5 = _tmp$6;
    const _param$6 = _tmp$7;
    const _param$7 = _tmp$8;
    const _param$8 = _tmp$9;
    const _param$9 = _tmp$10;
    if (_param$9 > _param$5.last) {
      const _bind = _param$2(_param$4);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _newline = _Some;
        if (_newline.first === _newline.last) {
          return undefined;
        }
        rami3l$cmark$cmark_base$$push_span(_param$5, _param$7, _param$5.last, acc);
        const start$3 = rami3l$cmark$cmark_base$$first_non_blank_in_span(_param$3, _newline);
        if (!moonbitlang$core$builtin$$StringBuilder$is_empty(_param)) {
          moonbitlang$core$builtin$$Logger$write_char$71$(_param, 32);
        }
        _tmp$6 = _newline;
        _tmp$7 = 0;
        _tmp$8 = start$3;
        _tmp$10 = start$3;
        continue;
      }
    }
    if (_param$8 > 999) {
      return undefined;
    }
    let prev;
    _L$2: {
      _L$3: {
        $bound_check(_param$3, _param$9);
        const _bind = _param$3.charCodeAt(_param$9);
        switch (_bind) {
          case 92: {
            if (_param$6 === 92) {
              moonbitlang$core$builtin$$Logger$write_char$71$(_param, 92);
              const _tmp$11 = _param$8 + 1 | 0;
              const _tmp$12 = _param$9 + 1 | 0;
              _tmp$7 = 0;
              _tmp$9 = _tmp$11;
              _tmp$10 = _tmp$12;
              continue _L;
            }
            break;
          }
          case 93: {
            if (_param$6 === 92) {
            } else {
              const key = moonbitlang$core$builtin$$StringBuilder$to_string(_param);
              if (moonbitlang$core$builtin$$Iter$all$10$(moonbitlang$core$string$$String$iter(key), rami3l$cmark$char$$is_ascii_whitespace)) {
                return undefined;
              }
              rami3l$cmark$cmark_base$$push_span(_param$5, _param$7, _param$9 - 1 | 0, acc);
              return { _0: _param$5, _1: acc, _2: _param$9, _3: key };
            }
            break;
          }
          case 91: {
            if (_param$6 === 92) {
            } else {
              return undefined;
            }
            break;
          }
          case 32: {
            prev = _bind;
            break _L$3;
          }
          case 9: {
            prev = _bind;
            break _L$3;
          }
        }
        break _L$2;
      }
      const _tmp$11 = _param$8 + 1 | 0;
      const _tmp$12 = _param$9 + 1 | 0;
      _tmp$7 = prev;
      _tmp$9 = _tmp$11;
      _tmp$10 = _tmp$12;
      continue;
    }
    if (rami3l$cmark$char$$is_ascii_blank(_param$6) && !moonbitlang$core$builtin$$StringBuilder$is_empty(_param)) {
      moonbitlang$core$builtin$$Logger$write_char$71$(_param, 32);
    }
    let u = rami3l$cmark$char$$at(_param$3, _param$9);
    if (u === 0) {
      u = rami3l$cmark$char$$rep;
    }
    const k1 = _param$9 + rami3l$cmark$char$$length_utf8(u) | 0;
    moonbitlang$core$builtin$$Logger$write_char$71$(_param, rami3l$cmark$char$$to_ascii_lower(u));
    $bound_check(_param$3, _param$9);
    const prev$2 = _param$3.charCodeAt(_param$9);
    const _tmp$11 = _param$8 + 1 | 0;
    _tmp$7 = prev$2;
    _tmp$9 = _tmp$11;
    _tmp$10 = k1;
    continue;
  }
}
function rami3l$cmark$cmark_base$$link_label$355$(buf, next_line, s, lines, line, start) {
  let _tmp;
  if (start > line.last) {
    _tmp = true;
  } else {
    $bound_check(s, start);
    _tmp = s.charCodeAt(start) !== 91;
  }
  if (_tmp) {
    return undefined;
  }
  const start$2 = start + 1 | 0;
  moonbitlang$core$builtin$$StringBuilder$reset(buf);
  const acc = [];
  let _tmp$2 = buf;
  let _tmp$3 = next_line;
  let _tmp$4 = s;
  let _tmp$5 = lines;
  let _tmp$6 = line;
  let _tmp$7 = 0;
  let _tmp$8 = start$2;
  let _tmp$9 = 0;
  let _tmp$10 = start$2;
  _L: while (true) {
    const _param = _tmp$2;
    const _param$2 = _tmp$3;
    const _param$3 = _tmp$4;
    const _param$4 = _tmp$5;
    const _param$5 = _tmp$6;
    const _param$6 = _tmp$7;
    const _param$7 = _tmp$8;
    const _param$8 = _tmp$9;
    const _param$9 = _tmp$10;
    if (_param$9 > _param$5.last) {
      const _bind = _param$2(_param$4);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _newline = _Some;
        if (_newline.first === _newline.last) {
          return undefined;
        }
        rami3l$cmark$cmark_base$$push_span(_param$5, _param$7, _param$5.last, acc);
        const start$3 = rami3l$cmark$cmark_base$$first_non_blank_in_span(_param$3, _newline);
        if (!moonbitlang$core$builtin$$StringBuilder$is_empty(_param)) {
          moonbitlang$core$builtin$$Logger$write_char$71$(_param, 32);
        }
        _tmp$6 = _newline;
        _tmp$7 = 0;
        _tmp$8 = start$3;
        _tmp$10 = start$3;
        continue;
      }
    }
    if (_param$8 > 999) {
      return undefined;
    }
    let prev;
    _L$2: {
      _L$3: {
        $bound_check(_param$3, _param$9);
        const _bind = _param$3.charCodeAt(_param$9);
        switch (_bind) {
          case 92: {
            if (_param$6 === 92) {
              moonbitlang$core$builtin$$Logger$write_char$71$(_param, 92);
              const _tmp$11 = _param$8 + 1 | 0;
              const _tmp$12 = _param$9 + 1 | 0;
              _tmp$7 = 0;
              _tmp$9 = _tmp$11;
              _tmp$10 = _tmp$12;
              continue _L;
            }
            break;
          }
          case 93: {
            if (_param$6 === 92) {
            } else {
              const key = moonbitlang$core$builtin$$StringBuilder$to_string(_param);
              if (moonbitlang$core$builtin$$Iter$all$10$(moonbitlang$core$string$$String$iter(key), rami3l$cmark$char$$is_ascii_whitespace)) {
                return undefined;
              }
              rami3l$cmark$cmark_base$$push_span(_param$5, _param$7, _param$9 - 1 | 0, acc);
              return { _0: _param$5, _1: acc, _2: _param$9, _3: key };
            }
            break;
          }
          case 91: {
            if (_param$6 === 92) {
            } else {
              return undefined;
            }
            break;
          }
          case 32: {
            prev = _bind;
            break _L$3;
          }
          case 9: {
            prev = _bind;
            break _L$3;
          }
        }
        break _L$2;
      }
      const _tmp$11 = _param$8 + 1 | 0;
      const _tmp$12 = _param$9 + 1 | 0;
      _tmp$7 = prev;
      _tmp$9 = _tmp$11;
      _tmp$10 = _tmp$12;
      continue;
    }
    if (rami3l$cmark$char$$is_ascii_blank(_param$6) && !moonbitlang$core$builtin$$StringBuilder$is_empty(_param)) {
      moonbitlang$core$builtin$$Logger$write_char$71$(_param, 32);
    }
    let u = rami3l$cmark$char$$at(_param$3, _param$9);
    if (u === 0) {
      u = rami3l$cmark$char$$rep;
    }
    const k1 = _param$9 + rami3l$cmark$char$$length_utf8(u) | 0;
    moonbitlang$core$builtin$$Logger$write_char$71$(_param, rami3l$cmark$char$$to_ascii_lower(u));
    $bound_check(_param$3, _param$9);
    const prev$2 = _param$3.charCodeAt(_param$9);
    const _tmp$11 = _param$8 + 1 | 0;
    _tmp$7 = prev$2;
    _tmp$9 = _tmp$11;
    _tmp$10 = k1;
    continue;
  }
}
function rami3l$cmark$cmark_base$$LineType$ext_footnote_label(buf, s, line_pos, last, start) {
  let _tmp;
  if (start <= last) {
    let _tmp$2;
    $bound_check(s, start);
    if (s.charCodeAt(start) === 91) {
      const _tmp$3 = start + 1 | 0;
      $bound_check(s, _tmp$3);
      _tmp$2 = s.charCodeAt(_tmp$3) === 94;
    } else {
      _tmp$2 = false;
    }
    _tmp = _tmp$2;
  } else {
    _tmp = false;
  }
  if (_tmp) {
    const rbrack = rami3l$cmark$cmark_base$$first_non_escaped_char(93, s, last, start + 2 | 0);
    const colon = rbrack + 1 | 0;
    let _tmp$2;
    if (colon <= last) {
      let _tmp$3;
      $bound_check(s, colon);
      if (s.charCodeAt(colon) === 58) {
        _tmp$3 = ((colon - start | 0) + 1 | 0) >= 5;
      } else {
        _tmp$3 = false;
      }
      _tmp$2 = _tmp$3;
    } else {
      _tmp$2 = false;
    }
    if (_tmp$2) {
      const line = { pos: line_pos, first: start, last: last };
      const _bind = rami3l$cmark$cmark_base$$link_label$12$(buf, (_x) => undefined, s, undefined, line, start);
      if (_bind === undefined) {
        return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _spans = _x._1;
        const _key = _x._3;
        return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$ExtFootnoteLabel(_spans, colon, _key);
      }
    } else {
      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
    }
  } else {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
}
function rami3l$cmark$cmark_base$$could_be_link_ref_definition(s, last, start) {
  if (start > last) {
    return false;
  }
  let _tmp = s;
  let _tmp$2 = start;
  let _tmp$3 = last;
  let _tmp$4 = start;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    if (_param$4 > _param$3) {
      return false;
    }
    let _tmp$5;
    if (((_param$4 - _param$2 | 0) + 1 | 0) < 4) {
      $bound_check(_param, _param$4);
      _tmp$5 = _param.charCodeAt(_param$4) === 32;
    } else {
      _tmp$5 = false;
    }
    if (_tmp$5) {
      _tmp$4 = _param$4 + 1 | 0;
      continue;
    }
    $bound_check(_param, _param$4);
    return _param.charCodeAt(_param$4) === 91;
  }
}
function rami3l$cmark$cmark_base$$LineType$list_marker(s, last, start) {
  if (start > last) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
  let c;
  _L: {
    $bound_check(s, start);
    const _bind = s.charCodeAt(start);
    if (_bind === 45) {
      c = _bind;
      break _L;
    } else {
      if (_bind === 43) {
        c = _bind;
        break _L;
      } else {
        if (_bind === 42) {
          c = _bind;
          break _L;
        } else {
          if (_bind >= 48 && _bind <= 57) {
            let _tmp = s;
            let _tmp$2 = last;
            let _tmp$3 = 1;
            let _tmp$4 = rami3l$cmark$char$$ascii_digit_to_int(_bind);
            let _tmp$5 = start + 1 | 0;
            while (true) {
              const _param = _tmp;
              const _param$2 = _tmp$2;
              const _param$3 = _tmp$3;
              const _param$4 = _tmp$4;
              const _param$5 = _tmp$5;
              if (_param$5 > _param$2 || _param$3 > 9) {
                return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
              }
              let c$2;
              _L$2: {
                $bound_check(_param, _param$5);
                const _bind$2 = _param.charCodeAt(_param$5);
                if (_bind$2 >= 48 && _bind$2 <= 57) {
                  const _tmp$6 = _param$3 + 1 | 0;
                  const _tmp$7 = (Math.imul(_param$4, 10) | 0) + rami3l$cmark$char$$ascii_digit_to_int(_bind$2) | 0;
                  const _tmp$8 = _param$5 + 1 | 0;
                  _tmp$3 = _tmp$6;
                  _tmp$4 = _tmp$7;
                  _tmp$5 = _tmp$8;
                  continue;
                } else {
                  if (_bind$2 === 46) {
                    c$2 = _bind$2;
                    break _L$2;
                  } else {
                    if (_bind$2 === 41) {
                      c$2 = _bind$2;
                      break _L$2;
                    } else {
                      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
                    }
                  }
                }
              }
              const next = _param$5 + 1 | 0;
              let _tmp$6;
              if (next > _param$2) {
                _tmp$6 = true;
              } else {
                $bound_check(_param, next);
                _tmp$6 = rami3l$cmark$char$$is_ascii_blank(_param.charCodeAt(next));
              }
              if (_tmp$6) {
                return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$ListMarkerLine(new $64$rami3l$47$cmark$47$cmark_base$46$ListType$Ordered(_param$4, c$2), _param$5);
              } else {
                return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
              }
            }
          } else {
            return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
          }
        }
      }
    }
  }
  const next = start + 1 | 0;
  let _tmp;
  if (next > last) {
    _tmp = true;
  } else {
    $bound_check(s, next);
    _tmp = rami3l$cmark$char$$is_ascii_blank(s.charCodeAt(next));
  }
  if (_tmp) {
    return new $64$rami3l$47$cmark$47$cmark_base$46$LineType$ListMarkerLine(new $64$rami3l$47$cmark$47$cmark_base$46$ListType$Unordered(c), start);
  } else {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch;
  }
}
function rami3l$cmark$cmark_base$$ext_task_marker(s, last, start) {
  if (start < last) {
    $bound_check(s, start);
    if (s.charCodeAt(start) === 91) {
      let next = start + 1 | 0;
      const _bind = rami3l$cmark$char$$at_checked(s, next);
      if (_bind.$tag === 1) {
        const _Ok = _bind;
        const _u = _Ok._0;
        next = next + rami3l$cmark$char$$length_utf16(_u) | 0;
        let _tmp;
        if (next <= last) {
          const _tmp$2 = next;
          $bound_check(s, _tmp$2);
          _tmp = s.charCodeAt(_tmp$2) === 93;
        } else {
          _tmp = false;
        }
        if (_tmp) {
          next = next + 1 | 0;
          if (next <= last) {
            const _tmp$2 = next;
            $bound_check(s, _tmp$2);
            if (s.charCodeAt(_tmp$2) === 32) {
              return { _0: _u, _1: next };
            } else {
              return undefined;
            }
          } else {
            return { _0: _u, _1: last };
          }
        } else {
          return undefined;
        }
      } else {
        return undefined;
      }
    } else {
      return undefined;
    }
  } else {
    return undefined;
  }
}
function rami3l$cmark$cmark_base$$char_is_atext_plus_dot(c) {
  if (rami3l$cmark$char$$is_ascii_alphanum(c)) {
    return true;
  } else {
    let _tmp;
    switch (c) {
      case 33: {
        _tmp = true;
        break;
      }
      case 35: {
        _tmp = true;
        break;
      }
      case 36: {
        _tmp = true;
        break;
      }
      case 37: {
        _tmp = true;
        break;
      }
      case 38: {
        _tmp = true;
        break;
      }
      case 92: {
        _tmp = true;
        break;
      }
      case 42: {
        _tmp = true;
        break;
      }
      case 43: {
        _tmp = true;
        break;
      }
      case 45: {
        _tmp = true;
        break;
      }
      case 47: {
        _tmp = true;
        break;
      }
      case 61: {
        _tmp = true;
        break;
      }
      case 63: {
        _tmp = true;
        break;
      }
      case 94: {
        _tmp = true;
        break;
      }
      case 95: {
        _tmp = true;
        break;
      }
      case 96: {
        _tmp = true;
        break;
      }
      case 124: {
        _tmp = true;
        break;
      }
      case 123: {
        _tmp = true;
        break;
      }
      case 125: {
        _tmp = true;
        break;
      }
      case 126: {
        _tmp = true;
        break;
      }
      case 46: {
        _tmp = true;
        break;
      }
      default: {
        _tmp = false;
      }
    }
    return _tmp;
  }
}
function rami3l$cmark$cmark_base$$autolink_email$46$label_seq$124$323(s, last, k) {
  let _tmp = s;
  let _tmp$2 = last;
  let _tmp$3 = k;
  _L: while (true) {
    const s$2 = _tmp;
    const last$2 = _tmp$2;
    const k$2 = _tmp$3;
    let _tmp$4;
    if (k$2 > last$2) {
      _tmp$4 = true;
    } else {
      $bound_check(s$2, k$2);
      _tmp$4 = !rami3l$cmark$char$$is_ascii_alphanum(s$2.charCodeAt(k$2));
    }
    if (_tmp$4) {
      return undefined;
    }
    let _tmp$5 = s$2;
    let _tmp$6 = last$2;
    let _tmp$7 = 1;
    let _tmp$8 = k$2 + 1 | 0;
    _L$2: while (true) {
      const _param = _tmp$5;
      const _param$2 = _tmp$6;
      const _param$3 = _tmp$7;
      const _param$4 = _tmp$8;
      if (_param$4 > _param$2) {
        return undefined;
      }
      let _tmp$9;
      $bound_check(_param, _param$4);
      const c = _param.charCodeAt(_param$4);
      if (rami3l$cmark$char$$is_ascii_alphanum(c) || c === 45) {
        _tmp$9 = _param$3 <= 63;
      } else {
        _tmp$9 = false;
      }
      if (_tmp$9) {
        const _tmp$10 = _param$3 + 1 | 0;
        const _tmp$11 = _param$4 + 1 | 0;
        _tmp$7 = _tmp$10;
        _tmp$8 = _tmp$11;
        continue;
      }
      let _tmp$10;
      if (_param$3 > 63) {
        _tmp$10 = true;
      } else {
        const _tmp$11 = _param$4 - 1 | 0;
        $bound_check(_param, _tmp$11);
        _tmp$10 = !rami3l$cmark$char$$is_ascii_alphanum(_param.charCodeAt(_tmp$11));
      }
      if (_tmp$10) {
        return undefined;
      }
      $bound_check(_param, _param$4);
      const _bind = _param.charCodeAt(_param$4);
      switch (_bind) {
        case 62: {
          return _param$4;
        }
        case 46: {
          const _tmp$11 = _param$4 + 1 | 0;
          _tmp = _param;
          _tmp$2 = _param$2;
          _tmp$3 = _tmp$11;
          continue _L;
        }
        default: {
          return undefined;
        }
      }
    }
  }
}
function rami3l$cmark$cmark_base$$autolink_email(s, last, start) {
  let _tmp;
  if (start > last) {
    _tmp = true;
  } else {
    $bound_check(s, start);
    _tmp = s.charCodeAt(start) !== 60;
  }
  if (_tmp) {
    return undefined;
  }
  let _tmp$2 = s;
  let _tmp$3 = last;
  let _tmp$4 = start + 1 | 0;
  while (true) {
    const _param = _tmp$2;
    const _param$2 = _tmp$3;
    const _param$3 = _tmp$4;
    if (_param$3 > _param$2) {
      return undefined;
    }
    $bound_check(_param, _param$3);
    if (rami3l$cmark$cmark_base$$char_is_atext_plus_dot(_param.charCodeAt(_param$3))) {
      _tmp$4 = _param$3 + 1 | 0;
      continue;
    }
    let _tmp$5;
    $bound_check(_param, _param$3);
    if (_param.charCodeAt(_param$3) === 64) {
      const _tmp$6 = _param$3 - 1 | 0;
      $bound_check(_param, _tmp$6);
      _tmp$5 = rami3l$cmark$cmark_base$$char_is_atext_plus_dot(_param.charCodeAt(_tmp$6));
    } else {
      _tmp$5 = false;
    }
    if (_tmp$5) {
      return rami3l$cmark$cmark_base$$autolink_email$46$label_seq$124$323(_param, _param$2, _param$3 + 1 | 0);
    }
    return undefined;
  }
}
function rami3l$cmark$cmark_base$$autolink_uri(s, last, start) {
  const next = start + 1 | 0;
  let _tmp;
  if (next > last) {
    _tmp = true;
  } else {
    let _tmp$2;
    $bound_check(s, start);
    if (s.charCodeAt(start) !== 60) {
      _tmp$2 = true;
    } else {
      $bound_check(s, next);
      _tmp$2 = !moonbitlang$core$char$$Char$is_ascii_alphabetic(s.charCodeAt(next));
    }
    _tmp = _tmp$2;
  }
  if (_tmp) {
    return undefined;
  }
  let _tmp$2 = s;
  let _tmp$3 = last;
  let _tmp$4 = 1;
  let _tmp$5 = next + 1 | 0;
  while (true) {
    const _param = _tmp$2;
    const _param$2 = _tmp$3;
    const _param$3 = _tmp$4;
    const _param$4 = _tmp$5;
    if (_param$4 > _param$2) {
      return undefined;
    }
    let _tmp$6;
    $bound_check(_param, _param$4);
    const c = _param.charCodeAt(_param$4);
    let _tmp$7;
    if (rami3l$cmark$char$$is_ascii_alphanum(c)) {
      _tmp$7 = true;
    } else {
      let _tmp$8;
      switch (c) {
        case 43: {
          _tmp$8 = true;
          break;
        }
        case 45: {
          _tmp$8 = true;
          break;
        }
        case 46: {
          _tmp$8 = true;
          break;
        }
        default: {
          _tmp$8 = false;
        }
      }
      _tmp$7 = _tmp$8;
    }
    if (_tmp$7) {
      _tmp$6 = _param$3 <= 32;
    } else {
      _tmp$6 = false;
    }
    if (_tmp$6) {
      const _tmp$8 = _param$3 + 1 | 0;
      const _tmp$9 = _param$4 + 1 | 0;
      _tmp$4 = _tmp$8;
      _tmp$5 = _tmp$9;
      continue;
    }
    let _tmp$8;
    $bound_check(_param, _param$4);
    if (_param.charCodeAt(_param$4) === 58) {
      _tmp$8 = 2 <= _param$3 && _param$3 <= 32;
    } else {
      _tmp$8 = false;
    }
    if (_tmp$8) {
      const k = _param$4 + 1 | 0;
      let _tmp$9;
      let _tmp$10 = _param;
      let _tmp$11 = _param$2;
      let _tmp$12 = k;
      while (true) {
        const _param$5 = _tmp$10;
        const _param$6 = _tmp$11;
        const _param$7 = _tmp$12;
        if (_param$7 > _param$6) {
          _tmp$9 = undefined;
          break;
        }
        $bound_check(_param$5, _param$7);
        const c$2 = _param$5.charCodeAt(_param$7);
        if (!(c$2 >= 0 && c$2 <= 31 ? true : c$2 === 127 ? true : c$2 === 60 ? true : c$2 === 62 ? true : c$2 === 32)) {
          _tmp$12 = _param$7 + 1 | 0;
          continue;
        }
        $bound_check(_param$5, _param$7);
        if (_param$5.charCodeAt(_param$7) === 62) {
          _tmp$9 = _param$7;
          break;
        }
        _tmp$9 = undefined;
        break;
      }
      return _tmp$9;
    }
    return undefined;
  }
}
function rami3l$cmark$cmark_base$$declaration$355$(next_line, s, lines, line, start) {
  const spans = [];
  return moonbitlang$core$option$$Option$map$61$(rami3l$cmark$cmark_base$$accept_to$355$(62, next_line, s, lines, line, spans, start), (_param1) => {
    const _line = _param1._0;
    const _k = _param1._1;
    return { _0: _line, _1: spans, _2: _k };
  });
}
function rami3l$cmark$cmark_base$$processing_instruction$355$(next_line, s, lines, line, start) {
  const acc = [];
  let _tmp = lines;
  let _tmp$2 = line;
  let _tmp$3 = start;
  let _tmp$4 = start + 2 | 0;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    if (_param$4 > _param$2.last) {
      const _bind = next_line(_param);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _new_line = _Some;
        rami3l$cmark$cmark_base$$push_span(_param$2, _param$3, _param$2.last, acc);
        const start$2 = rami3l$cmark$cmark_base$$first_non_blank_in_span(s, _new_line);
        _tmp$2 = _new_line;
        _tmp$3 = start$2;
        _tmp$4 = start$2;
        continue;
      }
    }
    $bound_check(s, _param$4);
    if (s.charCodeAt(_param$4) !== 63) {
      _tmp$4 = _param$4 + 1 | 0;
      continue;
    }
    const last = _param$4 + 1 | 0;
    let _tmp$5;
    if (last <= _param$2.last) {
      $bound_check(s, last);
      _tmp$5 = s.charCodeAt(last) === 62;
    } else {
      _tmp$5 = false;
    }
    if (_tmp$5) {
      rami3l$cmark$cmark_base$$push_span(_param$2, _param$3, last, acc);
      return { _0: _param$2, _1: acc, _2: last };
    }
    _tmp$4 = last;
    continue;
  }
}
function rami3l$cmark$cmark_base$$html_comment$355$(next_line, s, lines, line, start) {
  let _tmp;
  if ((start + 3 | 0) > line.last) {
    _tmp = true;
  } else {
    const _tmp$2 = start + 3 | 0;
    $bound_check(s, _tmp$2);
    _tmp = s.charCodeAt(_tmp$2) !== 45;
  }
  if (_tmp) {
    return undefined;
  }
  let _tmp$2;
  if ((start + 4 | 0) <= line.last) {
    const _tmp$3 = start + 4 | 0;
    $bound_check(s, _tmp$3);
    _tmp$2 = s.charCodeAt(_tmp$3) === 62;
  } else {
    _tmp$2 = false;
  }
  if (_tmp$2) {
    return undefined;
  }
  let _tmp$3;
  if ((start + 5 | 0) <= line.last) {
    let _tmp$4;
    const _tmp$5 = start + 4 | 0;
    $bound_check(s, _tmp$5);
    if (s.charCodeAt(_tmp$5) === 45) {
      const _tmp$6 = start + 5 | 0;
      $bound_check(s, _tmp$6);
      _tmp$4 = s.charCodeAt(_tmp$6) === 62;
    } else {
      _tmp$4 = false;
    }
    _tmp$3 = _tmp$4;
  } else {
    _tmp$3 = false;
  }
  if (_tmp$3) {
    return undefined;
  }
  const acc = [];
  let _tmp$4 = lines;
  let _tmp$5 = line;
  let _tmp$6 = start;
  let _tmp$7 = start + 4 | 0;
  while (true) {
    const _param = _tmp$4;
    const _param$2 = _tmp$5;
    const _param$3 = _tmp$6;
    const _param$4 = _tmp$7;
    if (_param$4 > _param$2.last) {
      const _bind = next_line(_param);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _new_line = _Some;
        rami3l$cmark$cmark_base$$push_span(_param$2, _param$3, _param$2.last, acc);
        const start$2 = rami3l$cmark$cmark_base$$first_non_blank_in_span(s, _new_line);
        _tmp$5 = _new_line;
        _tmp$6 = start$2;
        _tmp$7 = start$2;
        continue;
      }
    }
    let _tmp$8;
    $bound_check(s, _param$4);
    if (s.charCodeAt(_param$4) === 45) {
      const _tmp$9 = _param$4 - 1 | 0;
      $bound_check(s, _tmp$9);
      _tmp$8 = s.charCodeAt(_tmp$9) !== 45;
    } else {
      _tmp$8 = false;
    }
    if (_tmp$8) {
      const last = _param$4 + 2 | 0;
      let _tmp$9;
      if (last <= _param$2.last) {
        const _tmp$10 = _param$4 + 1 | 0;
        $bound_check(s, _tmp$10);
        _tmp$9 = s.charCodeAt(_tmp$10) === 45;
      } else {
        _tmp$9 = false;
      }
      if (_tmp$9) {
        let _tmp$10;
        $bound_check(s, last);
        if (s.charCodeAt(last) === 62) {
          rami3l$cmark$cmark_base$$push_span(_param$2, _param$3, last, acc);
          _tmp$10 = { _0: _param$2, _1: acc, _2: last };
        } else {
          _tmp$10 = undefined;
        }
        return _tmp$10;
      }
    }
    _tmp$7 = _param$4 + 1 | 0;
    continue;
  }
}
function rami3l$cmark$cmark_base$$cdata_section$355$(next_line, s, lines, line, start) {
  if ((start + 8 | 0) > line.last) {
    return undefined;
  }
  if (!moonbitlang$core$string$$String$starts_with(moonbitlang$core$string$$String$substring(s, start + 3 | 0, undefined), "CDATA[")) {
    return undefined;
  }
  const acc = [];
  let _tmp = lines;
  let _tmp$2 = line;
  let _tmp$3 = start;
  let _tmp$4 = start + 9 | 0;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    if (_param$4 > _param$2.last) {
      const _bind = next_line(_param);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _new_line = _Some;
        rami3l$cmark$cmark_base$$push_span(_param$2, _param$3, _param$2.last, acc);
        const start$2 = rami3l$cmark$cmark_base$$first_non_blank_in_span(s, _new_line);
        _tmp$2 = _new_line;
        _tmp$3 = start$2;
        _tmp$4 = start$2;
        continue;
      }
    }
    $bound_check(s, _param$4);
    if (s.charCodeAt(_param$4) !== 93) {
      _tmp$4 = _param$4 + 1 | 0;
      continue;
    }
    const last = _param$4 + 2 | 0;
    let _tmp$5;
    if (last <= _param$2.last) {
      let _tmp$6;
      const _tmp$7 = _param$4 + 1 | 0;
      $bound_check(s, _tmp$7);
      if (s.charCodeAt(_tmp$7) === 93) {
        $bound_check(s, last);
        _tmp$6 = s.charCodeAt(last) === 62;
      } else {
        _tmp$6 = false;
      }
      _tmp$5 = _tmp$6;
    } else {
      _tmp$5 = false;
    }
    if (_tmp$5) {
      rami3l$cmark$cmark_base$$push_span(_param$2, _param$3, last, acc);
      return { _0: _param$2, _1: acc, _2: last };
    }
    _tmp$4 = _param$4 + 1 | 0;
    continue;
  }
}
function rami3l$cmark$cmark_base$$raw_html$355$(next_line, s, lines, line, start) {
  const next = start + 1 | 0;
  const _last = line.last;
  let _tmp;
  if (next <= _last) {
    $bound_check(s, start);
    _tmp = s.charCodeAt(start) === 60;
  } else {
    _tmp = false;
  }
  if (_tmp) {
    $bound_check(s, next);
    const _bind = s.charCodeAt(next);
    switch (_bind) {
      case 47: {
        return rami3l$cmark$cmark_base$$closing_tag$355$(next_line, s, lines, line, start);
      }
      case 63: {
        return rami3l$cmark$cmark_base$$processing_instruction$355$(next_line, s, lines, line, start);
      }
      case 33: {
        const next$2 = next + 1 | 0;
        if (next$2 <= _last) {
          $bound_check(s, next$2);
          const _bind$2 = s.charCodeAt(next$2);
          switch (_bind$2) {
            case 45: {
              return rami3l$cmark$cmark_base$$html_comment$355$(next_line, s, lines, line, start);
            }
            case 91: {
              return rami3l$cmark$cmark_base$$cdata_section$355$(next_line, s, lines, line, start);
            }
            default: {
              return moonbitlang$core$char$$Char$is_ascii_alphabetic(_bind$2) ? rami3l$cmark$cmark_base$$declaration$355$(next_line, s, lines, line, start) : undefined;
            }
          }
        } else {
          return undefined;
        }
      }
      default: {
        return rami3l$cmark$cmark_base$$open_tag$355$(next_line, s, lines, line, start);
      }
    }
  } else {
    return undefined;
  }
}
function rami3l$cmark$cmark_base$$TextLoc$none() {
  return rami3l$cmark$cmark_base$$text_loc_none;
}
function rami3l$cmark$cmark_base$$max_by_key$370$(a, b, key) {
  return key(a) > key(b) ? a : b;
}
function rami3l$cmark$cmark_base$$min_by_key$370$(a, b, key) {
  return key(a) <= key(b) ? a : b;
}
function rami3l$cmark$cmark_base$$TextLoc$span(self, other) {
  const _bind = rami3l$cmark$cmark_base$$min_by_key$370$(self, other, (it) => it.first_byte);
  const _first_byte = _bind.first_byte;
  const _first_line = _bind.first_line;
  const _bind$2 = rami3l$cmark$cmark_base$$max_by_key$370$(self, other, (it) => it.last_byte);
  const _file = _bind$2.file;
  const _last_byte = _bind$2.last_byte;
  const _last_line = _bind$2.last_line;
  return { file: _file, first_byte: _first_byte, last_byte: _last_byte, first_line: _first_line, last_line: _last_line };
}
function rami3l$cmark$cmark_base$$TextLoc$reloc(self, other) {
  const _first_byte = self.first_byte;
  const _first_line = self.first_line;
  const _file = other.file;
  const _last_byte = other.last_byte;
  const _last_line = other.last_line;
  return { file: _file, first_byte: _first_byte, last_byte: _last_byte, first_line: _first_line, last_line: _last_line };
}
function rami3l$cmark$cmark_base$$link_destination(s, last, start) {
  if (start > last) {
    return undefined;
  }
  $bound_check(s, start);
  if (s.charCodeAt(start) === 60) {
    let _tmp = s;
    let _tmp$2 = start;
    let _tmp$3 = last;
    let _tmp$4 = 0;
    let _tmp$5 = start + 1 | 0;
    _L: while (true) {
      const _param = _tmp;
      const _param$2 = _tmp$2;
      const _param$3 = _tmp$3;
      const _param$4 = _tmp$4;
      const _param$5 = _tmp$5;
      if (_param$5 > _param$3) {
        return undefined;
      }
      $bound_check(_param, _param$5);
      const c = _param.charCodeAt(_param$5);
      _L$2: {
        _L$3: {
          switch (c) {
            case 10: {
              break _L$3;
            }
            case 13: {
              break _L$3;
            }
            case 92: {
              if (_param$4 === 92) {
                const _tmp$6 = _param$5 + 1 | 0;
                _tmp$4 = 0;
                _tmp$5 = _tmp$6;
                continue _L;
              }
              break;
            }
            case 60: {
              if (_param$4 === 92) {
              } else {
                return undefined;
              }
              break;
            }
            case 62: {
              if (_param$4 === 92) {
              } else {
                return { _0: true, _1: _param$2 + 1 | 0, _2: _param$5 - 1 | 0 };
              }
              break;
            }
          }
          break _L$2;
        }
        return undefined;
      }
      const _tmp$6 = _param$5 + 1 | 0;
      _tmp$4 = c;
      _tmp$5 = _tmp$6;
      continue;
    }
  } else {
    let _tmp = s;
    let _tmp$2 = start;
    let _tmp$3 = last;
    let _tmp$4 = 0;
    let _tmp$5 = 0;
    let _tmp$6 = start;
    _L: while (true) {
      const _param = _tmp;
      const _param$2 = _tmp$2;
      const _param$3 = _tmp$3;
      const _param$4 = _tmp$4;
      const _param$5 = _tmp$5;
      const _param$6 = _tmp$6;
      if (_param$6 > _param$3) {
        return _param$5 === 0 ? { _0: false, _1: _param$2, _2: _param$6 - 1 | 0 } : undefined;
      }
      $bound_check(_param, _param$6);
      const c = _param.charCodeAt(_param$6);
      let c$2;
      _L$2: {
        _L$3: {
          switch (c) {
            case 92: {
              if (_param$4 === 92) {
                const _tmp$7 = _param$6 + 1 | 0;
                _tmp$4 = 0;
                _tmp$6 = _tmp$7;
                continue _L;
              } else {
                c$2 = c;
                break _L$3;
              }
            }
            case 40: {
              if (_param$4 === 92) {
              } else {
                const _tmp$7 = _param$5 + 1 | 0;
                const _tmp$8 = _param$6 + 1 | 0;
                _tmp$4 = c;
                _tmp$5 = _tmp$7;
                _tmp$6 = _tmp$8;
                continue _L;
              }
              break;
            }
            case 41: {
              if (_param$4 === 92) {
              } else {
                const bal = _param$5 - 1 | 0;
                if (bal < 0) {
                  return { _0: false, _1: _param$2, _2: _param$6 - 1 | 0 };
                }
                const _tmp$7 = _param$6 + 1 | 0;
                _tmp$4 = c;
                _tmp$5 = bal;
                _tmp$6 = _tmp$7;
                continue _L;
              }
              break;
            }
            default: {
              c$2 = c;
              break _L$3;
            }
          }
          break _L$2;
        }
        if (c$2 === 32 || rami3l$cmark$char$$is_ascii_control(c$2)) {
          return _param$6 !== _param$2 && _param$5 === 0 ? { _0: false, _1: _param$2, _2: _param$6 - 1 | 0 } : undefined;
        }
      }
      const _tmp$7 = _param$6 + 1 | 0;
      _tmp$4 = c;
      _tmp$6 = _tmp$7;
      continue;
    }
  }
}
function rami3l$cmark$cmark_base$$link_title$369$(next_line, s, lines, line, start) {
  if (start > line.last) {
    return undefined;
  }
  let char;
  _L: {
    $bound_check(s, start);
    const _bind = s.charCodeAt(start);
    switch (_bind) {
      case 34: {
        char = _bind;
        break _L;
      }
      case 39: {
        char = _bind;
        break _L;
      }
      case 40: {
        const start$2 = start + 1 | 0;
        const acc = [];
        let _tmp = next_line;
        let _tmp$2 = s;
        let _tmp$3 = lines;
        let _tmp$4 = line;
        let _tmp$5 = false;
        let _tmp$6 = start$2;
        let _tmp$7 = start$2;
        while (true) {
          const _param = _tmp;
          const _param$2 = _tmp$2;
          const _param$3 = _tmp$3;
          const _param$4 = _tmp$4;
          const _param$5 = _tmp$5;
          const _param$6 = _tmp$6;
          const _param$7 = _tmp$7;
          if (_param$7 > _param$4.last) {
            const _bind$2 = _param(_param$3);
            if (_bind$2 === undefined) {
              return undefined;
            } else {
              const _Some = _bind$2;
              const _newline = _Some;
              if (_newline.first <= _newline.last) {
                rami3l$cmark$cmark_base$$push_span(_param$4, _param$6, _param$4.last, acc);
                const start$3 = rami3l$cmark$cmark_base$$first_non_blank_in_span(_param$2, _newline);
                _tmp$4 = _newline;
                _tmp$5 = false;
                _tmp$6 = start$3;
                _tmp$7 = start$3;
                continue;
              } else {
                return undefined;
              }
            }
          }
          if (!_param$5) {
            $bound_check(_param$2, _param$7);
            if (_param$2.charCodeAt(_param$7) === 40) {
              return undefined;
            }
            $bound_check(_param$2, _param$7);
            if (_param$2.charCodeAt(_param$7) === 41) {
              rami3l$cmark$cmark_base$$push_span(_param$4, _param$6, _param$7 - 1 | 0, acc);
              return { _0: _param$4, _1: acc, _2: _param$7 };
            }
          }
          let prev_bslash;
          $bound_check(_param$2, _param$7);
          if (_param$2.charCodeAt(_param$7) === 92) {
            prev_bslash = !_param$5;
          } else {
            prev_bslash = false;
          }
          const _tmp$8 = _param$7 + 1 | 0;
          _tmp$5 = prev_bslash;
          _tmp$7 = _tmp$8;
          continue;
        }
      }
      default: {
        return undefined;
      }
    }
  }
  const spans = [];
  return moonbitlang$core$option$$Option$map$61$(rami3l$cmark$cmark_base$$accept_upto$369$(char, next_line, s, lines, line, spans, start), (_param2) => {
    const _span = _param2._0;
    const _last = _param2._1;
    return { _0: _span, _1: spans, _2: _last };
  });
}
function rami3l$cmark$cmark_base$$link_title$355$(next_line, s, lines, line, start) {
  if (start > line.last) {
    return undefined;
  }
  let char;
  _L: {
    $bound_check(s, start);
    const _bind = s.charCodeAt(start);
    switch (_bind) {
      case 34: {
        char = _bind;
        break _L;
      }
      case 39: {
        char = _bind;
        break _L;
      }
      case 40: {
        const start$2 = start + 1 | 0;
        const acc = [];
        let _tmp = next_line;
        let _tmp$2 = s;
        let _tmp$3 = lines;
        let _tmp$4 = line;
        let _tmp$5 = false;
        let _tmp$6 = start$2;
        let _tmp$7 = start$2;
        while (true) {
          const _param = _tmp;
          const _param$2 = _tmp$2;
          const _param$3 = _tmp$3;
          const _param$4 = _tmp$4;
          const _param$5 = _tmp$5;
          const _param$6 = _tmp$6;
          const _param$7 = _tmp$7;
          if (_param$7 > _param$4.last) {
            const _bind$2 = _param(_param$3);
            if (_bind$2 === undefined) {
              return undefined;
            } else {
              const _Some = _bind$2;
              const _newline = _Some;
              if (_newline.first <= _newline.last) {
                rami3l$cmark$cmark_base$$push_span(_param$4, _param$6, _param$4.last, acc);
                const start$3 = rami3l$cmark$cmark_base$$first_non_blank_in_span(_param$2, _newline);
                _tmp$4 = _newline;
                _tmp$5 = false;
                _tmp$6 = start$3;
                _tmp$7 = start$3;
                continue;
              } else {
                return undefined;
              }
            }
          }
          if (!_param$5) {
            $bound_check(_param$2, _param$7);
            if (_param$2.charCodeAt(_param$7) === 40) {
              return undefined;
            }
            $bound_check(_param$2, _param$7);
            if (_param$2.charCodeAt(_param$7) === 41) {
              rami3l$cmark$cmark_base$$push_span(_param$4, _param$6, _param$7 - 1 | 0, acc);
              return { _0: _param$4, _1: acc, _2: _param$7 };
            }
          }
          let prev_bslash;
          $bound_check(_param$2, _param$7);
          if (_param$2.charCodeAt(_param$7) === 92) {
            prev_bslash = !_param$5;
          } else {
            prev_bslash = false;
          }
          const _tmp$8 = _param$7 + 1 | 0;
          _tmp$5 = prev_bslash;
          _tmp$7 = _tmp$8;
          continue;
        }
      }
      default: {
        return undefined;
      }
    }
  }
  const spans = [];
  return moonbitlang$core$option$$Option$map$61$(rami3l$cmark$cmark_base$$accept_upto$355$(char, next_line, s, lines, line, spans, start), (_param2) => {
    const _span = _param2._0;
    const _last = _param2._1;
    return { _0: _span, _1: spans, _2: _last };
  });
}
function rami3l$cmark$cmark_base$$Meta$new(loc) {
  const _bind = rami3l$cmark$cmark_base$$curr_id.val;
  const _bind$2 = undefined;
  const res = { id: _bind, loc: loc, extra: _bind$2 };
  rami3l$cmark$cmark_base$$curr_id.val = rami3l$cmark$cmark_base$$curr_id.val + 1 | 0;
  return res;
}
function rami3l$cmark$cmark_base$$Meta$new$46$loc$46$default() {
  return rami3l$cmark$cmark_base$$text_loc_none;
}
function rami3l$cmark$cmark_base$$Meta$none() {
  return rami3l$cmark$cmark_base$$meta_none;
}
function moonbitlang$core$builtin$$Eq$op_equal$119$(self, other) {
  return self.id === other.id;
}
function rami3l$cmark$cmark_base$$Meta$is_none(self) {
  return moonbitlang$core$builtin$$Eq$op_equal$119$(self, rami3l$cmark$cmark_base$$meta_none);
}
function moonbitlang$core$builtin$$Show$output$119$(self, logger) {
  if (rami3l$cmark$cmark_base$$Meta$is_none(self)) {
    logger.method_0(logger.self, "Meta::none()");
    return;
  } else {
    logger.method_0(logger.self, "Meta::new(id=");
    moonbitlang$core$builtin$$Logger$write_object$7$(logger, self.id);
    logger.method_0(logger.self, ", loc=");
    moonbitlang$core$builtin$$Logger$write_object$152$(logger, self.loc);
    logger.method_0(logger.self, ", dict=");
    moonbitlang$core$builtin$$Logger$write_object$153$(logger, self.extra);
    logger.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$180$(_x_3167, _x_3168) {
  _x_3168.method_0(_x_3168.self, "{");
  _x_3168.method_0(_x_3168.self, "indent: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_3168, _x_3167.indent);
  _x_3168.method_0(_x_3168.self, ", ");
  _x_3168.method_0(_x_3168.self, "angled_dest: ");
  moonbitlang$core$builtin$$Logger$write_object$82$(_x_3168, _x_3167.angled_dest);
  _x_3168.method_0(_x_3168.self, ", ");
  _x_3168.method_0(_x_3168.self, "before_dest: ");
  moonbitlang$core$builtin$$Logger$write_object$88$(_x_3168, _x_3167.before_dest);
  _x_3168.method_0(_x_3168.self, ", ");
  _x_3168.method_0(_x_3168.self, "after_dest: ");
  moonbitlang$core$builtin$$Logger$write_object$88$(_x_3168, _x_3167.after_dest);
  _x_3168.method_0(_x_3168.self, ", ");
  _x_3168.method_0(_x_3168.self, "title_open_delim: ");
  moonbitlang$core$builtin$$Logger$write_object$10$(_x_3168, _x_3167.title_open_delim);
  _x_3168.method_0(_x_3168.self, ", ");
  _x_3168.method_0(_x_3168.self, "after_title: ");
  moonbitlang$core$builtin$$Logger$write_object$88$(_x_3168, _x_3167.after_title);
  _x_3168.method_0(_x_3168.self, "}");
}
function moonbitlang$core$builtin$$Show$output$168$(_x_3145, _x_3146) {
  if (_x_3145 === 0) {
    _x_3146.method_0(_x_3146.self, "Hard");
    return;
  } else {
    _x_3146.method_0(_x_3146.self, "Soft");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$228$(_x_3119, _x_3120) {
  switch (_x_3119) {
    case 0: {
      _x_3120.method_0(_x_3120.self, "Left");
      return;
    }
    case 1: {
      _x_3120.method_0(_x_3120.self, "Center");
      return;
    }
    default: {
      _x_3120.method_0(_x_3120.self, "Right");
      return;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$160$(_x_3098, _x_3099) {
  _x_3099.method_0(_x_3099.self, "HtmlBlock(");
  moonbitlang$core$builtin$$Logger$write_object$88$(_x_3099, _x_3098);
  _x_3099.method_0(_x_3099.self, ")");
}
function moonbitlang$core$builtin$$Show$output$151$(_x_3075, _x_3076) {
  _x_3076.method_0(_x_3076.self, "{");
  _x_3076.method_0(_x_3076.self, "display: ");
  moonbitlang$core$builtin$$Logger$write_object$82$(_x_3076, _x_3075.display);
  _x_3076.method_0(_x_3076.self, ", ");
  _x_3076.method_0(_x_3076.self, "tex_layout: ");
  moonbitlang$core$builtin$$Logger$write_object$83$(_x_3076, _x_3075.tex_layout);
  _x_3076.method_0(_x_3076.self, "}");
}
function moonbitlang$core$builtin$$Show$output$158$(_x_3068, _x_3069) {
  _x_3069.method_0(_x_3069.self, "{");
  _x_3069.method_0(_x_3069.self, "layout: ");
  moonbitlang$core$builtin$$Logger$write_object$85$(_x_3069, _x_3068.layout);
  _x_3069.method_0(_x_3069.self, ", ");
  _x_3069.method_0(_x_3069.self, "info_string: ");
  moonbitlang$core$builtin$$Logger$write_object$86$(_x_3069, _x_3068.info_string);
  _x_3069.method_0(_x_3069.self, ", ");
  _x_3069.method_0(_x_3069.self, "code: ");
  moonbitlang$core$builtin$$Logger$write_object$88$(_x_3069, _x_3068.code);
  _x_3069.method_0(_x_3069.self, "}");
}
function moonbitlang$core$builtin$$Show$output$150$(_x_3056, _x_3057) {
  _x_3057.method_0(_x_3057.self, "InlineStrikethrough(");
  moonbitlang$core$builtin$$Logger$write_object$51$(_x_3057, _x_3056);
  _x_3057.method_0(_x_3057.self, ")");
}
function moonbitlang$core$builtin$$Show$output$161$(_x_3046, _x_3047) {
  _x_3047.method_0(_x_3047.self, "{");
  _x_3047.method_0(_x_3047.self, "layout: ");
  moonbitlang$core$builtin$$Logger$write_object$180$(_x_3047, _x_3046.layout);
  _x_3047.method_0(_x_3047.self, ", ");
  _x_3047.method_0(_x_3047.self, "label: ");
  moonbitlang$core$builtin$$Logger$write_object$91$(_x_3047, _x_3046.label);
  _x_3047.method_0(_x_3047.self, ", ");
  _x_3047.method_0(_x_3047.self, "defined_label: ");
  moonbitlang$core$builtin$$Logger$write_object$91$(_x_3047, _x_3046.defined_label);
  _x_3047.method_0(_x_3047.self, ", ");
  _x_3047.method_0(_x_3047.self, "dest: ");
  moonbitlang$core$builtin$$Logger$write_object$86$(_x_3047, _x_3046.dest);
  _x_3047.method_0(_x_3047.self, ", ");
  _x_3047.method_0(_x_3047.self, "title: ");
  moonbitlang$core$builtin$$Logger$write_object$181$(_x_3047, _x_3046.title);
  _x_3047.method_0(_x_3047.self, "}");
}
function moonbitlang$core$builtin$$Show$output$144$(_x_3031, _x_3032) {
  _x_3032.method_0(_x_3032.self, "{");
  _x_3032.method_0(_x_3032.self, "backticks: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_3032, _x_3031.backticks);
  _x_3032.method_0(_x_3032.self, ", ");
  _x_3032.method_0(_x_3032.self, "code_layout: ");
  moonbitlang$core$builtin$$Logger$write_object$83$(_x_3032, _x_3031.code_layout);
  _x_3032.method_0(_x_3032.self, "}");
}
function moonbitlang$core$builtin$$Show$output$143$(_x_3020, _x_3021) {
  _x_3021.method_0(_x_3021.self, "{");
  _x_3021.method_0(_x_3021.self, "layout_before: ");
  moonbitlang$core$builtin$$Logger$write_object$108$(_x_3021, _x_3020.layout_before);
  _x_3021.method_0(_x_3021.self, ", ");
  _x_3021.method_0(_x_3021.self, "ty: ");
  moonbitlang$core$builtin$$Logger$write_object$168$(_x_3021, _x_3020.ty);
  _x_3021.method_0(_x_3021.self, ", ");
  _x_3021.method_0(_x_3021.self, "layout_after: ");
  moonbitlang$core$builtin$$Logger$write_object$108$(_x_3021, _x_3020.layout_after);
  _x_3021.method_0(_x_3021.self, "}");
}
function moonbitlang$core$builtin$$Show$output$207$(_x_2914, _x_2915) {
  switch (_x_2914.$tag) {
    case 0: {
      const _Header = _x_2914;
      const _$42$arg_2916 = _Header._0;
      _x_2915.method_0(_x_2915.self, "Header(");
      moonbitlang$core$builtin$$Logger$write_object$210$(_x_2915, _$42$arg_2916);
      _x_2915.method_0(_x_2915.self, ")");
      return;
    }
    case 1: {
      const _Sep = _x_2914;
      const _$42$arg_2917 = _Sep._0;
      _x_2915.method_0(_x_2915.self, "Sep(");
      moonbitlang$core$builtin$$Logger$write_object$212$(_x_2915, _$42$arg_2917);
      _x_2915.method_0(_x_2915.self, ")");
      return;
    }
    default: {
      const _Data = _x_2914;
      const _$42$arg_2918 = _Data._0;
      _x_2915.method_0(_x_2915.self, "Data(");
      moonbitlang$core$builtin$$Logger$write_object$210$(_x_2915, _$42$arg_2918);
      _x_2915.method_0(_x_2915.self, ")");
      return;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$155$(_x_2892, _x_2893) {
  _x_2893.method_0(_x_2893.self, "{");
  _x_2893.method_0(_x_2893.self, "indent: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2893, _x_2892.indent);
  _x_2893.method_0(_x_2893.self, ", ");
  _x_2893.method_0(_x_2893.self, "block: ");
  moonbitlang$core$builtin$$Logger$write_object$93$(_x_2893, _x_2892.block);
  _x_2893.method_0(_x_2893.self, "}");
}
function moonbitlang$core$builtin$$Eq$op_equal$231$(_x_2873, _x_2874) {
  switch (_x_2873.$tag) {
    case 0: {
      const _Backticks = _x_2873;
      const _$42$x0_2875 = _Backticks._0;
      if (_x_2874.$tag === 0) {
        const _Backticks$2 = _x_2874;
        const _$42$y0_2876 = _Backticks$2._0;
        return _$42$x0_2875 === _$42$y0_2876;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_2874.$tag === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_2874.$tag === 2) {
        return true;
      } else {
        return false;
      }
    }
    case 3: {
      const _EmphasisMarks = _x_2873;
      const _$42$x0_2877 = _EmphasisMarks._0;
      if (_x_2874.$tag === 3) {
        const _EmphasisMarks$2 = _x_2874;
        const _$42$y0_2878 = _EmphasisMarks$2._0;
        return _$42$x0_2877 === _$42$y0_2878;
      } else {
        return false;
      }
    }
    case 4: {
      if (_x_2874.$tag === 4) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      const _MathSpanMarks = _x_2873;
      const _$42$x0_2879 = _MathSpanMarks._0;
      if (_x_2874.$tag === 5) {
        const _MathSpanMarks$2 = _x_2874;
        const _$42$y0_2880 = _MathSpanMarks$2._0;
        return _$42$x0_2879 === _$42$y0_2880;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Hash$hash_combine$231$(_x_2847, _x_2848) {
  switch (_x_2847.$tag) {
    case 0: {
      const _Backticks = _x_2847;
      const _$42$arg_2849 = _Backticks._0;
      moonbitlang$core$builtin$$Hasher$combine_int(_x_2848, 0);
      moonbitlang$core$builtin$$Hash$hash_combine$7$(_$42$arg_2849, _x_2848);
      return;
    }
    case 1: {
      moonbitlang$core$builtin$$Hasher$combine_int(_x_2848, 1);
      return;
    }
    case 2: {
      moonbitlang$core$builtin$$Hasher$combine_int(_x_2848, 2);
      return;
    }
    case 3: {
      const _EmphasisMarks = _x_2847;
      const _$42$arg_2850 = _EmphasisMarks._0;
      moonbitlang$core$builtin$$Hasher$combine_int(_x_2848, 3);
      moonbitlang$core$builtin$$Hash$hash_combine$10$(_$42$arg_2850, _x_2848);
      return;
    }
    case 4: {
      moonbitlang$core$builtin$$Hasher$combine_int(_x_2848, 4);
      return;
    }
    default: {
      const _MathSpanMarks = _x_2847;
      const _$42$arg_2851 = _MathSpanMarks._0;
      moonbitlang$core$builtin$$Hasher$combine_int(_x_2848, 5);
      moonbitlang$core$builtin$$Hash$hash_combine$7$(_$42$arg_2851, _x_2848);
      return;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$146$(_x_2815, _x_2816) {
  _x_2816.method_0(_x_2816.self, "{");
  _x_2816.method_0(_x_2816.self, "text: ");
  moonbitlang$core$builtin$$Logger$write_object$51$(_x_2816, _x_2815.text);
  _x_2816.method_0(_x_2816.self, ", ");
  _x_2816.method_0(_x_2816.self, "reference: ");
  moonbitlang$core$builtin$$Logger$write_object$169$(_x_2816, _x_2815.reference);
  _x_2816.method_0(_x_2816.self, "}");
}
function moonbitlang$core$builtin$$Show$output$84$(_x_2791, _x_2792) {
  _x_2792.method_0(_x_2792.self, "Seq(");
  moonbitlang$core$builtin$$Logger$write_object$114$(_x_2792, _x_2791);
  _x_2792.method_0(_x_2792.self, ")");
}
function moonbitlang$core$builtin$$Show$output$89$(_x_2791, _x_2792) {
  _x_2792.method_0(_x_2792.self, "Seq(");
  moonbitlang$core$builtin$$Logger$write_object$117$(_x_2792, _x_2791);
  _x_2792.method_0(_x_2792.self, ")");
}
function moonbitlang$core$builtin$$Show$output$148$(_x_2791, _x_2792) {
  _x_2792.method_0(_x_2792.self, "Seq(");
  moonbitlang$core$builtin$$Logger$write_object$170$(_x_2792, _x_2791);
  _x_2792.method_0(_x_2792.self, ")");
}
function moonbitlang$core$builtin$$Show$output$157$(_x_2791, _x_2792) {
  _x_2792.method_0(_x_2792.self, "Seq(");
  moonbitlang$core$builtin$$Logger$write_object$175$(_x_2792, _x_2791);
  _x_2792.method_0(_x_2792.self, ")");
}
function moonbitlang$core$builtin$$Show$output$185$(_x_2791, _x_2792) {
  _x_2792.method_0(_x_2792.self, "Seq(");
  moonbitlang$core$builtin$$Logger$write_object$192$(_x_2792, _x_2791);
  _x_2792.method_0(_x_2792.self, ")");
}
function moonbitlang$core$builtin$$Show$output$187$(_x_2791, _x_2792) {
  _x_2792.method_0(_x_2792.self, "Seq(");
  moonbitlang$core$builtin$$Logger$write_object$194$(_x_2792, _x_2791);
  _x_2792.method_0(_x_2792.self, ")");
}
function moonbitlang$core$builtin$$Show$output$211$(_x_2791, _x_2792) {
  _x_2792.method_0(_x_2792.self, "Seq(");
  moonbitlang$core$builtin$$Logger$write_object$214$(_x_2792, _x_2791);
  _x_2792.method_0(_x_2792.self, ")");
}
function moonbitlang$core$builtin$$Show$output$213$(_x_2791, _x_2792) {
  _x_2792.method_0(_x_2792.self, "Seq(");
  moonbitlang$core$builtin$$Logger$write_object$216$(_x_2792, _x_2791);
  _x_2792.method_0(_x_2792.self, ")");
}
function moonbitlang$core$builtin$$Show$output$202$(_x_2737, _x_2738) {
  _x_2738.method_0(_x_2738.self, "{");
  _x_2738.method_0(_x_2738.self, "before_marker: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2738, _x_2737.before_marker);
  _x_2738.method_0(_x_2738.self, ", ");
  _x_2738.method_0(_x_2738.self, "marker: ");
  moonbitlang$core$builtin$$Logger$write_object$108$(_x_2738, _x_2737.marker);
  _x_2738.method_0(_x_2738.self, ", ");
  _x_2738.method_0(_x_2738.self, "after_marker: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2738, _x_2737.after_marker);
  _x_2738.method_0(_x_2738.self, ", ");
  _x_2738.method_0(_x_2738.self, "block: ");
  moonbitlang$core$builtin$$Logger$write_object$93$(_x_2738, _x_2737.block);
  _x_2738.method_0(_x_2738.self, ", ");
  _x_2738.method_0(_x_2738.self, "ext_task_marker: ");
  moonbitlang$core$builtin$$Logger$write_object$205$(_x_2738, _x_2737.ext_task_marker);
  _x_2738.method_0(_x_2738.self, "}");
}
function moonbitlang$core$builtin$$Show$output$164$(_x_2729, _x_2730) {
  _x_2730.method_0(_x_2730.self, "{");
  _x_2730.method_0(_x_2730.self, "indent: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2730, _x_2729.indent);
  _x_2730.method_0(_x_2730.self, ", ");
  _x_2730.method_0(_x_2730.self, "layout: ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_2730, _x_2729.layout);
  _x_2730.method_0(_x_2730.self, "}");
}
function moonbitlang$core$builtin$$Show$output$116$(_x_2707, _x_2708) {
  _x_2708.method_0(_x_2708.self, "{");
  _x_2708.method_0(_x_2708.self, "indent: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2708, _x_2707.indent);
  _x_2708.method_0(_x_2708.self, ", ");
  _x_2708.method_0(_x_2708.self, "opening_fence: ");
  moonbitlang$core$builtin$$Logger$write_object$108$(_x_2708, _x_2707.opening_fence);
  _x_2708.method_0(_x_2708.self, ", ");
  _x_2708.method_0(_x_2708.self, "closing_fence: ");
  moonbitlang$core$builtin$$Logger$write_object$86$(_x_2708, _x_2707.closing_fence);
  _x_2708.method_0(_x_2708.self, "}");
}
function moonbitlang$core$builtin$$Show$output$163$(_x_2692, _x_2693) {
  _x_2693.method_0(_x_2693.self, "{");
  _x_2693.method_0(_x_2693.self, "leading_indent: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2693, _x_2692.leading_indent);
  _x_2693.method_0(_x_2693.self, ", ");
  _x_2693.method_0(_x_2693.self, "inline: ");
  moonbitlang$core$builtin$$Logger$write_object$51$(_x_2693, _x_2692.inline);
  _x_2693.method_0(_x_2693.self, ", ");
  _x_2693.method_0(_x_2693.self, "trailing_blanks: ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_2693, _x_2692.trailing_blanks);
  _x_2693.method_0(_x_2693.self, "}");
}
function moonbitlang$core$builtin$$Show$output$165$(_x_2685, _x_2686) {
  _x_2686.method_0(_x_2686.self, "{");
  _x_2686.method_0(_x_2686.self, "indent: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2686, _x_2685.indent);
  _x_2686.method_0(_x_2686.self, ", ");
  _x_2686.method_0(_x_2686.self, "col_count: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2686, _x_2685.col_count);
  _x_2686.method_0(_x_2686.self, ", ");
  _x_2686.method_0(_x_2686.self, "rows: ");
  moonbitlang$core$builtin$$Logger$write_object$186$(_x_2686, _x_2685.rows);
  _x_2686.method_0(_x_2686.self, "}");
}
function moonbitlang$core$builtin$$Show$output$85$(_x_2669, _x_2670) {
  if (_x_2669.$tag === 0) {
    _x_2670.method_0(_x_2670.self, "Indented");
    return;
  } else {
    const _Fenced = _x_2669;
    const _$42$arg_2671 = _Fenced._0;
    _x_2670.method_0(_x_2670.self, "Fenced(");
    moonbitlang$core$builtin$$Logger$write_object$116$(_x_2670, _$42$arg_2671);
    _x_2670.method_0(_x_2670.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$159$(_x_2639, _x_2640) {
  _x_2640.method_0(_x_2640.self, "{");
  _x_2640.method_0(_x_2640.self, "layout: ");
  moonbitlang$core$builtin$$Logger$write_object$177$(_x_2640, _x_2639.layout);
  _x_2640.method_0(_x_2640.self, ", ");
  _x_2640.method_0(_x_2640.self, "level: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2640, _x_2639.level);
  _x_2640.method_0(_x_2640.self, ", ");
  _x_2640.method_0(_x_2640.self, "inline: ");
  moonbitlang$core$builtin$$Logger$write_object$51$(_x_2640, _x_2639.inline);
  _x_2640.method_0(_x_2640.self, ", ");
  _x_2640.method_0(_x_2640.self, "id: ");
  moonbitlang$core$builtin$$Logger$write_object$178$(_x_2640, _x_2639.id);
  _x_2640.method_0(_x_2640.self, "}");
}
function moonbitlang$core$builtin$$Show$output$166$(_x_2631, _x_2632) {
  _x_2632.method_0(_x_2632.self, "{");
  _x_2632.method_0(_x_2632.self, "indent: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2632, _x_2631.indent);
  _x_2632.method_0(_x_2632.self, ", ");
  _x_2632.method_0(_x_2632.self, "label: ");
  moonbitlang$core$builtin$$Logger$write_object$90$(_x_2632, _x_2631.label);
  _x_2632.method_0(_x_2632.self, ", ");
  _x_2632.method_0(_x_2632.self, "defined_label: ");
  moonbitlang$core$builtin$$Logger$write_object$91$(_x_2632, _x_2631.defined_label);
  _x_2632.method_0(_x_2632.self, ", ");
  _x_2632.method_0(_x_2632.self, "block: ");
  moonbitlang$core$builtin$$Logger$write_object$93$(_x_2632, _x_2631.block);
  _x_2632.method_0(_x_2632.self, "}");
}
function moonbitlang$core$builtin$$Show$output$162$(_x_2623, _x_2624) {
  _x_2624.method_0(_x_2624.self, "{");
  _x_2624.method_0(_x_2624.self, "ty: ");
  moonbitlang$core$builtin$$Logger$write_object$183$(_x_2624, _x_2623.ty);
  _x_2624.method_0(_x_2624.self, ", ");
  _x_2624.method_0(_x_2624.self, "tight: ");
  moonbitlang$core$builtin$$Logger$write_object$82$(_x_2624, _x_2623.tight);
  _x_2624.method_0(_x_2624.self, ", ");
  _x_2624.method_0(_x_2624.self, "items: ");
  moonbitlang$core$builtin$$Logger$write_object$184$(_x_2624, _x_2623.items);
  _x_2624.method_0(_x_2624.self, "}");
}
function moonbitlang$core$builtin$$Show$output$191$(_x_2605, _x_2606) {
  if (_x_2605.$tag === 0) {
    const _Auto = _x_2605;
    const _$42$arg_2607 = _Auto._0;
    _x_2606.method_0(_x_2606.self, "Auto(");
    moonbitlang$core$builtin$$Logger$write_object$9$(_x_2606, _$42$arg_2607);
    _x_2606.method_0(_x_2606.self, ")");
    return;
  } else {
    const _Id = _x_2605;
    const _$42$arg_2608 = _Id._0;
    _x_2606.method_0(_x_2606.self, "Id(");
    moonbitlang$core$builtin$$Logger$write_object$9$(_x_2606, _$42$arg_2608);
    _x_2606.method_0(_x_2606.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$51$(_x_2496, _x_2497) {
  switch (_x_2496.$tag) {
    case 0: {
      const _Autolink = _x_2496;
      const _$42$arg_2498 = _Autolink._0;
      _x_2497.method_0(_x_2497.self, "Autolink(");
      moonbitlang$core$builtin$$Logger$write_object$94$(_x_2497, _$42$arg_2498);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    case 1: {
      const _Break = _x_2496;
      const _$42$arg_2499 = _Break._0;
      _x_2497.method_0(_x_2497.self, "Break(");
      moonbitlang$core$builtin$$Logger$write_object$96$(_x_2497, _$42$arg_2499);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    case 2: {
      const _CodeSpan = _x_2496;
      const _$42$arg_2500 = _CodeSpan._0;
      _x_2497.method_0(_x_2497.self, "CodeSpan(");
      moonbitlang$core$builtin$$Logger$write_object$98$(_x_2497, _$42$arg_2500);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    case 3: {
      const _Emphasis = _x_2496;
      const _$42$arg_2501 = _Emphasis._0;
      _x_2497.method_0(_x_2497.self, "Emphasis(");
      moonbitlang$core$builtin$$Logger$write_object$100$(_x_2497, _$42$arg_2501);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    case 4: {
      const _Image = _x_2496;
      const _$42$arg_2502 = _Image._0;
      _x_2497.method_0(_x_2497.self, "Image(");
      moonbitlang$core$builtin$$Logger$write_object$102$(_x_2497, _$42$arg_2502);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    case 5: {
      const _Inlines = _x_2496;
      const _$42$arg_2503 = _Inlines._0;
      _x_2497.method_0(_x_2497.self, "Inlines(");
      moonbitlang$core$builtin$$Logger$write_object$104$(_x_2497, _$42$arg_2503);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    case 6: {
      const _Link = _x_2496;
      const _$42$arg_2504 = _Link._0;
      _x_2497.method_0(_x_2497.self, "Link(");
      moonbitlang$core$builtin$$Logger$write_object$102$(_x_2497, _$42$arg_2504);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    case 7: {
      const _RawHtml = _x_2496;
      const _$42$arg_2505 = _RawHtml._0;
      _x_2497.method_0(_x_2497.self, "RawHtml(");
      moonbitlang$core$builtin$$Logger$write_object$106$(_x_2497, _$42$arg_2505);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    case 8: {
      const _StrongEmphasis = _x_2496;
      const _$42$arg_2506 = _StrongEmphasis._0;
      _x_2497.method_0(_x_2497.self, "StrongEmphasis(");
      moonbitlang$core$builtin$$Logger$write_object$100$(_x_2497, _$42$arg_2506);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    case 9: {
      const _Text = _x_2496;
      const _$42$arg_2507 = _Text._0;
      _x_2497.method_0(_x_2497.self, "Text(");
      moonbitlang$core$builtin$$Logger$write_object$108$(_x_2497, _$42$arg_2507);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    case 10: {
      const _ExtStrikethrough = _x_2496;
      const _$42$arg_2508 = _ExtStrikethrough._0;
      _x_2497.method_0(_x_2497.self, "ExtStrikethrough(");
      moonbitlang$core$builtin$$Logger$write_object$110$(_x_2497, _$42$arg_2508);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
    default: {
      const _ExtMathSpan = _x_2496;
      const _$42$arg_2509 = _ExtMathSpan._0;
      _x_2497.method_0(_x_2497.self, "ExtMathSpan(");
      moonbitlang$core$builtin$$Logger$write_object$112$(_x_2497, _$42$arg_2509);
      _x_2497.method_0(_x_2497.self, ")");
      return;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$145$(_x_2450, _x_2451) {
  _x_2451.method_0(_x_2451.self, "{");
  _x_2451.method_0(_x_2451.self, "delim: ");
  moonbitlang$core$builtin$$Logger$write_object$10$(_x_2451, _x_2450.delim);
  _x_2451.method_0(_x_2451.self, ", ");
  _x_2451.method_0(_x_2451.self, "inline: ");
  moonbitlang$core$builtin$$Logger$write_object$51$(_x_2451, _x_2450.inline);
  _x_2451.method_0(_x_2451.self, "}");
}
function moonbitlang$core$builtin$$Show$output$326$(_x_2346, _x_2347) {
  const _FolderError = _x_2346;
  const _$42$err_payload_2348 = _FolderError._0;
  _x_2347.method_0(_x_2347.self, "FolderError(");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_2347, _$42$err_payload_2348);
  _x_2347.method_0(_x_2347.self, ")");
}
function moonbitlang$core$builtin$$Show$output$149$(_x_2313, _x_2314) {
  _x_2314.method_0(_x_2314.self, "InlineRawHtml(");
  moonbitlang$core$builtin$$Logger$write_object$83$(_x_2314, _x_2313);
  _x_2314.method_0(_x_2314.self, ")");
}
function moonbitlang$core$builtin$$Show$output$169$(_x_2279, _x_2280) {
  if (_x_2279.$tag === 0) {
    const _Inline = _x_2279;
    const _$42$arg_2281 = _Inline._0;
    _x_2280.method_0(_x_2280.self, "Inline(");
    moonbitlang$core$builtin$$Logger$write_object$130$(_x_2280, _$42$arg_2281);
    _x_2280.method_0(_x_2280.self, ")");
    return;
  } else {
    const _Ref = _x_2279;
    const _$42$arg_2282 = _Ref._0;
    const _$42$arg_2283 = _Ref._1;
    const _$42$arg_2284 = _Ref._2;
    _x_2280.method_0(_x_2280.self, "Ref(");
    moonbitlang$core$builtin$$Logger$write_object$188$(_x_2280, _$42$arg_2282);
    _x_2280.method_0(_x_2280.self, ", ");
    moonbitlang$core$builtin$$Logger$write_object$90$(_x_2280, _$42$arg_2283);
    _x_2280.method_0(_x_2280.self, ", ");
    moonbitlang$core$builtin$$Logger$write_object$90$(_x_2280, _$42$arg_2284);
    _x_2280.method_0(_x_2280.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$142$(_x_2259, _x_2260) {
  _x_2260.method_0(_x_2260.self, "{");
  _x_2260.method_0(_x_2260.self, "is_email: ");
  moonbitlang$core$builtin$$Logger$write_object$82$(_x_2260, _x_2259.is_email);
  _x_2260.method_0(_x_2260.self, ", ");
  _x_2260.method_0(_x_2260.self, "link: ");
  moonbitlang$core$builtin$$Logger$write_object$108$(_x_2260, _x_2259.link);
  _x_2260.method_0(_x_2260.self, "}");
}
function moonbitlang$core$builtin$$Show$output$90$(_x_2252, _x_2253) {
  _x_2253.method_0(_x_2253.self, "{");
  _x_2253.method_0(_x_2253.self, "meta: ");
  moonbitlang$core$builtin$$Logger$write_object$119$(_x_2253, _x_2252.meta);
  _x_2253.method_0(_x_2253.self, ", ");
  _x_2253.method_0(_x_2253.self, "key: ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_2253, _x_2252.key);
  _x_2253.method_0(_x_2253.self, ", ");
  _x_2253.method_0(_x_2253.self, "text: ");
  moonbitlang$core$builtin$$Logger$write_object$83$(_x_2253, _x_2252.text);
  _x_2253.method_0(_x_2253.self, "}");
}
function moonbitlang$core$builtin$$Show$output$189$(_x_2231, _x_2232) {
  _x_2232.method_0(_x_2232.self, "{");
  _x_2232.method_0(_x_2232.self, "indent: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2232, _x_2231.indent);
  _x_2232.method_0(_x_2232.self, ", ");
  _x_2232.method_0(_x_2232.self, "after_opening: ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_2232, _x_2231.after_opening);
  _x_2232.method_0(_x_2232.self, ", ");
  _x_2232.method_0(_x_2232.self, "closing: ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_2232, _x_2231.closing);
  _x_2232.method_0(_x_2232.self, "}");
}
function moonbitlang$core$builtin$$Show$output$188$(_x_2200, _x_2201) {
  switch (_x_2200) {
    case 0: {
      _x_2201.method_0(_x_2201.self, "Collapsed");
      return;
    }
    case 1: {
      _x_2201.method_0(_x_2201.self, "Full");
      return;
    }
    default: {
      _x_2201.method_0(_x_2201.self, "Shortcut");
      return;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$190$(_x_2172, _x_2173) {
  _x_2173.method_0(_x_2173.self, "{");
  _x_2173.method_0(_x_2173.self, "leading_indent: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2173, _x_2172.leading_indent);
  _x_2173.method_0(_x_2173.self, ", ");
  _x_2173.method_0(_x_2173.self, "trailing_blanks: ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_2173, _x_2172.trailing_blanks);
  _x_2173.method_0(_x_2173.self, ", ");
  _x_2173.method_0(_x_2173.self, "underline_indent: ");
  moonbitlang$core$builtin$$Logger$write_object$7$(_x_2173, _x_2172.underline_indent);
  _x_2173.method_0(_x_2173.self, ", ");
  _x_2173.method_0(_x_2173.self, "underline_count: ");
  moonbitlang$core$builtin$$Logger$write_object$196$(_x_2173, _x_2172.underline_count);
  _x_2173.method_0(_x_2173.self, ", ");
  _x_2173.method_0(_x_2173.self, "underline_blanks: ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_2173, _x_2172.underline_blanks);
  _x_2173.method_0(_x_2173.self, "}");
}
function moonbitlang$core$builtin$$Show$output$93$(_x_2139, _x_2140) {
  switch (_x_2139.$tag) {
    case 0: {
      const _BlankLine = _x_2139;
      const _$42$arg_2141 = _BlankLine._0;
      _x_2140.method_0(_x_2140.self, "BlankLine(");
      moonbitlang$core$builtin$$Logger$write_object$108$(_x_2140, _$42$arg_2141);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 1: {
      const _BlockQuote = _x_2139;
      const _$42$arg_2142 = _BlockQuote._0;
      _x_2140.method_0(_x_2140.self, "BlockQuote(");
      moonbitlang$core$builtin$$Logger$write_object$120$(_x_2140, _$42$arg_2142);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 2: {
      const _Blocks = _x_2139;
      const _$42$arg_2143 = _Blocks._0;
      _x_2140.method_0(_x_2140.self, "Blocks(");
      moonbitlang$core$builtin$$Logger$write_object$122$(_x_2140, _$42$arg_2143);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 3: {
      const _CodeBlock = _x_2139;
      const _$42$arg_2144 = _CodeBlock._0;
      _x_2140.method_0(_x_2140.self, "CodeBlock(");
      moonbitlang$core$builtin$$Logger$write_object$124$(_x_2140, _$42$arg_2144);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 4: {
      const _Heading = _x_2139;
      const _$42$arg_2145 = _Heading._0;
      _x_2140.method_0(_x_2140.self, "Heading(");
      moonbitlang$core$builtin$$Logger$write_object$126$(_x_2140, _$42$arg_2145);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 5: {
      const _HtmlBlock = _x_2139;
      const _$42$arg_2146 = _HtmlBlock._0;
      _x_2140.method_0(_x_2140.self, "HtmlBlock(");
      moonbitlang$core$builtin$$Logger$write_object$128$(_x_2140, _$42$arg_2146);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 6: {
      const _LinkRefDefinition = _x_2139;
      const _$42$arg_2147 = _LinkRefDefinition._0;
      _x_2140.method_0(_x_2140.self, "LinkRefDefinition(");
      moonbitlang$core$builtin$$Logger$write_object$130$(_x_2140, _$42$arg_2147);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 7: {
      const _List = _x_2139;
      const _$42$arg_2148 = _List._0;
      _x_2140.method_0(_x_2140.self, "List(");
      moonbitlang$core$builtin$$Logger$write_object$132$(_x_2140, _$42$arg_2148);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 8: {
      const _Paragraph = _x_2139;
      const _$42$arg_2149 = _Paragraph._0;
      _x_2140.method_0(_x_2140.self, "Paragraph(");
      moonbitlang$core$builtin$$Logger$write_object$134$(_x_2140, _$42$arg_2149);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 9: {
      const _ThematicBreak = _x_2139;
      const _$42$arg_2150 = _ThematicBreak._0;
      _x_2140.method_0(_x_2140.self, "ThematicBreak(");
      moonbitlang$core$builtin$$Logger$write_object$136$(_x_2140, _$42$arg_2150);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 10: {
      const _ExtMathBlock = _x_2139;
      const _$42$arg_2151 = _ExtMathBlock._0;
      _x_2140.method_0(_x_2140.self, "ExtMathBlock(");
      moonbitlang$core$builtin$$Logger$write_object$124$(_x_2140, _$42$arg_2151);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    case 11: {
      const _ExtTable = _x_2139;
      const _$42$arg_2152 = _ExtTable._0;
      _x_2140.method_0(_x_2140.self, "ExtTable(");
      moonbitlang$core$builtin$$Logger$write_object$138$(_x_2140, _$42$arg_2152);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
    default: {
      const _ExtFootnoteDefinition = _x_2139;
      const _$42$arg_2153 = _ExtFootnoteDefinition._0;
      _x_2140.method_0(_x_2140.self, "ExtFootnoteDefinition(");
      moonbitlang$core$builtin$$Logger$write_object$140$(_x_2140, _$42$arg_2153);
      _x_2140.method_0(_x_2140.self, ")");
      return;
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$235$(_x_2058, _x_2059) {
  switch (_x_2058) {
    case 0: {
      if (_x_2059 === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_2059 === 1) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_2059 === 2) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Show$output$177$(_x_2034, _x_2035) {
  if (_x_2034.$tag === 0) {
    const _Atx = _x_2034;
    const _$42$arg_2036 = _Atx._0;
    _x_2035.method_0(_x_2035.self, "Atx(");
    moonbitlang$core$builtin$$Logger$write_object$189$(_x_2035, _$42$arg_2036);
    _x_2035.method_0(_x_2035.self, ")");
    return;
  } else {
    const _Setext = _x_2034;
    const _$42$arg_2037 = _Setext._0;
    _x_2035.method_0(_x_2035.self, "Setext(");
    moonbitlang$core$builtin$$Logger$write_object$190$(_x_2035, _$42$arg_2037);
    _x_2035.method_0(_x_2035.self, ")");
    return;
  }
}
function rami3l$cmark$cmark$$Block$empty() {
  return new $64$rami3l$47$cmark$47$cmark$46$Block$Blocks({ v: [], meta: rami3l$cmark$cmark_base$$Meta$none() });
}
function rami3l$cmark$cmark$$Block$meta(self) {
  switch (self.$tag) {
    case 0: {
      const _BlankLine = self;
      const _bl = _BlankLine._0;
      return _bl.meta;
    }
    case 1: {
      const _BlockQuote = self;
      const _bl$2 = _BlockQuote._0;
      return _bl$2.meta;
    }
    case 2: {
      const _Blocks = self;
      const _bl$3 = _Blocks._0;
      return _bl$3.meta;
    }
    case 3: {
      const _CodeBlock = self;
      const _bl$4 = _CodeBlock._0;
      return _bl$4.meta;
    }
    case 4: {
      const _Heading = self;
      const _bl$5 = _Heading._0;
      return _bl$5.meta;
    }
    case 5: {
      const _HtmlBlock = self;
      const _bl$6 = _HtmlBlock._0;
      return _bl$6.meta;
    }
    case 6: {
      const _LinkRefDefinition = self;
      const _bl$7 = _LinkRefDefinition._0;
      return _bl$7.meta;
    }
    case 7: {
      const _List = self;
      const _bl$8 = _List._0;
      return _bl$8.meta;
    }
    case 8: {
      const _Paragraph = self;
      const _bl$9 = _Paragraph._0;
      return _bl$9.meta;
    }
    case 9: {
      const _ThematicBreak = self;
      const _bl$10 = _ThematicBreak._0;
      return _bl$10.meta;
    }
    case 12: {
      const _ExtFootnoteDefinition = self;
      const _bl$11 = _ExtFootnoteDefinition._0;
      return _bl$11.meta;
    }
    case 11: {
      const _ExtTable = self;
      const _bl$12 = _ExtTable._0;
      return _bl$12.meta;
    }
    default: {
      const _ExtMathBlock = self;
      const _bl$13 = _ExtMathBlock._0;
      return _bl$13.meta;
    }
  }
}
function rami3l$cmark$cmark$$Seq$map$371$(self, f) {
  const _p = new Array(self.length);
  const _p$2 = self.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = self[_p$3];
      _p[_p$3] = f(_p$4);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return _p;
}
function rami3l$cmark$cmark$$Seq$map$372$(self, f) {
  const _p = new Array(self.length);
  const _p$2 = self.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = self[_p$3];
      _p[_p$3] = f(_p$4);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return _p;
}
function rami3l$cmark$cmark$$Seq$map$373$(self, f) {
  const _p = new Array(self.length);
  const _p$2 = self.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = self[_p$3];
      _p[_p$3] = f(_p$4);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return _p;
}
function rami3l$cmark$cmark$$Seq$map$374$(self, f) {
  const _p = new Array(self.length);
  const _p$2 = self.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = self[_p$3];
      _p[_p$3] = f(_p$4);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return _p;
}
function rami3l$cmark$cmark$$Seq$map$375$(self, f) {
  const _p = new Array(self.length);
  const _p$2 = self.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = self[_p$3];
      _p[_p$3] = f(_p$4);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return _p;
}
function rami3l$cmark$cmark$$layout_of_string(meta, s) {
  return { v: s, meta: meta };
}
function rami3l$cmark$cmark$$layout_of_string$46$meta$46$default() {
  return rami3l$cmark$cmark_base$$Meta$none();
}
function rami3l$cmark$cmark$$Seq$iter$108$(self) {
  return moonbitlang$core$array$$Array$iter$108$(self);
}
function rami3l$cmark$cmark$$Seq$iter$220$(self) {
  return moonbitlang$core$array$$Array$iter$220$(self);
}
function rami3l$cmark$cmark$$Seq$iter$93$(self) {
  return moonbitlang$core$array$$Array$iter$93$(self);
}
function rami3l$cmark$cmark$$Seq$iter$198$(self) {
  return moonbitlang$core$array$$Array$iter$198$(self);
}
function rami3l$cmark$cmark$$Seq$iter$200$(self) {
  return moonbitlang$core$array$$Array$iter$200$(self);
}
function rami3l$cmark$cmark$$Seq$iter$218$(self) {
  return moonbitlang$core$array$$Array$iter$218$(self);
}
function rami3l$cmark$cmark$$Seq$iter$51$(self) {
  return moonbitlang$core$array$$Array$iter$51$(self);
}
function rami3l$cmark$cmark$$Seq$iter$167$(self) {
  return moonbitlang$core$array$$Array$iter$167$(self);
}
function rami3l$cmark$cmark$$CodeBlock$language_of_info_string(s) {
  if (!moonbitlang$core$string$$String$is_empty(s)) {
    const max = s.length - 1 | 0;
    let white;
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      let _tmp$2;
      if (i > max) {
        _tmp$2 = true;
      } else {
        $bound_check(s, i);
        _tmp$2 = rami3l$cmark$char$$is_ascii_whitespace(s.charCodeAt(i));
      }
      if (_tmp$2) {
        white = i;
        break;
      }
      _tmp = i + 1 | 0;
      continue;
    }
    const rem_first = rami3l$cmark$cmark_base$$first_non_blank(s, max, white);
    const lang = moonbitlang$core$string$$String$substring(s, 0, white);
    return !moonbitlang$core$string$$String$is_empty(lang) ? { _0: lang, _1: moonbitlang$core$string$$String$substring(s, rem_first, max + 1 | 0) } : undefined;
  } else {
    return undefined;
  }
}
function rami3l$cmark$cmark$$CodeBlock$is_math_block(s) {
  if (s === undefined) {
    return false;
  } else {
    const _Some = s;
    const _s = _Some;
    return moonbitlang$core$builtin$$Eq$op_equal$263$(moonbitlang$core$option$$Option$map$60$(rami3l$cmark$cmark$$CodeBlock$language_of_info_string(_s), (i) => i._0), "math");
  }
}
function rami3l$cmark$cmark$$Node$new$166$(v, meta) {
  return { v: v, meta: meta };
}
function rami3l$cmark$cmark$$Node$new$46$meta$46$default$166$() {
  return rami3l$cmark$cmark_base$$Meta$none();
}
function rami3l$cmark$cmark$$Label$stub(label, defined_label) {
  return new $64$rami3l$47$cmark$47$cmark$46$LabelDef$FootnoteDef(rami3l$cmark$cmark$$Node$new$166$({ indent: 0, label: label, defined_label: defined_label, block: rami3l$cmark$cmark$$Block$empty() }, rami3l$cmark$cmark$$Node$new$46$meta$46$default$166$()));
}
function rami3l$cmark$cmark$$Seq$length$240$(self) {
  return self.length;
}
function rami3l$cmark$cmark$$Table$parse_sep_row(cs) {
  let _tmp = [];
  let _tmp$2 = cs;
  _L: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    _L$2: {
      if (_param$2.len === 0) {
        return new Option$Some$75$(_param);
      } else {
        const _x = _param$2.buf[_param$2.start];
        const _x$2 = _x._0;
        if (_x$2.$tag === 9) {
          const _Text = _x$2;
          const _x$3 = _Text._0;
          const _v = _x$3.v;
          const _meta = _x$3.meta;
          const _x$4 = _x._1;
          const _x$5 = _x$4._0;
          if (_x$5 === "") {
            const _x$6 = _x$4._1;
            if (_x$6 === "") {
              const _tmp$3 = _param$2.buf;
              const _tmp$4 = 1 + _param$2.start | 0;
              const _some = _param$2.len;
              const _x$7 = { buf: _tmp$3, start: _tmp$4, len: _some - 1 | 0 };
              if (!moonbitlang$core$string$$String$is_empty(_v)) {
                const max = _v.length - 1 | 0;
                $bound_check(_v, 0);
                const first_colon = _v.charCodeAt(0) === 58;
                $bound_check(_v, max);
                const last_colon = _v.charCodeAt(max) === 58;
                const first = first_colon ? 1 : 0;
                const last = last_colon ? max - 1 | 0 : max;
                let _tmp$5 = first;
                while (true) {
                  const i = _tmp$5;
                  if (i <= last) {
                    $bound_check(_v, i);
                    if (_v.charCodeAt(i) === 45) {
                    } else {
                      return Option$None$75$;
                    }
                    _tmp$5 = i + 1 | 0;
                    continue;
                  } else {
                    const count = (last - first | 0) + 1 | 0;
                    let sep;
                    if (first_colon === false) {
                      if (last_colon === false) {
                        sep = undefined;
                      } else {
                        sep = 2;
                      }
                    } else {
                      if (last_colon === true) {
                        sep = 1;
                      } else {
                        sep = 0;
                      }
                    }
                    moonbitlang$core$array$$Array$push$220$(_param, { v: { _0: sep, _1: count }, meta: _meta });
                    _tmp = _param;
                    _tmp$2 = _x$7;
                    continue _L;
                  }
                }
              } else {
                return Option$None$75$;
              }
            } else {
              break _L$2;
            }
          } else {
            break _L$2;
          }
        } else {
          break _L$2;
        }
      }
    }
    return Option$None$75$;
  }
}
function rami3l$cmark$cmark$$Token$start(self) {
  switch (self.$tag) {
    case 0: {
      const _AutolinkOrHtmlStart = self;
      const _t = _AutolinkOrHtmlStart._0;
      return _t.start;
    }
    case 1: {
      const _Backticks = self;
      const _t$2 = _Backticks._0;
      return _t$2.start;
    }
    case 2: {
      const _EmphasisMarks = self;
      const _t$3 = _EmphasisMarks._0;
      return _t$3.start;
    }
    case 3: {
      const _Inline = self;
      const _t$4 = _Inline._0;
      return _t$4.start;
    }
    case 4: {
      const _LinkStart = self;
      const _t$5 = _LinkStart._0;
      return _t$5.start;
    }
    case 5: {
      const _Newline = self;
      const _t$6 = _Newline._0;
      return _t$6.start;
    }
    case 6: {
      const _RightBrack = self;
      const _t$7 = _RightBrack._0;
      return _t$7.start;
    }
    case 7: {
      const _RightParen = self;
      const _t$8 = _RightParen._0;
      return _t$8.start;
    }
    case 8: {
      const _StrikethroughMarks = self;
      const _t$9 = _StrikethroughMarks._0;
      return _t$9.start;
    }
    default: {
      const _MathSpanMarks = self;
      const _t$10 = _MathSpanMarks._0;
      return _t$10.start;
    }
  }
}
function rami3l$cmark$cmark$$CloserIndex$pos(self, key, after) {
  return moonbitlang$core$option$$Option$bind$65$(moonbitlang$core$builtin$$Map$op_get$309$(self, key), (s) => moonbitlang$core$builtin$$Iter$find_first$7$(moonbitlang$core$set$$Set$iter$7$(s), (pos) => pos > after));
}
function rami3l$cmark$cmark$$CloserIndex$exists(self, key, after) {
  return !moonbitlang$core$option$$Option$is_empty$7$(rami3l$cmark$cmark$$CloserIndex$pos(self, key, after));
}
function rami3l$cmark$cmark$$CloserIndex$has_backticks(self, count, after) {
  return rami3l$cmark$cmark$$CloserIndex$exists(self, new $64$rami3l$47$cmark$47$cmark$46$Closer$Backticks(count), after);
}
function rami3l$cmark$cmark$$CloserIndex$has_right_brack(self, after) {
  return rami3l$cmark$cmark$$CloserIndex$exists(self, $64$rami3l$47$cmark$47$cmark$46$Closer$RightBrack, after);
}
function rami3l$cmark$cmark$$CloserIndex$has_right_paren(self, after) {
  return rami3l$cmark$cmark$$CloserIndex$exists(self, $64$rami3l$47$cmark$47$cmark$46$Closer$RightParen, after);
}
function rami3l$cmark$cmark$$CloserIndex$emphasis_pos(self, char, after) {
  return rami3l$cmark$cmark$$CloserIndex$pos(self, new $64$rami3l$47$cmark$47$cmark$46$Closer$EmphasisMarks(char), after);
}
function rami3l$cmark$cmark$$CloserIndex$has_emphasis(self, char, after) {
  return rami3l$cmark$cmark$$CloserIndex$exists(self, new $64$rami3l$47$cmark$47$cmark$46$Closer$EmphasisMarks(char), after);
}
function rami3l$cmark$cmark$$CloserIndex$has_strikethrough(self, after) {
  return rami3l$cmark$cmark$$CloserIndex$exists(self, $64$rami3l$47$cmark$47$cmark$46$Closer$StrikethroughMarks, after);
}
function rami3l$cmark$cmark$$CloserIndex$has_math_span(self, count, after) {
  return rami3l$cmark$cmark$$CloserIndex$exists(self, new $64$rami3l$47$cmark$47$cmark$46$Closer$MathSpanMarks(count), after);
}
function rami3l$cmark$cmark$$CloserIndex$add(self, key, pos) {
  const _bind = moonbitlang$core$builtin$$Map$op_get$309$(self, key);
  let _tmp;
  if (_bind === undefined) {
    const ps = moonbitlang$core$set$$Set$new$7$(moonbitlang$core$set$$Set$new$46$capacity$46$default$7$());
    moonbitlang$core$builtin$$Map$op_set$309$(self, key, ps);
    _tmp = ps;
  } else {
    const _Some = _bind;
    const _ps = _Some;
    _tmp = _ps;
  }
  moonbitlang$core$set$$Set$add$7$(_tmp, pos);
}
function rami3l$cmark$cmark$$CloserIndex$new() {
  return moonbitlang$core$builtin$$Map$new$309$(moonbitlang$core$builtin$$Map$new$46$capacity$46$default$309$());
}
function rami3l$cmark$cmark$$make_closer_index(toks) {
  const cidx = rami3l$cmark$cmark$$CloserIndex$new();
  if (!moonbitlang$core$deque$$T$is_empty$289$(toks)) {
    moonbitlang$core$deque$$T$retain$289$(toks, (curr) => {
      switch (curr.$tag) {
        case 1: {
          const _Backticks = curr;
          const _x = _Backticks._0;
          const _count = _x.count;
          const _start = _x.start;
          rami3l$cmark$cmark$$CloserIndex$add(cidx, new $64$rami3l$47$cmark$47$cmark$46$Closer$Backticks(_count), _start);
          break;
        }
        case 6: {
          const _RightBrack = curr;
          const _x$2 = _RightBrack._0;
          const _start$2 = _x$2.start;
          rami3l$cmark$cmark$$CloserIndex$add(cidx, $64$rami3l$47$cmark$47$cmark$46$Closer$RightBrack, _start$2);
          break;
        }
        case 7: {
          const _RightParen = curr;
          const _x$3 = _RightParen._0;
          const _start$3 = _x$3.start;
          rami3l$cmark$cmark$$CloserIndex$add(cidx, $64$rami3l$47$cmark$47$cmark$46$Closer$RightParen, _start$3);
          return false;
        }
        case 2: {
          const _EmphasisMarks = curr;
          const _x$4 = _EmphasisMarks._0;
          const _char = _x$4.char;
          const _start$4 = _x$4.start;
          const _x$5 = _x$4.may_close;
          if (_x$5 === true) {
            rami3l$cmark$cmark$$CloserIndex$add(cidx, new $64$rami3l$47$cmark$47$cmark$46$Closer$EmphasisMarks(_char), _start$4);
          }
          break;
        }
        case 8: {
          const _StrikethroughMarks = curr;
          const _x$6 = _StrikethroughMarks._0;
          const _start$5 = _x$6.start;
          const _x$7 = _x$6.may_close;
          if (_x$7 === true) {
            rami3l$cmark$cmark$$CloserIndex$add(cidx, $64$rami3l$47$cmark$47$cmark$46$Closer$StrikethroughMarks, _start$5);
          }
          break;
        }
        case 9: {
          const _MathSpanMarks = curr;
          const _x$8 = _MathSpanMarks._0;
          const _count$2 = _x$8.count;
          const _start$6 = _x$8.start;
          const _x$9 = _x$8.may_close;
          if (_x$9 === true) {
            rami3l$cmark$cmark$$CloserIndex$add(cidx, new $64$rami3l$47$cmark$47$cmark$46$Closer$MathSpanMarks(_count$2), _start$6);
          }
          break;
        }
      }
      return true;
    });
    return cidx;
  } else {
    return cidx;
  }
}
function rami3l$cmark$cmark$$tokens_shorten_last_line(to_last, toks) {
  let _tmp = moonbitlang$core$deque$$T$length$289$(toks) - 1 | 0;
  _L: while (true) {
    const i = _tmp;
    if (i >= 0) {
      const _bind = moonbitlang$core$deque$$T$op_get$289$(toks, i);
      switch (_bind.$tag) {
        case 5: {
          const _Newline = _bind;
          const _x = _Newline._0;
          const _newline = _x.newline;
          moonbitlang$core$deque$$T$op_set$289$(toks, i, new $64$rami3l$47$cmark$47$cmark$46$Token$Newline({ start: _x.start, break_ty: _x.break_ty, newline: { pos: _newline.pos, first: _newline.first, last: to_last } }));
          break _L;
        }
        case 3: {
          const _Inline = _bind;
          const _x$2 = _Inline._0;
          const _endline = _x$2.endline;
          moonbitlang$core$deque$$T$op_set$289$(toks, i, new $64$rami3l$47$cmark$47$cmark$46$Token$Inline({ start: _x$2.start, inline: _x$2.inline, endline: { pos: _endline.pos, first: _endline.first, last: to_last }, next: _x$2.next }));
          break _L;
        }
      }
      _tmp = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function rami3l$cmark$cmark$$RevTokens$pop(self) {
  return moonbitlang$core$deque$$T$pop_front$289$(self);
}
function rami3l$cmark$cmark$$tokens_drop_stop_after_right_brack(rev_toks) {
  while (true) {
    _L: {
      _L$2: {
        const _bind = rami3l$cmark$cmark$$RevTokens$pop(rev_toks);
        if (_bind === undefined) {
          break _L$2;
        } else {
          const _Some = _bind;
          const _x = _Some;
          if (_x.$tag === 6) {
            break _L$2;
          } else {
            break _L;
          }
        }
      }
      break;
    }
    continue;
  }
}
function rami3l$cmark$cmark$$RevTokens$push(self, t) {
  moonbitlang$core$deque$$T$push_front$289$(self, t);
}
function rami3l$cmark$cmark$$tokens_pop_until(start, rev_toks) {
  while (true) {
    _L: {
      const _bind = rami3l$cmark$cmark$$RevTokens$pop(rev_toks);
      if (_bind === undefined) {
        break;
      } else {
        const _Some = _bind;
        const _t = _Some;
        if (rami3l$cmark$cmark$$Token$start(_t) < start) {
          break _L;
        }
        rami3l$cmark$cmark$$RevTokens$push(rev_toks, _t);
        break;
      }
    }
    continue;
  }
}
function rami3l$cmark$cmark$$tokens_next_line(rev_toks) {
  const acc = [];
  while (true) {
    const _bind = rami3l$cmark$cmark$$RevTokens$pop(rev_toks);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _t = _Some;
      if (_t.$tag === 5) {
        const _Newline = _t;
        const _x = _Newline._0;
        const _newline = _x.newline;
        return _newline;
      }
      moonbitlang$core$array$$Array$push$289$(acc, _t);
      continue;
    }
  }
  while (true) {
    const _bind = moonbitlang$core$array$$Array$pop$289$(acc);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _t = _Some;
      rami3l$cmark$cmark$$RevTokens$push(rev_toks, _t);
      continue;
    }
  }
  return undefined;
}
function rami3l$cmark$cmark$$Token$newline(s, prev_line, newline) {
  const _first = prev_line.first;
  const _last = prev_line.last;
  const non_space = rami3l$cmark$cmark_base$$rev_drop_spaces(s, _first, _last);
  let start;
  let break_ty;
  _L: {
    let _tmp;
    if (non_space === _last) {
      $bound_check(s, non_space);
      _tmp = s.charCodeAt(non_space) === 92;
    } else {
      _tmp = false;
    }
    if (_tmp) {
      start = non_space;
      break_ty = 0;
      break _L;
    } else {
      const start$2 = non_space + 1 | 0;
      const _tmp$2 = ((_last - start$2 | 0) + 1 | 0) >= 2 ? 0 : 1;
      start = start$2;
      break_ty = _tmp$2;
      break _L;
    }
  }
  return new $64$rami3l$47$cmark$47$cmark$46$Token$Newline({ start: start, break_ty: break_ty, newline: newline });
}
function rami3l$cmark$cmark$$Tokens$push(self, t) {
  moonbitlang$core$deque$$T$push_back$289$(self, t);
}
function rami3l$cmark$cmark$$tokens_add_backtick(toks, s, line, prev_bslash, start) {
  const last = rami3l$cmark$cmark_base$$run_of(96, s, line.last, start + 1 | 0);
  const count = (last - start | 0) + 1 | 0;
  rami3l$cmark$cmark$$Tokens$push(toks, new $64$rami3l$47$cmark$47$cmark$46$Token$Backticks({ start: start, count: count, escaped: prev_bslash }));
  return last + 1 | 0;
}
function rami3l$cmark$cmark$$tokens_try_add_image_link_start(toks, s, line, start) {
  const next = start + 1 | 0;
  let _tmp;
  if (next <= line.last) {
    $bound_check(s, next);
    _tmp = s.charCodeAt(next) === 91;
  } else {
    _tmp = false;
  }
  if (_tmp) {
    rami3l$cmark$cmark$$Tokens$push(toks, new $64$rami3l$47$cmark$47$cmark$46$Token$LinkStart({ start: start, image: true }));
    return next + 1 | 0;
  } else {
    return next;
  }
}
function rami3l$cmark$cmark$$tokens_try_add_emphasis(toks, s, line, start) {
  const _first = line.first;
  const _last = line.last;
  $bound_check(s, start);
  const char = s.charCodeAt(start);
  const run_last = rami3l$cmark$cmark_base$$run_of(char, s, _last, start + 1 | 0);
  const count = (run_last - start | 0) + 1 | 0;
  const prev_char = rami3l$cmark$char$$prev_char(s, _first, start);
  const next_char = rami3l$cmark$char$$next_char(s, _last, run_last);
  const is_prev_white = rami3l$cmark$char$$is_ascii_whitespace(prev_char);
  const is_prev_punct = rami3l$cmark$char$$is_ascii_punctuation(prev_char);
  const is_next_white = rami3l$cmark$char$$is_ascii_whitespace(next_char);
  const is_next_punct = rami3l$cmark$char$$is_ascii_punctuation(next_char);
  const is_left_flanking = !is_next_white && (!is_next_punct || (is_prev_white || is_prev_punct));
  const is_right_flanking = !is_prev_white && (!is_prev_punct || (is_next_white || is_next_punct));
  const next = run_last + 1 | 0;
  if (is_left_flanking || is_right_flanking) {
    const may_open = char === 42 && is_left_flanking || char === 95 && (is_left_flanking && (!is_right_flanking || is_prev_punct));
    const may_close = char === 42 && is_right_flanking || char === 95 && (is_right_flanking && (!is_left_flanking || is_next_punct));
    if (may_open || may_close) {
      rami3l$cmark$cmark$$Tokens$push(toks, new $64$rami3l$47$cmark$47$cmark$46$Token$EmphasisMarks({ start: start, char: char, count: count, may_open: may_open, may_close: may_close }));
      return next;
    } else {
      return next;
    }
  } else {
    return next;
  }
}
function rami3l$cmark$cmark$$tokens_try_add_strikethrough_marks(toks, s, line, start) {
  const _first = line.first;
  const _last = line.last;
  $bound_check(s, start);
  const char = s.charCodeAt(start);
  const run_last = rami3l$cmark$cmark_base$$run_of(char, s, _last, start + 1 | 0);
  const count = (run_last - start | 0) + 1 | 0;
  const next = run_last + 1 | 0;
  if (count === 2) {
    const prev_char = rami3l$cmark$char$$prev_char(s, _first, start);
    const next_char = rami3l$cmark$char$$next_char(s, _last, run_last);
    const may_open = !rami3l$cmark$char$$is_ascii_whitespace(next_char);
    const may_close = !rami3l$cmark$char$$is_ascii_whitespace(prev_char);
    rami3l$cmark$cmark$$Tokens$push(toks, new $64$rami3l$47$cmark$47$cmark$46$Token$StrikethroughMarks({ start: start, may_open: may_open, may_close: may_close }));
    return next;
  } else {
    return next;
  }
}
function rami3l$cmark$cmark$$tokens_try_add_math_span_marks(toks, s, line, start) {
  const _first = line.first;
  const _last = line.last;
  $bound_check(s, start);
  const char = s.charCodeAt(start);
  const run_last = rami3l$cmark$cmark_base$$run_of(char, s, _last, start + 1 | 0);
  const count = (run_last - start | 0) + 1 | 0;
  const next = run_last + 1 | 0;
  if (count <= 2) {
    let may_open = true;
    let may_close = true;
    if (count === 1) {
      const prev_char = rami3l$cmark$char$$prev_char(s, _first, start);
      const next_char = rami3l$cmark$char$$next_char(s, _last, run_last);
      may_open = !rami3l$cmark$char$$is_ascii_whitespace(next_char);
      may_close = !rami3l$cmark$char$$is_ascii_whitespace(prev_char);
    }
    if (may_open || may_close) {
      rami3l$cmark$cmark$$Tokens$push(toks, new $64$rami3l$47$cmark$47$cmark$46$Token$MathSpanMarks({ start: start, count: count, may_open: may_open, may_close: may_close }));
      return next;
    } else {
      return next;
    }
  } else {
    return next;
  }
}
function rami3l$cmark$cmark$$tokenize(exts, s, lines) {
  if (lines.length >= 1) {
    const _line = lines[0];
    const _x = moonbitlang$core$array$$Array$op_as_view$239$(lines, 1, lines.length);
    const toks = moonbitlang$core$deque$$new$289$(moonbitlang$core$deque$$new$46$capacity$46$default$289$());
    let cidx;
    let _tmp = _x;
    let _tmp$2 = _line;
    let _tmp$3 = false;
    let _tmp$4 = _line.first;
    _L: while (true) {
      const _param = _tmp;
      const _param$2 = _tmp$2;
      const _param$3 = _tmp$3;
      const _param$4 = _tmp$4;
      if (_param$4 > _param$2.last) {
        if (_param.len === 0) {
          cidx = rami3l$cmark$cmark$$make_closer_index(toks);
          break;
        } else {
          const _newline = _param.buf[_param.start];
          const _tmp$5 = _param.buf;
          const _tmp$6 = 1 + _param.start | 0;
          const _some = _param.len;
          const _x$2 = { buf: _tmp$5, start: _tmp$6, len: _some - 1 | 0 };
          const t = rami3l$cmark$cmark$$Token$newline(s, _param$2, _newline);
          rami3l$cmark$cmark$$Tokens$push(toks, t);
          const _tmp$7 = _newline.first;
          _tmp = _x$2;
          _tmp$2 = _newline;
          _tmp$3 = false;
          _tmp$4 = _tmp$7;
          continue;
        }
      }
      let next;
      _L$2: {
        _L$3: {
          _L$4: {
            _L$5: {
              $bound_check(s, _param$4);
              const _bind = s.charCodeAt(_param$4);
              switch (_bind) {
                case 92: {
                  const _tmp$5 = !_param$3;
                  const _tmp$6 = _param$4 + 1 | 0;
                  _tmp$3 = _tmp$5;
                  _tmp$4 = _tmp$6;
                  continue _L;
                }
                case 96: {
                  next = rami3l$cmark$cmark$$tokens_add_backtick(toks, s, _param$2, _param$3, _param$4);
                  break;
                }
                default: {
                  if (_param$3) {
                    next = _param$4 + 1 | 0;
                  } else {
                    switch (_bind) {
                      case 42: {
                        break _L$5;
                      }
                      case 95: {
                        break _L$5;
                      }
                      case 93: {
                        rami3l$cmark$cmark$$Tokens$push(toks, new $64$rami3l$47$cmark$47$cmark$46$Token$RightBrack({ start: _param$4 }));
                        next = _param$4 + 1 | 0;
                        break;
                      }
                      case 91: {
                        rami3l$cmark$cmark$$Tokens$push(toks, new $64$rami3l$47$cmark$47$cmark$46$Token$LinkStart({ start: _param$4, image: false }));
                        next = _param$4 + 1 | 0;
                        break;
                      }
                      case 33: {
                        next = rami3l$cmark$cmark$$tokens_try_add_image_link_start(toks, s, _param$2, _param$4);
                        break;
                      }
                      case 60: {
                        rami3l$cmark$cmark$$Tokens$push(toks, new $64$rami3l$47$cmark$47$cmark$46$Token$AutolinkOrHtmlStart({ start: _param$4 }));
                        next = _param$4 + 1 | 0;
                        break;
                      }
                      case 41: {
                        rami3l$cmark$cmark$$Tokens$push(toks, new $64$rami3l$47$cmark$47$cmark$46$Token$RightParen({ start: _param$4 }));
                        next = _param$4 + 1 | 0;
                        break;
                      }
                      case 126: {
                        if (exts) {
                          next = rami3l$cmark$cmark$$tokens_try_add_strikethrough_marks(toks, s, _param$2, _param$4);
                        } else {
                          break _L$3;
                        }
                        break;
                      }
                      case 36: {
                        if (exts) {
                          next = rami3l$cmark$cmark$$tokens_try_add_math_span_marks(toks, s, _param$2, _param$4);
                        } else {
                          break _L$3;
                        }
                        break;
                      }
                      default: {
                        break _L$3;
                      }
                    }
                  }
                }
              }
              break _L$4;
            }
            next = rami3l$cmark$cmark$$tokens_try_add_emphasis(toks, s, _param$2, _param$4);
          }
          break _L$2;
        }
        next = _param$4 + 1 | 0;
      }
      _tmp$3 = false;
      _tmp$4 = next;
      continue;
    }
    return { _0: cidx, _1: toks, _2: _line };
  } else {
    return moonbitlang$core$abort$$abort$47$("expected at least one line");
  }
}
function rami3l$cmark$cmark$$Parser$first_non_blank_in_span(self, span) {
  return rami3l$cmark$cmark_base$$first_non_blank_in_span(self.i, span);
}
function rami3l$cmark$cmark$$Parser$layout_clean_raw_span1(self, pad, span) {
  if (self.no_layouts) {
    return "";
  }
  return rami3l$cmark$char$$utf_16_clean_raw(pad, self.buf, self.i, span.first, span.last);
}
function rami3l$cmark$cmark$$Parser$layout_clean_raw_span1$46$pad$46$default() {
  return 0;
}
function rami3l$cmark$cmark$$Parser$meta(self, loc) {
  if (self.no_locs) {
    return rami3l$cmark$cmark_base$$Meta$none();
  }
  return rami3l$cmark$cmark_base$$Meta$new(loc);
}
function rami3l$cmark$cmark$$Parser$text_loc_of_span(self, span) {
  if (self.no_locs) {
    return rami3l$cmark$cmark_base$$TextLoc$none();
  }
  return { file: self.file, first_byte: span.first, last_byte: span.last, first_line: span.pos, last_line: span.pos };
}
function rami3l$cmark$cmark$$Parser$layout_clean_raw_span(self, pad, span) {
  if (self.no_layouts) {
    return rami3l$cmark$cmark$$layout_empty;
  }
  const _bind = rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark$$Parser$text_loc_of_span(self, span));
  const _bind$2 = rami3l$cmark$cmark$$Parser$layout_clean_raw_span1(self, pad, span);
  return { v: _bind$2, meta: _bind };
}
function rami3l$cmark$cmark$$Parser$layout_clean_raw_span$46$pad$46$default() {
  return 0;
}
function rami3l$cmark$cmark$$Parser$text_loc_of_lines(self, first, last, first_line, last_line) {
  if (self.no_locs) {
    return rami3l$cmark$cmark_base$$TextLoc$none();
  }
  return { file: self.file, first_byte: first, last_byte: last, first_line: first_line.pos, last_line: last_line.pos };
}
function rami3l$cmark$cmark$$Parser$meta_of_spans(self, first, last) {
  if (self.no_locs) {
    return rami3l$cmark$cmark_base$$Meta$none();
  }
  return rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark$$Parser$text_loc_of_lines(self, first.first, last.last, first, last));
}
function rami3l$cmark$cmark$$Parser$break_inline(self, line, start, break_ty, newline) {
  const layout_before = { pos: line.pos, first: start, last: line.last };
  const non_blank = rami3l$cmark$cmark$$Parser$first_non_blank_in_span(self, newline);
  const layout_after = { pos: newline.pos, first: newline.first, last: non_blank - 1 | 0 };
  const m = rami3l$cmark$cmark$$Parser$meta_of_spans(self, layout_before, layout_after);
  const layout_before$2 = rami3l$cmark$cmark$$Parser$layout_clean_raw_span(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span$46$pad$46$default(), layout_before);
  const layout_after$2 = rami3l$cmark$cmark$$Parser$layout_clean_raw_span(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span$46$pad$46$default(), layout_after);
  return new $64$rami3l$47$cmark$47$cmark$46$Inline$Break({ v: { layout_before: layout_before$2, ty: break_ty, layout_after: layout_after$2 }, meta: m });
}
function rami3l$cmark$cmark$$Parser$clean_unesc_unref_span(self, span) {
  return { v: rami3l$cmark$char$$utf_16_clean_unesc_unref(self.buf, self.i, span.first, span.last), meta: rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark$$Parser$text_loc_of_span(self, span)) };
}
function rami3l$cmark$cmark$$Parser$try_add_text_inline(self, line, first, last, acc) {
  if (first > last) {
    return undefined;
  }
  let first$2 = first;
  if (first$2 === line.first) {
    first$2 = rami3l$cmark$cmark$$Parser$first_non_blank_in_span(self, line);
  }
  moonbitlang$core$array$$Array$push$51$(acc, new $64$rami3l$47$cmark$47$cmark$46$Inline$Text(rami3l$cmark$cmark$$Parser$clean_unesc_unref_span(self, { pos: line.pos, first: first$2, last: last })));
}
function rami3l$cmark$cmark$$Parser$inlines_inline(self, first, last, first_line, last_line, acc) {
  if (acc.length === 1) {
    const _i = acc[0];
    return _i;
  } else {
    const text_loc = rami3l$cmark$cmark$$Parser$text_loc_of_lines(self, first, last, first_line, last_line);
    return new $64$rami3l$47$cmark$47$cmark$46$Inline$Inlines({ v: acc, meta: rami3l$cmark$cmark$$Parser$meta(self, text_loc) });
  }
}
function rami3l$cmark$cmark$$Parser$_tight_block_lines(self, f, spans) {
  const acc = [];
  const _len = moonbitlang$core$array$$ArrayView$length$50$(spans);
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const span = spans.buf[spans.start + _i | 0];
      const _fst_ln = span.span;
      if (_i === 0) {
        moonbitlang$core$array$$Array$push$167$(acc, { blanks: "", node: f(self, _fst_ln) });
      } else {
        const _line_start = span.start;
        const layout = self.no_layouts || _fst_ln.first <= _line_start ? "" : rami3l$cmark$char$$utf_16_clean_raw(rami3l$cmark$char$$utf_16_clean_raw$46$pad$46$default(), self.buf, self.i, _line_start, _fst_ln.first - 1 | 0);
        moonbitlang$core$array$$Array$push$167$(acc, { blanks: layout, node: f(self, _fst_ln) });
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return acc;
}
function rami3l$cmark$cmark$$Parser$clean_raw_span(self, pad, span) {
  return { v: rami3l$cmark$char$$utf_16_clean_raw(pad, self.buf, self.i, span.first, span.last), meta: rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark$$Parser$text_loc_of_span(self, span)) };
}
function rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default() {
  return 0;
}
function rami3l$cmark$cmark$$Parser$raw_tight_block_lines(self, spans) {
  return rami3l$cmark$cmark$$Parser$_tight_block_lines(self, (p, s) => rami3l$cmark$cmark$$Parser$clean_raw_span(p, rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default(), s), spans);
}
function rami3l$cmark$cmark$$Parser$code_span_token(self, count, first, last, first_line, last_line, spans) {
  const text_loc = rami3l$cmark$cmark$$Parser$text_loc_of_lines(self, first, last, first_line, last_line);
  const code_layout = rami3l$cmark$cmark$$Parser$raw_tight_block_lines(self, spans);
  const meta = rami3l$cmark$cmark$$Parser$meta(self, text_loc);
  const cs = new $64$rami3l$47$cmark$47$cmark$46$Inline$CodeSpan({ v: { backticks: count, code_layout: code_layout }, meta: meta });
  return new $64$rami3l$47$cmark$47$cmark$46$Token$Inline({ start: first, inline: cs, endline: last_line, next: last + 1 | 0 });
}
function rami3l$cmark$cmark$$Parser$clean_unref_span(self, span) {
  return { v: rami3l$cmark$char$$utf_16_clean_unref(self.buf, self.i, span.first, span.last), meta: rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark$$Parser$text_loc_of_span(self, span)) };
}
function rami3l$cmark$cmark$$Parser$autolink_token(self, line, first, last, is_email) {
  const meta = rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark$$Parser$text_loc_of_span(self, { pos: line.pos, first: first, last: last }));
  const link = { pos: line.pos, first: first + 1 | 0, last: last - 1 | 0 };
  const link$2 = rami3l$cmark$cmark$$Parser$clean_unref_span(self, link);
  const inline = new $64$rami3l$47$cmark$47$cmark$46$Inline$Autolink({ v: { is_email: is_email, link: link$2 }, meta: meta });
  return new $64$rami3l$47$cmark$47$cmark$46$Token$Inline({ start: first, inline: inline, endline: line, next: last + 1 | 0 });
}
function rami3l$cmark$cmark$$Seq$from_array$108$(arr) {
  return arr;
}
function rami3l$cmark$cmark$$Seq$from_array$240$(arr) {
  return arr;
}
function rami3l$cmark$cmark$$Seq$from_array$167$(arr) {
  return arr;
}
function rami3l$cmark$cmark$$Seq$op_get$240$(self, idx) {
  return moonbitlang$core$array$$Array$op_get$240$(self, idx);
}
function rami3l$cmark$cmark$$Seq$op_get$167$(self, idx) {
  return moonbitlang$core$array$$Array$op_get$167$(self, idx);
}
function rami3l$cmark$cmark$$Parser$raw_html_token(self, first, last, first_line, last_line, spans) {
  const raw = rami3l$cmark$cmark$$Seq$from_array$167$(rami3l$cmark$cmark$$Parser$raw_tight_block_lines(self, spans));
  const first$2 = rami3l$cmark$cmark$$Seq$op_get$167$(raw, 0).node.meta.loc;
  const _bind = moonbitlang$core$array$$ArrayView$op_get$50$(spans, moonbitlang$core$array$$ArrayView$length$50$(spans) - 1 | 0).span;
  const _last_byte = _bind.last;
  const _last_line = _bind.pos;
  const text_loc = { file: first$2.file, first_byte: first$2.first_byte, last_byte: _last_byte, first_line: first$2.first_line, last_line: _last_line };
  const inline = new $64$rami3l$47$cmark$47$cmark$46$Inline$RawHtml({ v: raw, meta: rami3l$cmark$cmark$$Parser$meta(self, text_loc) });
  return new $64$rami3l$47$cmark$47$cmark$46$Token$Inline({ start: first, inline: inline, endline: last_line, next: last + 1 | 0 });
}
function rami3l$cmark$cmark$$Parser$link_token(self, first, last, first_line, last_line, image, link) {
  const text_loc = rami3l$cmark$cmark$$Parser$text_loc_of_lines(self, first, last, first_line, last_line);
  const link$2 = { v: link, meta: rami3l$cmark$cmark$$Parser$meta(self, text_loc) };
  const inline = image ? new $64$rami3l$47$cmark$47$cmark$46$Inline$Image(link$2) : new $64$rami3l$47$cmark$47$cmark$46$Inline$Link(link$2);
  return new $64$rami3l$47$cmark$47$cmark$46$Token$Inline({ start: first, inline: inline, endline: last_line, next: last + 1 | 0 });
}
function rami3l$cmark$cmark$$Parser$emphasis_token(self, first, last, first_line, last_line, strong, emph) {
  const text_loc = rami3l$cmark$cmark$$Parser$text_loc_of_lines(self, first, last, first_line, last_line);
  const _tmp = self.i;
  $bound_check(_tmp, first);
  const delim = _tmp.charCodeAt(first);
  const emph$2 = { v: { delim: delim, inline: emph }, meta: rami3l$cmark$cmark$$Parser$meta(self, text_loc) };
  const inline = strong ? new $64$rami3l$47$cmark$47$cmark$46$Inline$StrongEmphasis(emph$2) : new $64$rami3l$47$cmark$47$cmark$46$Inline$Emphasis(emph$2);
  return new $64$rami3l$47$cmark$47$cmark$46$Token$Inline({ start: first, inline: inline, endline: last_line, next: last + 1 | 0 });
}
function rami3l$cmark$cmark$$Parser$ext_strikethough_token(self, first, last, first_line, last_line, s) {
  const text_loc = rami3l$cmark$cmark$$Parser$text_loc_of_lines(self, first, last, first_line, last_line);
  const inline = new $64$rami3l$47$cmark$47$cmark$46$Inline$ExtStrikethrough({ v: s, meta: rami3l$cmark$cmark$$Parser$meta(self, text_loc) });
  return new $64$rami3l$47$cmark$47$cmark$46$Token$Inline({ start: first, inline: inline, endline: last_line, next: last + 1 | 0 });
}
function rami3l$cmark$cmark$$Parser$ext_math_span_token(self, count, first, last, first_line, last_line, spans) {
  const textloc = rami3l$cmark$cmark$$Parser$text_loc_of_lines(self, first, last, first_line, last_line);
  const tex_layout = rami3l$cmark$cmark$$Parser$raw_tight_block_lines(self, spans);
  const meta = rami3l$cmark$cmark$$Parser$meta(self, textloc);
  const ms = { display: count === 2, tex_layout: tex_layout };
  const inline = new $64$rami3l$47$cmark$47$cmark$46$Inline$ExtMathSpan({ v: ms, meta: meta });
  return new $64$rami3l$47$cmark$47$cmark$46$Token$Inline({ start: first, inline: inline, endline: last_line, next: last + 1 | 0 });
}
function rami3l$cmark$cmark$$Parser$try_code(self, rev_toks, start_line, start, count, escaped) {
  if (!escaped && rami3l$cmark$cmark$$CloserIndex$has_backticks(self.cidx, count, start)) {
    const first = start + count | 0;
    const _bind = start_line.pos;
    const _bind$2 = start_line.last;
    let line = { pos: _bind, first: first, last: _bind$2 };
    const spans = [];
    let k = first;
    const old_rev_toks = moonbitlang$core$deque$$T$copy$289$(rev_toks.val);
    while (true) {
      _L: {
        const _bind$3 = rami3l$cmark$cmark$$RevTokens$pop(rev_toks.val);
        if (_bind$3 === undefined) {
          break;
        } else {
          const _Some = _bind$3;
          const _x = _Some;
          switch (_x.$tag) {
            case 1: {
              const _Backticks = _x;
              const _x$2 = _Backticks._0;
              const _start = _x$2.start;
              const _c = _x$2.count;
              if (_c === count) {
                const _bind$4 = line;
                const span = { start: first, span: { pos: _bind$4.pos, first: k, last: _start - 1 | 0 } };
                moonbitlang$core$array$$Array$push$50$(spans, span);
                const t = rami3l$cmark$cmark$$Parser$code_span_token(self, count, start, (_start + count | 0) - 1 | 0, start_line, line, { buf: spans, start: 0, len: spans.length });
                return { _0: line, _1: t };
              } else {
                break _L;
              }
            }
            case 5: {
              const _Newline = _x;
              const _x$3 = _Newline._0;
              const _newline = _x$3.newline;
              const _bind$4 = line;
              const span = { start: first, span: { pos: _bind$4.pos, first: k, last: _bind$4.last } };
              moonbitlang$core$array$$Array$push$50$(spans, span);
              k = rami3l$cmark$cmark$$Parser$first_non_blank_in_span(self, _newline);
              line = _newline;
              break;
            }
            default: {
              break _L;
            }
          }
        }
        break _L;
      }
      continue;
    }
    rev_toks.val = old_rev_toks;
    return undefined;
  } else {
    return undefined;
  }
}
function rami3l$cmark$cmark$$Parser$try_math_span(self, rev_toks, start_line, start, count) {
  if (rami3l$cmark$cmark$$CloserIndex$has_math_span(self.cidx, count, start)) {
    const old_rev_toks = moonbitlang$core$deque$$T$copy$289$(rev_toks.val);
    const first = start + count | 0;
    const _bind = start_line.pos;
    const _bind$2 = start_line.last;
    let line = { pos: _bind, first: first, last: _bind$2 };
    const spans = [];
    let k = first;
    while (true) {
      _L: {
        const _bind$3 = rami3l$cmark$cmark$$RevTokens$pop(rev_toks.val);
        if (_bind$3 === undefined) {
          break;
        } else {
          const _Some = _bind$3;
          const _x = _Some;
          switch (_x.$tag) {
            case 9: {
              const _MathSpanMarks = _x;
              const _x$2 = _MathSpanMarks._0;
              const _start = _x$2.start;
              const _c = _x$2.count;
              const _may_close = _x$2.may_close;
              if (_c === count && _may_close) {
                const _bind$4 = line;
                const span = { start: first, span: { pos: _bind$4.pos, first: k, last: _start - 1 | 0 } };
                moonbitlang$core$array$$Array$push$50$(spans, span);
                const t = rami3l$cmark$cmark$$Parser$ext_math_span_token(self, count, start, (_start + count | 0) - 1 | 0, start_line, line, { buf: spans, start: 0, len: spans.length });
                return { _0: line, _1: t };
              } else {
                break _L;
              }
            }
            case 5: {
              const _Newline = _x;
              const _x$3 = _Newline._0;
              const _newline = _x$3.newline;
              const _bind$4 = line;
              const span = { start: first, span: { pos: _bind$4.pos, first: k, last: _bind$4.last } };
              moonbitlang$core$array$$Array$push$50$(spans, span);
              k = rami3l$cmark$cmark$$Parser$first_non_blank_in_span(self, _newline);
              line = _newline;
              break;
            }
            default: {
              break _L;
            }
          }
        }
        break _L;
      }
      continue;
    }
    rev_toks.val = old_rev_toks;
    return undefined;
  } else {
    return undefined;
  }
}
function rami3l$cmark$cmark$$Parser$try_autolink_or_html(self, rev_toks, line, start) {
  const _bind = rami3l$cmark$cmark_base$$autolink_uri(self.i, line.last, start);
  if (_bind === undefined) {
  } else {
    const _Some = _bind;
    const _last = _Some;
    const t = rami3l$cmark$cmark$$Parser$autolink_token(self, line, start, _last, false);
    rami3l$cmark$cmark$$tokens_pop_until(_last + 1 | 0, rev_toks.val);
    return { _0: line, _1: t };
  }
  const _bind$2 = rami3l$cmark$cmark_base$$autolink_email(self.i, line.last, start);
  if (_bind$2 === undefined) {
  } else {
    const _Some = _bind$2;
    const _last = _Some;
    const t = rami3l$cmark$cmark$$Parser$autolink_token(self, line, start, _last, true);
    rami3l$cmark$cmark$$tokens_pop_until(_last + 1 | 0, rev_toks.val);
    return { _0: line, _1: t };
  }
  const _bind$3 = rami3l$cmark$cmark_base$$raw_html$355$(rami3l$cmark$cmark$$tokens_next_line, self.i, rev_toks.val, line, start);
  if (_bind$3 === undefined) {
    return undefined;
  } else {
    const _Some = _bind$3;
    const _x = _Some;
    const _last_line = _x._0;
    const _spans = _x._1;
    const _last = _x._2;
    const t = rami3l$cmark$cmark$$Parser$raw_html_token(self, start, _last, line, _last_line, { buf: _spans, start: 0, len: _spans.length });
    rami3l$cmark$cmark$$tokens_pop_until(_last + 1 | 0, rev_toks.val);
    return { _0: _last_line, _1: t };
  }
}
function rami3l$cmark$cmark$$Parser$tight_block_lines(self, spans) {
  return rami3l$cmark$cmark$$Parser$_tight_block_lines(self, rami3l$cmark$cmark$$Parser$clean_unesc_unref_span, spans);
}
function rami3l$cmark$cmark$$Parser$label_of_spans(self, key, spans) {
  const meta = self.no_locs || moonbitlang$core$array$$ArrayView$length$50$(spans) === 0 ? rami3l$cmark$cmark_base$$Meta$none() : rami3l$cmark$cmark$$Parser$meta_of_spans(self, moonbitlang$core$array$$ArrayView$op_get$50$(spans, 0).span, moonbitlang$core$array$$ArrayView$op_get$50$(spans, moonbitlang$core$array$$ArrayView$length$50$(spans) - 1 | 0).span);
  const text = rami3l$cmark$cmark$$Parser$tight_block_lines(self, spans);
  return { meta: meta, key: key, text: text };
}
function rami3l$cmark$cmark$$Parser$find_label_defining_key(self, key) {
  const _bind = moonbitlang$core$builtin$$Map$op_get$308$(self.defs, key);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x.$tag === 0) {
      const _LinkDef = _x;
      const _ld = _LinkDef._0;
      return _ld.v.defined_label;
    } else {
      const _FootnoteDef = _x;
      const _ld = _FootnoteDef._0;
      return _ld.v.defined_label;
    }
  }
}
function rami3l$cmark$cmark$$Parser$find_def_for_ref(self, image, ref_) {
  const kind = image ? 1 : 0;
  const def = rami3l$cmark$cmark$$Parser$find_label_defining_key(self, ref_.key);
  const _func = self.resolver;
  return _func(new $64$rami3l$47$cmark$47$cmark$46$LabelContext$Ref(kind, ref_, def));
}
function rami3l$cmark$cmark$$Parser$try_full_reflink_remainder(self, rev_toks, line, image, start) {
  const _bind = rami3l$cmark$cmark_base$$link_label$355$(self.buf, rami3l$cmark$cmark$$tokens_next_line, self.i, rev_toks.val, line, start);
  if (_bind === undefined) {
    return Option$None$76$;
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _line = _x._0;
    const _spans = _x._1;
    const _last = _x._2;
    const _key = _x._3;
    const ref_ = rami3l$cmark$cmark$$Parser$label_of_spans(self, _key, { buf: _spans, start: 0, len: _spans.length });
    const _bind$2 = rami3l$cmark$cmark$$Parser$find_def_for_ref(self, image, ref_);
    if (_bind$2 === undefined) {
      return new Option$Some$76$(undefined);
    } else {
      const _Some$2 = _bind$2;
      const _def = _Some$2;
      rami3l$cmark$cmark$$tokens_drop_stop_after_right_brack(rev_toks.val);
      return new Option$Some$76$({ _0: _line, _1: new $64$rami3l$47$cmark$47$cmark$46$ReferenceKind$Ref(1, ref_, _def), _2: _last });
    }
  }
}
function rami3l$cmark$cmark$$Parser$try_shortcut_reflink(self, rev_toks, line, image, start) {
  const start$2 = start + moonbitlang$core$bool$$Bool$to_int(image) | 0;
  const _bind = rami3l$cmark$cmark_base$$link_label$355$(self.buf, rami3l$cmark$cmark$$tokens_next_line, self.i, rev_toks.val, line, start$2);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _line = _x._0;
    const _spans = _x._1;
    const _last = _x._2;
    const _key = _x._3;
    const ref_ = rami3l$cmark$cmark$$Parser$label_of_spans(self, _key, { buf: _spans, start: 0, len: _spans.length });
    const _bind$2 = rami3l$cmark$cmark$$Parser$find_def_for_ref(self, image, ref_);
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some$2 = _bind$2;
      const _def = _Some$2;
      rami3l$cmark$cmark$$tokens_drop_stop_after_right_brack(rev_toks.val);
      return { _0: _line, _1: new $64$rami3l$47$cmark$47$cmark$46$ReferenceKind$Ref(2, ref_, _def), _2: _last };
    }
  }
}
function rami3l$cmark$cmark$$Parser$try_collapsed_reflink(self, rev_toks, line, image, start) {
  const start$2 = start + moonbitlang$core$bool$$Bool$to_int(image) | 0;
  const _bind = rami3l$cmark$cmark_base$$link_label$355$(self.buf, rami3l$cmark$cmark$$tokens_next_line, self.i, rev_toks.val, line, start$2);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _line = _x._0;
    const _spans = _x._1;
    const _last = _x._2;
    const _key = _x._3;
    const ref_ = rami3l$cmark$cmark$$Parser$label_of_spans(self, _key, { buf: _spans, start: 0, len: _spans.length });
    const last = _last + 2 | 0;
    const _bind$2 = rami3l$cmark$cmark$$Parser$find_def_for_ref(self, image, ref_);
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some$2 = _bind$2;
      const _def = _Some$2;
      rami3l$cmark$cmark$$tokens_drop_stop_after_right_brack(rev_toks.val);
      rami3l$cmark$cmark$$tokens_drop_stop_after_right_brack(rev_toks.val);
      return { _0: _line, _1: new $64$rami3l$47$cmark$47$cmark$46$ReferenceKind$Ref(0, ref_, _def), _2: last };
    }
  }
}
function rami3l$cmark$cmark$$Parser$first_non_blank_over_nl$369$(self, next_line, lines, line, start) {
  const _bind = rami3l$cmark$cmark_base$$first_non_blank_over_nl$369$(next_line, self.i, lines, line, start);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x.$tag === 0) {
      const _ThisLine = _x;
      const _nb = _ThisLine._0;
      const layout = _nb === start ? [] : [rami3l$cmark$cmark$$Parser$clean_raw_span(self, rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default(), { pos: line.pos, first: start, last: _nb - 1 | 0 })];
      return { _0: line, _1: layout, _2: _nb };
    } else {
      const _NextLine = _x;
      const _newline = _NextLine._0;
      const _nb = _NextLine._1;
      const first_layout = rami3l$cmark$cmark$$Parser$clean_raw_span(self, rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default(), { pos: line.pos, first: start, last: line.last });
      const next_layout = rami3l$cmark$cmark$$Parser$clean_raw_span(self, rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default(), { pos: _newline.pos, first: _newline.first, last: _nb - 1 | 0 });
      const layout = [first_layout, next_layout];
      return { _0: _newline, _1: layout, _2: _nb };
    }
  }
}
function rami3l$cmark$cmark$$Parser$first_non_blank_over_nl$355$(self, next_line, lines, line, start) {
  const _bind = rami3l$cmark$cmark_base$$first_non_blank_over_nl$355$(next_line, self.i, lines, line, start);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x.$tag === 0) {
      const _ThisLine = _x;
      const _nb = _ThisLine._0;
      const layout = _nb === start ? [] : [rami3l$cmark$cmark$$Parser$clean_raw_span(self, rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default(), { pos: line.pos, first: start, last: _nb - 1 | 0 })];
      return { _0: line, _1: layout, _2: _nb };
    } else {
      const _NextLine = _x;
      const _newline = _NextLine._0;
      const _nb = _NextLine._1;
      const first_layout = rami3l$cmark$cmark$$Parser$clean_raw_span(self, rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default(), { pos: line.pos, first: start, last: line.last });
      const next_layout = rami3l$cmark$cmark$$Parser$clean_raw_span(self, rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default(), { pos: _newline.pos, first: _newline.first, last: _nb - 1 | 0 });
      const layout = [first_layout, next_layout];
      return { _0: _newline, _1: layout, _2: _nb };
    }
  }
}
function rami3l$cmark$cmark$$Parser$try_inline_link_remainder(self, rev_toks, start_line, image, start) {
  if (rami3l$cmark$cmark$$CloserIndex$has_right_paren(self.cidx, start)) {
    const _bind = rami3l$cmark$cmark$$Parser$first_non_blank_over_nl$355$(self, rami3l$cmark$cmark$$tokens_next_line, rev_toks.val, start_line, start + 1 | 0);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _line = _x._0;
      const _before_dest = _x._1;
      const _start = _x._2;
      const _bind$2 = rami3l$cmark$cmark_base$$link_destination(self.i, _line.last, _start);
      let _bind$3;
      if (_bind$2 === undefined) {
        _bind$3 = { _0: _line, _1: false, _2: undefined, _3: _start };
      } else {
        const _Some$2 = _bind$2;
        const _x$2 = _Some$2;
        const _angled = _x$2._0;
        const _first = _x$2._1;
        const _last = _x$2._2;
        const dest = rami3l$cmark$cmark$$Parser$clean_unesc_unref_span(self, { pos: _line.pos, first: _first, last: _last });
        const next = (_last + 1 | 0) + moonbitlang$core$bool$$Bool$to_int(_angled) | 0;
        _bind$3 = { _0: _line, _1: _angled, _2: dest, _3: next };
      }
      const _line$2 = _bind$3._0;
      const _angled_dest = _bind$3._1;
      const _dest = _bind$3._2;
      const _start$2 = _bind$3._3;
      const _bind$4 = rami3l$cmark$cmark$$Parser$first_non_blank_over_nl$355$(self, rami3l$cmark$cmark$$tokens_next_line, rev_toks.val, _line$2, _start$2);
      let _bind$5;
      if (_bind$4 === undefined) {
        _bind$5 = { _0: _line$2, _1: [], _2: 34, _3: Option$None$77$, _4: _start$2 };
      } else {
        const _Some$2 = _bind$4;
        const _x$2 = _Some$2;
        const _line$3 = _x$2._0;
        const _after_dest = _x$2._1;
        const _start1 = _x$2._2;
        if (_start1 === _start$2) {
          _bind$5 = { _0: _line$3, _1: [], _2: 34, _3: Option$None$77$, _4: _start$2 };
        } else {
          const _bind$6 = rami3l$cmark$cmark_base$$link_title$355$(rami3l$cmark$cmark$$tokens_next_line, self.i, rev_toks.val, _line$3, _start1);
          if (_bind$6 === undefined) {
            _bind$5 = { _0: _line$3, _1: _after_dest, _2: 34, _3: Option$None$77$, _4: _start1 };
          } else {
            const _Some$3 = _bind$6;
            const _x$3 = _Some$3;
            const _line$4 = _x$3._0;
            const _spans = _x$3._1;
            const _last = _x$3._2;
            const title = rami3l$cmark$cmark$$Parser$tight_block_lines(self, { buf: _spans, start: 0, len: _spans.length });
            const _tmp = self.i;
            $bound_check(_tmp, _start1);
            const _tmp$2 = _tmp.charCodeAt(_start1);
            _bind$5 = { _0: _line$4, _1: _after_dest, _2: _tmp$2, _3: new Option$Some$77$(title), _4: _last + 1 | 0 };
          }
        }
      }
      const _line$3 = _bind$5._0;
      const _after_dest = _bind$5._1;
      const _title_open_delim = _bind$5._2;
      const _title = _bind$5._3;
      const _start$3 = _bind$5._4;
      const _bind$6 = moonbitlang$core$option$$Option$or$69$(rami3l$cmark$cmark$$Parser$first_non_blank_over_nl$355$(self, rami3l$cmark$cmark$$tokens_next_line, rev_toks.val, _line$3, _start$3), { _0: _line$3, _1: [], _2: _start$3 });
      const _line$4 = _bind$6._0;
      const _after_title = _bind$6._1;
      const _last = _bind$6._2;
      let _tmp;
      if (_last > _line$4.last) {
        _tmp = true;
      } else {
        const _tmp$2 = self.i;
        $bound_check(_tmp$2, _last);
        _tmp = _tmp$2.charCodeAt(_last) !== 41;
      }
      if (_tmp) {
        return undefined;
      }
      const layout = { indent: 0, angled_dest: _angled_dest, before_dest: _before_dest, after_dest: _after_dest, title_open_delim: _title_open_delim, after_title: _after_title };
      const label = undefined;
      const defined_label = undefined;
      const ld = { layout: layout, label: label, defined_label: defined_label, dest: _dest, title: _title };
      const textloc = rami3l$cmark$cmark$$Parser$text_loc_of_lines(self, start, _start$3, start_line, _line$4);
      const ld$2 = { v: ld, meta: rami3l$cmark$cmark$$Parser$meta(self, textloc) };
      rami3l$cmark$cmark$$tokens_pop_until(_last + 1 | 0, rev_toks.val);
      return { _0: _line$4, _1: new $64$rami3l$47$cmark$47$cmark$46$ReferenceKind$Inline(ld$2), _2: _last };
    }
  } else {
    return undefined;
  }
}
function rami3l$cmark$cmark$$Parser$find_link_text_tokens(self, rev_toks, start_line, start) {
  const line = { val: start_line };
  let nest = 0;
  const acc = moonbitlang$core$deque$$new$289$(moonbitlang$core$deque$$new$46$capacity$46$default$289$());
  const old_rev_toks = moonbitlang$core$deque$$T$copy$289$(rev_toks.val);
  while (true) {
    _L: {
      let l;
      let t;
      _L$2: {
        _L$3: {
          const _bind = rami3l$cmark$cmark$$RevTokens$pop(rev_toks.val);
          const _bind$2 = nest;
          if (_bind === undefined) {
            break;
          } else {
            const _Some = _bind;
            const _x = _Some;
            switch (_x.$tag) {
              case 6: {
                const _RightBrack = _x;
                const _x$2 = _RightBrack._0;
                const _last = _x$2.start;
                if (_bind$2 === 0) {
                  rami3l$cmark$cmark$$tokens_shorten_last_line(_last - 1 | 0, acc);
                  return { _0: line.val, _1: acc, _2: _last };
                } else {
                  rami3l$cmark$cmark$$Tokens$push(acc, _RightBrack);
                  nest = nest - 1 | 0;
                }
                break;
              }
              case 1: {
                const _Backticks = _x;
                const _x$3 = _Backticks._0;
                const _start = _x$3.start;
                const _count = _x$3.count;
                const _escaped = _x$3.escaped;
                const _bind$3 = rami3l$cmark$cmark$$Parser$try_code(self, rev_toks, line.val, _start, _count, _escaped);
                if (_bind$3 === undefined) {
                } else {
                  const _Some$2 = _bind$3;
                  const _x$4 = _Some$2;
                  const _line_ = _x$4._0;
                  const _t = _x$4._1;
                  line.val = _line_;
                  rami3l$cmark$cmark$$Tokens$push(acc, _t);
                }
                break;
              }
              case 9: {
                const _MathSpanMarks = _x;
                const _x$4 = _MathSpanMarks._0;
                const _start$2 = _x$4.start;
                const _count$2 = _x$4.count;
                const _may_open = _x$4.may_open;
                if (_may_open) {
                  const _bind$4 = rami3l$cmark$cmark$$Parser$try_math_span(self, rev_toks, line.val, _start$2, _count$2);
                  if (_bind$4 === undefined) {
                    break _L;
                  } else {
                    const _Some$2 = _bind$4;
                    const _x$5 = _Some$2;
                    const _line_ = _x$5._0;
                    const _t = _x$5._1;
                    line.val = _line_;
                    rami3l$cmark$cmark$$Tokens$push(acc, _t);
                  }
                } else {
                  break _L;
                }
                break;
              }
              case 0: {
                const _AutolinkOrHtmlStart = _x;
                const _x$5 = _AutolinkOrHtmlStart._0;
                const _start$3 = _x$5.start;
                const _bind$4 = rami3l$cmark$cmark$$Parser$try_autolink_or_html(self, rev_toks, line.val, _start$3);
                if (_bind$4 === undefined) {
                  break _L;
                } else {
                  const _Some$2 = _bind$4;
                  const _x$6 = _Some$2;
                  const _line_ = _x$6._0;
                  const _t = _x$6._1;
                  line.val = _line_;
                  rami3l$cmark$cmark$$Tokens$push(acc, _t);
                }
                break;
              }
              case 4: {
                const _LinkStart = _x;
                rami3l$cmark$cmark$$Tokens$push(acc, _LinkStart);
                nest = nest + 1 | 0;
                break;
              }
              case 5: {
                const _Newline = _x;
                const _x$6 = _Newline._0;
                const _l = _x$6.newline;
                l = _l;
                t = _x;
                break _L$3;
              }
              case 3: {
                const _Inline = _x;
                const _x$7 = _Inline._0;
                const _l$2 = _x$7.endline;
                l = _l$2;
                t = _x;
                break _L$3;
              }
              default: {
                rami3l$cmark$cmark$$Tokens$push(acc, _x);
              }
            }
          }
          break _L$2;
        }
        line.val = l;
        rami3l$cmark$cmark$$Tokens$push(acc, t);
      }
      break _L;
    }
    continue;
  }
  rev_toks.val = old_rev_toks;
  return undefined;
}
function rami3l$cmark$cmark$$Parser$try_link_def(self, start, start_rev_toks, start_line, rev_toks, line, text_last, image, text) {
  const next = text_last + 1 | 0;
  const old_rev_toks = moonbitlang$core$deque$$T$copy$289$(start_rev_toks.val);
  let link;
  if (next > line.last) {
    link = rami3l$cmark$cmark$$Parser$try_shortcut_reflink(self, start_rev_toks, start_line, image, start);
  } else {
    const _tmp = self.i;
    $bound_check(_tmp, next);
    const _bind = _tmp.charCodeAt(next);
    switch (_bind) {
      case 40: {
        const _bind$2 = rami3l$cmark$cmark$$Parser$try_inline_link_remainder(self, rev_toks, line, image, next);
        if (_bind$2 === undefined) {
          link = rami3l$cmark$cmark$$Parser$try_shortcut_reflink(self, start_rev_toks, start_line, image, start);
        } else {
          const _Some = _bind$2;
          link = _Some;
        }
        break;
      }
      case 91: {
        const next1 = next + 1 | 0;
        let _tmp$2;
        if (next1 <= line.last) {
          const _tmp$3 = self.i;
          $bound_check(_tmp$3, next1);
          _tmp$2 = _tmp$3.charCodeAt(next1) === 93;
        } else {
          _tmp$2 = false;
        }
        if (_tmp$2) {
          link = rami3l$cmark$cmark$$Parser$try_collapsed_reflink(self, start_rev_toks, start_line, image, start);
        } else {
          const r = rami3l$cmark$cmark$$Parser$try_full_reflink_remainder(self, rev_toks, line, image, next);
          if (r.$tag === 0) {
            link = rami3l$cmark$cmark$$Parser$try_shortcut_reflink(self, start_rev_toks, start_line, image, start);
          } else {
            const _Some = r;
            const _x = _Some._0;
            if (_x === undefined) {
              link = undefined;
            } else {
              const _Some$2 = _x;
              link = _Some$2;
            }
          }
        }
        break;
      }
      default: {
        link = rami3l$cmark$cmark$$Parser$try_shortcut_reflink(self, start_rev_toks, start_line, image, start);
      }
    }
  }
  if (link === undefined) {
    start_rev_toks.val = old_rev_toks;
    return undefined;
  } else {
    const _Some = link;
    const _x = _Some;
    const _endline = _x._0;
    const _reference = _x._1;
    const _last = _x._2;
    const text$2 = rami3l$cmark$cmark$$Parser$inlines_inline(self, start, text_last, start_line, line, text);
    const link$2 = { text: text$2, reference: _reference };
    const t = rami3l$cmark$cmark$$Parser$link_token(self, start, _last, start_line, _endline, image, link$2);
    const had_link = !image && !self.nested_links;
    return { _0: _endline, _1: t, _2: had_link };
  }
}
function rami3l$cmark$cmark$$Parser$last_pass(self, toks, line) {
  const acc = [];
  const line$2 = { val: line };
  const k = { val: line$2.val.first };
  const _bind = moonbitlang$core$deque$$T$iter$289$(toks);
  _bind((tok) => {
    switch (tok.$tag) {
      case 5: {
        const _Newline = tok;
        const _x = _Newline._0;
        const _start = _x.start;
        const _break_ty = _x.break_ty;
        const _newline = _x.newline;
        rami3l$cmark$cmark$$Parser$try_add_text_inline(self, line$2.val, k.val, _start - 1 | 0, acc);
        const break_ = rami3l$cmark$cmark$$Parser$break_inline(self, line$2.val, _start, _break_ty, _newline);
        line$2.val = _newline;
        moonbitlang$core$array$$Array$push$51$(acc, break_);
        k.val = _newline.first;
        break;
      }
      case 3: {
        const _Inline = tok;
        const _x$2 = _Inline._0;
        const _start$2 = _x$2.start;
        const _inline = _x$2.inline;
        const _endline = _x$2.endline;
        const _next = _x$2.next;
        rami3l$cmark$cmark$$Parser$try_add_text_inline(self, line$2.val, k.val, _start$2 - 1 | 0, acc);
        if (_inline.$tag === 5) {
          const _Inlines = _inline;
          const _x$3 = _Inlines._0;
          const _is_ = _x$3.v;
          moonbitlang$core$array$$Array$push_iter$51$(acc, rami3l$cmark$cmark$$Seq$iter$51$(_is_));
        } else {
          moonbitlang$core$array$$Array$push$51$(acc, _inline);
        }
        line$2.val = _endline;
        k.val = _next;
        break;
      }
      default: {
        moonbitlang$core$abort$$abort$12$("unreachable");
      }
    }
    return 1;
  });
  rami3l$cmark$cmark$$Parser$try_add_text_inline(self, line$2.val, k.val, line$2.val.last, acc);
  return acc;
}
function rami3l$cmark$cmark$$Parser$second_pass(self, toks, line) {
  const rev_toks = moonbitlang$core$ref$$Ref$new$355$(toks.val);
  const acc = moonbitlang$core$deque$$new$289$(moonbitlang$core$deque$$new$46$capacity$46$default$289$());
  toks.val = acc;
  const line$2 = { val: line };
  while (true) {
    let t;
    let l;
    _L: {
      _L$2: {
        const _bind = rami3l$cmark$cmark$$RevTokens$pop(rev_toks.val);
        if (_bind === undefined) {
          break;
        } else {
          const _Some = _bind;
          const _x = _Some;
          switch (_x.$tag) {
            case 2: {
              const _EmphasisMarks = _x;
              const _opener = _EmphasisMarks._0;
              if (_opener.may_open) {
                const _bind$2 = rami3l$cmark$cmark$$Parser$try_emphasis(self, rev_toks, line$2.val, _opener);
                if (_bind$2 === undefined) {
                } else {
                  const _Some$2 = _bind$2;
                  const _l = _Some$2;
                  line$2.val = _l;
                }
              }
              break;
            }
            case 8: {
              const _StrikethroughMarks = _x;
              const _opener$2 = _StrikethroughMarks._0;
              if (_opener$2.may_open) {
                const _bind$2 = rami3l$cmark$cmark$$Parser$try_strikethrough(self, rev_toks, line$2.val, _opener$2);
                if (_bind$2 === undefined) {
                } else {
                  const _Some$2 = _bind$2;
                  const _l = _Some$2;
                  line$2.val = _l;
                }
              }
              break;
            }
            case 5: {
              const _Newline = _x;
              const _x$2 = _Newline._0;
              const _l = _x$2.newline;
              t = _x;
              l = _l;
              break _L$2;
            }
            case 3: {
              const _Inline = _x;
              const _x$3 = _Inline._0;
              const _l$2 = _x$3.endline;
              t = _x;
              l = _l$2;
              break _L$2;
            }
            default: {
              rami3l$cmark$cmark$$Tokens$push(acc, _x);
            }
          }
        }
        break _L;
      }
      rami3l$cmark$cmark$$Tokens$push(acc, t);
      line$2.val = l;
    }
    continue;
  }
}
function rami3l$cmark$cmark$$Parser$try_emphasis(self, rev_toks, start_line, opener) {
  const start = opener.start;
  if (rami3l$cmark$cmark$$CloserIndex$has_emphasis(self.cidx, opener.char, start)) {
    const _bind = rami3l$cmark$cmark$$Parser$find_emphasis_text(self, rev_toks, start_line, opener);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _line = _x._0;
      const _used = _x._1;
      const _emph_toks = _x._2;
      const _closer = _x._3;
      const text_first = start + opener.count | 0;
      const text_last = _closer.start - 1 | 0;
      const first = text_first - _used | 0;
      const last = (_closer.start + _used | 0) - 1 | 0;
      const last$2 = moonbitlang$core$builtin$$Eq$op_equal$239$(start_line, _line) ? text_last : start_line.last;
      const text_start = { pos: start_line.pos, first: text_first, last: last$2 };
      const emph_toks = moonbitlang$core$ref$$Ref$new$354$(_emph_toks);
      rami3l$cmark$cmark$$Parser$second_pass(self, emph_toks, text_start);
      const text = rami3l$cmark$cmark$$Parser$last_pass(self, emph_toks.val, text_start);
      const emph = rami3l$cmark$cmark$$Parser$inlines_inline(self, first, text_last, _line, _line, text);
      const count = _closer.count - _used | 0;
      if (count !== 0) {
        rami3l$cmark$cmark$$RevTokens$push(rev_toks.val, new $64$rami3l$47$cmark$47$cmark$46$Token$EmphasisMarks({ start: last + 1 | 0, char: _closer.char, count: count, may_open: _closer.may_open, may_close: _closer.may_close }));
      }
      const emph$2 = rami3l$cmark$cmark$$Parser$emphasis_token(self, first, last, _line, _line, _used === 2, emph);
      rami3l$cmark$cmark$$RevTokens$push(rev_toks.val, emph$2);
      const count$2 = opener.count - _used | 0;
      if (count$2 !== 0) {
        rami3l$cmark$cmark$$RevTokens$push(rev_toks.val, new $64$rami3l$47$cmark$47$cmark$46$Token$EmphasisMarks({ start: opener.start, char: opener.char, count: count$2, may_open: opener.may_open, may_close: opener.may_close }));
      }
      return _line;
    }
  } else {
    return undefined;
  }
}
function rami3l$cmark$cmark$$Parser$find_emphasis_text(self, rev_toks, line, opener) {
  const line$2 = { val: line };
  const acc = moonbitlang$core$deque$$new$289$(moonbitlang$core$deque$$new$46$capacity$46$default$289$());
  _L: while (true) {
    let t;
    let l;
    _L$2: {
      _L$3: {
        const _bind = rami3l$cmark$cmark$$RevTokens$pop(rev_toks.val);
        if (_bind === undefined) {
          break;
        } else {
          const _Some = _bind;
          const _x = _Some;
          switch (_x.$tag) {
            case 2: {
              const _EmphasisMarks = _x;
              const _marks = _EmphasisMarks._0;
              const after = _marks.start;
              if (_marks.may_close && (opener.char === _marks.char && (_marks.may_open || !opener.may_close || ((_marks.count % 3 | 0) === 0 || ((opener.count + _marks.count | 0) % 3 | 0) !== 0)))) {
                const used = _marks.count >= 2 && opener.count >= 2 ? 2 : 1;
                const to_last = _marks.start - 1 | 0;
                rami3l$cmark$cmark$$tokens_shorten_last_line(to_last, acc);
                return { _0: line$2.val, _1: used, _2: acc, _3: _marks };
              } else {
                let _tmp;
                if (_marks.may_open) {
                  let _tmp$2;
                  let _return_value;
                  _L$4: {
                    _L$5: {
                      if (_marks.char === opener.char) {
                        _return_value = true;
                        break _L$5;
                      }
                      const after$2 = _marks.start;
                      _tmp$2 = moonbitlang$core$builtin$$op_lt$14$(rami3l$cmark$cmark$$CloserIndex$emphasis_pos(self.cidx, _marks.char, after$2), rami3l$cmark$cmark$$CloserIndex$emphasis_pos(self.cidx, opener.char, after$2));
                      break _L$4;
                    }
                    _tmp$2 = _return_value;
                  }
                  _tmp = _tmp$2;
                } else {
                  _tmp = false;
                }
                if (_tmp) {
                  const _bind$2 = rami3l$cmark$cmark$$Parser$try_emphasis(self, rev_toks, line$2.val, _marks);
                  if (_bind$2 === undefined) {
                  } else {
                    const _Some$2 = _bind$2;
                    const _l = _Some$2;
                    line$2.val = _l;
                  }
                } else {
                  rami3l$cmark$cmark$$Tokens$push(acc, _EmphasisMarks);
                  if (rami3l$cmark$cmark$$CloserIndex$has_emphasis(self.cidx, opener.char, after)) {
                  } else {
                    break _L;
                  }
                }
              }
              break;
            }
            case 5: {
              const _Newline = _x;
              const _x$2 = _Newline._0;
              const _l = _x$2.newline;
              t = _x;
              l = _l;
              break _L$3;
            }
            case 3: {
              const _Inline = _x;
              const _x$3 = _Inline._0;
              const _l$2 = _x$3.endline;
              t = _x;
              l = _l$2;
              break _L$3;
            }
            default: {
              rami3l$cmark$cmark$$Tokens$push(acc, _x);
            }
          }
        }
        break _L$2;
      }
      line$2.val = l;
      rami3l$cmark$cmark$$Tokens$push(acc, t);
    }
    continue;
  }
  let _tmp = moonbitlang$core$deque$$T$length$289$(acc) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      rami3l$cmark$cmark$$RevTokens$push(rev_toks.val, moonbitlang$core$deque$$T$op_get$289$(acc, i));
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function rami3l$cmark$cmark$$Parser$try_strikethrough(self, rev_toks, start_line, opener) {
  const start = opener.start;
  if (rami3l$cmark$cmark$$CloserIndex$has_strikethrough(self.cidx, start)) {
    const _bind = rami3l$cmark$cmark$$Parser$find_strikethrough_text(self, rev_toks, start_line);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _line = _x._0;
      const _stricken_toks = _x._1;
      const _closer = _x._2;
      const first = start + 2 | 0;
      const last = _closer.start - 1 | 0;
      const last$2 = moonbitlang$core$builtin$$Eq$op_equal$239$(start_line, _line) ? last : start_line.last;
      const text_start = { pos: start_line.pos, first: first, last: last$2 };
      const emph_toks = moonbitlang$core$ref$$Ref$new$354$(_stricken_toks);
      rami3l$cmark$cmark$$Parser$second_pass(self, emph_toks, text_start);
      const text = rami3l$cmark$cmark$$Parser$last_pass(self, emph_toks.val, text_start);
      const text$2 = rami3l$cmark$cmark$$Parser$inlines_inline(self, first, last, start_line, _line, text);
      rami3l$cmark$cmark$$RevTokens$push(rev_toks.val, rami3l$cmark$cmark$$Parser$ext_strikethough_token(self, opener.start, _closer.start + 1 | 0, start_line, _line, text$2));
      return _line;
    }
  } else {
    return undefined;
  }
}
function rami3l$cmark$cmark$$Parser$find_strikethrough_text(self, rev_toks, start_line) {
  const acc = moonbitlang$core$deque$$new$289$(moonbitlang$core$deque$$new$46$capacity$46$default$289$());
  const line = { val: start_line };
  while (true) {
    let t;
    let l;
    _L: {
      _L$2: {
        const _bind = rami3l$cmark$cmark$$RevTokens$pop(rev_toks.val);
        if (_bind === undefined) {
          break;
        } else {
          const _Some = _bind;
          const _x = _Some;
          switch (_x.$tag) {
            case 8: {
              const _StrikethroughMarks = _x;
              const _marks = _StrikethroughMarks._0;
              if (_marks.may_close) {
                const to_last = _marks.start - 1 | 0;
                rami3l$cmark$cmark$$tokens_shorten_last_line(to_last, acc);
                return { _0: line.val, _1: acc, _2: _marks };
              } else {
                if (_marks.may_open) {
                  const _bind$2 = rami3l$cmark$cmark$$Parser$try_strikethrough(self, rev_toks, line.val, _marks);
                  if (_bind$2 === undefined) {
                  } else {
                    const _Some$2 = _bind$2;
                    const _l = _Some$2;
                    line.val = _l;
                  }
                } else {
                  moonbitlang$core$abort$$abort$12$("unreachable");
                }
              }
              break;
            }
            case 5: {
              const _Newline = _x;
              const _x$2 = _Newline._0;
              const _l = _x$2.newline;
              t = _x;
              l = _l;
              break _L$2;
            }
            case 3: {
              const _Inline = _x;
              const _x$3 = _Inline._0;
              const _l$2 = _x$3.endline;
              t = _x;
              l = _l$2;
              break _L$2;
            }
            default: {
              rami3l$cmark$cmark$$Tokens$push(acc, _x);
            }
          }
        }
        break _L;
      }
      rami3l$cmark$cmark$$Tokens$push(acc, t);
      line.val = l;
    }
    continue;
  }
  let _tmp = moonbitlang$core$deque$$T$length$289$(acc) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      rami3l$cmark$cmark$$RevTokens$push(rev_toks.val, moonbitlang$core$deque$$T$op_get$289$(acc, i));
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function rami3l$cmark$cmark$$Parser$try_link(self, start_rev_toks, start_line, image, start) {
  const rev_toks = moonbitlang$core$ref$$Ref$new$355$(moonbitlang$core$deque$$T$copy$289$(start_rev_toks.val));
  if (rami3l$cmark$cmark$$CloserIndex$has_right_brack(self.cidx, start)) {
    const _bind = rami3l$cmark$cmark$$Parser$find_link_text_tokens(self, rev_toks, start_line, start);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _line = _x._0;
      const _text_toks = _x._1;
      const _text_last = _x._2;
      const first = (start + 1 | 0) + moonbitlang$core$bool$$Bool$to_int(image) | 0;
      const last = moonbitlang$core$builtin$$Eq$op_equal$239$(start_line, _line) ? _text_last - 1 | 0 : start_line.last;
      const _bind$2 = rami3l$cmark$cmark$$Parser$parse_tokens(self, _text_toks, { pos: start_line.pos, first: first, last: last });
      const _text = _bind$2._0;
      const _had_link = _bind$2._1;
      if (_had_link && !image) {
        return undefined;
      }
      return moonbitlang$core$option$$Option$map$62$(rami3l$cmark$cmark$$Parser$try_link_def(self, start, start_rev_toks, start_line, rev_toks, _line, _text_last, image, _text), (it) => {
        start_rev_toks.val = rev_toks.val;
        return it;
      });
    }
  } else {
    return undefined;
  }
}
function rami3l$cmark$cmark$$Parser$parse_tokens(self, toks, first_line) {
  const toks$2 = moonbitlang$core$ref$$Ref$new$354$(toks);
  const had_link = rami3l$cmark$cmark$$Parser$first_pass(self, toks$2, first_line);
  rami3l$cmark$cmark$$Parser$second_pass(self, toks$2, first_line);
  const inlines = rami3l$cmark$cmark$$Parser$last_pass(self, toks$2.val, first_line);
  return { _0: inlines, _1: had_link };
}
function rami3l$cmark$cmark$$Parser$first_pass(self, toks, line) {
  const acc = moonbitlang$core$deque$$new$289$(moonbitlang$core$deque$$new$46$capacity$46$default$289$());
  let had_link = false;
  let line$2 = line;
  const rev_toks = moonbitlang$core$ref$$Ref$new$355$(toks.val);
  _L: while (true) {
    const _bind = rami3l$cmark$cmark$$RevTokens$pop(rev_toks.val);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _t = _Some;
      switch (_t.$tag) {
        case 1: {
          const _Backticks = _t;
          const _x = _Backticks._0;
          const _start = _x.start;
          const _count = _x.count;
          const _escaped = _x.escaped;
          const _bind$2 = rami3l$cmark$cmark$$Parser$try_code(self, rev_toks, line$2, _start, _count, _escaped);
          if (_bind$2 === undefined) {
          } else {
            const _Some$2 = _bind$2;
            const _x$2 = _Some$2;
            const _line_ = _x$2._0;
            const _t$2 = _x$2._1;
            line$2 = _line_;
            rami3l$cmark$cmark$$Tokens$push(acc, _t$2);
          }
          break;
        }
        case 9: {
          const _MathSpanMarks = _t;
          const _x$2 = _MathSpanMarks._0;
          const _start$2 = _x$2.start;
          const _count$2 = _x$2.count;
          const _may_open = _x$2.may_open;
          _L$2: {
            _L$3: {
              if (_may_open) {
                const _bind$3 = rami3l$cmark$cmark$$Parser$try_math_span(self, rev_toks, line$2, _start$2, _count$2);
                if (_bind$3 === undefined) {
                  break _L$3;
                } else {
                  const _Some$2 = _bind$3;
                  const _x$3 = _Some$2;
                  const _line_ = _x$3._0;
                  const _t$2 = _x$3._1;
                  line$2 = _line_;
                  rami3l$cmark$cmark$$Tokens$push(acc, _t$2);
                }
              } else {
                break _L$3;
              }
              break _L$2;
            }
            continue _L;
          }
          break;
        }
        case 0: {
          const _AutolinkOrHtmlStart = _t;
          const _x$3 = _AutolinkOrHtmlStart._0;
          const _start$3 = _x$3.start;
          const _bind$3 = rami3l$cmark$cmark$$Parser$try_autolink_or_html(self, rev_toks, line$2, _start$3);
          if (_bind$3 === undefined) {
          } else {
            const _Some$2 = _bind$3;
            const _x$4 = _Some$2;
            const _line_ = _x$4._0;
            const _t$2 = _x$4._1;
            line$2 = _line_;
            rami3l$cmark$cmark$$Tokens$push(acc, _t$2);
          }
          break;
        }
        case 4: {
          const _LinkStart = _t;
          const _x$4 = _LinkStart._0;
          const _start$4 = _x$4.start;
          const _image = _x$4.image;
          const _bind$4 = rami3l$cmark$cmark$$Parser$try_link(self, rev_toks, line$2, _image, _start$4);
          if (_bind$4 === undefined) {
          } else {
            const _Some$2 = _bind$4;
            const _x$5 = _Some$2;
            const _l = _x$5._0;
            const _t$2 = _x$5._1;
            const _had_link_ = _x$5._2;
            rami3l$cmark$cmark$$Tokens$push(acc, _t$2);
            line$2 = _l;
            had_link = _had_link_;
          }
          break;
        }
        case 6: {
          break;
        }
        case 5: {
          const _Newline = _t;
          const _x$5 = _Newline._0;
          const _newline = _x$5.newline;
          line$2 = _newline;
          rami3l$cmark$cmark$$Tokens$push(acc, _Newline);
          break;
        }
        default: {
          rami3l$cmark$cmark$$Tokens$push(acc, _t);
        }
      }
      continue;
    }
  }
  toks.val = acc;
  return had_link;
}
function rami3l$cmark$cmark$$Parser$strip_paragraph(self, lines) {
  const _bind = moonbitlang$core$array$$Array$pop$239$(lines);
  let _bind$2;
  if (_bind === undefined) {
    _bind$2 = $panic();
  } else {
    const _Some = _bind;
    const _line = _Some;
    const _first = _line.first;
    const _start = _line.last;
    const non_blank = rami3l$cmark$cmark_base$$last_non_blank(self.i, _first, _start);
    const last = { pos: _line.pos, first: _line.first, last: non_blank };
    const trailing_blanks = rami3l$cmark$cmark$$Parser$layout_clean_raw_span1(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span1$46$pad$46$default(), { pos: _line.pos, first: non_blank + 1 | 0, last: _line.last });
    _bind$2 = { _0: last, _1: trailing_blanks };
  }
  const _last = _bind$2._0;
  const _trailing_blanks = _bind$2._1;
  moonbitlang$core$array$$Array$push$239$(lines, _last);
  const lines$2 = lines;
  const line = moonbitlang$core$array$$Array$op_get$239$(lines$2, 0);
  const non_blank = rami3l$cmark$cmark$$Parser$first_non_blank_in_span(self, line);
  const first = { pos: line.pos, first: non_blank, last: line.last };
  const leading_indent = non_blank - line.first | 0;
  moonbitlang$core$array$$Array$op_set$239$(lines$2, 0, first);
  return { _0: { _0: leading_indent, _1: _trailing_blanks }, _1: rami3l$cmark$cmark$$Parser$meta_of_spans(self, first, _last), _2: lines$2 };
}
function rami3l$cmark$cmark$$Parser$parse_inline(self, lines) {
  const _bind = rami3l$cmark$cmark$$Parser$strip_paragraph(self, lines);
  const _layout = _bind._0;
  const _meta = _bind._1;
  const _lines = _bind._2;
  const _bind$2 = rami3l$cmark$cmark$$tokenize(self.exts, self.i, _lines);
  const _cidx = _bind$2._0;
  const _toks = _bind$2._1;
  const _first_line = _bind$2._2;
  self.cidx = _cidx;
  const _bind$3 = rami3l$cmark$cmark$$Parser$parse_tokens(self, _toks, _first_line);
  const _is_ = _bind$3._0;
  let inline;
  if (_is_.length === 1) {
    const _i = _is_[0];
    inline = _i;
  } else {
    inline = new $64$rami3l$47$cmark$47$cmark$46$Inline$Inlines({ v: _is_, meta: _meta });
  }
  return { _0: _layout, _1: inline };
}
function rami3l$cmark$cmark$$Parser$get_blanks(self, line, before, k) {
  const nb = rami3l$cmark$cmark_base$$first_non_blank(self.i, before - 1 | 0, k);
  const line$2 = { pos: line.pos, first: k, last: nb - 1 | 0 };
  return { _0: rami3l$cmark$cmark$$Parser$layout_clean_raw_span1(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span1$46$pad$46$default(), line$2), _1: nb };
}
function rami3l$cmark$cmark$$Inline$meta(self) {
  switch (self.$tag) {
    case 0: {
      const _Autolink = self;
      const _x = _Autolink._0;
      const _meta = _x.meta;
      return _meta;
    }
    case 1: {
      const _Break = self;
      const _x$2 = _Break._0;
      const _meta$2 = _x$2.meta;
      return _meta$2;
    }
    case 2: {
      const _CodeSpan = self;
      const _x$3 = _CodeSpan._0;
      const _meta$3 = _x$3.meta;
      return _meta$3;
    }
    case 3: {
      const _Emphasis = self;
      const _x$4 = _Emphasis._0;
      const _meta$4 = _x$4.meta;
      return _meta$4;
    }
    case 4: {
      const _Image = self;
      const _x$5 = _Image._0;
      const _meta$5 = _x$5.meta;
      return _meta$5;
    }
    case 5: {
      const _Inlines = self;
      const _x$6 = _Inlines._0;
      const _meta$6 = _x$6.meta;
      return _meta$6;
    }
    case 6: {
      const _Link = self;
      const _x$7 = _Link._0;
      const _meta$7 = _x$7.meta;
      return _meta$7;
    }
    case 7: {
      const _RawHtml = self;
      const _x$8 = _RawHtml._0;
      const _meta$8 = _x$8.meta;
      return _meta$8;
    }
    case 8: {
      const _StrongEmphasis = self;
      const _x$9 = _StrongEmphasis._0;
      const _meta$9 = _x$9.meta;
      return _meta$9;
    }
    case 9: {
      const _Text = self;
      const _x$10 = _Text._0;
      const _meta$10 = _x$10.meta;
      return _meta$10;
    }
    case 10: {
      const _ExtStrikethrough = self;
      const _x$11 = _ExtStrikethrough._0;
      const _meta$11 = _x$11.meta;
      return _meta$11;
    }
    default: {
      const _ExtMathSpan = self;
      const _x$12 = _ExtMathSpan._0;
      const _meta$12 = _x$12.meta;
      return _meta$12;
    }
  }
}
function rami3l$cmark$cmark$$Parser$meta_of_metas(self, first, last) {
  if (self.no_locs) {
    return rami3l$cmark$cmark_base$$Meta$none();
  }
  return rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark_base$$TextLoc$span(first.loc, last.loc));
}
function rami3l$cmark$cmark$$Parser$make_col(self, is_) {
  if (is_.length === 0) {
    return moonbitlang$core$abort$$abort$51$("unreachable");
  } else {
    if (is_.length === 1) {
      const _i = is_[0];
      return _i;
    } else {
      const first = rami3l$cmark$cmark$$Inline$meta(moonbitlang$core$array$$Array$op_get$51$(is_, 0));
      const last = rami3l$cmark$cmark$$Inline$meta(moonbitlang$core$array$$Array$op_get$51$(is_, is_.length - 1 | 0));
      const meta = rami3l$cmark$cmark$$Parser$meta_of_metas(self, first, last);
      return new $64$rami3l$47$cmark$47$cmark$46$Inline$Inlines({ v: is_, meta: meta });
    }
  }
}
function rami3l$cmark$cmark$$find_pipe$46$text$124$1269(_env, first, last) {
  const self = _env._1;
  const line = _env._0;
  const line$2 = { pos: line.pos, first: first, last: last };
  return new $64$rami3l$47$cmark$47$cmark$46$Inline$Text(rami3l$cmark$cmark$$Parser$clean_unesc_unref_span(self, line$2));
}
function rami3l$cmark$cmark$$Parser$find_pipe(self, line, before, k) {
  const _env = { _0: line, _1: self };
  const n = rami3l$cmark$cmark_base$$first_non_escaped_char(124, self.i, before - 1 | 0, k);
  if (n === before) {
    return new Result$Err$78$(rami3l$cmark$cmark$$find_pipe$46$text$124$1269(_env, k, n - 1 | 0));
  }
  const nb = rami3l$cmark$cmark_base$$last_non_blank(self.i, k, n - 1 | 0);
  const after = rami3l$cmark$cmark$$Parser$layout_clean_raw_span1(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span1$46$pad$46$default(), { pos: line.pos, first: nb + 1 | 0, last: n - 1 | 0 });
  const text = nb < k ? undefined : rami3l$cmark$cmark$$find_pipe$46$text$124$1269(_env, k, nb);
  return new Result$Ok$78$({ _0: text, _1: after, _2: n + 1 | 0 });
}
function rami3l$cmark$cmark$$Parser$start_col(self, line, before, k) {
  const _bind = rami3l$cmark$cmark$$Parser$get_blanks(self, line, before, k);
  const _bbefore = _bind._0;
  const _k = _bind._1;
  if (_k >= before) {
    return new $64$rami3l$47$cmark$47$cmark$46$StartColResult$Start(_bbefore, []);
  }
  const _bind$2 = rami3l$cmark$cmark$$Parser$find_pipe(self, line, before, _k);
  if (_bind$2.$tag === 0) {
    const _Err = _bind$2;
    const _text = _Err._0;
    return new $64$rami3l$47$cmark$47$cmark$46$StartColResult$Start(_bbefore, [_text]);
  } else {
    const _Ok = _bind$2;
    const _x = _Ok._0;
    const _text = _x._0;
    const _bafter = _x._1;
    const _k$2 = _x._2;
    const text = moonbitlang$core$option$$Option$or_else$51$(_text, () => {
      const l = rami3l$cmark$cmark$$Parser$text_loc_of_span(self, { pos: line.pos, first: _k$2, last: _k$2 - 1 | 0 });
      return new $64$rami3l$47$cmark$47$cmark$46$Inline$Inlines({ v: [], meta: rami3l$cmark$cmark$$Parser$meta(self, l) });
    });
    return new $64$rami3l$47$cmark$47$cmark$46$StartColResult$Col({ _0: text, _1: { _0: _bbefore, _1: _bafter } }, _k$2);
  }
}
function rami3l$cmark$cmark$$Parser$finish_col(self, line, blanks_before, is_, toks, k) {
  let _tmp = k;
  while (true) {
    const _param = _tmp;
    if (moonbitlang$core$deque$$T$is_empty$289$(toks)) {
      const _bind = rami3l$cmark$cmark$$Parser$find_pipe(self, line, line.last + 1 | 0, _param);
      if (_bind.$tag === 1) {
        const _Ok = _bind;
        const _x = _Ok._0;
        const _text = _x._0;
        const _after = _x._1;
        const _k = _x._2;
        moonbitlang$core$array$$Array$push_iter$51$(is_, moonbitlang$core$option$$Option$iter$51$(_text));
        return { _0: { _0: rami3l$cmark$cmark$$Parser$make_col(self, is_), _1: { _0: blanks_before, _1: _after } }, _1: _k };
      } else {
        $panic();
      }
    }
    _L: {
      const _bind = moonbitlang$core$deque$$T$front$289$(toks);
      if (_bind === undefined) {
        break _L;
      } else {
        const _Some = _bind;
        const _x = _Some;
        if (_x.$tag === 3) {
          const _Inline = _x;
          const _x$2 = _Inline._0;
          const _start = _x$2.start;
          const _inline = _x$2.inline;
          const _next = _x$2.next;
          if (_param >= _start) {
            moonbitlang$core$deque$$T$unsafe_pop_front$289$(toks);
            moonbitlang$core$array$$Array$push$51$(is_, _inline);
            continue;
          }
          const _bind$2 = rami3l$cmark$cmark$$Parser$find_pipe(self, line, _start, _param);
          if (_bind$2.$tag === 0) {
            const _Err = _bind$2;
            const _text = _Err._0;
            moonbitlang$core$array$$Array$push$51$(is_, _text);
            moonbitlang$core$array$$Array$push$51$(is_, _inline);
            moonbitlang$core$deque$$T$unsafe_pop_front$289$(toks);
            _tmp = _next;
            continue;
          } else {
            const _Ok = _bind$2;
            const _x$3 = _Ok._0;
            const _text = _x$3._0;
            const _after = _x$3._1;
            const _k = _x$3._2;
            moonbitlang$core$array$$Array$push_iter$51$(is_, moonbitlang$core$option$$Option$iter$51$(_text));
            return { _0: { _0: rami3l$cmark$cmark$$Parser$make_col(self, is_), _1: { _0: blanks_before, _1: _after } }, _1: _k };
          }
        } else {
          break _L;
        }
      }
    }
    return $panic();
  }
}
function rami3l$cmark$cmark$$Parser$parse_cols(self, line, acc, toks, k) {
  let _tmp = line;
  let _tmp$2 = k;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if (moonbitlang$core$deque$$T$is_empty$289$(toks)) {
      if (_param$2 <= _param.last) {
        const _bind = rami3l$cmark$cmark$$Parser$start_col(self, _param, _param.last + 1 | 0, _param$2);
        if (_bind.$tag === 0) {
          const _Col = _bind;
          const _col = _Col._0;
          const _k = _Col._1;
          moonbitlang$core$array$$Array$push$218$(acc, _col);
          _tmp$2 = _k;
          continue;
        } else {
          $panic();
        }
      } else {
        break;
      }
    }
    _L: {
      const _bind = moonbitlang$core$deque$$T$front$289$(toks);
      if (_bind === undefined) {
        break _L;
      } else {
        const _Some = _bind;
        const _x = _Some;
        if (_x.$tag === 3) {
          const _Inline = _x;
          const _x$2 = _Inline._0;
          const _start = _x$2.start;
          const _inline = _x$2.inline;
          const _next = _x$2.next;
          const _bind$2 = rami3l$cmark$cmark$$Parser$start_col(self, _param, _start, _param$2);
          if (_bind$2.$tag === 0) {
            const _Col = _bind$2;
            const _col = _Col._0;
            const _k = _Col._1;
            moonbitlang$core$array$$Array$push$218$(acc, _col);
            _tmp$2 = _k;
            continue;
          } else {
            const _Start = _bind$2;
            const _before = _Start._0;
            const _is_ = _Start._1;
            moonbitlang$core$deque$$T$unsafe_pop_front$289$(toks);
            moonbitlang$core$array$$Array$push$51$(_is_, _inline);
            const _bind$3 = rami3l$cmark$cmark$$Parser$finish_col(self, _param, _before, _is_, toks, _next);
            const _col = _bind$3._0;
            const _k = _bind$3._1;
            moonbitlang$core$array$$Array$push$218$(acc, _col);
            _tmp$2 = _k;
            continue;
          }
        } else {
          break _L;
        }
      }
    }
    $panic();
    return;
  }
}
function rami3l$cmark$cmark$$Parser$parse_table_row(self, line) {
  const _bind = rami3l$cmark$cmark$$tokenize(self.exts, self.i, [line]);
  const _cidx = _bind._0;
  const _toks = _bind._1;
  const _first_line = _bind._2;
  self.cidx = _cidx;
  const toks = moonbitlang$core$ref$$Ref$new$354$(_toks);
  rami3l$cmark$cmark$$Parser$first_pass(self, toks, _first_line);
  rami3l$cmark$cmark$$Parser$second_pass(self, toks, _first_line);
  const rows = [];
  rami3l$cmark$cmark$$Parser$parse_cols(self, line, rows, toks.val, line.first);
  return rows;
}
function rami3l$cmark$cmark$$Folder$fold_inline$376$(self, acc, i) {
  let _tmp = self;
  let _tmp$2 = acc;
  let _tmp$3 = i;
  _L: while (true) {
    const self$2 = _tmp;
    const acc$2 = _tmp$2;
    const i$2 = _tmp$3;
    const _func = self$2.inline;
    const _bind = _func(self$2, acc$2, i$2);
    if (_bind.$tag === 1) {
      const _Fold = _bind;
      const _acc = _Fold._0;
      return new Result$Ok$79$(_acc);
    }
    let v;
    _L$2: {
      let v$2;
      _L$3: {
        _L$4: {
          switch (i$2.$tag) {
            case 0: {
              break _L$4;
            }
            case 1: {
              break _L$4;
            }
            case 2: {
              break _L$4;
            }
            case 7: {
              break _L$4;
            }
            case 9: {
              break _L$4;
            }
            case 11: {
              break _L$4;
            }
            case 4: {
              const _Image = i$2;
              const _x = _Image._0;
              const _v = _x.v;
              v$2 = _v;
              break _L$3;
            }
            case 6: {
              const _Link = i$2;
              const _x$2 = _Link._0;
              const _v$2 = _x$2.v;
              v$2 = _v$2;
              break _L$3;
            }
            case 3: {
              const _Emphasis = i$2;
              const _x$3 = _Emphasis._0;
              const _v$3 = _x$3.v;
              v = _v$3;
              break _L$2;
            }
            case 8: {
              const _StrongEmphasis = i$2;
              const _x$4 = _StrongEmphasis._0;
              const _v$4 = _x$4.v;
              v = _v$4;
              break _L$2;
            }
            case 5: {
              const _Inlines = i$2;
              const _x$5 = _Inlines._0;
              const _is_ = _x$5.v;
              const acc$3 = { val: acc$2 };
              const _foreach_result = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$80$ };
              const _bind$2 = rami3l$cmark$cmark$$Seq$iter$51$(_is_);
              _bind$2((x) => {
                let _foreach_error;
                _L$5: {
                  const _bind$3 = rami3l$cmark$cmark$$Folder$fold_inline$376$(self$2, acc$3.val, x);
                  let _tmp$4;
                  if (_bind$3.$tag === 1) {
                    const _ok = _bind$3;
                    _tmp$4 = _ok._0;
                  } else {
                    const _err = _bind$3;
                    const _tmp$5 = _err._0;
                    _foreach_error = _tmp$5;
                    break _L$5;
                  }
                  acc$3.val = _tmp$4;
                  return 1;
                }
                _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$80$(_foreach_error);
                return 0;
              });
              const _tmp$4 = _foreach_result.val;
              switch (_tmp$4.$tag) {
                case 0: {
                  break;
                }
                case 1: {
                  const _break = _tmp$4;
                  _break._0;
                  break;
                }
                case 2: {
                  const _return = _tmp$4;
                  return new Result$Ok$79$(_return._0);
                }
                case 3: {
                  const _error = _tmp$4;
                  return new Result$Err$79$(_error._0);
                }
                default: {
                  $panic();
                }
              }
              return new Result$Ok$79$(acc$3.val);
            }
            default: {
              const _ExtStrikethrough = i$2;
              const _x$6 = _ExtStrikethrough._0;
              const _v$5 = _x$6.v;
              _tmp$3 = _v$5;
              continue _L;
            }
          }
        }
        return new Result$Ok$79$(acc$2);
      }
      _tmp$3 = v$2.text;
      continue;
    }
    _tmp$3 = v.inline;
    continue;
  }
}
function rami3l$cmark$cmark$$Folder$fold_block$376$(self, acc, b) {
  let _tmp = self;
  let _tmp$2 = acc;
  let _tmp$3 = b;
  _L: while (true) {
    const self$2 = _tmp;
    const acc$2 = _tmp$2;
    const b$2 = _tmp$3;
    const _func = self$2.block;
    const _bind = _func(self$2, acc$2, b$2);
    if (_bind.$tag === 1) {
      const _Fold = _bind;
      const _acc = _Fold._0;
      return new Result$Ok$79$(_acc);
    }
    _L$2: {
      switch (b$2.$tag) {
        case 0: {
          break _L$2;
        }
        case 3: {
          break _L$2;
        }
        case 5: {
          break _L$2;
        }
        case 6: {
          break _L$2;
        }
        case 9: {
          break _L$2;
        }
        case 10: {
          break _L$2;
        }
        case 4: {
          const _Heading = b$2;
          const _x = _Heading._0;
          const _v = _x.v;
          return rami3l$cmark$cmark$$Folder$fold_inline$376$(self$2, acc$2, _v.inline);
        }
        case 1: {
          const _BlockQuote = b$2;
          const _x$2 = _BlockQuote._0;
          const _v$2 = _x$2.v;
          _tmp$3 = _v$2.block;
          continue _L;
        }
        case 2: {
          const _Blocks = b$2;
          const _x$3 = _Blocks._0;
          const _v$3 = _x$3.v;
          const acc$3 = { val: acc$2 };
          const _foreach_result = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$80$ };
          const _bind$2 = rami3l$cmark$cmark$$Seq$iter$93$(_v$3);
          _bind$2((x) => {
            let _foreach_error;
            _L$3: {
              const _bind$3 = rami3l$cmark$cmark$$Folder$fold_block$376$(self$2, acc$3.val, x);
              let _tmp$4;
              if (_bind$3.$tag === 1) {
                const _ok = _bind$3;
                _tmp$4 = _ok._0;
              } else {
                const _err = _bind$3;
                const _tmp$5 = _err._0;
                _foreach_error = _tmp$5;
                break _L$3;
              }
              acc$3.val = _tmp$4;
              return 1;
            }
            _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$80$(_foreach_error);
            return 0;
          });
          const _tmp$4 = _foreach_result.val;
          switch (_tmp$4.$tag) {
            case 0: {
              break;
            }
            case 1: {
              const _break = _tmp$4;
              _break._0;
              break;
            }
            case 2: {
              const _return = _tmp$4;
              return new Result$Ok$79$(_return._0);
            }
            case 3: {
              const _error = _tmp$4;
              return new Result$Err$79$(_error._0);
            }
            default: {
              $panic();
            }
          }
          return new Result$Ok$79$(acc$3.val);
        }
        case 7: {
          const _List = b$2;
          const _x$4 = _List._0;
          const _v$4 = _x$4.v;
          const acc$4 = { val: acc$2 };
          const _foreach_result$2 = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$80$ };
          const _bind$3 = rami3l$cmark$cmark$$Seq$iter$198$(_v$4.items);
          _bind$3((x) => {
            let _foreach_error;
            _L$3: {
              const _bind$4 = rami3l$cmark$cmark$$Folder$fold_block$376$(self$2, acc$4.val, x.v.block);
              let _tmp$5;
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp$5 = _ok._0;
              } else {
                const _err = _bind$4;
                const _tmp$6 = _err._0;
                _foreach_error = _tmp$6;
                break _L$3;
              }
              acc$4.val = _tmp$5;
              return 1;
            }
            _foreach_result$2.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$80$(_foreach_error);
            return 0;
          });
          const _tmp$5 = _foreach_result$2.val;
          switch (_tmp$5.$tag) {
            case 0: {
              break;
            }
            case 1: {
              const _break$2 = _tmp$5;
              _break$2._0;
              break;
            }
            case 2: {
              const _return$2 = _tmp$5;
              return new Result$Ok$79$(_return$2._0);
            }
            case 3: {
              const _error$2 = _tmp$5;
              return new Result$Err$79$(_error$2._0);
            }
            default: {
              $panic();
            }
          }
          return new Result$Ok$79$(acc$4.val);
        }
        case 8: {
          const _Paragraph = b$2;
          const _x$5 = _Paragraph._0;
          const _v$5 = _x$5.v;
          return rami3l$cmark$cmark$$Folder$fold_inline$376$(self$2, acc$2, _v$5.inline);
        }
        case 11: {
          const _ExtTable = b$2;
          const _x$6 = _ExtTable._0;
          const _v$6 = _x$6.v;
          const acc$5 = { val: acc$2 };
          const _foreach_result$3 = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$80$ };
          const _bind$4 = rami3l$cmark$cmark$$Seq$iter$200$(_v$6.rows);
          _bind$4((x) => {
            let _foreach_error;
            _L$3: {
              let is_;
              _L$4: {
                _L$5: {
                  const _bind$5 = x._0.v;
                  switch (_bind$5.$tag) {
                    case 0: {
                      const _Header = _bind$5;
                      const _is_ = _Header._0;
                      is_ = _is_;
                      break _L$5;
                    }
                    case 2: {
                      const _Data = _bind$5;
                      const _is_$2 = _Data._0;
                      is_ = _is_$2;
                      break _L$5;
                    }
                  }
                  break _L$4;
                }
                const _foreach_result$4 = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$80$ };
                const _bind$5 = rami3l$cmark$cmark$$Seq$iter$218$(is_);
                _bind$5((y) => {
                  let _foreach_error$2;
                  _L$6: {
                    const _bind$6 = rami3l$cmark$cmark$$Folder$fold_inline$376$(self$2, acc$5.val, y._0);
                    let _tmp$6;
                    if (_bind$6.$tag === 1) {
                      const _ok = _bind$6;
                      _tmp$6 = _ok._0;
                    } else {
                      const _err = _bind$6;
                      const _tmp$7 = _err._0;
                      _foreach_error$2 = _tmp$7;
                      break _L$6;
                    }
                    acc$5.val = _tmp$6;
                    return 1;
                  }
                  _foreach_result$4.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$80$(_foreach_error$2);
                  return 0;
                });
                const _tmp$6 = _foreach_result$4.val;
                switch (_tmp$6.$tag) {
                  case 0: {
                    break;
                  }
                  case 1: {
                    const _break$3 = _tmp$6;
                    _break$3._0;
                    break;
                  }
                  case 2: {
                    const _return$3 = _tmp$6;
                    _foreach_result$3.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$80$(_return$3._0);
                    return 0;
                  }
                  case 3: {
                    const _error$3 = _tmp$6;
                    const _tmp$7 = _error$3._0;
                    _foreach_error = _tmp$7;
                    break _L$3;
                  }
                  default: {
                    $panic();
                  }
                }
              }
              return 1;
            }
            _foreach_result$3.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$80$(_foreach_error);
            return 0;
          });
          const _tmp$6 = _foreach_result$3.val;
          switch (_tmp$6.$tag) {
            case 0: {
              break;
            }
            case 1: {
              const _break$3 = _tmp$6;
              _break$3._0;
              break;
            }
            case 2: {
              const _return$3 = _tmp$6;
              return new Result$Ok$79$(_return$3._0);
            }
            case 3: {
              const _error$3 = _tmp$6;
              return new Result$Err$79$(_error$3._0);
            }
            default: {
              $panic();
            }
          }
          return new Result$Ok$79$(acc$5.val);
        }
        default: {
          const _ExtFootnoteDefinition = b$2;
          const _x$7 = _ExtFootnoteDefinition._0;
          const _v$7 = _x$7.v;
          _tmp$3 = _v$7.block;
          continue _L;
        }
      }
    }
    return new Result$Ok$79$(acc$2);
  }
}
function rami3l$cmark$cmark$$Folder$fold_doc$376$(self, acc, doc) {
  return rami3l$cmark$cmark$$Folder$fold_block$376$(self, acc, doc.block);
}
function moonbitlang$core$builtin$$Show$output$95$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$142$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$97$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$143$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$99$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$144$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$101$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$145$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$103$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$146$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$105$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$147$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$107$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$149$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$109$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$9$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$111$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$150$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$113$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$151$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$121$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$155$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$123$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$156$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$125$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$158$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$127$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$159$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$129$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$160$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$131$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$161$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$133$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$162$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$135$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$163$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$137$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$164$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$139$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$165$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$141$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$166$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$197$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$7$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$199$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$202$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$204$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$207$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$209$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$10$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function moonbitlang$core$builtin$$Show$output$221$(self, logger) {
  logger.method_0(logger.self, "Node::new(");
  moonbitlang$core$builtin$$Logger$write_object$224$(logger, self.v);
  if (!rami3l$cmark$cmark_base$$Meta$is_none(self.meta)) {
    logger.method_0(logger.self, ", meta=");
    moonbitlang$core$builtin$$Logger$write_object$119$(logger, self.meta);
  }
  logger.method_2(logger.self, 41);
}
function rami3l$cmark$cmark$$Seq$empty$9$() {
  return [];
}
function rami3l$cmark$cmark$$Seq$to_array$23$(self) {
  return self;
}
function rami3l$cmark$cmark$$Seq$to_array$376$(self) {
  return self;
}
function rami3l$cmark$cmark$$Seq$to_array$200$(self) {
  return self;
}
function rami3l$cmark$cmark$$Tight$list_text_loc(ls) {
  const _bind = ls;
  if (_bind.length === 0) {
    return rami3l$cmark$cmark_base$$TextLoc$none();
  } else {
    if (_bind.length === 1) {
      const _head = _bind[0];
      return _head.node.meta.loc;
    } else {
      const _head = _bind[0];
      const _last = _bind[_bind.length - 1 | 0];
      return rami3l$cmark$cmark_base$$TextLoc$reloc(_head.node.meta.loc, _last.node.meta.loc);
    }
  }
}
function rami3l$cmark$cmark$$Label$text_loc(self) {
  return rami3l$cmark$cmark$$Tight$list_text_loc(self.text);
}
function rami3l$cmark$cmark$$LabelContext$default_resolver(self) {
  if (self.$tag === 0) {
    const _Def = self;
    const _x = _Def._0;
    if (_x === undefined) {
      const _k = _Def._1;
      return _k;
    } else {
      return undefined;
    }
  } else {
    const _Ref = self;
    const _k = _Ref._2;
    return _k;
  }
}
function rami3l$cmark$cmark$$Tight$to_string(self) {
  return self.node.v;
}
function rami3l$cmark$cmark$$InlineCodeSpan$code(self) {
  const _bind = rami3l$cmark$cmark$$Seq$iter$167$(self.code_layout);
  const _lhs = moonbitlang$core$builtin$$Iter$to_array$9$((_p) => _bind((_p$2) => _p(rami3l$cmark$cmark$$Tight$to_string(_p$2))));
  const s = moonbitlang$core$string$$concat(_lhs, " ");
  if (s === "") {
    return "";
  }
  let _tmp;
  $bound_check(s, 0);
  if (s.charCodeAt(0) === 32) {
    let _tmp$2;
    const _tmp$3 = s.length - 1 | 0;
    $bound_check(s, _tmp$3);
    if (s.charCodeAt(_tmp$3) === 32) {
      _tmp$2 = !moonbitlang$core$builtin$$Iter$all$10$(moonbitlang$core$string$$String$iter(s), (it) => it === 32);
    } else {
      _tmp$2 = false;
    }
    _tmp = _tmp$2;
  } else {
    _tmp = false;
  }
  if (_tmp) {
    return moonbitlang$core$string$$String$substring(s, 1, s.length - 1 | 0);
  }
  return s;
}
function rami3l$cmark$cmark$$InlineMathSpan$tex(self) {
  const _p = self.tex_layout;
  const _p$2 = new Array(_p.length);
  const _p$3 = _p.length;
  let _tmp = 0;
  while (true) {
    const _p$4 = _tmp;
    if (_p$4 < _p$3) {
      const _p$5 = _p[_p$4];
      _p$2[_p$4] = rami3l$cmark$cmark$$Tight$to_string(_p$5);
      _tmp = _p$4 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _lhs = _p$2;
  return moonbitlang$core$string$$concat(_lhs, " ");
}
function rami3l$cmark$cmark$$to_plain_text$46$push$124$958(acc, s) {
  moonbitlang$core$array$$Array$push$9$(rami3l$cmark$cmark$$Seq$op_get$240$(acc, rami3l$cmark$cmark$$Seq$length$240$(acc) - 1 | 0), s);
}
function rami3l$cmark$cmark$$to_plain_text$46$newline$124$959(acc) {
  moonbitlang$core$array$$Array$push$240$(acc, []);
}
function rami3l$cmark$cmark$$Inline$to_plain_text(self, break_on_soft) {
  const acc = rami3l$cmark$cmark$$Seq$from_array$240$([rami3l$cmark$cmark$$Seq$empty$9$()]);
  const st = [self];
  while (true) {
    const _bind = moonbitlang$core$array$$Array$pop$51$(st);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _curr = _Some;
      let inline;
      _L: {
        _L$2: {
          switch (_curr.$tag) {
            case 0: {
              const _Autolink = _curr;
              const _a = _Autolink._0;
              rami3l$cmark$cmark$$to_plain_text$46$push$124$958(acc, `<${moonbitlang$core$builtin$$Show$to_string$9$(_a.v.link.v)}>`);
              break;
            }
            case 1: {
              const _Break = _curr;
              const _x = _Break._0;
              const _x$2 = _x.v;
              const _x$3 = _x$2.ty;
              if (_x$3 === 0) {
                rami3l$cmark$cmark$$to_plain_text$46$newline$124$959(acc);
              } else {
                if (break_on_soft) {
                  rami3l$cmark$cmark$$to_plain_text$46$newline$124$959(acc);
                } else {
                  rami3l$cmark$cmark$$to_plain_text$46$push$124$958(acc, " ");
                }
              }
              break;
            }
            case 2: {
              const _CodeSpan = _curr;
              const _cs = _CodeSpan._0;
              rami3l$cmark$cmark$$to_plain_text$46$push$124$958(acc, rami3l$cmark$cmark$$InlineCodeSpan$code(_cs.v));
              break;
            }
            case 3: {
              const _Emphasis = _curr;
              const _x$4 = _Emphasis._0;
              const _x$5 = _x$4.v;
              const _inline = _x$5.inline;
              inline = _inline;
              break _L$2;
            }
            case 8: {
              const _StrongEmphasis = _curr;
              const _x$6 = _StrongEmphasis._0;
              const _x$7 = _x$6.v;
              const _inline$2 = _x$7.inline;
              inline = _inline$2;
              break _L$2;
            }
            case 5: {
              const _Inlines = _curr;
              const _x$8 = _Inlines._0;
              const _is1 = _x$8.v;
              const _arr = moonbitlang$core$array$$Array$rev$51$(_is1);
              const _len = _arr.length;
              let _tmp = 0;
              while (true) {
                const _i = _tmp;
                if (_i < _len) {
                  const i = _arr[_i];
                  moonbitlang$core$array$$Array$push$51$(st, i);
                  _tmp = _i + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              break;
            }
            case 6: {
              const _Link = _curr;
              const _l = _Link._0;
              moonbitlang$core$array$$Array$push$51$(st, _l.v.text);
              break;
            }
            case 7: {
              break;
            }
            case 9: {
              const _Text = _curr;
              const _t = _Text._0;
              rami3l$cmark$cmark$$to_plain_text$46$push$124$958(acc, _t.v);
              break;
            }
            case 10: {
              const _ExtStrikethrough = _curr;
              const _i = _ExtStrikethrough._0;
              moonbitlang$core$array$$Array$push$51$(st, _i.v);
              break;
            }
            case 11: {
              const _ExtMathSpan = _curr;
              const _m = _ExtMathSpan._0;
              rami3l$cmark$cmark$$to_plain_text$46$push$124$958(acc, rami3l$cmark$cmark$$InlineMathSpan$tex(_m.v));
              break;
            }
            default: {
              moonbitlang$core$array$$Array$push$51$(st, _curr);
            }
          }
          break _L;
        }
        moonbitlang$core$array$$Array$push$51$(st, inline);
      }
    }
    continue;
  }
  return acc;
}
function rami3l$cmark$cmark$$id$46$collapse_blanks$124$937(buf, prev) {
  if (rami3l$cmark$char$$is_ascii_blank(prev) && !moonbitlang$core$builtin$$StringBuilder$is_empty(buf)) {
    moonbitlang$core$builtin$$Logger$write_char$71$(buf, 45);
    return;
  } else {
    return;
  }
}
function rami3l$cmark$cmark$$Inline$id(self, buf) {
  const text = rami3l$cmark$cmark$$Inline$to_plain_text(self, false);
  const _p = new Array(text.length);
  const _p$2 = text.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = text[_p$3];
      const l = _p$4;
      _p[_p$3] = moonbitlang$core$string$$concat(l, moonbitlang$core$string$$concat$46$separator$46$default());
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _lhs = _p;
  const s = moonbitlang$core$string$$concat(_lhs, "\n");
  let _tmp$2 = s;
  let _tmp$3 = s.length - 1 | 0;
  let _tmp$4 = 0;
  let _tmp$5 = 0;
  _L: while (true) {
    const _param = _tmp$2;
    const _param$2 = _tmp$3;
    const _param$3 = _tmp$4;
    const _param$4 = _tmp$5;
    if (_param$4 > _param$2) {
      return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
    }
    let c;
    _L$2: {
      let prev_byte;
      _L$3: {
        $bound_check(_param, _param$4);
        const _bind = _param.charCodeAt(_param$4);
        switch (_bind) {
          case 32: {
            prev_byte = _bind;
            break _L$3;
          }
          case 9: {
            prev_byte = _bind;
            break _L$3;
          }
          case 95: {
            c = _bind;
            break _L$2;
          }
          case 45: {
            c = _bind;
            break _L$2;
          }
          default: {
            rami3l$cmark$cmark$$id$46$collapse_blanks$124$937(buf, _param$3);
            let u = rami3l$cmark$char$$at(_param, _param$4);
            if (u === 0) {
              u = rami3l$cmark$char$$rep;
            }
            const k = _param$4 + rami3l$cmark$char$$length_utf16(u) | 0;
            if (rami3l$cmark$char$$is_ascii_punctuation(_bind)) {
              _tmp$4 = 0;
              _tmp$5 = k;
              continue _L;
            }
            moonbitlang$core$builtin$$Logger$write_char$71$(buf, rami3l$cmark$char$$to_ascii_lower(u));
            _tmp$4 = _bind;
            _tmp$5 = k;
            continue _L;
          }
        }
      }
      const _tmp$6 = _param$4 + 1 | 0;
      _tmp$4 = prev_byte;
      _tmp$5 = _tmp$6;
      continue;
    }
    rami3l$cmark$cmark$$id$46$collapse_blanks$124$937(buf, _param$3);
    moonbitlang$core$builtin$$Logger$write_char$71$(buf, c);
    const _tmp$6 = _param$4 + 1 | 0;
    _tmp$4 = c;
    _tmp$5 = _tmp$6;
    continue;
  }
}
function rami3l$cmark$cmark$$Inline$id$46$buf$46$default() {
  return moonbitlang$core$builtin$$StringBuilder$new(256);
}
function rami3l$cmark$cmark$$Parser$curr_col(self) {
  return self.curr_char_col + self.tab_consumed_cols | 0;
}
function rami3l$cmark$cmark$$Parser$curr_indent(self) {
  return self.next_non_blank_col - rami3l$cmark$cmark$$Parser$curr_col(self) | 0;
}
function rami3l$cmark$cmark$$Parser$end_of_line(self) {
  return self.curr_char > self.curr_line_last_char;
}
function rami3l$cmark$cmark$$Parser$only_blanks(self) {
  return self.next_non_blank > self.curr_line_last_char;
}
function rami3l$cmark$cmark$$Parser$has_next_non_blank(self) {
  return self.next_non_blank <= self.curr_line_last_char;
}
function rami3l$cmark$cmark$$next_tab_stop(col) {
  return col + 4 & ~3;
}
function rami3l$cmark$cmark$$Parser$update_next_non_blank(self) {
  let _tmp = self.i;
  let _tmp$2 = self.curr_line_last_char;
  let _tmp$3 = self.curr_char;
  let _tmp$4 = self.curr_char_col;
  _L: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    if (_param$3 > _param$2) {
      self.next_non_blank = _param$3;
      self.next_non_blank_col = _param$4;
      return;
    } else {
      $bound_check(_param, _param$3);
      const _bind = _param.charCodeAt(_param$3);
      switch (_bind) {
        case 32: {
          const _tmp$5 = _param$3 + 1 | 0;
          const _tmp$6 = _param$4 + 1 | 0;
          _tmp$3 = _tmp$5;
          _tmp$4 = _tmp$6;
          continue _L;
        }
        case 9: {
          const _tmp$7 = _param$3 + 1 | 0;
          const _tmp$8 = rami3l$cmark$cmark$$next_tab_stop(_param$4);
          _tmp$3 = _tmp$7;
          _tmp$4 = _tmp$8;
          continue _L;
        }
        default: {
          self.next_non_blank = _param$3;
          self.next_non_blank_col = _param$4;
          return;
        }
      }
    }
  }
}
function rami3l$cmark$cmark$$Parser$accept_cols(self, count) {
  let _tmp = count;
  let _tmp$2 = self.curr_char;
  let _tmp$3 = self.curr_char_col;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    if (_param === 0) {
      self.curr_char = _param$2;
      self.curr_char_col = _param$3;
      break;
    } else {
      const _tmp$4 = self.i;
      $bound_check(_tmp$4, _param$2);
      if (_tmp$4.charCodeAt(_param$2) !== 9) {
        const _tmp$5 = _param - 1 | 0;
        const _tmp$6 = _param$2 + 1 | 0;
        const _tmp$7 = _param$3 + 1 | 0;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _tmp$7;
        continue;
      } else {
        const col1 = rami3l$cmark$cmark$$next_tab_stop(_param$3);
        const tab_cols = col1 - (_param$3 + self.tab_consumed_cols | 0) | 0;
        if (tab_cols > _param) {
          self.tab_consumed_cols = _param;
          _tmp = 0;
          continue;
        } else {
          self.tab_consumed_cols = 0;
          const _tmp$5 = _param - tab_cols | 0;
          const _tmp$6 = _param$2 + 1 | 0;
          _tmp = _tmp$5;
          _tmp$2 = _tmp$6;
          _tmp$3 = col1;
          continue;
        }
      }
    }
  }
  rami3l$cmark$cmark$$Parser$update_next_non_blank(self);
}
function rami3l$cmark$cmark$$Parser$match_and_accept_block_quote(self) {
  let _tmp;
  if (rami3l$cmark$cmark$$Parser$end_of_line(self)) {
    _tmp = true;
  } else {
    const _tmp$2 = self.i;
    const _tmp$3 = self.curr_char;
    $bound_check(_tmp$2, _tmp$3);
    _tmp = _tmp$2.charCodeAt(_tmp$3) !== 62;
  }
  if (_tmp) {
    return false;
  }
  const next = self.curr_char + 1 | 0;
  let next_is_blank;
  if (next <= self.curr_line_last_char) {
    const _tmp$2 = self.i;
    $bound_check(_tmp$2, next);
    next_is_blank = rami3l$cmark$char$$is_ascii_blank(_tmp$2.charCodeAt(next));
  } else {
    next_is_blank = false;
  }
  rami3l$cmark$cmark$$Parser$accept_cols(self, next_is_blank ? 2 : 1);
  return true;
}
function rami3l$cmark$cmark$$Parser$accept_list_marker_and_indent(self, marker_size, last) {
  rami3l$cmark$cmark$$Parser$accept_cols(self, marker_size);
  const indent = rami3l$cmark$cmark$$Parser$curr_indent(self);
  const min_indent = rami3l$cmark$cmark$$Parser$only_blanks(self) || indent > 4 ? 1 : moonbitlang$core$math$$minimum$7$(indent, 4);
  rami3l$cmark$cmark$$Parser$accept_cols(self, min_indent);
  return min_indent;
}
function rami3l$cmark$cmark$$Parser$accept_code_indent(self, count) {
  rami3l$cmark$cmark$$Parser$accept_cols(self, count);
  if (self.tab_consumed_cols === 0) {
    return { _0: 0, _1: self.curr_char };
  }
  const col1 = rami3l$cmark$cmark$$next_tab_stop(self.curr_char_col);
  const pad = col1 - (self.curr_char_col + self.tab_consumed_cols | 0) | 0;
  return { _0: pad, _1: self.curr_char + 1 | 0 };
}
function rami3l$cmark$cmark$$BlockStruct$is_blank_line(self) {
  if (self.$tag === 1) {
    return true;
  } else {
    return false;
  }
}
function rami3l$cmark$cmark$$Parser$curr_line_span(self, first, last) {
  const _bind = self.curr_line_pos;
  return { pos: _bind, first: first, last: last };
}
function rami3l$cmark$cmark$$Parser$blank_line(self) {
  const first = self.curr_char;
  const last = self.curr_line_last_char;
  return new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlankLine(0, rami3l$cmark$cmark$$Parser$curr_line_span(self, first, last));
}
function rami3l$cmark$cmark$$Parser$thematic_break(self, indent, last) {
  const last$2 = self.curr_line_last_char;
  return new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ThematicBreak(indent, rami3l$cmark$cmark$$Parser$curr_line_span(self, self.curr_char, last$2));
}
function rami3l$cmark$cmark$$Parser$atx_heading(self, indent, level, after_open, first_content, last_content) {
  const heading = rami3l$cmark$cmark$$Parser$curr_line_span(self, first_content, last_content);
  const layout_after = rami3l$cmark$cmark$$Parser$curr_line_span(self, last_content + 1 | 0, self.curr_line_last_char);
  return new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$Heading(new $64$rami3l$47$cmark$47$cmark$46$Heading$Atx({ indent: indent, level: level, after_open: after_open, heading: heading, layout_after: layout_after }));
}
function rami3l$cmark$cmark$$Parser$setext_heading(self, level, heading_lines, indent, last_underline) {
  const u = rami3l$cmark$cmark$$Parser$curr_line_span(self, self.curr_char, last_underline);
  const blanks = rami3l$cmark$cmark$$Parser$curr_line_span(self, last_underline + 1 | 0, self.curr_line_last_char);
  const underline = { _0: indent, _1: u, _2: blanks };
  return new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$Heading(new $64$rami3l$47$cmark$47$cmark$46$Heading$Setext({ level: level, heading_lines: heading_lines, underline: underline }));
}
function rami3l$cmark$cmark$$Parser$indented_code_block(self) {
  const _bind = rami3l$cmark$cmark$$Parser$accept_code_indent(self, 4);
  const _pad = _bind._0;
  const _first = _bind._1;
  const code = rami3l$cmark$cmark$$Parser$curr_line_span(self, _first, self.curr_line_last_char);
  return new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(new $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Indented([{ pad: _pad, code: code, is_blank: false }]));
}
function rami3l$cmark$cmark$$Parser$fenced_code_block(self, indent, fence_first, fence_last, info) {
  let _bind;
  if (info === undefined) {
    _bind = { _0: undefined, _1: self.curr_line_last_char };
  } else {
    const _Some = info;
    const _x = _Some;
    const _first = _x._0;
    const _last = _x._1;
    _bind = { _0: rami3l$cmark$cmark$$Parser$curr_line_span(self, _first, _last), _1: _first };
  }
  const _info_string = _bind._0;
  const _layout_last = _bind._1;
  const opening_fence = rami3l$cmark$cmark$$Parser$curr_line_span(self, fence_first, _layout_last);
  const _tmp = self.i;
  $bound_check(_tmp, fence_first);
  const fence = { _0: _tmp.charCodeAt(fence_first), _1: (fence_last - fence_first | 0) + 1 | 0 };
  const fence$2 = { indent: indent, opening_fence: opening_fence, fence: fence, info_string: _info_string, closing_fence: undefined };
  return new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(new $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Fenced({ fence: fence$2, code: [] }));
}
function rami3l$cmark$cmark$$Parser$html_block(self, end_cond, indent_start) {
  const last = self.curr_line_last_char;
  const end_cond$2 = rami3l$cmark$cmark_base$$LineType$html_block_end(self.i, end_cond, last, self.curr_char) ? undefined : end_cond;
  return new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$HtmlBlock({ end_cond: end_cond$2, html: [rami3l$cmark$cmark$$Parser$curr_line_span(self, indent_start, last)] });
}
function rami3l$cmark$cmark$$Parser$paragraph(self, start) {
  const last = self.curr_line_last_char;
  const maybe_ref = rami3l$cmark$cmark_base$$could_be_link_ref_definition(self.i, last, start);
  const lines = [rami3l$cmark$cmark$$Parser$curr_line_span(self, start, last)];
  return new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$Paragraph({ maybe_ref: maybe_ref, lines: lines });
}
function rami3l$cmark$cmark$$Parser$add_paragraph_line(self, indent_start, par, bs) {
  const last = self.curr_line_last_char;
  const lines = par.lines;
  moonbitlang$core$array$$Array$push$239$(lines, rami3l$cmark$cmark$$Parser$curr_line_span(self, indent_start, last));
  moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$Paragraph({ maybe_ref: par.maybe_ref, lines: lines }));
}
function rami3l$cmark$cmark$$Parser$table_row(self, first, last) {
  return { _0: rami3l$cmark$cmark$$Parser$curr_line_span(self, first, last), _1: rami3l$cmark$cmark$$Parser$curr_line_span(self, last + 1 | 0, self.curr_line_last_char) };
}
function rami3l$cmark$cmark$$Parser$table(self, indent, last) {
  const row = rami3l$cmark$cmark$$Parser$table_row(self, self.curr_char, last);
  return new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtTable(indent, [row]);
}
function rami3l$cmark$cmark$$Parser$def_label(self, l) {
  const _func = self.resolver;
  return _func(new $64$rami3l$47$cmark$47$cmark$46$LabelContext$Def(rami3l$cmark$cmark$$Parser$find_label_defining_key(self, l.key), l));
}
function rami3l$cmark$cmark$$Parser$set_label_def(self, l, def) {
  moonbitlang$core$builtin$$Map$op_set$308$(self.defs, l.key, def);
}
function rami3l$cmark$cmark$$Parser$parse_link_ref_definition(self, lines) {
  const next_line = (i) => {
    if (i.val < lines.length) {
      const res = moonbitlang$core$array$$Array$op_get$239$(lines, i.val);
      i.val = i.val + 1 | 0;
      return res;
    } else {
      return undefined;
    }
  };
  const lines$2 = moonbitlang$core$ref$$Ref$new$7$(0);
  const _bind = next_line(lines$2);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _line = _Some;
    const start = rami3l$cmark$cmark$$Parser$first_non_blank_in_span(self, _line);
    const indent = start - _line.first | 0;
    const meta_first = { pos: _line.pos, first: start, last: _line.last };
    const _bind$2 = rami3l$cmark$cmark_base$$link_label$369$(self.buf, next_line, self.i, lines$2, _line, start);
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some$2 = _bind$2;
      const _x = _Some$2;
      const _line$2 = _x._0;
      const _spans = _x._1;
      const _last = _x._2;
      const _key = _x._3;
      const colon = _last + 1 | 0;
      let _tmp;
      if (colon <= _line$2.last) {
        const _tmp$2 = self.i;
        $bound_check(_tmp$2, colon);
        _tmp = _tmp$2.charCodeAt(colon) === 58;
      } else {
        _tmp = false;
      }
      if (_tmp) {
        const label = rami3l$cmark$cmark$$Parser$label_of_spans(self, _key, { buf: _spans, start: 0, len: _spans.length });
        const start$2 = colon + 1 | 0;
        const _bind$3 = rami3l$cmark$cmark$$Parser$first_non_blank_over_nl$369$(self, next_line, lines$2, _line$2, start$2);
        if (_bind$3 === undefined) {
          return undefined;
        } else {
          const _Some$3 = _bind$3;
          const _x$2 = _Some$3;
          const _line$3 = _x$2._0;
          const _before_dest = _x$2._1;
          const _start = _x$2._2;
          const _bind$4 = rami3l$cmark$cmark_base$$link_destination(self.i, _line$3.last, _start);
          if (_bind$4 === undefined) {
            return undefined;
          } else {
            const _Some$4 = _bind$4;
            const _x$3 = _Some$4;
            const _angled = _x$3._0;
            const _first = _x$3._1;
            const _last$2 = _x$3._2;
            const dest = rami3l$cmark$cmark$$Parser$clean_unesc_unref_span(self, { pos: _line$3.pos, first: _first, last: _last$2 });
            const next = _angled ? _last$2 + 2 | 0 : _last$2 + 1 | 0;
            const dest$2 = dest;
            const meta_last = { pos: _line$3.pos, first: _line$3.first, last: _last$2 };
            const lines$3 = lines$2.val;
            const _bind$5 = rami3l$cmark$cmark$$Parser$first_non_blank_over_nl$369$(self, next_line, lines$2, _line$3, next);
            let _bind$6;
            if (_bind$5 === undefined) {
              lines$2.val = lines$3;
              _bind$6 = { _0: lines$2, _1: [], _2: 34, _3: Option$None$77$, _4: [], _5: meta_last };
            } else {
              const _Some$5 = _bind$5;
              const _x$4 = _Some$5;
              const _line1 = _x$4._0;
              const _after_dest = _x$4._1;
              const _start1 = _x$4._2;
              if (_start1 !== next) {
                const no_newline = moonbitlang$core$builtin$$Eq$op_equal$173$(_line1.pos, _line$3.pos);
                const _bind$7 = rami3l$cmark$cmark_base$$link_title$369$(next_line, self.i, lines$2, _line1, _start1);
                if (_bind$7 === undefined) {
                  if (!no_newline) {
                    lines$2.val = lines$3;
                    _bind$6 = { _0: lines$2, _1: [], _2: 34, _3: Option$None$77$, _4: [], _5: meta_last };
                  } else {
                    return undefined;
                  }
                } else {
                  const _Some$6 = _bind$7;
                  const _x$5 = _Some$6;
                  const _line1$2 = _x$5._0;
                  const _spans$2 = _x$5._1;
                  const _last$3 = _x$5._2;
                  const last = _line1$2.last;
                  const start$3 = last + 1 | 0;
                  const nb = rami3l$cmark$cmark_base$$first_non_blank(self.i, last, start$3);
                  const after_title = nb <= _line1$2.last ? Option$None$81$ : new Option$Some$81$([rami3l$cmark$cmark$$Parser$layout_clean_raw_span(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span$46$pad$46$default(), { pos: _line1$2.pos, first: start$3, last: _line1$2.last })]);
                  if (after_title.$tag === 1) {
                    const _Some$7 = after_title;
                    const _after_title = _Some$7._0;
                    const t = rami3l$cmark$cmark$$Parser$tight_block_lines(self, { buf: _spans$2, start: 0, len: _spans$2.length });
                    const _tmp$2 = self.i;
                    $bound_check(_tmp$2, _start1);
                    const _tmp$3 = _tmp$2.charCodeAt(_start1);
                    _bind$6 = { _0: lines$2, _1: _after_dest, _2: _tmp$3, _3: new Option$Some$77$(t), _4: _after_title, _5: { pos: _line1$2.pos, first: _line1$2.first, last: _last$3 } };
                  } else {
                    if (!no_newline) {
                      lines$2.val = lines$3;
                      _bind$6 = { _0: lines$2, _1: [], _2: 34, _3: Option$None$77$, _4: [], _5: meta_last };
                    } else {
                      return undefined;
                    }
                  }
                }
              } else {
                return undefined;
              }
            }
            const _lines = _bind$6._0;
            const _after_dest = _bind$6._1;
            const _title_open_delim = _bind$6._2;
            const _title = _bind$6._3;
            const _after_title = _bind$6._4;
            const _meta_last = _bind$6._5;
            const meta = rami3l$cmark$cmark$$Parser$meta_of_spans(self, meta_first, _meta_last);
            const layout = { indent: indent, angled_dest: _angled, before_dest: _before_dest, after_dest: _after_dest, title_open_delim: _title_open_delim, after_title: _after_title };
            const defined_label = rami3l$cmark$cmark$$Parser$def_label(self, label);
            const label$2 = label;
            const ld = { v: { layout: layout, label: label$2, defined_label: defined_label, dest: dest$2, title: _title }, meta: meta };
            if (defined_label === undefined) {
            } else {
              const _Some$5 = defined_label;
              const _def = _Some$5;
              rami3l$cmark$cmark$$Parser$set_label_def(self, _def, new $64$rami3l$47$cmark$47$cmark$46$LabelDef$LinkDef(ld));
            }
            moonbitlang$core$array$$Array$drain$239$(lines, 0, _lines.val);
            return ld;
          }
        }
      } else {
        return undefined;
      }
    }
  }
}
function rami3l$cmark$cmark$$Parser$maybe_add_link_ref_definitions(self, lines, prevs) {
  while (true) {
    if (!moonbitlang$core$array$$Array$is_empty$239$(lines)) {
      const _bind = rami3l$cmark$cmark$$Parser$parse_link_ref_definition(self, lines);
      if (_bind === undefined) {
        moonbitlang$core$array$$Array$push$288$(prevs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$Paragraph({ maybe_ref: false, lines: lines }));
        break;
      } else {
        const _Some = _bind;
        const _ld = _Some;
        moonbitlang$core$array$$Array$push$288$(prevs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$LinkRefDef(_ld));
      }
      continue;
    } else {
      return;
    }
  }
}
function rami3l$cmark$cmark$$Parser$close_indented_code_block(self, lines, bs) {
  const blanks = [];
  while (true) {
    const _bind = moonbitlang$core$array$$Array$last$278$(lines);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _x$2 = _x.is_blank;
      if (_x$2 === true) {
        const _bind$2 = moonbitlang$core$array$$Array$pop$278$(lines);
        if (_bind$2 === undefined) {
          $panic();
        } else {
          const _Some$2 = _bind$2;
          const _x$3 = _Some$2;
          const _pad = _x$3.pad;
          const _code = _x$3.code;
          moonbitlang$core$array$$Array$push$288$(blanks, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlankLine(_pad, _code));
        }
      } else {
        moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(new $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Indented(lines)));
        break;
      }
    }
    continue;
  }
  moonbitlang$core$array$$Array$push_iter$288$(bs, moonbitlang$core$array$$Array$iter$288$(blanks));
}
function rami3l$cmark$cmark$$Parser$close_paragraph(self, par, bs) {
  if (par.maybe_ref) {
    rami3l$cmark$cmark$$Parser$maybe_add_link_ref_definitions(self, par.lines, bs);
    return;
  } else {
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$Paragraph(par));
    return;
  }
}
function rami3l$cmark$cmark$$Parser$close_last_block(self, bs) {
  let t;
  _L: {
    const _bind = moonbitlang$core$array$$Array$pop$288$(bs);
    if (_bind === undefined) {
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      switch (_x.$tag) {
        case 2: {
          const _CodeBlock = _x;
          const _x$2 = _CodeBlock._0;
          if (_x$2.$tag === 0) {
            const _Indented = _x$2;
            const _ls = _Indented._0;
            rami3l$cmark$cmark$$Parser$close_indented_code_block(self, _ls, bs);
            return;
          } else {
            t = _x;
            break _L;
          }
        }
        case 7: {
          const _Paragraph = _x;
          const _par = _Paragraph._0;
          rami3l$cmark$cmark$$Parser$close_paragraph(self, _par, bs);
          return;
        }
        case 5: {
          const _List = _x;
          const _l = _List._0;
          rami3l$cmark$cmark$$Parser$close_list(self, _l, bs);
          return;
        }
        case 10: {
          const _ExtFootnote = _x;
          const _i = _ExtFootnote._0;
          const _l$2 = _ExtFootnote._1;
          const _blocks = _ExtFootnote._2;
          rami3l$cmark$cmark$$Parser$close_footnote(self, _i, _l$2, _blocks, bs);
          return;
        }
        default: {
          t = _x;
          break _L;
        }
      }
    }
  }
  moonbitlang$core$array$$Array$push$288$(bs, t);
}
function rami3l$cmark$cmark$$Parser$close_footnote(self, indent, label, blocks, bs) {
  rami3l$cmark$cmark$$Parser$close_last_block(self, blocks);
  const blanks = [];
  while (true) {
    _L: {
      _L$2: {
        if (blocks.length >= 2) {
          const _x = blocks[blocks.length - 1 | 0];
          if (_x.$tag === 1) {
            const _bind = moonbitlang$core$array$$Array$pop$288$(blocks);
            if (_bind === undefined) {
              $panic();
            } else {
              const _Some = _bind;
              const _bl = _Some;
              moonbitlang$core$array$$Array$push$288$(blanks, _bl);
            }
          } else {
            break _L$2;
          }
        } else {
          break _L$2;
        }
        break _L;
      }
      break;
    }
    continue;
  }
  moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtFootnote(indent, label, blocks));
  moonbitlang$core$array$$Array$push_iter$288$(bs, moonbitlang$core$array$$Array$iter$288$(blanks));
}
function rami3l$cmark$cmark$$Parser$close_list(self, l, bs) {
  const _bind = moonbitlang$core$array$$Array$last$238$(l.items);
  if (_bind === undefined) {
    $panic();
    return;
  } else {
    const _Some = _bind;
    const _i = _Some;
    const blocks = _i.blocks;
    rami3l$cmark$cmark$$Parser$close_last_block(self, blocks);
    _L: {
      if (blocks.length >= 2) {
        const _x = blocks[blocks.length - 1 | 0];
        if (_x.$tag === 1) {
          const _bind$2 = moonbitlang$core$array$$Array$pop$288$(blocks);
          if (_bind$2 === undefined) {
            $panic();
            return;
          } else {
            const _Some$2 = _bind$2;
            const _bl = _Some$2;
            const items = l.items;
            moonbitlang$core$array$$Array$op_set$238$(items, items.length - 1 | 0, { before_marker: _i.before_marker, marker: _i.marker, after_marker: _i.after_marker, ext_task_marker: _i.ext_task_marker, blocks: blocks });
            moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$List({ last_blank: l.last_blank, loose: l.loose, item_min_indent: l.item_min_indent, list_type: l.list_type, items: items }));
            moonbitlang$core$array$$Array$push$288$(bs, _bl);
            return;
          }
        } else {
          break _L;
        }
      } else {
        break _L;
      }
    }
    const items = l.items;
    moonbitlang$core$array$$Array$op_set$238$(items, items.length - 1 | 0, { before_marker: _i.before_marker, marker: _i.marker, after_marker: _i.after_marker, ext_task_marker: _i.ext_task_marker, blocks: blocks });
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$List({ last_blank: l.last_blank, loose: l.loose, item_min_indent: l.item_min_indent, list_type: l.list_type, items: items }));
    return;
  }
}
function rami3l$cmark$cmark$$Parser$close_last_list_item(self, l) {
  const _bind = moonbitlang$core$array$$Array$last$238$(l.items);
  if (_bind === undefined) {
    $panic();
    return;
  } else {
    const _Some = _bind;
    const _item = _Some;
    rami3l$cmark$cmark$$Parser$close_last_block(self, _item.blocks);
    return;
  }
}
function rami3l$cmark$cmark$$Parser$end_doc_close_fenced_code_block(self, fenced, bs) {
  const _code = fenced.code;
  if (_code.length >= 1) {
    const _x = _code[_code.length - 1 | 0];
    const _x$2 = _x._1;
    const _first = _x$2.first;
    const _last = _x$2.last;
    if (_first > _last) {
      moonbitlang$core$array$$Array$pop$306$(_code);
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(new $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Fenced({ fence: fenced.fence, code: _code })));
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlankLine(0, _x$2));
      return undefined;
    }
  }
  moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(new $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Fenced(fenced)));
}
function rami3l$cmark$cmark$$Parser$end_doc_close_html(self, h, bs) {
  const _html = h.html;
  if (_html.length >= 1) {
    const _x = _html[_html.length - 1 | 0];
    const _first = _x.first;
    const _last = _x.last;
    if (_first > _last) {
      moonbitlang$core$array$$Array$pop$239$(_html);
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$HtmlBlock({ end_cond: undefined, html: _html }));
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlankLine(0, _x));
      return undefined;
    }
  }
  moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$HtmlBlock({ end_cond: undefined, html: h.html }));
}
function rami3l$cmark$cmark$$Parser$end_doc(self, bs) {
  const _bind = moonbitlang$core$array$$Array$pop$288$(bs);
  if (_bind === undefined) {
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    switch (_x.$tag) {
      case 0: {
        const _BlockQuote = _x;
        const _indent = _BlockQuote._0;
        const _bq = _BlockQuote._1;
        rami3l$cmark$cmark$$Parser$end_doc(self, _bq);
        moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlockQuote(_indent, _bq));
        return;
      }
      case 5: {
        const _List = _x;
        const _l = _List._0;
        rami3l$cmark$cmark$$Parser$close_list(self, _l, bs);
        return;
      }
      case 7: {
        const _Paragraph = _x;
        const _par = _Paragraph._0;
        rami3l$cmark$cmark$$Parser$close_paragraph(self, _par, bs);
        return;
      }
      case 2: {
        const _CodeBlock = _x;
        const _x$2 = _CodeBlock._0;
        if (_x$2.$tag === 0) {
          const _Indented = _x$2;
          const _ls = _Indented._0;
          rami3l$cmark$cmark$$Parser$close_indented_code_block(self, _ls, bs);
          return;
        } else {
          const _Fenced = _x$2;
          const _f = _Fenced._0;
          rami3l$cmark$cmark$$Parser$end_doc_close_fenced_code_block(self, _f, bs);
          return;
        }
      }
      case 4: {
        const _HtmlBlock = _x;
        const _html = _HtmlBlock._0;
        rami3l$cmark$cmark$$Parser$end_doc_close_html(self, _html, bs);
        return;
      }
      case 10: {
        const _ExtFootnote = _x;
        const _indent$2 = _ExtFootnote._0;
        const _label = _ExtFootnote._1;
        const _blocks = _ExtFootnote._2;
        rami3l$cmark$cmark$$Parser$close_footnote(self, _indent$2, _label, _blocks, bs);
        return;
      }
      default: {
        moonbitlang$core$array$$Array$push$288$(bs, _x);
        return;
      }
    }
  }
}
function rami3l$cmark$cmark$$Parser$match_line_type(self, no_setext, indent) {
  if (rami3l$cmark$cmark$$Parser$only_blanks(self)) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$BlankLine;
  }
  if (indent >= 4) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$IndentedCodeBlockLine;
  }
  rami3l$cmark$cmark$$Parser$accept_cols(self, indent);
  if (rami3l$cmark$cmark$$Parser$end_of_line(self)) {
    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$BlankLine;
  }
  const start = self.curr_char;
  const last = self.curr_line_last_char;
  _L: {
    _L$2: {
      _L$3: {
        const _tmp = self.i;
        $bound_check(_tmp, start);
        const _bind = _tmp.charCodeAt(start);
        if (_bind === 62) {
          if (rami3l$cmark$cmark$$Parser$match_and_accept_block_quote(self)) {
            return $64$rami3l$47$cmark$47$cmark_base$46$LineType$BlockQuoteLine;
          }
          return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
        } else {
          if (_bind === 61) {
            if (!no_setext) {
              const r = rami3l$cmark$cmark_base$$LineType$setext_heading_underline(self.i, last, start);
              if (r.$tag === 12) {
                return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
              } else {
                return r;
              }
            } else {
              break _L;
            }
          } else {
            if (_bind === 45) {
              const r = no_setext ? $64$rami3l$47$cmark$47$cmark_base$46$LineType$Nomatch : rami3l$cmark$cmark_base$$LineType$setext_heading_underline(self.i, last, start);
              if (r.$tag === 12) {
                const r$2 = rami3l$cmark$cmark_base$$LineType$thematic_break(self.i, last, start);
                if (r$2.$tag === 12) {
                  const r$3 = rami3l$cmark$cmark_base$$LineType$list_marker(self.i, last, start);
                  if (r$3.$tag === 12) {
                    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
                  } else {
                    return r$3;
                  }
                } else {
                  return r$2;
                }
              } else {
                return r;
              }
            } else {
              if (_bind === 35) {
                const r = rami3l$cmark$cmark_base$$LineType$atx_heading(self.i, last, start);
                if (r.$tag === 12) {
                  return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
                } else {
                  return r;
                }
              } else {
                if (_bind === 43) {
                  break _L$3;
                } else {
                  if (_bind === 42) {
                    break _L$3;
                  } else {
                    if (_bind >= 48 && _bind <= 57) {
                      break _L$3;
                    } else {
                      if (_bind === 95) {
                        const r = rami3l$cmark$cmark_base$$LineType$thematic_break(self.i, last, start);
                        if (r.$tag === 12) {
                          return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
                        } else {
                          return r;
                        }
                      } else {
                        if (_bind === 126) {
                          break _L$2;
                        } else {
                          if (_bind === 96) {
                            break _L$2;
                          } else {
                            if (_bind === 60) {
                              const r = rami3l$cmark$cmark_base$$LineType$html_block_start(self.i, last, start);
                              if (r.$tag === 12) {
                                return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
                              } else {
                                return r;
                              }
                            } else {
                              if (_bind === 124) {
                                if (self.exts) {
                                  const r = rami3l$cmark$cmark_base$$LineType$ext_table_row(self.i, last, start);
                                  if (r.$tag === 12) {
                                    return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
                                  } else {
                                    return r;
                                  }
                                } else {
                                  break _L;
                                }
                              } else {
                                if (_bind === 91) {
                                  if (self.exts) {
                                    const r = rami3l$cmark$cmark_base$$LineType$ext_footnote_label(self.buf, self.i, self.curr_line_pos, last, start);
                                    if (r.$tag === 12) {
                                      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
                                    } else {
                                      return r;
                                    }
                                  } else {
                                    break _L;
                                  }
                                } else {
                                  break _L;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      const r = rami3l$cmark$cmark_base$$LineType$thematic_break(self.i, last, start);
      if (r.$tag === 12) {
        const r$2 = rami3l$cmark$cmark_base$$LineType$list_marker(self.i, last, start);
        if (r$2.$tag === 12) {
          return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
        } else {
          return r$2;
        }
      } else {
        return r;
      }
    }
    const r = rami3l$cmark$cmark_base$$LineType$fenced_code_block_start(self.i, last, start);
    if (r.$tag === 12) {
      return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
    } else {
      return r;
    }
  }
  return $64$rami3l$47$cmark$47$cmark_base$46$LineType$ParagraphLine;
}
function rami3l$cmark$cmark$$Parser$list_marker_can_interrupt_paragraph(self, marker, marker_last) {
  _L: {
    if (marker.$tag === 1) {
      const _Ordered = marker;
      const _x = _Ordered._0;
      if (_x === 1) {
        break _L;
      } else {
        return false;
      }
    } else {
      break _L;
    }
  }
  const non_blank = rami3l$cmark$cmark_base$$first_non_blank(self.i, self.curr_line_last_char, marker_last + 1 | 0);
  return non_blank <= self.curr_line_last_char;
}
function rami3l$cmark$cmark$$Parser$add_open_blocks_with_line_class(self, indent_start, indent, bs, lt) {
  switch (lt.$tag) {
    case 1: {
      moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$blank_line(self));
      return;
    }
    case 5: {
      moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$indented_code_block(self));
      return;
    }
    case 2: {
      const bs1 = [];
      rami3l$cmark$cmark$$Parser$add_open_blocks(self, bs1);
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlockQuote(indent, bs1));
      return;
    }
    case 9: {
      const _ThematicBreakLine = lt;
      const _last = _ThematicBreakLine._0;
      moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$thematic_break(self, indent, _last));
      return;
    }
    case 6: {
      const _ListMarkerLine = lt;
      const _marker = _ListMarkerLine._0;
      const _marker_last = _ListMarkerLine._1;
      rami3l$cmark$cmark$$Parser$list(self, indent, _marker, _marker_last, bs);
      return;
    }
    case 0: {
      const _AtxHeadingLine = lt;
      const _level = _AtxHeadingLine._0;
      const _after_open = _AtxHeadingLine._1;
      const _first_content = _AtxHeadingLine._2;
      const _last_content = _AtxHeadingLine._3;
      moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$atx_heading(self, indent, _level, _after_open, _first_content, _last_content));
      return;
    }
    case 3: {
      const _FencedCodeBlockLine = lt;
      const _fence_first = _FencedCodeBlockLine._0;
      const _fence_last = _FencedCodeBlockLine._1;
      const _info = _FencedCodeBlockLine._2;
      moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$fenced_code_block(self, indent, _fence_first, _fence_last, _info));
      return;
    }
    case 4: {
      const _HtmlBlockLine = lt;
      const _end_cond = _HtmlBlockLine._0;
      moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$html_block(self, _end_cond, indent_start));
      return;
    }
    case 7: {
      moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$paragraph(self, indent_start));
      return;
    }
    case 10: {
      const _ExtTableRow = lt;
      const _last$2 = _ExtTableRow._0;
      moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$table(self, indent, _last$2));
      return;
    }
    case 11: {
      const _ExtFootnoteLabel = lt;
      const _spans = _ExtFootnoteLabel._0;
      const _last$3 = _ExtFootnoteLabel._1;
      const _key = _ExtFootnoteLabel._2;
      moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$footnote(self, indent, _last$3, { buf: _spans, start: 0, len: _spans.length }, _key));
      return;
    }
    default: {
      moonbitlang$core$abort$$abort$12$("unimplemented");
      return;
    }
  }
}
function rami3l$cmark$cmark$$Parser$add_open_blocks(self, bs) {
  const indent_start = self.curr_char;
  const indent = rami3l$cmark$cmark$$Parser$curr_indent(self);
  const line_type = rami3l$cmark$cmark$$Parser$match_line_type(self, true, indent);
  rami3l$cmark$cmark$$Parser$add_open_blocks_with_line_class(self, indent_start, indent, bs, line_type);
}
function rami3l$cmark$cmark$$Parser$footnote(self, indent, last, spans, key) {
  const label = rami3l$cmark$cmark$$Parser$label_of_spans(self, key, spans);
  const defined_label = rami3l$cmark$cmark$$Parser$def_label(self, label);
  if (defined_label === undefined) {
  } else {
    const _Some = defined_label;
    const _def = _Some;
    rami3l$cmark$cmark$$Parser$set_label_def(self, _def, rami3l$cmark$cmark$$Label$stub(label, defined_label));
  }
  rami3l$cmark$cmark$$Parser$accept_cols(self, (last - self.curr_char | 0) + 1 | 0);
  const blocks = [];
  rami3l$cmark$cmark$$Parser$add_open_blocks(self, blocks);
  return new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtFootnote(indent, { _0: label, _1: defined_label }, blocks);
}
function rami3l$cmark$cmark$$Parser$list(self, indent, list_type, marker_last, bs) {
  const _bind = rami3l$cmark$cmark$$Parser$list_item(self, indent, list_type, marker_last);
  const _item_min_indent = _bind._0;
  const _item = _bind._1;
  moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$List({ last_blank: false, loose: false, item_min_indent: _item_min_indent, list_type: list_type, items: [_item] }));
}
function rami3l$cmark$cmark$$Parser$list_item(self, indent, _list_type, last) {
  const marker_size = (last - self.curr_char | 0) + 1 | 0;
  const marker = rami3l$cmark$cmark$$Parser$curr_line_span(self, self.curr_char, last);
  const after_marker = rami3l$cmark$cmark$$Parser$accept_list_marker_and_indent(self, marker_size, last);
  let _bind;
  if (self.exts) {
    const start = self.curr_char;
    const last$2 = self.curr_line_last_char;
    const _bind$2 = rami3l$cmark$cmark_base$$ext_task_marker(self.i, last$2, start);
    if (_bind$2 === undefined) {
      _bind = { _0: undefined, _1: 0 };
    } else {
      const _Some = _bind$2;
      const _x = _Some;
      const _u = _x._0;
      const _last = _x._1;
      rami3l$cmark$cmark$$Parser$accept_cols(self, (_last - start | 0) + 1 | 0);
      const last$3 = _last === self.curr_line_last_char ? _last : _last - 1 | 0;
      _bind = { _0: { _0: _u, _1: rami3l$cmark$cmark$$Parser$curr_line_span(self, start, last$3) }, _1: 4 };
    }
  } else {
    _bind = { _0: undefined, _1: 0 };
  }
  const _ext_task_marker = _bind._0;
  const _ext_task_marker_size = _bind._1;
  const min = ((indent + marker_size | 0) + after_marker | 0) + _ext_task_marker_size | 0;
  const blocks = [];
  rami3l$cmark$cmark$$Parser$add_open_blocks(self, blocks);
  return { _0: min, _1: { before_marker: indent, marker: marker, after_marker: after_marker, ext_task_marker: _ext_task_marker, blocks: blocks } };
}
function rami3l$cmark$cmark$$Parser$try_add_to_list(self, indent, list_type, marker_last, list, bs) {
  const _bind = rami3l$cmark$cmark$$Parser$list_item(self, indent, list_type, marker_last);
  const _item_min_indent = _bind._0;
  const _item = _bind._1;
  if (rami3l$cmark$cmark_base$$ListType$is_same_type(list.list_type, list_type)) {
    rami3l$cmark$cmark$$Parser$close_last_list_item(self, list);
    const _tmp = list.last_blank;
    const _tmp$2 = list.list_type;
    const _self = list.items;
    moonbitlang$core$array$$Array$push$238$(_self, _item);
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$List({ last_blank: false, loose: _tmp, item_min_indent: _item_min_indent, list_type: _tmp$2, items: _self }));
    return;
  } else {
    rami3l$cmark$cmark$$Parser$close_list(self, list, bs);
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$List({ last_blank: false, loose: false, item_min_indent: _item_min_indent, list_type: list_type, items: [_item] }));
    return;
  }
}
function rami3l$cmark$cmark$$Parser$try_add_to_paragraph(self, par, bs) {
  const indent_start = self.curr_char;
  const indent = rami3l$cmark$cmark$$Parser$curr_indent(self);
  _L: {
    const _bind = rami3l$cmark$cmark$$Parser$match_line_type(self, false, indent);
    switch (_bind.$tag) {
      case 4: {
        const _HtmlBlockLine = _bind;
        const _x = _HtmlBlockLine._0;
        if (_x.$tag === 3) {
          break _L;
        } else {
          rami3l$cmark$cmark$$Parser$close_paragraph(self, par, bs);
          moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$html_block(self, _x, indent_start));
          return;
        }
      }
      case 5: {
        break _L;
      }
      case 10: {
        break _L;
      }
      case 11: {
        break _L;
      }
      case 7: {
        break _L;
      }
      case 6: {
        const _ListMarkerLine = _bind;
        const _marker = _ListMarkerLine._0;
        const _marker_last = _ListMarkerLine._1;
        if (rami3l$cmark$cmark$$Parser$list_marker_can_interrupt_paragraph(self, _marker, _marker_last)) {
          rami3l$cmark$cmark$$Parser$close_paragraph(self, par, bs);
          rami3l$cmark$cmark$$Parser$list(self, indent, _marker, _marker_last, bs);
          return;
        } else {
          rami3l$cmark$cmark$$Parser$add_paragraph_line(self, indent_start, par, bs);
          return;
        }
      }
      case 1: {
        rami3l$cmark$cmark$$Parser$close_paragraph(self, par, bs);
        moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$blank_line(self));
        return;
      }
      case 2: {
        rami3l$cmark$cmark$$Parser$close_paragraph(self, par, bs);
        const blocks = [];
        rami3l$cmark$cmark$$Parser$add_open_blocks(self, blocks);
        moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlockQuote(indent, blocks));
        return;
      }
      case 8: {
        const _SetextUnderlineLine = _bind;
        const _level = _SetextUnderlineLine._0;
        const _last_underline = _SetextUnderlineLine._1;
        rami3l$cmark$cmark$$Parser$close_paragraph(self, par, bs);
        let bs$2;
        _L$2: {
          if (bs.length >= 1) {
            const _x$2 = bs[bs.length - 1 | 0];
            if (_x$2.$tag === 7) {
              const _Paragraph = _x$2;
              const _par = _Paragraph._0;
              moonbitlang$core$array$$Array$op_set$288$(bs, bs.length - 1 | 0, rami3l$cmark$cmark$$Parser$setext_heading(self, _level, _par.lines, indent, _last_underline));
              return;
            } else {
              bs$2 = bs;
              break _L$2;
            }
          } else {
            bs$2 = bs;
            break _L$2;
          }
        }
        moonbitlang$core$array$$Array$push$288$(bs$2, rami3l$cmark$cmark$$Parser$paragraph(self, indent_start));
        return;
      }
      case 9: {
        const _ThematicBreakLine = _bind;
        const _last = _ThematicBreakLine._0;
        rami3l$cmark$cmark$$Parser$close_paragraph(self, par, bs);
        moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$thematic_break(self, indent, _last));
        return;
      }
      case 0: {
        const _AtxHeadingLine = _bind;
        const _level$2 = _AtxHeadingLine._0;
        const _after_open = _AtxHeadingLine._1;
        const _first_content = _AtxHeadingLine._2;
        const _last_content = _AtxHeadingLine._3;
        rami3l$cmark$cmark$$Parser$close_paragraph(self, par, bs);
        moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$atx_heading(self, indent, _level$2, _after_open, _first_content, _last_content));
        return;
      }
      case 3: {
        const _FencedCodeBlockLine = _bind;
        const _fence_first = _FencedCodeBlockLine._0;
        const _fence_last = _FencedCodeBlockLine._1;
        const _info = _FencedCodeBlockLine._2;
        rami3l$cmark$cmark$$Parser$close_paragraph(self, par, bs);
        moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$fenced_code_block(self, indent, _fence_first, _fence_last, _info));
        return;
      }
      default: {
        moonbitlang$core$abort$$abort$12$("unreachable");
        return;
      }
    }
  }
  rami3l$cmark$cmark$$Parser$add_paragraph_line(self, indent_start, par, bs);
}
function rami3l$cmark$cmark$$Parser$try_add_to_indented_code_block(self, ls, bs) {
  if (rami3l$cmark$cmark$$Parser$curr_indent(self) < 4) {
    if (rami3l$cmark$cmark$$Parser$has_next_non_blank(self)) {
      rami3l$cmark$cmark$$Parser$close_indented_code_block(self, ls, bs);
      rami3l$cmark$cmark$$Parser$add_open_blocks(self, bs);
      return;
    } else {
      const first = self.curr_line_last_char + 1 | 0;
      const last = self.curr_line_last_char;
      const code = rami3l$cmark$cmark$$Parser$curr_line_span(self, first, last);
      const l = { pad: 0, code: code, is_blank: true };
      moonbitlang$core$array$$Array$push$278$(ls, l);
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(new $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Indented(ls)));
      return;
    }
  } else {
    const _bind = rami3l$cmark$cmark$$Parser$accept_code_indent(self, 4);
    const _pad = _bind._0;
    const _first = _bind._1;
    const last = self.curr_line_last_char;
    const is_blank = rami3l$cmark$cmark$$Parser$only_blanks(self);
    const l = { pad: _pad, code: rami3l$cmark$cmark$$Parser$curr_line_span(self, _first, last), is_blank: is_blank };
    moonbitlang$core$array$$Array$push$278$(ls, l);
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(new $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Indented(ls)));
    return;
  }
}
function rami3l$cmark$cmark$$Parser$try_add_to_fenced_code_block(self, f, bs) {
  const _x = f.fence;
  const _x$2 = _x.closing_fence;
  if (_x$2 === undefined) {
    const _indent = _x.indent;
    const _fence = _x.fence;
    const _ls = f.code;
    const start = self.curr_char;
    const last = self.curr_line_last_char;
    const _bind = rami3l$cmark$cmark_base$$FencedCodeBlockContinue$new(self.i, _fence, last, start);
    if (_bind.$tag === 1) {
      const strip = moonbitlang$core$math$$minimum$7$(_indent, rami3l$cmark$cmark$$Parser$curr_indent(self));
      const _bind$2 = rami3l$cmark$cmark$$Parser$accept_code_indent(self, strip);
      const _pad = _bind$2._0;
      const _first = _bind$2._1;
      moonbitlang$core$array$$Array$push$306$(_ls, { _0: _pad, _1: rami3l$cmark$cmark$$Parser$curr_line_span(self, _first, last) });
      const code = _ls;
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(new $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Fenced({ fence: f.fence, code: code })));
      return;
    } else {
      const _Close = _bind;
      const _first = _Close._0;
      const close = rami3l$cmark$cmark$$Parser$curr_line_span(self, _first, last);
      const _bind$2 = f.fence;
      const fence = { indent: _bind$2.indent, opening_fence: _bind$2.opening_fence, fence: _bind$2.fence, info_string: _bind$2.info_string, closing_fence: close };
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(new $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Fenced({ fence: fence, code: f.code })));
      return;
    }
  } else {
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$CodeBlock(new $64$rami3l$47$cmark$47$cmark$46$CodeBlockStruct$Fenced(f)));
    rami3l$cmark$cmark$$Parser$add_open_blocks(self, bs);
    return;
  }
}
function rami3l$cmark$cmark$$Parser$try_add_to_html_block(self, b, bs) {
  const _bind = b.end_cond;
  if (_bind === undefined) {
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$HtmlBlock({ end_cond: undefined, html: b.html }));
    rami3l$cmark$cmark$$Parser$add_open_blocks(self, bs);
    return;
  } else {
    const _Some = _bind;
    const _end_cond = _Some;
    const start = self.curr_char;
    const last = self.curr_line_last_char;
    const l = rami3l$cmark$cmark$$Parser$curr_line_span(self, start, last);
    if (rami3l$cmark$cmark_base$$LineType$html_block_end(self.i, _end_cond, last, start)) {
      _L: {
        switch (_end_cond.$tag) {
          case 3: {
            break _L;
          }
          case 2: {
            break _L;
          }
          default: {
            const _self = b.html;
            moonbitlang$core$array$$Array$push$239$(_self, l);
            const _bind$2 = _self;
            const _bind$3 = undefined;
            moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$HtmlBlock({ end_cond: _bind$3, html: _bind$2 }));
            return;
          }
        }
      }
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$HtmlBlock({ end_cond: undefined, html: b.html }));
      moonbitlang$core$array$$Array$push$288$(bs, rami3l$cmark$cmark$$Parser$blank_line(self));
      return;
    } else {
      const _tmp = b.end_cond;
      const _self = b.html;
      moonbitlang$core$array$$Array$push$239$(_self, l);
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$HtmlBlock({ end_cond: _tmp, html: _self }));
      return;
    }
  }
}
function rami3l$cmark$cmark$$Parser$try_lazy_continuation(self, indent_start, bs) {
  let _tmp = self;
  let _tmp$2 = indent_start;
  let _tmp$3 = bs;
  _L: while (true) {
    const self$2 = _tmp;
    const indent_start$2 = _tmp$2;
    const bs$2 = _tmp$3;
    const _bind = moonbitlang$core$array$$Array$last$288$(bs$2);
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _x = _Some;
      switch (_x.$tag) {
        case 7: {
          const _Paragraph = _x;
          const _par = _Paragraph._0;
          moonbitlang$core$array$$Array$pop$288$(bs$2);
          rami3l$cmark$cmark$$Parser$add_paragraph_line(self$2, indent_start$2, _par, bs$2);
          return true;
        }
        case 0: {
          const _BlockQuote = _x;
          const _bq = _BlockQuote._1;
          _tmp$3 = _bq;
          continue _L;
        }
        case 5: {
          const _List = _x;
          const _l = _List._0;
          const _bind$2 = moonbitlang$core$array$$Array$last$238$(_l.items);
          if (_bind$2 === undefined) {
            return $panic();
          } else {
            const _Some$2 = _bind$2;
            const _i = _Some$2;
            const res = rami3l$cmark$cmark$$Parser$try_lazy_continuation(self$2, indent_start$2, _i.blocks);
            if (res) {
              _l.last_blank = false;
            }
            return res;
          }
        }
        default: {
          return false;
        }
      }
    }
  }
}
function rami3l$cmark$cmark$$Parser$try_add_to_table(self, indent, rows, bs) {
  const indent_start = self.curr_char;
  const curr_indent = rami3l$cmark$cmark$$Parser$curr_indent(self);
  const _bind = rami3l$cmark$cmark$$Parser$match_line_type(self, true, curr_indent);
  if (_bind.$tag === 10) {
    const _ExtTableRow = _bind;
    const _last = _ExtTableRow._0;
    const row = rami3l$cmark$cmark$$Parser$table_row(self, self.curr_char, _last);
    moonbitlang$core$array$$Array$push$307$(rows, row);
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtTable(indent, rows));
    return;
  } else {
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtTable(indent, rows));
    rami3l$cmark$cmark$$Parser$add_open_blocks_with_line_class(self, indent_start, curr_indent, bs, _bind);
    return;
  }
}
function rami3l$cmark$cmark$$Parser$try_add_to_block_quote(self, indent_layout, bq, bs) {
  const indent_start = self.curr_char;
  const indent = rami3l$cmark$cmark$$Parser$curr_indent(self);
  let ltype;
  _L: {
    const _bind = rami3l$cmark$cmark$$Parser$match_line_type(self, true, indent);
    switch (_bind.$tag) {
      case 2: {
        rami3l$cmark$cmark$$Parser$add_line(self, bq);
        moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlockQuote(indent_layout, bq));
        return;
      }
      case 5: {
        ltype = _bind;
        break _L;
      }
      case 7: {
        ltype = _bind;
        break _L;
      }
      default: {
        rami3l$cmark$cmark$$Parser$close_last_block(self, bq);
        moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlockQuote(indent_layout, bq));
        rami3l$cmark$cmark$$Parser$add_open_blocks_with_line_class(self, indent_start, indent, bs, _bind);
        return;
      }
    }
  }
  if (rami3l$cmark$cmark$$Parser$try_lazy_continuation(self, indent_start, bq)) {
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlockQuote(indent_layout, bq));
    return;
  } else {
    rami3l$cmark$cmark$$Parser$close_last_block(self, bq);
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$BlockQuote(indent_layout, bq));
    rami3l$cmark$cmark$$Parser$add_open_blocks_with_line_class(self, indent_start, indent, bs, ltype);
    return;
  }
}
function rami3l$cmark$cmark$$Parser$add_line(self, bs) {
  _L: {
    const _bind = moonbitlang$core$array$$Array$last$288$(bs);
    if (_bind === undefined) {
      break _L;
    } else {
      const _Some = _bind;
      const _x = _Some;
      switch (_x.$tag) {
        case 7: {
          const _Paragraph = _x;
          const _par = _Paragraph._0;
          moonbitlang$core$array$$Array$pop$288$(bs);
          rami3l$cmark$cmark$$Parser$try_add_to_paragraph(self, _par, bs);
          return;
        }
        case 8: {
          break _L;
        }
        case 3: {
          break _L;
        }
        case 1: {
          break _L;
        }
        case 6: {
          break _L;
        }
        case 5: {
          const _List = _x;
          const _l = _List._0;
          moonbitlang$core$array$$Array$pop$288$(bs);
          rami3l$cmark$cmark$$Parser$try_add_to_list_item(self, _l, bs);
          return;
        }
        case 2: {
          const _CodeBlock = _x;
          const _x$2 = _CodeBlock._0;
          if (_x$2.$tag === 0) {
            const _Indented = _x$2;
            const _ls = _Indented._0;
            moonbitlang$core$array$$Array$pop$288$(bs);
            rami3l$cmark$cmark$$Parser$try_add_to_indented_code_block(self, _ls, bs);
            return;
          } else {
            const _Fenced = _x$2;
            const _f = _Fenced._0;
            moonbitlang$core$array$$Array$pop$288$(bs);
            rami3l$cmark$cmark$$Parser$try_add_to_fenced_code_block(self, _f, bs);
            return;
          }
        }
        case 0: {
          const _BlockQuote = _x;
          const _indent = _BlockQuote._0;
          const _bq = _BlockQuote._1;
          moonbitlang$core$array$$Array$pop$288$(bs);
          rami3l$cmark$cmark$$Parser$try_add_to_block_quote(self, _indent, _bq, bs);
          return;
        }
        case 4: {
          const _HtmlBlock = _x;
          const _html = _HtmlBlock._0;
          moonbitlang$core$array$$Array$pop$288$(bs);
          rami3l$cmark$cmark$$Parser$try_add_to_html_block(self, _html, bs);
          return;
        }
        case 9: {
          const _ExtTable = _x;
          const _indent$2 = _ExtTable._0;
          const _rows = _ExtTable._1;
          moonbitlang$core$array$$Array$pop$288$(bs);
          rami3l$cmark$cmark$$Parser$try_add_to_table(self, _indent$2, _rows, bs);
          return;
        }
        default: {
          const _ExtFootnote = _x;
          const _i = _ExtFootnote._0;
          const _l$2 = _ExtFootnote._1;
          const _blocks = _ExtFootnote._2;
          moonbitlang$core$array$$Array$pop$288$(bs);
          rami3l$cmark$cmark$$Parser$try_add_to_footnote(self, _i, _l$2, _blocks, bs);
          return;
        }
      }
    }
  }
  rami3l$cmark$cmark$$Parser$add_open_blocks(self, bs);
}
function rami3l$cmark$cmark$$Parser$try_add_to_footnote(self, fn_indent, label, blocks, bs) {
  const indent_start = self.curr_char;
  const indent = rami3l$cmark$cmark$$Parser$curr_indent(self);
  if (indent < (fn_indent + 1 | 0)) {
    let lt;
    _L: {
      const _bind = rami3l$cmark$cmark$$Parser$match_line_type(self, true, indent);
      switch (_bind.$tag) {
        case 5: {
          lt = _bind;
          break _L;
        }
        case 7: {
          lt = _bind;
          break _L;
        }
        case 1: {
          rami3l$cmark$cmark$$Parser$add_line(self, blocks);
          moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtFootnote(fn_indent, label, blocks));
          return;
        }
        default: {
          rami3l$cmark$cmark$$Parser$close_footnote(self, fn_indent, label, blocks, bs);
          rami3l$cmark$cmark$$Parser$add_open_blocks_with_line_class(self, indent_start, indent, bs, _bind);
          return;
        }
      }
    }
    if (rami3l$cmark$cmark$$Parser$try_lazy_continuation(self, indent_start, blocks)) {
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtFootnote(fn_indent, label, blocks));
      return;
    } else {
      rami3l$cmark$cmark$$Parser$close_last_block(self, blocks);
      rami3l$cmark$cmark$$Parser$close_footnote(self, fn_indent, label, blocks, bs);
      rami3l$cmark$cmark$$Parser$add_open_blocks_with_line_class(self, indent_start, indent, bs, lt);
      return;
    }
  } else {
    rami3l$cmark$cmark$$Parser$accept_cols(self, fn_indent + 1 | 0);
    rami3l$cmark$cmark$$Parser$add_line(self, blocks);
    moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$ExtFootnote(fn_indent, label, blocks));
    return;
  }
}
function rami3l$cmark$cmark$$Parser$try_add_to_list_item(self, list, bs) {
  const indent_start = self.curr_char;
  const indent = rami3l$cmark$cmark$$Parser$curr_indent(self);
  if (indent >= list.item_min_indent) {
    const last_blank = rami3l$cmark$cmark$$Parser$only_blanks(self);
    const _bind = moonbitlang$core$array$$Array$last$238$(list.items);
    if (_bind === undefined) {
      $panic();
    } else {
      const _Some = _bind;
      const _item = _Some;
      if (list.last_blank && (!last_blank && moonbitlang$core$builtin$$Iter$all$288$(moonbitlang$core$array$$Array$iter$288$(_item.blocks), rami3l$cmark$cmark$$BlockStruct$is_blank_line))) {
        moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$List(list));
        rami3l$cmark$cmark$$Parser$add_open_blocks(self, bs);
      } else {
        rami3l$cmark$cmark$$Parser$accept_cols(self, list.item_min_indent);
        rami3l$cmark$cmark$$Parser$add_line(self, _item.blocks);
        moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$List({ last_blank: last_blank, loose: list.loose, item_min_indent: list.item_min_indent, list_type: list.list_type, items: list.items }));
      }
      return undefined;
    }
  }
  let ltype;
  _L: {
    const _bind = rami3l$cmark$cmark$$Parser$match_line_type(self, true, indent);
    switch (_bind.$tag) {
      case 1: {
        const items = list.items;
        const _bind$2 = moonbitlang$core$array$$Array$last$238$(items);
        if (_bind$2 === undefined) {
          $panic();
          return;
        } else {
          const _Some = _bind$2;
          const _item = _Some;
          rami3l$cmark$cmark$$Parser$add_line(self, _item.blocks);
          moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$List({ last_blank: true, loose: list.loose, item_min_indent: list.item_min_indent, list_type: list.list_type, items: items }));
          return;
        }
      }
      case 5: {
        ltype = _bind;
        break _L;
      }
      case 7: {
        ltype = _bind;
        break _L;
      }
      case 6: {
        const _ListMarkerLine = _bind;
        const _marker = _ListMarkerLine._0;
        const _marker_last = _ListMarkerLine._1;
        rami3l$cmark$cmark$$Parser$try_add_to_list(self, indent, _marker, _marker_last, list, bs);
        return;
      }
      default: {
        rami3l$cmark$cmark$$Parser$close_list(self, list, bs);
        rami3l$cmark$cmark$$Parser$add_open_blocks_with_line_class(self, indent_start, indent, bs, _bind);
        return;
      }
    }
  }
  const items = list.items;
  const _bind = moonbitlang$core$array$$Array$last$238$(items);
  if (_bind === undefined) {
    $panic();
    return;
  } else {
    const _Some = _bind;
    const _item = _Some;
    if (rami3l$cmark$cmark$$Parser$try_lazy_continuation(self, indent_start, _item.blocks)) {
      moonbitlang$core$array$$Array$push$288$(bs, new $64$rami3l$47$cmark$47$cmark$46$BlockStruct$List({ last_blank: false, loose: list.loose, item_min_indent: list.item_min_indent, list_type: list.list_type, items: items }));
      return;
    } else {
      rami3l$cmark$cmark$$Parser$close_list(self, list, bs);
      rami3l$cmark$cmark$$Parser$add_open_blocks_with_line_class(self, indent_start, indent, bs, ltype);
      return;
    }
  }
}
function rami3l$cmark$cmark$$Parser$get_first_line(self) {
  const max = self.i.length - 1 | 0;
  let k = 0;
  let last_char;
  while (true) {
    let _tmp;
    if (k <= max) {
      let _tmp$2;
      const _tmp$3 = self.i;
      const _tmp$4 = k;
      $bound_check(_tmp$3, _tmp$4);
      if (_tmp$3.charCodeAt(_tmp$4) !== 13) {
        const _tmp$5 = self.i;
        const _tmp$6 = k;
        $bound_check(_tmp$5, _tmp$6);
        _tmp$2 = _tmp$5.charCodeAt(_tmp$6) !== 10;
      } else {
        _tmp$2 = false;
      }
      _tmp = _tmp$2;
    } else {
      _tmp = false;
    }
    if (_tmp) {
      k = k + 1 | 0;
      continue;
    } else {
      last_char = k - 1 | 0;
      break;
    }
  }
  self.curr_line_last_char = last_char;
  rami3l$cmark$cmark$$Parser$update_next_non_blank(self);
  let _tmp;
  if (k > max) {
    _tmp = true;
  } else {
    const _tmp$2 = self.i;
    const _tmp$3 = k;
    $bound_check(_tmp$2, _tmp$3);
    _tmp = _tmp$2.charCodeAt(_tmp$3) === 10;
  }
  if (_tmp) {
    return "\n";
  }
  const next = k + 1 | 0;
  let _tmp$2;
  if (next <= max) {
    const _tmp$3 = self.i;
    $bound_check(_tmp$3, next);
    _tmp$2 = _tmp$3.charCodeAt(next) === 10;
  } else {
    _tmp$2 = false;
  }
  if (_tmp$2) {
    return "\r\n";
  }
  return "\r";
}
function rami3l$cmark$cmark$$Parser$get_next_line(self) {
  const max = self.i.length - 1 | 0;
  if (self.curr_line_last_char === max) {
    return false;
  }
  const nl = self.curr_line_last_char + 1 | 0;
  let first_char;
  const _tmp = self.i;
  $bound_check(_tmp, nl);
  if (_tmp.charCodeAt(nl) === 10) {
    first_char = nl + 1 | 0;
  } else {
    let next = nl + 1 | 0;
    let _tmp$2;
    if (next <= max) {
      const _tmp$3 = self.i;
      const _tmp$4 = next;
      $bound_check(_tmp$3, _tmp$4);
      _tmp$2 = _tmp$3.charCodeAt(_tmp$4) === 10;
    } else {
      _tmp$2 = false;
    }
    if (_tmp$2) {
      next = next + 1 | 0;
    }
    first_char = next;
  }
  let last_char;
  let _tmp$2 = first_char;
  while (true) {
    const k = _tmp$2;
    let _tmp$3;
    if (k <= max) {
      let _tmp$4;
      const _tmp$5 = self.i;
      $bound_check(_tmp$5, k);
      if (_tmp$5.charCodeAt(k) !== 13) {
        const _tmp$6 = self.i;
        $bound_check(_tmp$6, k);
        _tmp$4 = _tmp$6.charCodeAt(k) !== 10;
      } else {
        _tmp$4 = false;
      }
      _tmp$3 = _tmp$4;
    } else {
      _tmp$3 = false;
    }
    if (_tmp$3) {
      _tmp$2 = k + 1 | 0;
      continue;
    } else {
      last_char = k - 1 | 0;
      break;
    }
  }
  self.curr_line_pos = { _0: self.curr_line_pos._0 + 1 | 0, _1: first_char };
  self.curr_line_last_char = last_char;
  self.curr_char = first_char;
  self.curr_char_col = 0;
  self.tab_consumed_cols = 0;
  rami3l$cmark$cmark$$Parser$update_next_non_blank(self);
  return true;
}
function rami3l$cmark$cmark$$Parser$parse_block(self) {
  const nl = rami3l$cmark$cmark$$Parser$get_first_line(self);
  let blocks;
  let _tmp = [];
  while (true) {
    const _param = _tmp;
    rami3l$cmark$cmark$$Parser$add_line(self, _param);
    if (rami3l$cmark$cmark$$Parser$get_next_line(self)) {
      continue;
    }
    rami3l$cmark$cmark$$Parser$end_doc(self, _param);
    blocks = { v: _param, meta: rami3l$cmark$cmark$$Parser$meta(self, { file: self.file, first_byte: 0, last_byte: self.curr_line_last_char, first_line: { _0: 1, _1: 0 }, last_line: self.curr_line_pos }) };
    break;
  }
  return { _0: nl, _1: blocks };
}
function rami3l$cmark$cmark$$Parser$block_struct_to_blank_line(self, pad, span) {
  return new $64$rami3l$47$cmark$47$cmark$46$Block$BlankLine(rami3l$cmark$cmark$$Parser$clean_raw_span(self, pad, span));
}
function rami3l$cmark$cmark$$Parser$block_struct_to_code_block(self, b) {
  if (b.$tag === 0) {
    const _Indented = b;
    const _ls = _Indented._0;
    const line = (i) => rami3l$cmark$cmark$$Parser$clean_raw_span(self, i.pad, i.code);
    const layout = $64$rami3l$47$cmark$47$cmark$46$CodeBlockLayout$Indented;
    const info_string = undefined;
    const last = moonbitlang$core$option$$Option$unwrap$278$(moonbitlang$core$array$$Array$last$278$(_ls)).code;
    const _p = new Array(_ls.length);
    const _p$2 = _ls.length;
    let _tmp = 0;
    while (true) {
      const _p$3 = _tmp;
      if (_p$3 < _p$2) {
        const _p$4 = _ls[_p$3];
        _p[_p$3] = line(_p$4);
        _tmp = _p$3 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const code = _p;
    const last_line = last.pos;
    const last_byte = last.last;
    const start = moonbitlang$core$array$$Array$op_get$108$(code, 0).meta.loc;
    const meta = rami3l$cmark$cmark$$Parser$meta(self, { file: start.file, first_byte: start.first_byte, last_byte: last_byte, first_line: start.first_line, last_line: last_line });
    return new $64$rami3l$47$cmark$47$cmark$46$Block$CodeBlock({ v: { layout: layout, info_string: info_string, code: code }, meta: meta });
  } else {
    const _Fenced = b;
    const _x = _Fenced._0;
    const _fence = _x.fence;
    const _ls = _x.code;
    const opening_fence = rami3l$cmark$cmark$$Parser$layout_clean_raw_span(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span$46$pad$46$default(), _fence.opening_fence);
    const closing_fence = moonbitlang$core$option$$Option$map$57$(_fence.closing_fence, (i) => rami3l$cmark$cmark$$Parser$layout_clean_raw_span(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span$46$pad$46$default(), i));
    const layout = { indent: _fence.indent, opening_fence: opening_fence, closing_fence: closing_fence };
    const info_string = moonbitlang$core$option$$Option$map$57$(_fence.info_string, (i) => rami3l$cmark$cmark$$Parser$clean_unesc_unref_span(self, i));
    const _p = new Array(_ls.length);
    const _p$2 = _ls.length;
    let _tmp = 0;
    while (true) {
      const _p$3 = _tmp;
      if (_p$3 < _p$2) {
        const _p$4 = _ls[_p$3];
        const i = _p$4;
        _p[_p$3] = rami3l$cmark$cmark$$Parser$clean_raw_span(self, i._0, i._1);
        _tmp = _p$3 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const code = _p;
    const first = _fence.opening_fence;
    const _bind = _fence.closing_fence;
    let last;
    if (_bind === undefined) {
      const _bind$2 = moonbitlang$core$array$$Array$last$306$(_ls);
      if (_bind$2 === undefined) {
        last = first;
      } else {
        const _Some = _bind$2;
        const _x$2 = _Some;
        const _last = _x$2._1;
        last = _last;
      }
    } else {
      const _Some = _bind;
      const _last = _Some;
      last = _last;
    }
    const meta = rami3l$cmark$cmark$$Parser$meta_of_spans(self, first, last);
    const cb = { layout: new $64$rami3l$47$cmark$47$cmark$46$CodeBlockLayout$Fenced(layout), info_string: info_string, code: code };
    if (self.exts && rami3l$cmark$cmark$$CodeBlock$is_math_block(moonbitlang$core$option$$Option$map$58$(info_string, (i) => i.v))) {
      return new $64$rami3l$47$cmark$47$cmark$46$Block$ExtMathBlock({ v: cb, meta: meta });
    }
    return new $64$rami3l$47$cmark$47$cmark$46$Block$CodeBlock({ v: cb, meta: meta });
  }
}
function rami3l$cmark$cmark$$Parser$block_struct_to_heading(self, b) {
  if (b.$tag === 0) {
    const _Atx = b;
    const _x = _Atx._0;
    const _indent = _x.indent;
    const _level = _x.level;
    const _after_open = _x.after_open;
    const _heading = _x.heading;
    const _layout_after = _x.layout_after;
    const last = _heading.first - 1 | 0;
    const after_opening = rami3l$cmark$cmark$$Parser$layout_clean_raw_span1(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span1$46$pad$46$default(), { pos: _heading.pos, first: _after_open, last: last });
    const closing = rami3l$cmark$cmark$$Parser$layout_clean_raw_span1(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span1$46$pad$46$default(), _layout_after);
    const layout = new $64$rami3l$47$cmark$47$cmark$46$BlockHeadingLayout$Atx({ indent: _indent, after_opening: after_opening, closing: closing });
    const meta = rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark$$Parser$text_loc_of_span(self, { pos: _heading.pos, first: _after_open - _level | 0, last: _heading.last }));
    const _bind = rami3l$cmark$cmark$$Parser$parse_inline(self, [_heading]);
    const _inline = _bind._1;
    const id = self.heading_auto_ids ? new $64$rami3l$47$cmark$47$cmark$46$BlockHeadingId$Auto(rami3l$cmark$cmark$$Inline$id(_inline, rami3l$cmark$cmark$$Inline$id$46$buf$46$default())) : undefined;
    return new $64$rami3l$47$cmark$47$cmark$46$Block$Heading({ v: { layout: layout, level: _level, inline: _inline, id: id }, meta: meta });
  } else {
    const _Setext = b;
    const _x = _Setext._0;
    const _level = _x.level;
    const _heading_lines = _x.heading_lines;
    const _underline = _x.underline;
    const _bind = rami3l$cmark$cmark$$Parser$parse_inline(self, _heading_lines);
    const _x$2 = _bind._0;
    const _leading_indent = _x$2._0;
    const _trailing_blanks = _x$2._1;
    const _inline = _bind._1;
    const _underline_indent = _underline._0;
    const _u = _underline._1;
    const _blanks = _underline._2;
    const underline_blanks = rami3l$cmark$cmark$$Parser$layout_clean_raw_span1(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span1$46$pad$46$default(), _blanks);
    const underline_count = { v: (_u.last - _u.first | 0) + 1 | 0, meta: rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark$$Parser$text_loc_of_span(self, _u)) };
    const layout = { leading_indent: _leading_indent, trailing_blanks: _trailing_blanks, underline_indent: _underline_indent, underline_count: underline_count, underline_blanks: underline_blanks };
    const last_line = _u.pos;
    const last_byte = _u.last;
    const start = rami3l$cmark$cmark$$Inline$meta(_inline).loc;
    const meta = rami3l$cmark$cmark$$Parser$meta(self, { file: start.file, first_byte: start.first_byte, last_byte: last_byte, first_line: start.first_line, last_line: last_line });
    const id = self.heading_auto_ids ? new $64$rami3l$47$cmark$47$cmark$46$BlockHeadingId$Auto(rami3l$cmark$cmark$$Inline$id(_inline, self.buf)) : undefined;
    return new $64$rami3l$47$cmark$47$cmark$46$Block$Heading({ v: { layout: new $64$rami3l$47$cmark$47$cmark$46$BlockHeadingLayout$Setext(layout), level: _level, inline: _inline, id: id }, meta: meta });
  }
}
function rami3l$cmark$cmark$$Parser$block_struct_to_html_block(self, b) {
  const _bind = moonbitlang$core$array$$Array$last$239$(b.html);
  if (_bind === undefined) {
    return $panic();
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _last_byte = _x.last;
    const _last_line = _x.pos;
    const _p = b.html;
    const _p$2 = new Array(_p.length);
    const _p$3 = _p.length;
    let _tmp = 0;
    while (true) {
      const _p$4 = _tmp;
      if (_p$4 < _p$3) {
        const _p$5 = _p[_p$4];
        const i = _p$5;
        _p$2[_p$4] = rami3l$cmark$cmark$$Parser$clean_raw_span(self, rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default(), i);
        _tmp = _p$4 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const lines = _p$2;
    const start_loc = moonbitlang$core$option$$Option$unwrap$108$(moonbitlang$core$array$$Array$last$108$(lines)).meta.loc;
    const meta = rami3l$cmark$cmark$$Parser$meta(self, { file: start_loc.file, first_byte: start_loc.first_byte, last_byte: _last_byte, first_line: start_loc.first_line, last_line: _last_line });
    return new $64$rami3l$47$cmark$47$cmark$46$Block$HtmlBlock({ v: rami3l$cmark$cmark$$Seq$from_array$108$(lines), meta: meta });
  }
}
function rami3l$cmark$cmark$$Parser$block_struct_to_paragraph(self, par) {
  const _bind = rami3l$cmark$cmark$$Parser$parse_inline(self, par.lines);
  const _layout = _bind._0;
  const _inline = _bind._1;
  const _leading_indent = _layout._0;
  const _trailing_blanks = _layout._1;
  const meta = rami3l$cmark$cmark$$Inline$meta(_inline);
  return new $64$rami3l$47$cmark$47$cmark$46$Block$Paragraph({ v: { leading_indent: _leading_indent, inline: _inline, trailing_blanks: _trailing_blanks }, meta: meta });
}
function rami3l$cmark$cmark$$Parser$block_struct_to_thematic_break(self, indent, span) {
  const _bind = rami3l$cmark$cmark$$Parser$clean_raw_span(self, rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default(), span);
  const _layout = _bind.v;
  const _meta = _bind.meta;
  return new $64$rami3l$47$cmark$47$cmark$46$Block$ThematicBreak({ v: { indent: indent, layout: _layout }, meta: _meta });
}
function rami3l$cmark$cmark$$Parser$block_struct_to_table(self, indent, rows) {
  const _bind = moonbitlang$core$array$$Array$last$307$(rows);
  if (_bind === undefined) {
    return $panic();
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _last = _x._0;
    let _bind$2;
    let _tmp = 0;
    let _tmp$2 = false;
    let _tmp$3 = [];
    let _tmp$4 = { buf: rows, start: 0, len: rows.length };
    while (true) {
      const _param = _tmp;
      const _param$2 = _tmp$2;
      const _param$3 = _tmp$3;
      const _param$4 = _tmp$4;
      if (_param$4.len >= 1) {
        const _x$2 = _param$4.buf[_param$4.start + (_param$4.len - 1 | 0) | 0];
        const _row = _x$2._0;
        const _blanks = _x$2._1;
        const _tmp$5 = _param$4.buf;
        const _tmp$6 = _param$4.start;
        const _some = _param$4.len - 1 | 0;
        const _x$3 = { buf: _tmp$5, start: _tmp$6, len: _some };
        const meta = rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark$$Parser$text_loc_of_span(self, _row));
        const row1 = { pos: _row.pos, first: _row.first + 1 | 0, last: _row.last };
        const cols = rami3l$cmark$cmark$$Parser$parse_table_row(self, row1);
        const col_count = moonbitlang$core$math$$maximum$7$(_param, cols.length);
        const _bind$3 = rami3l$cmark$cmark$$Table$parse_sep_row({ buf: cols, start: 0, len: cols.length });
        let _bind$4;
        if (_bind$3.$tag === 1) {
          const _Some$2 = _bind$3;
          const _seps = _Some$2._0;
          _bind$4 = { _0: { v: new $64$rami3l$47$cmark$47$cmark$46$TableRow$Sep(_seps), meta: meta }, _1: true };
        } else {
          const v = _param$2 ? new $64$rami3l$47$cmark$47$cmark$46$TableRow$Header(cols) : new $64$rami3l$47$cmark$47$cmark$46$TableRow$Data(cols);
          _bind$4 = { _0: { v: v, meta: meta }, _1: false };
        }
        const _r = _bind$4._0;
        const _last_was_sep = _bind$4._1;
        moonbitlang$core$array$$Array$push$200$(_param$3, { _0: _r, _1: rami3l$cmark$cmark$$Parser$layout_clean_raw_span1(self, rami3l$cmark$cmark$$Parser$layout_clean_raw_span1$46$pad$46$default(), _blanks) });
        const acc = _param$3;
        if (moonbitlang$core$array$$ArrayView$length$307$(_x$3) !== 0) {
          _tmp = col_count;
          _tmp$2 = _last_was_sep;
          _tmp$3 = acc;
          _tmp$4 = _x$3;
          continue;
        } else {
          _bind$2 = { _0: _row, _1: col_count, _2: acc };
          break;
        }
      } else {
        _bind$2 = moonbitlang$core$abort$$abort$44$("unreachable");
        break;
      }
    }
    const _first = _bind$2._0;
    const _col_count = _bind$2._1;
    const _rows = _bind$2._2;
    moonbitlang$core$array$$Array$rev_inplace$200$(_rows);
    const meta = rami3l$cmark$cmark$$Parser$meta_of_spans(self, _first, _last);
    return new $64$rami3l$47$cmark$47$cmark$46$Block$ExtTable({ v: { indent: indent, col_count: _col_count, rows: _rows }, meta: meta });
  }
}
function rami3l$cmark$cmark$$Parser$block_struct_to_block_quote(self, indent, bs) {
  const _p = new Array(bs.length);
  const _p$2 = bs.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = bs[_p$3];
      const b = _p$4;
      _p[_p$3] = rami3l$cmark$cmark$$Parser$block_struct_to_block(self, b);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const acc = _p;
  let block;
  if (acc.length === 1) {
    const _b = acc[0];
    block = _b;
  } else {
    const first = rami3l$cmark$cmark$$Block$meta(moonbitlang$core$array$$Array$op_get$93$(acc, 0));
    const last = rami3l$cmark$cmark$$Block$meta(moonbitlang$core$option$$Option$unwrap$93$(moonbitlang$core$array$$Array$last$93$(acc)));
    const meta = rami3l$cmark$cmark$$Parser$meta_of_metas(self, first, last);
    block = new $64$rami3l$47$cmark$47$cmark$46$Block$Blocks({ v: acc, meta: meta });
  }
  return new $64$rami3l$47$cmark$47$cmark$46$Block$BlockQuote({ v: { indent: indent, block: block }, meta: rami3l$cmark$cmark$$Block$meta(block) });
}
function rami3l$cmark$cmark$$Parser$block_struct_to_block(self, b) {
  switch (b.$tag) {
    case 0: {
      const _BlockQuote = b;
      const _indent = _BlockQuote._0;
      const _bs = _BlockQuote._1;
      return rami3l$cmark$cmark$$Parser$block_struct_to_block_quote(self, _indent, _bs);
    }
    case 5: {
      const _List = b;
      const _l = _List._0;
      return rami3l$cmark$cmark$$Parser$block_struct_to_list(self, _l);
    }
    case 7: {
      const _Paragraph = b;
      const _par = _Paragraph._0;
      return rami3l$cmark$cmark$$Parser$block_struct_to_paragraph(self, _par);
    }
    case 8: {
      const _ThematicBreak = b;
      const _indent$2 = _ThematicBreak._0;
      const _span = _ThematicBreak._1;
      return rami3l$cmark$cmark$$Parser$block_struct_to_thematic_break(self, _indent$2, _span);
    }
    case 2: {
      const _CodeBlock = b;
      const _cb = _CodeBlock._0;
      return rami3l$cmark$cmark$$Parser$block_struct_to_code_block(self, _cb);
    }
    case 3: {
      const _Heading = b;
      const _h = _Heading._0;
      return rami3l$cmark$cmark$$Parser$block_struct_to_heading(self, _h);
    }
    case 4: {
      const _HtmlBlock = b;
      const _html = _HtmlBlock._0;
      return rami3l$cmark$cmark$$Parser$block_struct_to_html_block(self, _html);
    }
    case 1: {
      const _BlankLine = b;
      const _pad = _BlankLine._0;
      const _span$2 = _BlankLine._1;
      return rami3l$cmark$cmark$$Parser$block_struct_to_blank_line(self, _pad, _span$2);
    }
    case 6: {
      const _LinkRefDef = b;
      const _r = _LinkRefDef._0;
      return new $64$rami3l$47$cmark$47$cmark$46$Block$LinkRefDefinition(_r);
    }
    case 9: {
      const _ExtTable = b;
      const _i = _ExtTable._0;
      const _rows = _ExtTable._1;
      return rami3l$cmark$cmark$$Parser$block_struct_to_table(self, _i, _rows);
    }
    default: {
      const _ExtFootnote = b;
      const _i$2 = _ExtFootnote._0;
      const _x = _ExtFootnote._1;
      const _lb = _x._0;
      const _dlb = _x._1;
      const _bs$2 = _ExtFootnote._2;
      return rami3l$cmark$cmark$$Parser$block_struct_to_footnote_definition(self, _i$2, _lb, _dlb, _bs$2);
    }
  }
}
function rami3l$cmark$cmark$$Parser$block_struct_to_footnote_definition(self, indent, label, defined_label, bs) {
  const _p = new Array(bs.length);
  const _p$2 = bs.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = bs[_p$3];
      const b = _p$4;
      _p[_p$3] = rami3l$cmark$cmark$$Parser$block_struct_to_block(self, b);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const block = _p;
  const last = rami3l$cmark$cmark$$Block$meta(moonbitlang$core$option$$Option$unwrap$93$(moonbitlang$core$array$$Array$last$93$(block)));
  let block$2;
  if (block.length === 1) {
    const _b = block[0];
    block$2 = _b;
  } else {
    const first = rami3l$cmark$cmark$$Block$meta(moonbitlang$core$array$$Array$op_get$93$(block, 0));
    const meta = rami3l$cmark$cmark$$Parser$meta_of_metas(self, first, last);
    block$2 = new $64$rami3l$47$cmark$47$cmark$46$Block$Blocks({ v: block, meta: meta });
  }
  const labelloc = rami3l$cmark$cmark$$Label$text_loc(label);
  const lastloc = last.loc;
  const loc = rami3l$cmark$cmark_base$$TextLoc$span(labelloc, lastloc);
  const first_byte = loc.first_byte - 1 | 0;
  const loc$2 = { file: loc.file, first_byte: first_byte, last_byte: loc.last_byte, first_line: loc.first_line, last_line: loc.last_line };
  const footnote = { v: { indent: indent, label: label, defined_label: defined_label, block: block$2 }, meta: rami3l$cmark$cmark$$Parser$meta(self, loc$2) };
  if (defined_label === undefined) {
  } else {
    const _Some = defined_label;
    const _def = _Some;
    rami3l$cmark$cmark$$Parser$set_label_def(self, _def, new $64$rami3l$47$cmark$47$cmark$46$LabelDef$FootnoteDef(footnote));
  }
  return new $64$rami3l$47$cmark$47$cmark$46$Block$ExtFootnoteDefinition(footnote);
}
function rami3l$cmark$cmark$$Parser$block_struct_to_list(self, list) {
  const items = list.items;
  const _bind = rami3l$cmark$cmark$$Parser$block_struct_to_list_item(self, moonbitlang$core$array$$Array$op_get$238$(items, 0));
  const _first = _bind._0;
  const _tight = _bind._1;
  let _bind$2;
  let _tmp = !list.loose && _tight;
  let _tmp$2 = [_first];
  let _tmp$3 = moonbitlang$core$array$$Array$op_as_view$238$(items, 1, undefined);
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    if (_param$3.len === 0) {
      _bind$2 = { _0: _param, _1: _param$2 };
      break;
    } else {
      const _item = _param$3.buf[_param$3.start];
      const _tmp$4 = _param$3.buf;
      const _tmp$5 = 1 + _param$3.start | 0;
      const _some = _param$3.len;
      const _x = { buf: _tmp$4, start: _tmp$5, len: _some - 1 | 0 };
      const _bind$3 = rami3l$cmark$cmark$$Parser$block_struct_to_list_item(self, _item);
      const _item$2 = _bind$3._0;
      const _item_tight = _bind$3._1;
      const _tmp$6 = _param && _item_tight;
      moonbitlang$core$array$$Array$push$198$(_param$2, _item$2);
      _tmp = _tmp$6;
      _tmp$2 = _param$2;
      _tmp$3 = _x;
      continue;
    }
  }
  const _tight$2 = _bind$2._0;
  const _items = _bind$2._1;
  const meta = rami3l$cmark$cmark$$Parser$meta_of_metas(self, _first.meta, moonbitlang$core$option$$Option$unwrap$198$(moonbitlang$core$array$$Array$last$198$(_items)).meta);
  return new $64$rami3l$47$cmark$47$cmark$46$Block$List({ v: { ty: list.list_type, tight: _tight$2, items: _items }, meta: meta });
}
function rami3l$cmark$cmark$$block_struct_to_list_item$46$go$124$228(self, bstate, tight, acc, bs) {
  let _tmp = bstate;
  let _tmp$2 = tight;
  let _tmp$3 = acc;
  let _tmp$4 = bs;
  _L: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    let acc$2;
    let bstate$2;
    let tight$2;
    let bs$2;
    let b;
    _L$2: {
      if (_param$4.len >= 1) {
        const _x = _param$4.buf[_param$4.start];
        switch (_x.$tag) {
          case 1: {
            const _BlankLine = _x;
            const _tmp$5 = _param$4.buf;
            const _tmp$6 = 1 + _param$4.start | 0;
            const _some = _param$4.len;
            const _x$2 = { buf: _tmp$5, start: _tmp$6, len: _some - 1 | 0 };
            const bstate$3 = moonbitlang$core$builtin$$Eq$op_equal$235$(_param, 1) ? 1 : 0;
            moonbitlang$core$array$$Array$push$93$(_param$3, rami3l$cmark$cmark$$Parser$block_struct_to_block(self, _BlankLine));
            _tmp = bstate$3;
            _tmp$3 = _param$3;
            _tmp$4 = _x$2;
            continue _L;
          }
          case 5: {
            const _List = _x;
            const _x$3 = _List._0;
            const _x$4 = _x$3.items;
            if (_x$4.length >= 1) {
              const _x$5 = _x$4[_x$4.length - 1 | 0];
              const _x$6 = _x$5.blocks;
              if (_x$6.length >= 1) {
                const _x$7 = _x$6[_x$6.length - 1 | 0];
                if (_x$7.$tag === 1) {
                  const _tmp$7 = _param$4.buf;
                  const _tmp$8 = 1 + _param$4.start | 0;
                  const _some$2 = _param$4.len;
                  const _x$8 = { buf: _tmp$7, start: _tmp$8, len: _some$2 - 1 | 0 };
                  moonbitlang$core$array$$Array$push$93$(_param$3, rami3l$cmark$cmark$$Parser$block_struct_to_block(self, _List));
                  _tmp$2 = false;
                  _tmp$3 = _param$3;
                  _tmp$4 = _x$8;
                  continue _L;
                } else {
                  const _tmp$7 = _param$4.buf;
                  const _tmp$8 = 1 + _param$4.start | 0;
                  const _some$2 = _param$4.len;
                  const _x$8 = { buf: _tmp$7, start: _tmp$8, len: _some$2 - 1 | 0 };
                  acc$2 = _param$3;
                  bstate$2 = _param;
                  tight$2 = _param$2;
                  bs$2 = _x$8;
                  b = _x;
                  break _L$2;
                }
              } else {
                const _tmp$7 = _param$4.buf;
                const _tmp$8 = 1 + _param$4.start | 0;
                const _some$2 = _param$4.len;
                const _x$7 = { buf: _tmp$7, start: _tmp$8, len: _some$2 - 1 | 0 };
                acc$2 = _param$3;
                bstate$2 = _param;
                tight$2 = _param$2;
                bs$2 = _x$7;
                b = _x;
                break _L$2;
              }
            } else {
              const _tmp$7 = _param$4.buf;
              const _tmp$8 = 1 + _param$4.start | 0;
              const _some$2 = _param$4.len;
              const _x$5 = { buf: _tmp$7, start: _tmp$8, len: _some$2 - 1 | 0 };
              acc$2 = _param$3;
              bstate$2 = _param;
              tight$2 = _param$2;
              bs$2 = _x$5;
              b = _x;
              break _L$2;
            }
          }
          default: {
            const _tmp$7 = _param$4.buf;
            const _tmp$8 = 1 + _param$4.start | 0;
            const _some$2 = _param$4.len;
            const _x$5 = { buf: _tmp$7, start: _tmp$8, len: _some$2 - 1 | 0 };
            acc$2 = _param$3;
            bstate$2 = _param;
            tight$2 = _param$2;
            bs$2 = _x$5;
            b = _x;
            break _L$2;
          }
        }
      } else {
        return { _0: _param$2, _1: _param$3 };
      }
    }
    const tight$3 = tight$2 && moonbitlang$core$builtin$$op_notequal$235$(bstate$2, 0);
    moonbitlang$core$array$$Array$push$93$(acc$2, rami3l$cmark$cmark$$Parser$block_struct_to_block(self, b));
    _tmp = 2;
    _tmp$2 = tight$3;
    _tmp$3 = acc$2;
    _tmp$4 = bs$2;
    continue;
  }
}
function rami3l$cmark$cmark$$Parser$block_struct_to_list_item(self, i) {
  let _bind;
  let bs;
  let b;
  _L: {
    _L$2: {
      const _bind$2 = i.blocks;
      const _bind_len = _bind$2.length;
      if (_bind_len === 1) {
        const _x = _bind$2[0];
        if (_x.$tag === 1) {
          const _BlankLine = _x;
          const bl = rami3l$cmark$cmark$$Parser$block_struct_to_block(self, _BlankLine);
          _bind = { _0: rami3l$cmark$cmark$$Block$meta(bl), _1: { _0: true, _1: [bl] } };
        } else {
          const _some = _bind_len;
          const _x$2 = { buf: _bind$2, start: 1, len: _some - 1 | 0 };
          bs = _x$2;
          b = _x;
          break _L$2;
        }
      } else {
        if (_bind_len >= 1) {
          const _x = _bind$2[0];
          if (_x.$tag === 1) {
            const _BlankLine = _x;
            const _some = _bind_len;
            const _x$2 = { buf: _bind$2, start: 1, len: _some - 1 | 0 };
            const bl = rami3l$cmark$cmark$$Parser$block_struct_to_block(self, _BlankLine);
            _bind = { _0: rami3l$cmark$cmark$$Block$meta(bl), _1: rami3l$cmark$cmark$$block_struct_to_list_item$46$go$124$228(self, 1, true, [bl], _x$2) };
          } else {
            const _some = _bind_len;
            const _x$2 = { buf: _bind$2, start: 1, len: _some - 1 | 0 };
            bs = _x$2;
            b = _x;
            break _L$2;
          }
        } else {
          _bind = moonbitlang$core$abort$$abort$45$("unreachable");
        }
      }
      break _L;
    }
    const b$2 = rami3l$cmark$cmark$$Parser$block_struct_to_block(self, b);
    _bind = { _0: rami3l$cmark$cmark$$Block$meta(b$2), _1: rami3l$cmark$cmark$$block_struct_to_list_item$46$go$124$228(self, 2, true, [b$2], bs) };
  }
  const _last_meta = _bind._0;
  const _x = _bind._1;
  const _tight = _x._0;
  const _blocks = _x._1;
  let block;
  if (_blocks.length === 1) {
    const _i = _blocks[0];
    block = _i;
  } else {
    const first = rami3l$cmark$cmark$$Block$meta(moonbitlang$core$array$$Array$op_get$93$(_blocks, 0));
    block = new $64$rami3l$47$cmark$47$cmark$46$Block$Blocks({ v: _blocks, meta: rami3l$cmark$cmark$$Parser$meta_of_metas(self, first, _last_meta) });
  }
  const before_marker = i.before_marker;
  const after_marker = i.after_marker;
  const marker = rami3l$cmark$cmark$$Parser$clean_raw_span(self, rami3l$cmark$cmark$$Parser$clean_raw_span$46$pad$46$default(), i.marker);
  const ext_task_marker = moonbitlang$core$option$$Option$map$59$(i.ext_task_marker, (_param1) => {
    const _v = _param1._0;
    const _span = _param1._1;
    return { v: _v, meta: rami3l$cmark$cmark$$Parser$meta(self, rami3l$cmark$cmark$$Parser$text_loc_of_span(self, _span)) };
  });
  const v = { before_marker: before_marker, marker: marker, after_marker: after_marker, block: block, ext_task_marker: ext_task_marker };
  const meta = rami3l$cmark$cmark$$Parser$meta_of_metas(self, marker.meta, _last_meta);
  return { _0: { v: v, meta: meta }, _1: _tight };
}
function rami3l$cmark$cmark$$Parser$block_struct_to_doc(self, doc) {
  const _doc = doc.v;
  const _meta = doc.meta;
  const _p = new Array(_doc.length);
  const _p$2 = _doc.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = _doc[_p$3];
      const b = _p$4;
      _p[_p$3] = rami3l$cmark$cmark$$Parser$block_struct_to_block(self, b);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _bind = _p;
  if (_bind.length === 1) {
    const _b = _bind[0];
    return _b;
  } else {
    return new $64$rami3l$47$cmark$47$cmark$46$Block$Blocks({ v: _bind, meta: _meta });
  }
}
function rami3l$cmark$cmark$$Doc$new(nl, defs, block) {
  return { nl: nl, block: block, defs: defs };
}
function rami3l$cmark$cmark$$Parser$new(defs, resolver, nested_links, heading_auto_ids, layout, locs, file, strict, i) {
  const _bind = moonbitlang$core$builtin$$StringBuilder$new(512);
  const _bind$2 = !locs;
  const _bind$3 = !layout;
  const _bind$4 = !strict;
  const _bind$5 = rami3l$cmark$cmark$$CloserIndex$new();
  const _bind$6 = { _0: 1, _1: 0 };
  return { file: file, i: i, buf: _bind, exts: _bind$4, no_locs: _bind$2, no_layouts: _bind$3, heading_auto_ids: heading_auto_ids, nested_links: nested_links, defs: defs, resolver: resolver, cidx: _bind$5, curr_line_pos: _bind$6, curr_line_last_char: -1, curr_char: 0, curr_char_col: 0, next_non_blank: 0, next_non_blank_col: 0, tab_consumed_cols: 0 };
}
function rami3l$cmark$cmark$$Doc$from_string(defs, resolver, nested_links, heading_auto_ids, layout, locs, file, strict, s) {
  const p = rami3l$cmark$cmark$$Parser$new(defs, resolver, nested_links, heading_auto_ids, layout, locs, file, strict, s);
  const _bind = rami3l$cmark$cmark$$Parser$parse_block(p);
  const _nl = _bind._0;
  const _doc = _bind._1;
  const block = rami3l$cmark$cmark$$Parser$block_struct_to_doc(p, _doc);
  return rami3l$cmark$cmark$$Doc$new(_nl, p.defs, block);
}
function rami3l$cmark$cmark$$Doc$from_string$46$defs$46$default() {
  return moonbitlang$core$builtin$$Map$new$308$(moonbitlang$core$builtin$$Map$new$46$capacity$46$default$308$());
}
function rami3l$cmark$cmark$$Doc$from_string$46$resolver$46$default() {
  return rami3l$cmark$cmark$$LabelContext$default_resolver;
}
function rami3l$cmark$cmark$$Doc$from_string$46$nested_links$46$default() {
  return false;
}
function rami3l$cmark$cmark$$Doc$from_string$46$heading_auto_ids$46$default() {
  return false;
}
function rami3l$cmark$cmark$$Doc$from_string$46$layout$46$default() {
  return false;
}
function rami3l$cmark$cmark$$Doc$from_string$46$locs$46$default() {
  return false;
}
function rami3l$cmark$cmark$$Doc$from_string$46$file$46$default() {
  return rami3l$cmark$cmark_base$$file_path_none;
}
function moonbitlang$core$builtin$$Show$output$167$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_object$9$(logger, self.node.v);
}
function moonbitlang$mooncakes$util$highlight$$parse(signature) {
  let _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
  const _arg = moonbitlang$core$string$$String$view$46$start_offset$46$default();
  const _arg$2 = moonbitlang$core$string$$String$view$46$end_offset$46$default(signature);
  let _tmp$2 = moonbitlang$core$string$$String$view(signature, _arg, _arg$2);
  let _tmp$3 = $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$58$;
  _L: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    let acc;
    _L$2: {
      let c;
      let s;
      let acc$2;
      _L$3: {
        let s$2;
        let op;
        let acc$3;
        _L$4: {
          let c$2;
          let s$3;
          let acc$4;
          _L$5: {
            let s$4;
            let path;
            let id;
            let acc$5;
            _L$6: {
              let c$3;
              let s$5;
              let path$2;
              let id$2;
              let acc$6;
              _L$7: {
                let s$6;
                let acc$7;
                _L$8: {
                  let s$7;
                  let id$3;
                  let acc$8;
                  _L$9: {
                    let c$4;
                    let s$8;
                    let id$4;
                    let acc$9;
                    _L$10: {
                      let c$5;
                      let s$9;
                      let acc$10;
                      _L$11: {
                        let s$10;
                        let content;
                        let acc$11;
                        _L$12: {
                          let c$6;
                          let s$11;
                          let acc$12;
                          _L$13: {
                            let c$7;
                            let s$12;
                            let content$2;
                            let acc$13;
                            _L$14: {
                              let s$13;
                              let content$3;
                              let acc$14;
                              _L$15: {
                                let s$14;
                                let acc$15;
                                _L$16: {
                                  let c$8;
                                  let s$15;
                                  let content$4;
                                  let acc$16;
                                  _L$17: {
                                    let s$16;
                                    let content$5;
                                    let acc$17;
                                    _L$18: {
                                      let s$17;
                                      let acc$18;
                                      _L$19: {
                                        let s$18;
                                        let nums;
                                        let acc$19;
                                        _L$20: {
                                          let c$9;
                                          let s$19;
                                          let nums$2;
                                          let acc$20;
                                          _L$21: {
                                            let c$10;
                                            let s$20;
                                            let acc$21;
                                            _L$22: {
                                              let c$11;
                                              let s$21;
                                              let href;
                                              let content$6;
                                              let acc$22;
                                              _L$23: {
                                                let c$12;
                                                let s$22;
                                                let href$2;
                                                let acc$23;
                                                _L$24: {
                                                  let s$23;
                                                  let content$7;
                                                  let acc$24;
                                                  _L$25: {
                                                    let s$24;
                                                    let n;
                                                    let acc$25;
                                                    _L$26: {
                                                      switch (_param.$tag) {
                                                        case 0: {
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            switch (_x) {
                                                              case 10: {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                const _tmp$7 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$($64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Newline, _param$3);
                                                                _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
                                                                _tmp$2 = _x$2;
                                                                _tmp$3 = _tmp$7;
                                                                continue _L;
                                                              }
                                                              case 32: {
                                                                const _tmp$8 = _param$2.str;
                                                                const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$9;
                                                                if (_bind$2 === undefined) {
                                                                  _tmp$9 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind$2;
                                                                  _tmp$9 = _Some;
                                                                }
                                                                const _tmp$10 = _tmp$9;
                                                                const _x$3 = { str: _tmp$8, start: _tmp$10, end: _param$2.end };
                                                                const _tmp$11 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexSpace(1);
                                                                _tmp = _tmp$11;
                                                                _tmp$2 = _x$3;
                                                                continue _L;
                                                              }
                                                              default: {
                                                                if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 2, _param$2.start, _param$2.end)) {
                                                                  if (_x === 47) {
                                                                    const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end));
                                                                    if (_x$4 === 47) {
                                                                      const _tmp$12 = _param$2.str;
                                                                      const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 2, _param$2.start, _param$2.end);
                                                                      let _tmp$13;
                                                                      if (_bind$3 === undefined) {
                                                                        _tmp$13 = _param$2.end;
                                                                      } else {
                                                                        const _Some = _bind$3;
                                                                        _tmp$13 = _Some;
                                                                      }
                                                                      const _tmp$14 = _tmp$13;
                                                                      const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                      const _tmp$15 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexComment($64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$);
                                                                      _tmp = _tmp$15;
                                                                      _tmp$2 = _x$5;
                                                                      continue _L;
                                                                    } else {
                                                                      const _tmp$12 = _param$2.str;
                                                                      const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                      let _tmp$13;
                                                                      if (_bind$3 === undefined) {
                                                                        _tmp$13 = _param$2.end;
                                                                      } else {
                                                                        const _Some = _bind$3;
                                                                        _tmp$13 = _Some;
                                                                      }
                                                                      const _tmp$14 = _tmp$13;
                                                                      const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                      if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                        c$2 = _x;
                                                                        s$3 = _x$5;
                                                                        acc$4 = _param$3;
                                                                        break _L$5;
                                                                      } else {
                                                                        c = _x;
                                                                        s = _x$5;
                                                                        acc$2 = _param$3;
                                                                        break _L$3;
                                                                      }
                                                                    }
                                                                  } else {
                                                                    if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 9, _param$2.start, _param$2.end)) {
                                                                      if (_x === 60) {
                                                                        const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end));
                                                                        if (_x$4 === 97) {
                                                                          const _x$5 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 2, _param$2.start, _param$2.end));
                                                                          if (_x$5 === 32) {
                                                                            const _x$6 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 3, _param$2.start, _param$2.end));
                                                                            if (_x$6 === 104) {
                                                                              const _x$7 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 4, _param$2.start, _param$2.end));
                                                                              if (_x$7 === 114) {
                                                                                const _x$8 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 5, _param$2.start, _param$2.end));
                                                                                if (_x$8 === 101) {
                                                                                  const _x$9 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 6, _param$2.start, _param$2.end));
                                                                                  if (_x$9 === 102) {
                                                                                    const _x$10 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 7, _param$2.start, _param$2.end));
                                                                                    if (_x$10 === 61) {
                                                                                      const _x$11 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 8, _param$2.start, _param$2.end));
                                                                                      if (_x$11 === 34) {
                                                                                        const _tmp$12 = _param$2.str;
                                                                                        const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 9, _param$2.start, _param$2.end);
                                                                                        let _tmp$13;
                                                                                        if (_bind$3 === undefined) {
                                                                                          _tmp$13 = _param$2.end;
                                                                                        } else {
                                                                                          const _Some = _bind$3;
                                                                                          _tmp$13 = _Some;
                                                                                        }
                                                                                        const _tmp$14 = _tmp$13;
                                                                                        const _x$12 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                        const _tmp$15 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexLinkHref($64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$);
                                                                                        _tmp = _tmp$15;
                                                                                        _tmp$2 = _x$12;
                                                                                        continue _L;
                                                                                      } else {
                                                                                        const _tmp$12 = _param$2.str;
                                                                                        const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                        let _tmp$13;
                                                                                        if (_bind$3 === undefined) {
                                                                                          _tmp$13 = _param$2.end;
                                                                                        } else {
                                                                                          const _Some = _bind$3;
                                                                                          _tmp$13 = _Some;
                                                                                        }
                                                                                        const _tmp$14 = _tmp$13;
                                                                                        const _x$12 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                        if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                          c$2 = _x;
                                                                                          s$3 = _x$12;
                                                                                          acc$4 = _param$3;
                                                                                          break _L$5;
                                                                                        } else {
                                                                                          c = _x;
                                                                                          s = _x$12;
                                                                                          acc$2 = _param$3;
                                                                                          break _L$3;
                                                                                        }
                                                                                      }
                                                                                    } else {
                                                                                      const _tmp$12 = _param$2.str;
                                                                                      const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                      let _tmp$13;
                                                                                      if (_bind$3 === undefined) {
                                                                                        _tmp$13 = _param$2.end;
                                                                                      } else {
                                                                                        const _Some = _bind$3;
                                                                                        _tmp$13 = _Some;
                                                                                      }
                                                                                      const _tmp$14 = _tmp$13;
                                                                                      const _x$11 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                      if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                        c$2 = _x;
                                                                                        s$3 = _x$11;
                                                                                        acc$4 = _param$3;
                                                                                        break _L$5;
                                                                                      } else {
                                                                                        c = _x;
                                                                                        s = _x$11;
                                                                                        acc$2 = _param$3;
                                                                                        break _L$3;
                                                                                      }
                                                                                    }
                                                                                  } else {
                                                                                    const _tmp$12 = _param$2.str;
                                                                                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                    let _tmp$13;
                                                                                    if (_bind$3 === undefined) {
                                                                                      _tmp$13 = _param$2.end;
                                                                                    } else {
                                                                                      const _Some = _bind$3;
                                                                                      _tmp$13 = _Some;
                                                                                    }
                                                                                    const _tmp$14 = _tmp$13;
                                                                                    const _x$10 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                    if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                      c$2 = _x;
                                                                                      s$3 = _x$10;
                                                                                      acc$4 = _param$3;
                                                                                      break _L$5;
                                                                                    } else {
                                                                                      c = _x;
                                                                                      s = _x$10;
                                                                                      acc$2 = _param$3;
                                                                                      break _L$3;
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  const _tmp$12 = _param$2.str;
                                                                                  const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                  let _tmp$13;
                                                                                  if (_bind$3 === undefined) {
                                                                                    _tmp$13 = _param$2.end;
                                                                                  } else {
                                                                                    const _Some = _bind$3;
                                                                                    _tmp$13 = _Some;
                                                                                  }
                                                                                  const _tmp$14 = _tmp$13;
                                                                                  const _x$9 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                  if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                    c$2 = _x;
                                                                                    s$3 = _x$9;
                                                                                    acc$4 = _param$3;
                                                                                    break _L$5;
                                                                                  } else {
                                                                                    c = _x;
                                                                                    s = _x$9;
                                                                                    acc$2 = _param$3;
                                                                                    break _L$3;
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                const _tmp$12 = _param$2.str;
                                                                                const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                let _tmp$13;
                                                                                if (_bind$3 === undefined) {
                                                                                  _tmp$13 = _param$2.end;
                                                                                } else {
                                                                                  const _Some = _bind$3;
                                                                                  _tmp$13 = _Some;
                                                                                }
                                                                                const _tmp$14 = _tmp$13;
                                                                                const _x$8 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                  c$2 = _x;
                                                                                  s$3 = _x$8;
                                                                                  acc$4 = _param$3;
                                                                                  break _L$5;
                                                                                } else {
                                                                                  c = _x;
                                                                                  s = _x$8;
                                                                                  acc$2 = _param$3;
                                                                                  break _L$3;
                                                                                }
                                                                              }
                                                                            } else {
                                                                              const _tmp$12 = _param$2.str;
                                                                              const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                              let _tmp$13;
                                                                              if (_bind$3 === undefined) {
                                                                                _tmp$13 = _param$2.end;
                                                                              } else {
                                                                                const _Some = _bind$3;
                                                                                _tmp$13 = _Some;
                                                                              }
                                                                              const _tmp$14 = _tmp$13;
                                                                              const _x$7 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                              if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                c$2 = _x;
                                                                                s$3 = _x$7;
                                                                                acc$4 = _param$3;
                                                                                break _L$5;
                                                                              } else {
                                                                                c = _x;
                                                                                s = _x$7;
                                                                                acc$2 = _param$3;
                                                                                break _L$3;
                                                                              }
                                                                            }
                                                                          } else {
                                                                            const _tmp$12 = _param$2.str;
                                                                            const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                            let _tmp$13;
                                                                            if (_bind$3 === undefined) {
                                                                              _tmp$13 = _param$2.end;
                                                                            } else {
                                                                              const _Some = _bind$3;
                                                                              _tmp$13 = _Some;
                                                                            }
                                                                            const _tmp$14 = _tmp$13;
                                                                            const _x$6 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                            if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                              c$2 = _x;
                                                                              s$3 = _x$6;
                                                                              acc$4 = _param$3;
                                                                              break _L$5;
                                                                            } else {
                                                                              c = _x;
                                                                              s = _x$6;
                                                                              acc$2 = _param$3;
                                                                              break _L$3;
                                                                            }
                                                                          }
                                                                        } else {
                                                                          const _tmp$12 = _param$2.str;
                                                                          const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                          let _tmp$13;
                                                                          if (_bind$3 === undefined) {
                                                                            _tmp$13 = _param$2.end;
                                                                          } else {
                                                                            const _Some = _bind$3;
                                                                            _tmp$13 = _Some;
                                                                          }
                                                                          const _tmp$14 = _tmp$13;
                                                                          const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                          if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                            c$2 = _x;
                                                                            s$3 = _x$5;
                                                                            acc$4 = _param$3;
                                                                            break _L$5;
                                                                          } else {
                                                                            c = _x;
                                                                            s = _x$5;
                                                                            acc$2 = _param$3;
                                                                            break _L$3;
                                                                          }
                                                                        }
                                                                      } else {
                                                                        if (_x >= 48 && _x <= 57) {
                                                                          const _tmp$12 = _param$2.str;
                                                                          const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                          let _tmp$13;
                                                                          if (_bind$3 === undefined) {
                                                                            _tmp$13 = _param$2.end;
                                                                          } else {
                                                                            const _Some = _bind$3;
                                                                            _tmp$13 = _Some;
                                                                          }
                                                                          const _tmp$14 = _tmp$13;
                                                                          const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                          c$10 = _x;
                                                                          s$20 = _x$4;
                                                                          acc$21 = _param$3;
                                                                          break _L$22;
                                                                        } else {
                                                                          if (_x === 34) {
                                                                            const _tmp$12 = _param$2.str;
                                                                            const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                            let _tmp$13;
                                                                            if (_bind$3 === undefined) {
                                                                              _tmp$13 = _param$2.end;
                                                                            } else {
                                                                              const _Some = _bind$3;
                                                                              _tmp$13 = _Some;
                                                                            }
                                                                            const _tmp$14 = _tmp$13;
                                                                            const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                            s$17 = _x$4;
                                                                            acc$18 = _param$3;
                                                                            break _L$19;
                                                                          } else {
                                                                            if (_x === 39) {
                                                                              const _tmp$12 = _param$2.str;
                                                                              const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                              let _tmp$13;
                                                                              if (_bind$3 === undefined) {
                                                                                _tmp$13 = _param$2.end;
                                                                              } else {
                                                                                const _Some = _bind$3;
                                                                                _tmp$13 = _Some;
                                                                              }
                                                                              const _tmp$14 = _tmp$13;
                                                                              const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                              s$14 = _x$4;
                                                                              acc$15 = _param$3;
                                                                              break _L$16;
                                                                            } else {
                                                                              if (_x === 35) {
                                                                                const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end));
                                                                                if (_x$4 === 124) {
                                                                                  const _tmp$12 = _param$2.str;
                                                                                  const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 2, _param$2.start, _param$2.end);
                                                                                  let _tmp$13;
                                                                                  if (_bind$3 === undefined) {
                                                                                    _tmp$13 = _param$2.end;
                                                                                  } else {
                                                                                    const _Some = _bind$3;
                                                                                    _tmp$13 = _Some;
                                                                                  }
                                                                                  const _tmp$14 = _tmp$13;
                                                                                  const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                  c$6 = _x;
                                                                                  s$11 = _x$5;
                                                                                  acc$12 = _param$3;
                                                                                  break _L$13;
                                                                                } else {
                                                                                  const _tmp$12 = _param$2.str;
                                                                                  const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                  let _tmp$13;
                                                                                  if (_bind$3 === undefined) {
                                                                                    _tmp$13 = _param$2.end;
                                                                                  } else {
                                                                                    const _Some = _bind$3;
                                                                                    _tmp$13 = _Some;
                                                                                  }
                                                                                  const _tmp$14 = _tmp$13;
                                                                                  const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                  if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                    c$2 = _x;
                                                                                    s$3 = _x$5;
                                                                                    acc$4 = _param$3;
                                                                                    break _L$5;
                                                                                  } else {
                                                                                    c = _x;
                                                                                    s = _x$5;
                                                                                    acc$2 = _param$3;
                                                                                    break _L$3;
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                if (_x === 36) {
                                                                                  const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end));
                                                                                  if (_x$4 === 124) {
                                                                                    const _tmp$12 = _param$2.str;
                                                                                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 2, _param$2.start, _param$2.end);
                                                                                    let _tmp$13;
                                                                                    if (_bind$3 === undefined) {
                                                                                      _tmp$13 = _param$2.end;
                                                                                    } else {
                                                                                      const _Some = _bind$3;
                                                                                      _tmp$13 = _Some;
                                                                                    }
                                                                                    const _tmp$14 = _tmp$13;
                                                                                    const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                    c$6 = _x;
                                                                                    s$11 = _x$5;
                                                                                    acc$12 = _param$3;
                                                                                    break _L$13;
                                                                                  } else {
                                                                                    const _tmp$12 = _param$2.str;
                                                                                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                    let _tmp$13;
                                                                                    if (_bind$3 === undefined) {
                                                                                      _tmp$13 = _param$2.end;
                                                                                    } else {
                                                                                      const _Some = _bind$3;
                                                                                      _tmp$13 = _Some;
                                                                                    }
                                                                                    const _tmp$14 = _tmp$13;
                                                                                    const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                    if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                      c$2 = _x;
                                                                                      s$3 = _x$5;
                                                                                      acc$4 = _param$3;
                                                                                      break _L$5;
                                                                                    } else {
                                                                                      c = _x;
                                                                                      s = _x$5;
                                                                                      acc$2 = _param$3;
                                                                                      break _L$3;
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  if (_x >= 65 && _x <= 90) {
                                                                                    const _tmp$12 = _param$2.str;
                                                                                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                    let _tmp$13;
                                                                                    if (_bind$3 === undefined) {
                                                                                      _tmp$13 = _param$2.end;
                                                                                    } else {
                                                                                      const _Some = _bind$3;
                                                                                      _tmp$13 = _Some;
                                                                                    }
                                                                                    const _tmp$14 = _tmp$13;
                                                                                    const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                    c$5 = _x;
                                                                                    s$9 = _x$4;
                                                                                    acc$10 = _param$3;
                                                                                    break _L$11;
                                                                                  } else {
                                                                                    if (_x >= 97 && _x <= 122) {
                                                                                      const _tmp$12 = _param$2.str;
                                                                                      const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                      let _tmp$13;
                                                                                      if (_bind$3 === undefined) {
                                                                                        _tmp$13 = _param$2.end;
                                                                                      } else {
                                                                                        const _Some = _bind$3;
                                                                                        _tmp$13 = _Some;
                                                                                      }
                                                                                      const _tmp$14 = _tmp$13;
                                                                                      const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                      c$5 = _x;
                                                                                      s$9 = _x$4;
                                                                                      acc$10 = _param$3;
                                                                                      break _L$11;
                                                                                    } else {
                                                                                      if (_x === 95) {
                                                                                        const _tmp$12 = _param$2.str;
                                                                                        const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                        let _tmp$13;
                                                                                        if (_bind$3 === undefined) {
                                                                                          _tmp$13 = _param$2.end;
                                                                                        } else {
                                                                                          const _Some = _bind$3;
                                                                                          _tmp$13 = _Some;
                                                                                        }
                                                                                        const _tmp$14 = _tmp$13;
                                                                                        const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                        c$5 = _x;
                                                                                        s$9 = _x$4;
                                                                                        acc$10 = _param$3;
                                                                                        break _L$11;
                                                                                      } else {
                                                                                        if (_x === 64) {
                                                                                          const _tmp$12 = _param$2.str;
                                                                                          const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                          let _tmp$13;
                                                                                          if (_bind$3 === undefined) {
                                                                                            _tmp$13 = _param$2.end;
                                                                                          } else {
                                                                                            const _Some = _bind$3;
                                                                                            _tmp$13 = _Some;
                                                                                          }
                                                                                          const _tmp$14 = _tmp$13;
                                                                                          const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                          s$6 = _x$4;
                                                                                          acc$7 = _param$3;
                                                                                          break _L$8;
                                                                                        } else {
                                                                                          const _tmp$12 = _param$2.str;
                                                                                          const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                          let _tmp$13;
                                                                                          if (_bind$3 === undefined) {
                                                                                            _tmp$13 = _param$2.end;
                                                                                          } else {
                                                                                            const _Some = _bind$3;
                                                                                            _tmp$13 = _Some;
                                                                                          }
                                                                                          const _tmp$14 = _tmp$13;
                                                                                          const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                          if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                            c$2 = _x;
                                                                                            s$3 = _x$4;
                                                                                            acc$4 = _param$3;
                                                                                            break _L$5;
                                                                                          } else {
                                                                                            c = _x;
                                                                                            s = _x$4;
                                                                                            acc$2 = _param$3;
                                                                                            break _L$3;
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    } else {
                                                                      if (_x >= 48 && _x <= 57) {
                                                                        const _tmp$12 = _param$2.str;
                                                                        const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                        let _tmp$13;
                                                                        if (_bind$3 === undefined) {
                                                                          _tmp$13 = _param$2.end;
                                                                        } else {
                                                                          const _Some = _bind$3;
                                                                          _tmp$13 = _Some;
                                                                        }
                                                                        const _tmp$14 = _tmp$13;
                                                                        const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                        c$10 = _x;
                                                                        s$20 = _x$4;
                                                                        acc$21 = _param$3;
                                                                        break _L$22;
                                                                      } else {
                                                                        if (_x === 34) {
                                                                          const _tmp$12 = _param$2.str;
                                                                          const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                          let _tmp$13;
                                                                          if (_bind$3 === undefined) {
                                                                            _tmp$13 = _param$2.end;
                                                                          } else {
                                                                            const _Some = _bind$3;
                                                                            _tmp$13 = _Some;
                                                                          }
                                                                          const _tmp$14 = _tmp$13;
                                                                          const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                          s$17 = _x$4;
                                                                          acc$18 = _param$3;
                                                                          break _L$19;
                                                                        } else {
                                                                          if (_x === 39) {
                                                                            const _tmp$12 = _param$2.str;
                                                                            const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                            let _tmp$13;
                                                                            if (_bind$3 === undefined) {
                                                                              _tmp$13 = _param$2.end;
                                                                            } else {
                                                                              const _Some = _bind$3;
                                                                              _tmp$13 = _Some;
                                                                            }
                                                                            const _tmp$14 = _tmp$13;
                                                                            const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                            s$14 = _x$4;
                                                                            acc$15 = _param$3;
                                                                            break _L$16;
                                                                          } else {
                                                                            if (_x === 35) {
                                                                              const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end));
                                                                              if (_x$4 === 124) {
                                                                                const _tmp$12 = _param$2.str;
                                                                                const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 2, _param$2.start, _param$2.end);
                                                                                let _tmp$13;
                                                                                if (_bind$3 === undefined) {
                                                                                  _tmp$13 = _param$2.end;
                                                                                } else {
                                                                                  const _Some = _bind$3;
                                                                                  _tmp$13 = _Some;
                                                                                }
                                                                                const _tmp$14 = _tmp$13;
                                                                                const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                c$6 = _x;
                                                                                s$11 = _x$5;
                                                                                acc$12 = _param$3;
                                                                                break _L$13;
                                                                              } else {
                                                                                const _tmp$12 = _param$2.str;
                                                                                const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                let _tmp$13;
                                                                                if (_bind$3 === undefined) {
                                                                                  _tmp$13 = _param$2.end;
                                                                                } else {
                                                                                  const _Some = _bind$3;
                                                                                  _tmp$13 = _Some;
                                                                                }
                                                                                const _tmp$14 = _tmp$13;
                                                                                const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                  c$2 = _x;
                                                                                  s$3 = _x$5;
                                                                                  acc$4 = _param$3;
                                                                                  break _L$5;
                                                                                } else {
                                                                                  c = _x;
                                                                                  s = _x$5;
                                                                                  acc$2 = _param$3;
                                                                                  break _L$3;
                                                                                }
                                                                              }
                                                                            } else {
                                                                              if (_x === 36) {
                                                                                const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end));
                                                                                if (_x$4 === 124) {
                                                                                  const _tmp$12 = _param$2.str;
                                                                                  const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 2, _param$2.start, _param$2.end);
                                                                                  let _tmp$13;
                                                                                  if (_bind$3 === undefined) {
                                                                                    _tmp$13 = _param$2.end;
                                                                                  } else {
                                                                                    const _Some = _bind$3;
                                                                                    _tmp$13 = _Some;
                                                                                  }
                                                                                  const _tmp$14 = _tmp$13;
                                                                                  const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                  c$6 = _x;
                                                                                  s$11 = _x$5;
                                                                                  acc$12 = _param$3;
                                                                                  break _L$13;
                                                                                } else {
                                                                                  const _tmp$12 = _param$2.str;
                                                                                  const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                  let _tmp$13;
                                                                                  if (_bind$3 === undefined) {
                                                                                    _tmp$13 = _param$2.end;
                                                                                  } else {
                                                                                    const _Some = _bind$3;
                                                                                    _tmp$13 = _Some;
                                                                                  }
                                                                                  const _tmp$14 = _tmp$13;
                                                                                  const _x$5 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                  if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                    c$2 = _x;
                                                                                    s$3 = _x$5;
                                                                                    acc$4 = _param$3;
                                                                                    break _L$5;
                                                                                  } else {
                                                                                    c = _x;
                                                                                    s = _x$5;
                                                                                    acc$2 = _param$3;
                                                                                    break _L$3;
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                if (_x >= 65 && _x <= 90) {
                                                                                  const _tmp$12 = _param$2.str;
                                                                                  const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                  let _tmp$13;
                                                                                  if (_bind$3 === undefined) {
                                                                                    _tmp$13 = _param$2.end;
                                                                                  } else {
                                                                                    const _Some = _bind$3;
                                                                                    _tmp$13 = _Some;
                                                                                  }
                                                                                  const _tmp$14 = _tmp$13;
                                                                                  const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                  c$5 = _x;
                                                                                  s$9 = _x$4;
                                                                                  acc$10 = _param$3;
                                                                                  break _L$11;
                                                                                } else {
                                                                                  if (_x >= 97 && _x <= 122) {
                                                                                    const _tmp$12 = _param$2.str;
                                                                                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                    let _tmp$13;
                                                                                    if (_bind$3 === undefined) {
                                                                                      _tmp$13 = _param$2.end;
                                                                                    } else {
                                                                                      const _Some = _bind$3;
                                                                                      _tmp$13 = _Some;
                                                                                    }
                                                                                    const _tmp$14 = _tmp$13;
                                                                                    const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                    c$5 = _x;
                                                                                    s$9 = _x$4;
                                                                                    acc$10 = _param$3;
                                                                                    break _L$11;
                                                                                  } else {
                                                                                    if (_x === 95) {
                                                                                      const _tmp$12 = _param$2.str;
                                                                                      const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                      let _tmp$13;
                                                                                      if (_bind$3 === undefined) {
                                                                                        _tmp$13 = _param$2.end;
                                                                                      } else {
                                                                                        const _Some = _bind$3;
                                                                                        _tmp$13 = _Some;
                                                                                      }
                                                                                      const _tmp$14 = _tmp$13;
                                                                                      const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                      c$5 = _x;
                                                                                      s$9 = _x$4;
                                                                                      acc$10 = _param$3;
                                                                                      break _L$11;
                                                                                    } else {
                                                                                      if (_x === 64) {
                                                                                        const _tmp$12 = _param$2.str;
                                                                                        const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                        let _tmp$13;
                                                                                        if (_bind$3 === undefined) {
                                                                                          _tmp$13 = _param$2.end;
                                                                                        } else {
                                                                                          const _Some = _bind$3;
                                                                                          _tmp$13 = _Some;
                                                                                        }
                                                                                        const _tmp$14 = _tmp$13;
                                                                                        const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                        s$6 = _x$4;
                                                                                        acc$7 = _param$3;
                                                                                        break _L$8;
                                                                                      } else {
                                                                                        const _tmp$12 = _param$2.str;
                                                                                        const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                        let _tmp$13;
                                                                                        if (_bind$3 === undefined) {
                                                                                          _tmp$13 = _param$2.end;
                                                                                        } else {
                                                                                          const _Some = _bind$3;
                                                                                          _tmp$13 = _Some;
                                                                                        }
                                                                                        const _tmp$14 = _tmp$13;
                                                                                        const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                        if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                          c$2 = _x;
                                                                                          s$3 = _x$4;
                                                                                          acc$4 = _param$3;
                                                                                          break _L$5;
                                                                                        } else {
                                                                                          c = _x;
                                                                                          s = _x$4;
                                                                                          acc$2 = _param$3;
                                                                                          break _L$3;
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                } else {
                                                                  if (_x >= 48 && _x <= 57) {
                                                                    const _tmp$12 = _param$2.str;
                                                                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                    let _tmp$13;
                                                                    if (_bind$3 === undefined) {
                                                                      _tmp$13 = _param$2.end;
                                                                    } else {
                                                                      const _Some = _bind$3;
                                                                      _tmp$13 = _Some;
                                                                    }
                                                                    const _tmp$14 = _tmp$13;
                                                                    const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                    c$10 = _x;
                                                                    s$20 = _x$4;
                                                                    acc$21 = _param$3;
                                                                    break _L$22;
                                                                  } else {
                                                                    if (_x === 34) {
                                                                      const _tmp$12 = _param$2.str;
                                                                      const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                      let _tmp$13;
                                                                      if (_bind$3 === undefined) {
                                                                        _tmp$13 = _param$2.end;
                                                                      } else {
                                                                        const _Some = _bind$3;
                                                                        _tmp$13 = _Some;
                                                                      }
                                                                      const _tmp$14 = _tmp$13;
                                                                      const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                      s$17 = _x$4;
                                                                      acc$18 = _param$3;
                                                                      break _L$19;
                                                                    } else {
                                                                      if (_x === 39) {
                                                                        const _tmp$12 = _param$2.str;
                                                                        const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                        let _tmp$13;
                                                                        if (_bind$3 === undefined) {
                                                                          _tmp$13 = _param$2.end;
                                                                        } else {
                                                                          const _Some = _bind$3;
                                                                          _tmp$13 = _Some;
                                                                        }
                                                                        const _tmp$14 = _tmp$13;
                                                                        const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                        s$14 = _x$4;
                                                                        acc$15 = _param$3;
                                                                        break _L$16;
                                                                      } else {
                                                                        if (_x >= 65 && _x <= 90) {
                                                                          const _tmp$12 = _param$2.str;
                                                                          const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                          let _tmp$13;
                                                                          if (_bind$3 === undefined) {
                                                                            _tmp$13 = _param$2.end;
                                                                          } else {
                                                                            const _Some = _bind$3;
                                                                            _tmp$13 = _Some;
                                                                          }
                                                                          const _tmp$14 = _tmp$13;
                                                                          const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                          c$5 = _x;
                                                                          s$9 = _x$4;
                                                                          acc$10 = _param$3;
                                                                          break _L$11;
                                                                        } else {
                                                                          if (_x >= 97 && _x <= 122) {
                                                                            const _tmp$12 = _param$2.str;
                                                                            const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                            let _tmp$13;
                                                                            if (_bind$3 === undefined) {
                                                                              _tmp$13 = _param$2.end;
                                                                            } else {
                                                                              const _Some = _bind$3;
                                                                              _tmp$13 = _Some;
                                                                            }
                                                                            const _tmp$14 = _tmp$13;
                                                                            const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                            c$5 = _x;
                                                                            s$9 = _x$4;
                                                                            acc$10 = _param$3;
                                                                            break _L$11;
                                                                          } else {
                                                                            if (_x === 95) {
                                                                              const _tmp$12 = _param$2.str;
                                                                              const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                              let _tmp$13;
                                                                              if (_bind$3 === undefined) {
                                                                                _tmp$13 = _param$2.end;
                                                                              } else {
                                                                                const _Some = _bind$3;
                                                                                _tmp$13 = _Some;
                                                                              }
                                                                              const _tmp$14 = _tmp$13;
                                                                              const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                              c$5 = _x;
                                                                              s$9 = _x$4;
                                                                              acc$10 = _param$3;
                                                                              break _L$11;
                                                                            } else {
                                                                              if (_x === 64) {
                                                                                const _tmp$12 = _param$2.str;
                                                                                const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                let _tmp$13;
                                                                                if (_bind$3 === undefined) {
                                                                                  _tmp$13 = _param$2.end;
                                                                                } else {
                                                                                  const _Some = _bind$3;
                                                                                  _tmp$13 = _Some;
                                                                                }
                                                                                const _tmp$14 = _tmp$13;
                                                                                const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                s$6 = _x$4;
                                                                                acc$7 = _param$3;
                                                                                break _L$8;
                                                                              } else {
                                                                                const _tmp$12 = _param$2.str;
                                                                                const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                                let _tmp$13;
                                                                                if (_bind$3 === undefined) {
                                                                                  _tmp$13 = _param$2.end;
                                                                                } else {
                                                                                  const _Some = _bind$3;
                                                                                  _tmp$13 = _Some;
                                                                                }
                                                                                const _tmp$14 = _tmp$13;
                                                                                const _x$4 = { str: _tmp$12, start: _tmp$14, end: _param$2.end };
                                                                                if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _x)) {
                                                                                  c$2 = _x;
                                                                                  s$3 = _x$4;
                                                                                  acc$4 = _param$3;
                                                                                  break _L$5;
                                                                                } else {
                                                                                  c = _x;
                                                                                  s = _x$4;
                                                                                  acc$2 = _param$3;
                                                                                  break _L$3;
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            acc = _param$3;
                                                            break _L$2;
                                                          }
                                                        }
                                                        case 1: {
                                                          const _LexSpace = _param;
                                                          const _n = _LexSpace._0;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            if (_x === 32) {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              const _tmp$7 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexSpace(_n + 1 | 0);
                                                              _tmp = _tmp$7;
                                                              _tmp$2 = _x$2;
                                                              continue _L;
                                                            } else {
                                                              s$24 = _param$2;
                                                              n = _n;
                                                              acc$25 = _param$3;
                                                              break _L$26;
                                                            }
                                                          } else {
                                                            s$24 = _param$2;
                                                            n = _n;
                                                            acc$25 = _param$3;
                                                            break _L$26;
                                                          }
                                                        }
                                                        case 12: {
                                                          const _LexComment = _param;
                                                          const _content = _LexComment._0;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            if (_x === 10) {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              s$23 = _x$2;
                                                              content$7 = _content;
                                                              acc$24 = _param$3;
                                                              break _L$25;
                                                            } else {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              const _tmp$7 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexComment(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(_x, _content));
                                                              _tmp = _tmp$7;
                                                              _tmp$2 = _x$2;
                                                              continue _L;
                                                            }
                                                          } else {
                                                            s$23 = _param$2;
                                                            content$7 = _content;
                                                            acc$24 = _param$3;
                                                            break _L$25;
                                                          }
                                                        }
                                                        case 10: {
                                                          const _LexLinkHref = _param;
                                                          const _href = _LexLinkHref._0;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 2, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            if (_x === 34) {
                                                              const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end));
                                                              if (_x$2 === 62) {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 2, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$3 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                const href$3 = moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(_href)));
                                                                const _tmp$7 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexLinkContent(href$3, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$);
                                                                _tmp = _tmp$7;
                                                                _tmp$2 = _x$3;
                                                                continue _L;
                                                              } else {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$3 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                c$12 = _x;
                                                                s$22 = _x$3;
                                                                href$2 = _href;
                                                                acc$23 = _param$3;
                                                                break _L$24;
                                                              }
                                                            } else {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              c$12 = _x;
                                                              s$22 = _x$2;
                                                              href$2 = _href;
                                                              acc$23 = _param$3;
                                                              break _L$24;
                                                            }
                                                          } else {
                                                            if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                              const _c = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              c$12 = _c;
                                                              s$22 = _x;
                                                              href$2 = _href;
                                                              acc$23 = _param$3;
                                                              break _L$24;
                                                            } else {
                                                              acc = _param$3;
                                                              break _L$2;
                                                            }
                                                          }
                                                        }
                                                        case 11: {
                                                          const _LexLinkContent = _param;
                                                          const _href$2 = _LexLinkContent._0;
                                                          const _content$2 = _LexLinkContent._1;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 4, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            if (_x === 60) {
                                                              const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end));
                                                              if (_x$2 === 47) {
                                                                const _x$3 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 2, _param$2.start, _param$2.end));
                                                                if (_x$3 === 97) {
                                                                  const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 3, _param$2.start, _param$2.end));
                                                                  if (_x$4 === 62) {
                                                                    const _tmp$4 = _param$2.str;
                                                                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 4, _param$2.start, _param$2.end);
                                                                    let _tmp$5;
                                                                    if (_bind === undefined) {
                                                                      _tmp$5 = _param$2.end;
                                                                    } else {
                                                                      const _Some = _bind;
                                                                      _tmp$5 = _Some;
                                                                    }
                                                                    const _tmp$6 = _tmp$5;
                                                                    const _x$5 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                    const content$8 = moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(_content$2)));
                                                                    const spans = moonbitlang$mooncakes$util$highlight$$parse(content$8);
                                                                    const _tmp$7 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Link(_href$2, moonbitlang$core$immut$list$$T$to_array$305$(spans)), _param$3);
                                                                    _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
                                                                    _tmp$2 = _x$5;
                                                                    _tmp$3 = _tmp$7;
                                                                    continue _L;
                                                                  } else {
                                                                    const _tmp$4 = _param$2.str;
                                                                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                    let _tmp$5;
                                                                    if (_bind === undefined) {
                                                                      _tmp$5 = _param$2.end;
                                                                    } else {
                                                                      const _Some = _bind;
                                                                      _tmp$5 = _Some;
                                                                    }
                                                                    const _tmp$6 = _tmp$5;
                                                                    const _x$5 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                    c$11 = _x;
                                                                    s$21 = _x$5;
                                                                    href = _href$2;
                                                                    content$6 = _content$2;
                                                                    acc$22 = _param$3;
                                                                    break _L$23;
                                                                  }
                                                                } else {
                                                                  const _tmp$4 = _param$2.str;
                                                                  const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                  let _tmp$5;
                                                                  if (_bind === undefined) {
                                                                    _tmp$5 = _param$2.end;
                                                                  } else {
                                                                    const _Some = _bind;
                                                                    _tmp$5 = _Some;
                                                                  }
                                                                  const _tmp$6 = _tmp$5;
                                                                  const _x$4 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                  c$11 = _x;
                                                                  s$21 = _x$4;
                                                                  href = _href$2;
                                                                  content$6 = _content$2;
                                                                  acc$22 = _param$3;
                                                                  break _L$23;
                                                                }
                                                              } else {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$3 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                c$11 = _x;
                                                                s$21 = _x$3;
                                                                href = _href$2;
                                                                content$6 = _content$2;
                                                                acc$22 = _param$3;
                                                                break _L$23;
                                                              }
                                                            } else {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              c$11 = _x;
                                                              s$21 = _x$2;
                                                              href = _href$2;
                                                              content$6 = _content$2;
                                                              acc$22 = _param$3;
                                                              break _L$23;
                                                            }
                                                          } else {
                                                            if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                              const _c = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              c$11 = _c;
                                                              s$21 = _x;
                                                              href = _href$2;
                                                              content$6 = _content$2;
                                                              acc$22 = _param$3;
                                                              break _L$23;
                                                            } else {
                                                              acc = _param$3;
                                                              break _L$2;
                                                            }
                                                          }
                                                        }
                                                        case 9: {
                                                          const _LexNumber = _param;
                                                          const _nums = _LexNumber._0;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            if (_x >= 48 && _x <= 57) {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              c$9 = _x;
                                                              s$19 = _x$2;
                                                              nums$2 = _nums;
                                                              acc$20 = _param$3;
                                                              break _L$21;
                                                            } else {
                                                              if (_x === 95) {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                c$9 = _x;
                                                                s$19 = _x$2;
                                                                nums$2 = _nums;
                                                                acc$20 = _param$3;
                                                                break _L$21;
                                                              } else {
                                                                if (_x === 120) {
                                                                  const _tmp$4 = _param$2.str;
                                                                  const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                  let _tmp$5;
                                                                  if (_bind === undefined) {
                                                                    _tmp$5 = _param$2.end;
                                                                  } else {
                                                                    const _Some = _bind;
                                                                    _tmp$5 = _Some;
                                                                  }
                                                                  const _tmp$6 = _tmp$5;
                                                                  const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                  c$9 = _x;
                                                                  s$19 = _x$2;
                                                                  nums$2 = _nums;
                                                                  acc$20 = _param$3;
                                                                  break _L$21;
                                                                } else {
                                                                  if (_x === 98) {
                                                                    const _tmp$4 = _param$2.str;
                                                                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                    let _tmp$5;
                                                                    if (_bind === undefined) {
                                                                      _tmp$5 = _param$2.end;
                                                                    } else {
                                                                      const _Some = _bind;
                                                                      _tmp$5 = _Some;
                                                                    }
                                                                    const _tmp$6 = _tmp$5;
                                                                    const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                    c$9 = _x;
                                                                    s$19 = _x$2;
                                                                    nums$2 = _nums;
                                                                    acc$20 = _param$3;
                                                                    break _L$21;
                                                                  } else {
                                                                    if (_x === 111) {
                                                                      const _tmp$4 = _param$2.str;
                                                                      const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                      let _tmp$5;
                                                                      if (_bind === undefined) {
                                                                        _tmp$5 = _param$2.end;
                                                                      } else {
                                                                        const _Some = _bind;
                                                                        _tmp$5 = _Some;
                                                                      }
                                                                      const _tmp$6 = _tmp$5;
                                                                      const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                      c$9 = _x;
                                                                      s$19 = _x$2;
                                                                      nums$2 = _nums;
                                                                      acc$20 = _param$3;
                                                                      break _L$21;
                                                                    } else {
                                                                      if (_x === 46) {
                                                                        const _tmp$4 = _param$2.str;
                                                                        const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                        let _tmp$5;
                                                                        if (_bind === undefined) {
                                                                          _tmp$5 = _param$2.end;
                                                                        } else {
                                                                          const _Some = _bind;
                                                                          _tmp$5 = _Some;
                                                                        }
                                                                        const _tmp$6 = _tmp$5;
                                                                        const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                        c$9 = _x;
                                                                        s$19 = _x$2;
                                                                        nums$2 = _nums;
                                                                        acc$20 = _param$3;
                                                                        break _L$21;
                                                                      } else {
                                                                        if (_x >= 97 && _x <= 102) {
                                                                          const _tmp$4 = _param$2.str;
                                                                          const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                          let _tmp$5;
                                                                          if (_bind === undefined) {
                                                                            _tmp$5 = _param$2.end;
                                                                          } else {
                                                                            const _Some = _bind;
                                                                            _tmp$5 = _Some;
                                                                          }
                                                                          const _tmp$6 = _tmp$5;
                                                                          const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                          c$9 = _x;
                                                                          s$19 = _x$2;
                                                                          nums$2 = _nums;
                                                                          acc$20 = _param$3;
                                                                          break _L$21;
                                                                        } else {
                                                                          if (_x >= 65 && _x <= 70) {
                                                                            const _tmp$4 = _param$2.str;
                                                                            const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                            let _tmp$5;
                                                                            if (_bind === undefined) {
                                                                              _tmp$5 = _param$2.end;
                                                                            } else {
                                                                              const _Some = _bind;
                                                                              _tmp$5 = _Some;
                                                                            }
                                                                            const _tmp$6 = _tmp$5;
                                                                            const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                            c$9 = _x;
                                                                            s$19 = _x$2;
                                                                            nums$2 = _nums;
                                                                            acc$20 = _param$3;
                                                                            break _L$21;
                                                                          } else {
                                                                            s$18 = _param$2;
                                                                            nums = _nums;
                                                                            acc$19 = _param$3;
                                                                            break _L$20;
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            s$18 = _param$2;
                                                            nums = _nums;
                                                            acc$19 = _param$3;
                                                            break _L$20;
                                                          }
                                                        }
                                                        case 6: {
                                                          const _LexString = _param;
                                                          const _content$3 = _LexString._0;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 2, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            switch (_x) {
                                                              case 92: {
                                                                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end));
                                                                if (_x$2 === 34) {
                                                                  const _tmp$4 = _param$2.str;
                                                                  const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 2, _param$2.start, _param$2.end);
                                                                  let _tmp$5;
                                                                  if (_bind === undefined) {
                                                                    _tmp$5 = _param$2.end;
                                                                  } else {
                                                                    const _Some = _bind;
                                                                    _tmp$5 = _Some;
                                                                  }
                                                                  const _tmp$6 = _tmp$5;
                                                                  const _x$3 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                  const _tmp$7 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexString(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(34, new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(92, _content$3)));
                                                                  _tmp = _tmp$7;
                                                                  _tmp$2 = _x$3;
                                                                  continue _L;
                                                                } else {
                                                                  const _tmp$4 = _param$2.str;
                                                                  const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                  let _tmp$5;
                                                                  if (_bind === undefined) {
                                                                    _tmp$5 = _param$2.end;
                                                                  } else {
                                                                    const _Some = _bind;
                                                                    _tmp$5 = _Some;
                                                                  }
                                                                  const _tmp$6 = _tmp$5;
                                                                  const _x$3 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                  c$8 = _x;
                                                                  s$15 = _x$3;
                                                                  content$4 = _content$3;
                                                                  acc$16 = _param$3;
                                                                  break _L$17;
                                                                }
                                                              }
                                                              case 34: {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$3 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                s$16 = _x$3;
                                                                content$5 = _content$3;
                                                                acc$17 = _param$3;
                                                                break _L$18;
                                                              }
                                                              default: {
                                                                const _tmp$7 = _param$2.str;
                                                                const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$8;
                                                                if (_bind$2 === undefined) {
                                                                  _tmp$8 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind$2;
                                                                  _tmp$8 = _Some;
                                                                }
                                                                const _tmp$9 = _tmp$8;
                                                                const _x$4 = { str: _tmp$7, start: _tmp$9, end: _param$2.end };
                                                                c$8 = _x;
                                                                s$15 = _x$4;
                                                                content$4 = _content$3;
                                                                acc$16 = _param$3;
                                                                break _L$17;
                                                              }
                                                            }
                                                          } else {
                                                            if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                              const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                              if (_x === 34) {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                s$16 = _x$2;
                                                                content$5 = _content$3;
                                                                acc$17 = _param$3;
                                                                break _L$18;
                                                              } else {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                c$8 = _x;
                                                                s$15 = _x$2;
                                                                content$4 = _content$3;
                                                                acc$16 = _param$3;
                                                                break _L$17;
                                                              }
                                                            } else {
                                                              acc = _param$3;
                                                              break _L$2;
                                                            }
                                                          }
                                                        }
                                                        case 7: {
                                                          const _LexChar = _param;
                                                          const _content$4 = _LexChar._0;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 2, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            switch (_x) {
                                                              case 92: {
                                                                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end));
                                                                if (_x$2 === 39) {
                                                                  const _tmp$4 = _param$2.str;
                                                                  const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 2, _param$2.start, _param$2.end);
                                                                  let _tmp$5;
                                                                  if (_bind === undefined) {
                                                                    _tmp$5 = _param$2.end;
                                                                  } else {
                                                                    const _Some = _bind;
                                                                    _tmp$5 = _Some;
                                                                  }
                                                                  const _tmp$6 = _tmp$5;
                                                                  const _x$3 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                  const _tmp$7 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexChar(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(39, new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(92, _content$4)));
                                                                  _tmp = _tmp$7;
                                                                  _tmp$2 = _x$3;
                                                                  continue _L;
                                                                } else {
                                                                  const _tmp$4 = _param$2.str;
                                                                  const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                  let _tmp$5;
                                                                  if (_bind === undefined) {
                                                                    _tmp$5 = _param$2.end;
                                                                  } else {
                                                                    const _Some = _bind;
                                                                    _tmp$5 = _Some;
                                                                  }
                                                                  const _tmp$6 = _tmp$5;
                                                                  const _x$3 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                  c$7 = _x;
                                                                  s$12 = _x$3;
                                                                  content$2 = _content$4;
                                                                  acc$13 = _param$3;
                                                                  break _L$14;
                                                                }
                                                              }
                                                              case 39: {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$3 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                s$13 = _x$3;
                                                                content$3 = _content$4;
                                                                acc$14 = _param$3;
                                                                break _L$15;
                                                              }
                                                              default: {
                                                                const _tmp$7 = _param$2.str;
                                                                const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$8;
                                                                if (_bind$2 === undefined) {
                                                                  _tmp$8 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind$2;
                                                                  _tmp$8 = _Some;
                                                                }
                                                                const _tmp$9 = _tmp$8;
                                                                const _x$4 = { str: _tmp$7, start: _tmp$9, end: _param$2.end };
                                                                c$7 = _x;
                                                                s$12 = _x$4;
                                                                content$2 = _content$4;
                                                                acc$13 = _param$3;
                                                                break _L$14;
                                                              }
                                                            }
                                                          } else {
                                                            if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                              const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                              if (_x === 39) {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                s$13 = _x$2;
                                                                content$3 = _content$4;
                                                                acc$14 = _param$3;
                                                                break _L$15;
                                                              } else {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                c$7 = _x;
                                                                s$12 = _x$2;
                                                                content$2 = _content$4;
                                                                acc$13 = _param$3;
                                                                break _L$14;
                                                              }
                                                            } else {
                                                              acc = _param$3;
                                                              break _L$2;
                                                            }
                                                          }
                                                        }
                                                        case 8: {
                                                          const _LexMultiString = _param;
                                                          const _content$5 = _LexMultiString._0;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            if (_x === 10) {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              s$10 = _x$2;
                                                              content = _content$5;
                                                              acc$11 = _param$3;
                                                              break _L$12;
                                                            } else {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              const _tmp$7 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexMultiString(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(_x, _content$5));
                                                              _tmp = _tmp$7;
                                                              _tmp$2 = _x$2;
                                                              continue _L;
                                                            }
                                                          } else {
                                                            s$10 = _param$2;
                                                            content = _content$5;
                                                            acc$11 = _param$3;
                                                            break _L$12;
                                                          }
                                                        }
                                                        case 2: {
                                                          const _LexIdent = _param;
                                                          const _id = _LexIdent._0;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            if (_x >= 65 && _x <= 90) {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              c$4 = _x;
                                                              s$8 = _x$2;
                                                              id$4 = _id;
                                                              acc$9 = _param$3;
                                                              break _L$10;
                                                            } else {
                                                              if (_x >= 97 && _x <= 122) {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                c$4 = _x;
                                                                s$8 = _x$2;
                                                                id$4 = _id;
                                                                acc$9 = _param$3;
                                                                break _L$10;
                                                              } else {
                                                                if (_x >= 48 && _x <= 57) {
                                                                  const _tmp$4 = _param$2.str;
                                                                  const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                  let _tmp$5;
                                                                  if (_bind === undefined) {
                                                                    _tmp$5 = _param$2.end;
                                                                  } else {
                                                                    const _Some = _bind;
                                                                    _tmp$5 = _Some;
                                                                  }
                                                                  const _tmp$6 = _tmp$5;
                                                                  const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                  c$4 = _x;
                                                                  s$8 = _x$2;
                                                                  id$4 = _id;
                                                                  acc$9 = _param$3;
                                                                  break _L$10;
                                                                } else {
                                                                  if (_x === 95) {
                                                                    const _tmp$4 = _param$2.str;
                                                                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                    let _tmp$5;
                                                                    if (_bind === undefined) {
                                                                      _tmp$5 = _param$2.end;
                                                                    } else {
                                                                      const _Some = _bind;
                                                                      _tmp$5 = _Some;
                                                                    }
                                                                    const _tmp$6 = _tmp$5;
                                                                    const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                    c$4 = _x;
                                                                    s$8 = _x$2;
                                                                    id$4 = _id;
                                                                    acc$9 = _param$3;
                                                                    break _L$10;
                                                                  } else {
                                                                    s$7 = _param$2;
                                                                    id$3 = _id;
                                                                    acc$8 = _param$3;
                                                                    break _L$9;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            s$7 = _param$2;
                                                            id$3 = _id;
                                                            acc$8 = _param$3;
                                                            break _L$9;
                                                          }
                                                        }
                                                        case 3: {
                                                          const _LexQual = _param;
                                                          const _path = _LexQual._0;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            if (_x === 46) {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              const _bind$2 = moonbitlang$core$string$$String$split(moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(_path))), { str: moonbitlang$mooncakes$util$highlight$$parse$46$42$bind$124$225, start: 0, end: moonbitlang$mooncakes$util$highlight$$parse$46$42$bind$124$225.length });
                                                              const path$3 = moonbitlang$core$builtin$$Iter$collect$9$((_p) => _bind$2((_p$2) => _p(moonbitlang$core$builtin$$Show$to_string$16$(_p$2))));
                                                              const _tmp$7 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexQualIdent(path$3, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$);
                                                              _tmp = _tmp$7;
                                                              _tmp$2 = _x$2;
                                                              continue _L;
                                                            } else {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              const _tmp$7 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexQual(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(_x, _path));
                                                              _tmp = _tmp$7;
                                                              _tmp$2 = _x$2;
                                                              continue _L;
                                                            }
                                                          } else {
                                                            acc = _param$3;
                                                            break _L$2;
                                                          }
                                                        }
                                                        case 4: {
                                                          const _LexQualIdent = _param;
                                                          const _path$2 = _LexQualIdent._0;
                                                          const _id$2 = _LexQualIdent._1;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            if (_x >= 65 && _x <= 90) {
                                                              const _tmp$4 = _param$2.str;
                                                              const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                              let _tmp$5;
                                                              if (_bind === undefined) {
                                                                _tmp$5 = _param$2.end;
                                                              } else {
                                                                const _Some = _bind;
                                                                _tmp$5 = _Some;
                                                              }
                                                              const _tmp$6 = _tmp$5;
                                                              const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                              c$3 = _x;
                                                              s$5 = _x$2;
                                                              path$2 = _path$2;
                                                              id$2 = _id$2;
                                                              acc$6 = _param$3;
                                                              break _L$7;
                                                            } else {
                                                              if (_x >= 97 && _x <= 122) {
                                                                const _tmp$4 = _param$2.str;
                                                                const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                let _tmp$5;
                                                                if (_bind === undefined) {
                                                                  _tmp$5 = _param$2.end;
                                                                } else {
                                                                  const _Some = _bind;
                                                                  _tmp$5 = _Some;
                                                                }
                                                                const _tmp$6 = _tmp$5;
                                                                const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                c$3 = _x;
                                                                s$5 = _x$2;
                                                                path$2 = _path$2;
                                                                id$2 = _id$2;
                                                                acc$6 = _param$3;
                                                                break _L$7;
                                                              } else {
                                                                if (_x >= 48 && _x <= 57) {
                                                                  const _tmp$4 = _param$2.str;
                                                                  const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                  let _tmp$5;
                                                                  if (_bind === undefined) {
                                                                    _tmp$5 = _param$2.end;
                                                                  } else {
                                                                    const _Some = _bind;
                                                                    _tmp$5 = _Some;
                                                                  }
                                                                  const _tmp$6 = _tmp$5;
                                                                  const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                  c$3 = _x;
                                                                  s$5 = _x$2;
                                                                  path$2 = _path$2;
                                                                  id$2 = _id$2;
                                                                  acc$6 = _param$3;
                                                                  break _L$7;
                                                                } else {
                                                                  if (_x === 95) {
                                                                    const _tmp$4 = _param$2.str;
                                                                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                                    let _tmp$5;
                                                                    if (_bind === undefined) {
                                                                      _tmp$5 = _param$2.end;
                                                                    } else {
                                                                      const _Some = _bind;
                                                                      _tmp$5 = _Some;
                                                                    }
                                                                    const _tmp$6 = _tmp$5;
                                                                    const _x$2 = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                                    c$3 = _x;
                                                                    s$5 = _x$2;
                                                                    path$2 = _path$2;
                                                                    id$2 = _id$2;
                                                                    acc$6 = _param$3;
                                                                    break _L$7;
                                                                  } else {
                                                                    s$4 = _param$2;
                                                                    path = _path$2;
                                                                    id = _id$2;
                                                                    acc$5 = _param$3;
                                                                    break _L$6;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            s$4 = _param$2;
                                                            path = _path$2;
                                                            id = _id$2;
                                                            acc$5 = _param$3;
                                                            break _L$6;
                                                          }
                                                        }
                                                        default: {
                                                          const _LexOp = _param;
                                                          const _op = _LexOp._0;
                                                          if (moonbitlang$core$string$$String$char_length_ge(_param$2.str, 1, _param$2.start, _param$2.end)) {
                                                            const _c = moonbitlang$core$string$$String$unsafe_char_at(_param$2.str, moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 0, _param$2.start, _param$2.end));
                                                            const _tmp$4 = _param$2.str;
                                                            const _bind = moonbitlang$core$string$$String$offset_of_nth_char(_param$2.str, 1, _param$2.start, _param$2.end);
                                                            let _tmp$5;
                                                            if (_bind === undefined) {
                                                              _tmp$5 = _param$2.end;
                                                            } else {
                                                              const _Some = _bind;
                                                              _tmp$5 = _Some;
                                                            }
                                                            const _tmp$6 = _tmp$5;
                                                            const _x = { str: _tmp$4, start: _tmp$6, end: _param$2.end };
                                                            if (moonbitlang$core$set$$Set$contains$10$(moonbitlang$mooncakes$util$highlight$$operators, _c)) {
                                                              const _tmp$7 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexOp(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(_c, _op));
                                                              _tmp = _tmp$7;
                                                              _tmp$2 = _x;
                                                              continue _L;
                                                            } else {
                                                              s$2 = _param$2;
                                                              op = _op;
                                                              acc$3 = _param$3;
                                                              break _L$4;
                                                            }
                                                          } else {
                                                            s$2 = _param$2;
                                                            op = _op;
                                                            acc$3 = _param$3;
                                                            break _L$4;
                                                          }
                                                        }
                                                      }
                                                    }
                                                    const _tmp$4 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Space(n), acc$25);
                                                    _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
                                                    _tmp$2 = s$24;
                                                    _tmp$3 = _tmp$4;
                                                    continue;
                                                  }
                                                  const content$8 = moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(content$7)));
                                                  const _tmp$4 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$($64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Newline, new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Comment(`//${content$8}`), acc$24));
                                                  _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
                                                  _tmp$2 = s$23;
                                                  _tmp$3 = _tmp$4;
                                                  continue;
                                                }
                                                const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexLinkHref(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$12, href$2));
                                                _tmp = _tmp$4;
                                                _tmp$2 = s$22;
                                                _tmp$3 = acc$23;
                                                continue;
                                              }
                                              const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexLinkContent(href, new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$11, content$6));
                                              _tmp = _tmp$4;
                                              _tmp$2 = s$21;
                                              _tmp$3 = acc$22;
                                              continue;
                                            }
                                            const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexNumber(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$10, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$));
                                            _tmp = _tmp$4;
                                            _tmp$2 = s$20;
                                            _tmp$3 = acc$21;
                                            continue;
                                          }
                                          const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexNumber(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$9, nums$2));
                                          _tmp = _tmp$4;
                                          _tmp$2 = s$19;
                                          _tmp$3 = acc$20;
                                          continue;
                                        }
                                        const nums$2 = moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(nums)));
                                        const _tmp$4 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Number(nums$2), acc$19);
                                        _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
                                        _tmp$2 = s$18;
                                        _tmp$3 = _tmp$4;
                                        continue;
                                      }
                                      const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexString($64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$);
                                      _tmp = _tmp$4;
                                      _tmp$2 = s$17;
                                      _tmp$3 = acc$18;
                                      continue;
                                    }
                                    const content$6 = moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(content$5)));
                                    const _tmp$4 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$StringLit(`\"${content$6}\"`), acc$17);
                                    _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
                                    _tmp$2 = s$16;
                                    _tmp$3 = _tmp$4;
                                    continue;
                                  }
                                  const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexString(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$8, content$4));
                                  _tmp = _tmp$4;
                                  _tmp$2 = s$15;
                                  _tmp$3 = acc$16;
                                  continue;
                                }
                                const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexChar($64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$);
                                _tmp = _tmp$4;
                                _tmp$2 = s$14;
                                _tmp$3 = acc$15;
                                continue;
                              }
                              const content$4 = moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(content$3)));
                              const _tmp$4 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$CharLit(`'${content$4}'`), acc$14);
                              _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
                              _tmp$2 = s$13;
                              _tmp$3 = _tmp$4;
                              continue;
                            }
                            const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexChar(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$7, content$2));
                            _tmp = _tmp$4;
                            _tmp$2 = s$12;
                            _tmp$3 = acc$13;
                            continue;
                          }
                          const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexMultiString(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(124, new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$6, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$)));
                          _tmp = _tmp$4;
                          _tmp$2 = s$11;
                          _tmp$3 = acc$12;
                          continue;
                        }
                        const content$2 = moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(content)));
                        const _tmp$4 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$($64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Newline, new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$StringLit(content$2), acc$11));
                        _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
                        _tmp$2 = s$10;
                        _tmp$3 = _tmp$4;
                        continue;
                      }
                      const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexIdent(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$5, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$));
                      _tmp = _tmp$4;
                      _tmp$2 = s$9;
                      _tmp$3 = acc$10;
                      continue;
                    }
                    const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexIdent(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$4, id$4));
                    _tmp = _tmp$4;
                    _tmp$2 = s$8;
                    _tmp$3 = acc$9;
                    continue;
                  }
                  const id$4 = moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(id$3)));
                  $bound_check(id$4, 0);
                  const _bind = id$4.charCodeAt(0);
                  const span = _bind >= 97 && _bind <= 122 ? (moonbitlang$core$set$$Set$contains$9$(moonbitlang$mooncakes$util$highlight$$keywords, id$4) ? new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Keyword(id$4) : new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$LIdent(id$4)) : new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$UIdent(id$4);
                  const _tmp$4 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(span, acc$8);
                  _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
                  _tmp$2 = s$7;
                  _tmp$3 = _tmp$4;
                  continue;
                }
                const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexQual($64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$);
                _tmp = _tmp$4;
                _tmp$2 = s$6;
                _tmp$3 = acc$7;
                continue;
              }
              const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexQualIdent(path$2, new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$3, id$2));
              _tmp = _tmp$4;
              _tmp$2 = s$5;
              _tmp$3 = acc$6;
              continue;
            }
            const id$2 = moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(id)));
            const _tmp$4 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$QualIdent(path, id$2), acc$5);
            _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
            _tmp$2 = s$4;
            _tmp$3 = _tmp$4;
            continue;
          }
          const _tmp$4 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexOp(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$59$(c$2, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$));
          _tmp = _tmp$4;
          _tmp$2 = s$3;
          _tmp$3 = acc$4;
          continue;
        }
        const op$2 = moonbitlang$core$string$$String$from_iter(moonbitlang$core$immut$list$$T$iter$10$(moonbitlang$core$immut$list$$T$rev$10$(op)));
        _L$5: {
          if (moonbitlang$core$string$$String$char_length_ge(s$2.str, 8, s$2.start, s$2.end)) {
            const _x = moonbitlang$core$string$$String$unsafe_char_at(s$2.str, moonbitlang$core$string$$String$offset_of_nth_char(s$2.str, 0, s$2.start, s$2.end));
            if (_x === 97) {
              const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(s$2.str, moonbitlang$core$string$$String$offset_of_nth_char(s$2.str, 1, s$2.start, s$2.end));
              if (_x$2 === 32) {
                const _x$3 = moonbitlang$core$string$$String$unsafe_char_at(s$2.str, moonbitlang$core$string$$String$offset_of_nth_char(s$2.str, 2, s$2.start, s$2.end));
                if (_x$3 === 104) {
                  const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(s$2.str, moonbitlang$core$string$$String$offset_of_nth_char(s$2.str, 3, s$2.start, s$2.end));
                  if (_x$4 === 114) {
                    const _x$5 = moonbitlang$core$string$$String$unsafe_char_at(s$2.str, moonbitlang$core$string$$String$offset_of_nth_char(s$2.str, 4, s$2.start, s$2.end));
                    if (_x$5 === 101) {
                      const _x$6 = moonbitlang$core$string$$String$unsafe_char_at(s$2.str, moonbitlang$core$string$$String$offset_of_nth_char(s$2.str, 5, s$2.start, s$2.end));
                      if (_x$6 === 102) {
                        const _x$7 = moonbitlang$core$string$$String$unsafe_char_at(s$2.str, moonbitlang$core$string$$String$offset_of_nth_char(s$2.str, 6, s$2.start, s$2.end));
                        if (_x$7 === 61) {
                          const _x$8 = moonbitlang$core$string$$String$unsafe_char_at(s$2.str, moonbitlang$core$string$$String$offset_of_nth_char(s$2.str, 7, s$2.start, s$2.end));
                          if (_x$8 === 34) {
                            const _tmp$4 = s$2.str;
                            const _bind = moonbitlang$core$string$$String$offset_of_nth_char(s$2.str, 8, s$2.start, s$2.end);
                            let _tmp$5;
                            if (_bind === undefined) {
                              _tmp$5 = s$2.end;
                            } else {
                              const _Some = _bind;
                              _tmp$5 = _Some;
                            }
                            const _tmp$6 = _tmp$5;
                            const _x$9 = { str: _tmp$4, start: _tmp$6, end: s$2.end };
                            const _tmp$7 = new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexLinkHref($64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$59$);
                            const _tmp$8 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Symbol(moonbitlang$core$builtin$$Show$to_string$16$(moonbitlang$core$string$$String$view(op$2, moonbitlang$core$string$$String$view$46$start_offset$46$default(), op$2.length - 1 | 0))), acc$3);
                            _tmp = _tmp$7;
                            _tmp$2 = _x$9;
                            _tmp$3 = _tmp$8;
                            continue;
                          } else {
                            break _L$5;
                          }
                        } else {
                          break _L$5;
                        }
                      } else {
                        break _L$5;
                      }
                    } else {
                      break _L$5;
                    }
                  } else {
                    break _L$5;
                  }
                } else {
                  break _L$5;
                }
              } else {
                break _L$5;
              }
            } else {
              break _L$5;
            }
          } else {
            break _L$5;
          }
        }
        const _tmp$4 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Symbol(op$2), acc$3);
        _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
        _tmp$2 = s$2;
        _tmp$3 = _tmp$4;
        continue;
      }
      const _tmp$4 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$58$(new $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$CodeSpan$Unknown(c), acc$2);
      _tmp = $64$moonbitlang$47$mooncakes$47$util$47$highlight$46$State$LexStart;
      _tmp$2 = s;
      _tmp$3 = _tmp$4;
      continue;
    }
    return moonbitlang$core$immut$list$$T$rev$305$(acc);
  }
}
function moonbitlang$mooncakes$view$$collapse$362$(header, body, collapsed, toggle, caret_config) {
  let body$2;
  let icon;
  _L: {
    if (collapsed) {
      const _tmp = Yoorkin$rabbit$45$tea$html$$nothing$362$();
      body$2 = _tmp;
      icon = "/section-close.svg";
      break _L;
    } else {
      body$2 = body;
      icon = "/section-open.svg";
      break _L;
    }
  }
  let caret_style;
  if (caret_config === 0) {
    caret_style = "self-center";
  } else {
    caret_style = "";
  }
  let button_style;
  if (caret_config === 0) {
    button_style = "flex h-full w-6";
  } else {
    button_style = "h-6 w-6 top-0 m-1";
  }
  const button = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, `absolute ${moonbitlang$core$builtin$$Show$to_string$9$(button_style)} p-1 hover:bg-gray-200 active:bg-gray-300`, toggle, [Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, `size-4 ${moonbitlang$core$builtin$$Show$to_string$9$(caret_style)}`, icon, undefined, undefined, undefined, undefined, undefined, [])]);
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, undefined, undefined, [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "relative flex items-center", undefined, [button, header]), body$2]);
}
function moonbitlang$mooncakes$view$$unsupported$362$(node_type, message) {
  return Yoorkin$rabbit$45$tea$html$$p$362$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$(), undefined, "text-red-500", [Yoorkin$rabbit$45$tea$html$$text$362$(`Unsupported markdown syntax: ${node_type} ${message}`)]);
}
function moonbitlang$mooncakes$view$$inline_text$362$(str) {
  return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "inline leading-loose", [Yoorkin$rabbit$45$tea$html$$text$362$(str)]);
}
function moonbitlang$mooncakes$view$$image_render$362$(img) {
  if (img.$tag === 4) {
    const _Image = img;
    const _img = _Image._0;
    _L: {
      const _x = _img.v;
      const _x$2 = _x.text;
      if (_x$2.$tag === 9) {
        const _Text = _x$2;
        const _x$3 = _Text._0;
        const _alt = _x$3.v;
        const _x$4 = _x.reference;
        if (_x$4.$tag === 0) {
          const _Inline = _x$4;
          const _x$5 = _Inline._0;
          const _x$6 = _x$5.v;
          const _src = _x$6.dest;
          if (_src === undefined) {
            return Yoorkin$rabbit$45$tea$html$$text$362$("Loading image failed: invalid url");
          } else {
            const _Some = _src;
            const _x$7 = _Some;
            const _src$2 = _x$7.v;
            return Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, "my-2", _src$2, _alt, undefined, undefined, undefined, undefined, []);
          }
        } else {
          break _L;
        }
      } else {
        const _x$3 = _x.reference;
        if (_x$3.$tag === 1) {
          break _L;
        } else {
          moonbitlang$core$builtin$$println$9$("Unexpected behavior: If program reaches here, there is a cmark parse error");
          return $panic();
        }
      }
    }
    moonbitlang$core$builtin$$println$9$("Unsupported image reference");
    return Yoorkin$rabbit$45$tea$html$$nothing$362$();
  } else {
    moonbitlang$core$builtin$$println$51$(img);
    return moonbitlang$core$abort$$abort$23$("not an image");
  }
}
function moonbitlang$mooncakes$view$$code_block$362$(moonbit, collapse_namespace) {
  const spans = moonbitlang$mooncakes$util$highlight$$parse(moonbit);
  const go = (_param8) => {
    let s;
    _L: {
      switch (_param8.$tag) {
        case 0: {
          const _Unknown = _param8;
          const _c = _Unknown._0;
          return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(moonbitlang$core$string$$String$from_array([_c]))]);
        }
        case 1: {
          const _Keyword = _param8;
          const _s = _Keyword._0;
          return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-[#0033b3]", [Yoorkin$rabbit$45$tea$html$$text$362$(_s)]);
        }
        case 2: {
          const _Symbol = _param8;
          const _s$2 = _Symbol._0;
          return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-zinc-500 text-nowrap", [Yoorkin$rabbit$45$tea$html$$text$362$(_s$2)]);
        }
        case 3: {
          const _Link = _param8;
          const _href = _Link._0;
          const _content = _Link._1;
          const _tmp = Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$();
          const _tmp$2 = `/docs/${_href}`;
          const _tmp$3 = Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$();
          const _p = new Array(_content.length);
          const _p$2 = _content.length;
          let _tmp$4 = 0;
          while (true) {
            const _p$3 = _tmp$4;
            if (_p$3 < _p$2) {
              const _p$4 = _content[_p$3];
              _p[_p$3] = go(_p$4);
              _tmp$4 = _p$3 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          return Yoorkin$rabbit$45$tea$html$$a$362$(_tmp, undefined, "hover:text-gray-700 transition-colors underline underline-offset-4 text-gray-300", _tmp$2, _tmp$3, _p, Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$());
        }
        case 4: {
          const _UIdent = _param8;
          const _s$3 = _UIdent._0;
          return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-gray-800", [Yoorkin$rabbit$45$tea$html$$text$362$(_s$3)]);
        }
        case 5: {
          const _LIdent = _param8;
          const _s$4 = _LIdent._0;
          return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-[#00627a]", [Yoorkin$rabbit$45$tea$html$$text$362$(_s$4)]);
        }
        case 10: {
          return Yoorkin$rabbit$45$tea$html$$br$362$(Yoorkin$rabbit$45$tea$html$$br$46$style$46$default$362$(), undefined, undefined);
        }
        case 11: {
          const _Space = _param8;
          const _n = _Space._0;
          return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(moonbitlang$core$string$$String$repeat(" ", _n))]);
        }
        case 8: {
          const _CharLit = _param8;
          const _s$5 = _CharLit._0;
          s = _s$5;
          break _L;
        }
        case 7: {
          const _StringLit = _param8;
          const _s$6 = _StringLit._0;
          s = _s$6;
          break _L;
        }
        case 9: {
          const _Number = _param8;
          const _s$7 = _Number._0;
          s = _s$7;
          break _L;
        }
        case 12: {
          const _Comment = _param8;
          const _s$8 = _Comment._0;
          return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-green-800", [Yoorkin$rabbit$45$tea$html$$text$362$(_s$8)]);
        }
        default: {
          const _QualIdent = _param8;
          const _path = _QualIdent._0;
          const _name = _QualIdent._1;
          return collapse_namespace ? Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "group/ident relative", [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "absolute bottom-[120%] inset-0 flex items-center justify-center ", undefined, [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "z-10 -translate-y-2/3 group-hover/ident:inline-block hidden text-gray-700 border-gray-300 border px-2 py-1 bg-white rounded shadow-lg", undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(`@${moonbitlang$core$array$$Array$join(_path, "/")}.`), Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-blue-900", [Yoorkin$rabbit$45$tea$html$$text$362$(_name)])])]), Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-blue-900", [Yoorkin$rabbit$45$tea$html$$text$362$(_name)])]) : Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-gray-600", [Yoorkin$rabbit$45$tea$html$$text$362$(`@${moonbitlang$core$array$$Array$join(_path, "/")}.`)]), Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-blue-900", [Yoorkin$rabbit$45$tea$html$$text$362$(_name)])]);
        }
      }
    }
    return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-orange-800", [Yoorkin$rabbit$45$tea$html$$text$362$(s)]);
  };
  const elems = moonbitlang$core$immut$list$$T$map$353$(spans, go);
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, undefined, undefined, moonbitlang$core$immut$list$$T$to_array$23$(elems));
}
function moonbitlang$mooncakes$view$$markdown$362$(markdown, small_heading) {
  const doc = rami3l$cmark$cmark$$Doc$from_string(rami3l$cmark$cmark$$Doc$from_string$46$defs$46$default(), rami3l$cmark$cmark$$Doc$from_string$46$resolver$46$default(), rami3l$cmark$cmark$$Doc$from_string$46$nested_links$46$default(), rami3l$cmark$cmark$$Doc$from_string$46$heading_auto_ids$46$default(), rami3l$cmark$cmark$$Doc$from_string$46$layout$46$default(), rami3l$cmark$cmark$$Doc$from_string$46$locs$46$default(), rami3l$cmark$cmark$$Doc$from_string$46$file$46$default(), false, markdown);
  const link_defs = moonbitlang$core$builtin$$Map$from_array$11$([]);
  const _bind = moonbitlang$core$builtin$$Map$iter$308$(doc.defs);
  _bind((_p) => {
    const _key = _p._0;
    const _x = _p._1;
    if (_x.$tag === 0) {
      const _LinkDef = _x;
      const _x$2 = _LinkDef._0;
      const _x$3 = _x$2.v;
      const _x$4 = _x$3.dest;
      if (_x$4 === undefined) {
      } else {
        const _Some = _x$4;
        const _x$5 = _Some;
        const _dest = _x$5.v;
        moonbitlang$core$builtin$$Map$set$11$(link_defs, _key, _dest);
      }
    }
    return 1;
  });
  let unwrap_inline_link;
  let inline2html;
  unwrap_inline_link = (_param1) => {
    let inline;
    let key;
    _L: {
      let inline$2;
      _L$2: {
        const _x = _param1.text;
        switch (_x.$tag) {
          case 9: {
            const _Text = _x;
            const _x$2 = _Text._0;
            const _txt = _x$2.v;
            const _x$3 = _param1.reference;
            if (_x$3.$tag === 0) {
              const _Inline = _x$3;
              const _x$4 = _Inline._0;
              const _x$5 = _x$4.v;
              const _x$6 = _x$5.dest;
              if (_x$6 === undefined) {
                inline$2 = _x;
                break _L$2;
              } else {
                const _Some = _x$6;
                const _x$7 = _Some;
                const _link = _x$7.v;
                return [Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, "text-blue-600 underline underline-offset-2", _link, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [moonbitlang$mooncakes$view$$inline_text$362$(_txt)], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$())];
              }
            } else {
              const _Ref = _x$3;
              const _x$4 = _Ref._2;
              const _key = _x$4.key;
              inline = _x;
              key = _key;
              break _L;
            }
          }
          case 4: {
            const _Image = _x;
            const _x$4 = _param1.reference;
            if (_x$4.$tag === 0) {
              const _Inline = _x$4;
              const _x$5 = _Inline._0;
              const _x$6 = _x$5.v;
              const _x$7 = _x$6.dest;
              if (_x$7 === undefined) {
                inline$2 = _x;
                break _L$2;
              } else {
                const _Some = _x$7;
                const _x$8 = _Some;
                const _link = _x$8.v;
                return [Yoorkin$rabbit$45$tea$html$$a$362$(["display: inline-block"], undefined, undefined, _link, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [moonbitlang$mooncakes$view$$image_render$362$(_Image)], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$())];
              }
            } else {
              const _Ref = _x$4;
              const _x$5 = _Ref._2;
              const _key = _x$5.key;
              inline = _x;
              key = _key;
              break _L;
            }
          }
          default: {
            const _x$5 = _param1.reference;
            if (_x$5.$tag === 0) {
              const _Inline = _x$5;
              const _x$6 = _Inline._0;
              const _x$7 = _x$6.v;
              const _x$8 = _x$7.dest;
              if (_x$8 === undefined) {
                inline$2 = _x;
                break _L$2;
              } else {
                const _Some = _x$8;
                const _x$9 = _Some;
                const _link = _x$9.v;
                return [Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, undefined, _link, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), inline2html(_x), Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$())];
              }
            } else {
              const _Ref = _x$5;
              const _x$6 = _Ref._2;
              const _key = _x$6.key;
              inline = _x;
              key = _key;
              break _L;
            }
          }
        }
      }
      return inline2html(inline$2);
    }
    const _bind$2 = moonbitlang$core$builtin$$Map$get$11$(link_defs, key);
    if (_bind$2 === undefined) {
      return inline2html(inline);
    } else {
      const _Some = _bind$2;
      const _url = _Some;
      const _tmp = Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$();
      const _tmp$2 = Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$();
      const _self = [];
      moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(inline2html(inline)));
      return [Yoorkin$rabbit$45$tea$html$$a$362$(_tmp, undefined, " text-blue-600 underline underline-offset-2", _url, _tmp$2, _self, Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$())];
    }
  };
  inline2html = (_param2) => {
    switch (_param2.$tag) {
      case 0: {
        const _Autolink = _param2;
        const _x = _Autolink._0;
        const _x$2 = _x.v;
        const _x$3 = _x$2.link;
        const _v = _x$3.v;
        return [Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, undefined, _v, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [moonbitlang$mooncakes$view$$inline_text$362$(_v)], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$())];
      }
      case 1: {
        return [Yoorkin$rabbit$45$tea$html$$text$362$("\n")];
      }
      case 2: {
        const _CodeSpan = _param2;
        const _x$4 = _CodeSpan._0;
        const _x$5 = _x$4.v;
        const _tight = _x$5.code_layout;
        return [Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "font-roboto bg-[#f0f0f0] text-sm px-1 py-[1px] rounded", rami3l$cmark$cmark$$Seq$to_array$23$(rami3l$cmark$cmark$$Seq$map$371$(_tight, (x) => Yoorkin$rabbit$45$tea$html$$text$362$(x.node.v))))];
      }
      case 3: {
        const _Emphasis = _param2;
        const _x$6 = _Emphasis._0;
        const _x$7 = _x$6.v;
        const _inline = _x$7.inline;
        return [Yoorkin$rabbit$45$tea$html$$em$362$(Yoorkin$rabbit$45$tea$html$$em$46$style$46$default$362$(), undefined, undefined, inline2html(_inline))];
      }
      case 4: {
        const _Image = _param2;
        return [moonbitlang$mooncakes$view$$image_render$362$(_Image)];
      }
      case 5: {
        const _Inlines = _param2;
        const _x$8 = _Inlines._0;
        const _v$2 = _x$8.v;
        return moonbitlang$core$array$$Array$flatten$23$(rami3l$cmark$cmark$$Seq$to_array$376$(rami3l$cmark$cmark$$Seq$map$372$(_v$2, inline2html)));
      }
      case 6: {
        const _Link = _param2;
        const _x$9 = _Link._0;
        const _link = _x$9.v;
        return unwrap_inline_link(_link);
      }
      case 8: {
        const _StrongEmphasis = _param2;
        const _x$10 = _StrongEmphasis._0;
        const _x$11 = _x$10.v;
        const _inline$2 = _x$11.inline;
        const inline = inline2html(_inline$2);
        return [Yoorkin$rabbit$45$tea$html$$strong$362$(Yoorkin$rabbit$45$tea$html$$strong$46$style$46$default$362$(), undefined, undefined, inline)];
      }
      case 9: {
        const _Text = _param2;
        const _x$12 = _Text._0;
        const _str = _x$12.v;
        return [moonbitlang$mooncakes$view$$inline_text$362$(_str)];
      }
      case 7: {
        const _RawHtml = _param2;
        const _x$13 = _RawHtml._0;
        const _str$2 = _x$13.v;
        return [moonbitlang$mooncakes$view$$unsupported$362$("RawHtml", moonbitlang$core$builtin$$Show$to_string$317$(_str$2))];
      }
      case 10: {
        const _ExtStrikethrough = _param2;
        const _x$14 = _ExtStrikethrough._0;
        const _inline$3 = _x$14.v;
        return [moonbitlang$mooncakes$view$$unsupported$362$("ExtStrikethrough", moonbitlang$core$builtin$$Show$to_string$318$(_inline$3))];
      }
      default: {
        const _ExtMathSpan = _param2;
        const _x$15 = _ExtMathSpan._0;
        const _math = _x$15.v;
        return [moonbitlang$mooncakes$view$$unsupported$362$("ExtMathSpan", moonbitlang$core$builtin$$Show$to_string$319$(_math))];
      }
    }
  };
  const block2html = (_param3) => {
    switch (_param3.$tag) {
      case 0: {
        return Yoorkin$rabbit$45$tea$html$$p$362$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$(), undefined, undefined, []);
      }
      case 1: {
        const _BlockQuote = _param3;
        const _x = _BlockQuote._0;
        const _x$2 = _x.v;
        const _block = _x$2.block;
        return Yoorkin$rabbit$45$tea$html$$blockquote$362$(Yoorkin$rabbit$45$tea$html$$blockquote$46$style$46$default$362$(), undefined, "border-l-4 border-gray-400 bg-gray-50 text-gray-600 py-2 pl-4 my-2", [block2html(_block)]);
      }
      case 2: {
        const _Blocks = _param3;
        const _x$3 = _Blocks._0;
        const _xs = _x$3.v;
        return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, undefined, rami3l$cmark$cmark$$Seq$to_array$23$(rami3l$cmark$cmark$$Seq$map$373$(_xs, block2html)));
      }
      case 3: {
        const _CodeBlock = _param3;
        const _x$4 = _CodeBlock._0;
        const _x$5 = _x$4.v;
        const _code = _x$5.code;
        const _info_string = _x$5.info_string;
        const _bind$2 = rami3l$cmark$cmark$$Seq$iter$108$(_code);
        const code = moonbitlang$core$builtin$$Iter$join((_p) => _bind$2((_p$2) => _p(_p$2.v)), "\n");
        let code$2;
        _L: {
          _L$2: {
            if (_info_string === undefined) {
              break _L$2;
            } else {
              const _Some = _info_string;
              const _x$6 = _Some;
              const _lang = _x$6.v;
              _L$3: {
                if (_lang === "mbt") {
                  break _L$3;
                } else {
                  if (_lang === "moonbit") {
                    break _L$3;
                  } else {
                    break _L$2;
                  }
                }
              }
              const code$3 = moonbitlang$mooncakes$view$$code_block$362$(code, false);
              code$2 = Yoorkin$rabbit$45$tea$html$$code$362$(Yoorkin$rabbit$45$tea$html$$code$46$style$46$default$362$(), undefined, "font-roboto", [code$3]);
            }
            break _L;
          }
          code$2 = Yoorkin$rabbit$45$tea$html$$code$362$(Yoorkin$rabbit$45$tea$html$$code$46$style$46$default$362$(), undefined, "font-roboto", [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(code)])]);
        }
        return Yoorkin$rabbit$45$tea$html$$pre$362$(Yoorkin$rabbit$45$tea$html$$pre$46$style$46$default$362$(), undefined, "bg-gray-100 p-4 my-4 text-sm rounded overflow-x-scroll", [code$2]);
      }
      case 4: {
        const _Heading = _param3;
        const _x$6 = _Heading._0;
        const _x$7 = _x$6.v;
        const _level = _x$7.level;
        const _inline = _x$7.inline;
        const inline = inline2html(_inline);
        if (small_heading) {
          _L$2: {
            switch (_level) {
              case 1: {
                return Yoorkin$rabbit$45$tea$html$$h3$362$(Yoorkin$rabbit$45$tea$html$$h3$46$style$46$default$362$(), undefined, "text-gray-900 font-bold mt-1 text-sm", inline);
              }
              case 2: {
                break _L$2;
              }
              case 3: {
                break _L$2;
              }
              default: {
                return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "text-gray-900", undefined, inline);
              }
            }
          }
          return Yoorkin$rabbit$45$tea$html$$h4$362$(Yoorkin$rabbit$45$tea$html$$h4$46$style$46$default$362$(), undefined, "text-gray-900 font-semibold text-sm", inline);
        } else {
          switch (_level) {
            case 1: {
              return Yoorkin$rabbit$45$tea$html$$h1$362$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$362$(), undefined, "text-gray-800 font-semibold mt-4 mb-2 text-3xl", inline);
            }
            case 2: {
              return Yoorkin$rabbit$45$tea$html$$h2$362$(Yoorkin$rabbit$45$tea$html$$h2$46$style$46$default$362$(), undefined, "text-gray-800 font-semibold mt-4 mb-2 border-b text-2xl", inline);
            }
            case 3: {
              return Yoorkin$rabbit$45$tea$html$$h3$362$(Yoorkin$rabbit$45$tea$html$$h3$46$style$46$default$362$(), undefined, "text-gray-800 font-semibold text-xl mt-3 mb-2", inline);
            }
            case 4: {
              return Yoorkin$rabbit$45$tea$html$$h4$362$(Yoorkin$rabbit$45$tea$html$$h4$46$style$46$default$362$(), undefined, "text-gray-800", inline);
            }
            default: {
              return Yoorkin$rabbit$45$tea$html$$h5$362$(Yoorkin$rabbit$45$tea$html$$h5$46$style$46$default$362$(), undefined, "text-gray-800", inline);
            }
          }
        }
      }
      case 7: {
        const _List = _param3;
        const _x$8 = _List._0;
        const _x$9 = _x$8.v;
        const _ordered = _x$9.ty;
        const _tight = _x$9.tight;
        const _items = _x$9.items;
        const items = rami3l$cmark$cmark$$Seq$to_array$23$(rami3l$cmark$cmark$$Seq$map$374$(_items, (_param4) => {
          const _x$10 = _param4.v;
          const _block$2 = _x$10.block;
          const _ext_task_marker = _x$10.ext_task_marker;
          if (_ext_task_marker === undefined) {
            return Yoorkin$rabbit$45$tea$html$$li$362$(Yoorkin$rabbit$45$tea$html$$li$46$style$46$default$362$(), undefined, undefined, "list-inside", undefined, [block2html(_block$2)]);
          } else {
            const _Some = _ext_task_marker;
            const _x$11 = _Some;
            const _char = _x$11.v;
            return Yoorkin$rabbit$45$tea$html$$li$362$(Yoorkin$rabbit$45$tea$html$$li$46$style$46$default$362$(), undefined, undefined, "list-inside flex gap-1", undefined, [Yoorkin$rabbit$45$tea$html$$input$362$(1, undefined, undefined, _char === 120 || _char === 88, true, -1, undefined, undefined, undefined, Yoorkin$rabbit$45$tea$html$$input$46$style$46$default$362$(), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, Yoorkin$rabbit$45$tea$html$$input$46$childrens$46$default$362$(), undefined, undefined), block2html(_block$2)]);
          }
        }));
        const class_ = `ml-2 list-inside ${_tight ? "space-y-0.5" : "space-y-1"}`;
        if (_ordered.$tag === 0) {
          return Yoorkin$rabbit$45$tea$html$$ul$362$(Yoorkin$rabbit$45$tea$html$$ul$46$style$46$default$362$(), undefined, `${class_} list-disc`, undefined, items);
        } else {
          const _Ordered = _ordered;
          const _start = _Ordered._0;
          return Yoorkin$rabbit$45$tea$html$$ol$362$(Yoorkin$rabbit$45$tea$html$$ol$46$style$46$default$362$(), -1, _start, undefined, `${class_} list-decimal`, items);
        }
      }
      case 8: {
        const _Paragraph = _param3;
        const _x$10 = _Paragraph._0;
        const _x$11 = _x$10.v;
        const _inline$2 = _x$11.inline;
        return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, undefined, inline2html(_inline$2));
      }
      case 9: {
        return Yoorkin$rabbit$45$tea$html$$hr$362$(Yoorkin$rabbit$45$tea$html$$hr$46$style$46$default$362$(), undefined, "my-4", Yoorkin$rabbit$45$tea$html$$hr$46$childrens$46$default$362$());
      }
      case 11: {
        const _ExtTable = _param3;
        const _x$12 = _ExtTable._0;
        const _x$13 = _x$12.v;
        const _rows = _x$13.rows;
        const colgroup = [];
        const _p = rami3l$cmark$cmark$$Seq$to_array$200$(_rows);
        let body;
        let _p$2;
        _L$2: {
          _L$3: {
            if (_p.length === 0) {
              const _tmp = [];
              _p$2 = _tmp;
              break _L$3;
            }
            const _p$3 = new Array(_p.length);
            const _p$4 = _p.length;
            let _tmp = 0;
            while (true) {
              const _p$5 = _tmp;
              if (_p$5 < _p$4) {
                const _p$6 = _p[_p$5];
                const i = _p$5;
                const row = _p$6;
                const _x$14 = row._0;
                const _x$15 = _x$14.v;
                let _tmp$2;
                switch (_x$15.$tag) {
                  case 0: {
                    const _Header = _x$15;
                    const _cols = _Header._0;
                    const colgroup$2 = colgroup.length > 0 ? 1 : 0;
                    const class$2 = ((i - colgroup$2 | 0) % 2 | 0) === 0 ? "bg-gray-100" : "";
                    const cols = rami3l$cmark$cmark$$Seq$to_array$23$(rami3l$cmark$cmark$$Seq$map$375$(_cols, (_param5) => {
                      const _inline$3 = _param5._0;
                      return Yoorkin$rabbit$45$tea$html$$th$362$(Yoorkin$rabbit$45$tea$html$$th$46$style$46$default$362$(), undefined, undefined, undefined, undefined, undefined, undefined, "border border-gray-300 p-2 font-semibold", inline2html(_inline$3));
                    }));
                    _tmp$2 = Yoorkin$rabbit$45$tea$html$$tr$362$(Yoorkin$rabbit$45$tea$html$$tr$46$style$46$default$362$(), undefined, class$2, cols);
                    break;
                  }
                  case 2: {
                    const _Data = _x$15;
                    const _cols$2 = _Data._0;
                    const colgroup$3 = colgroup.length > 0 ? 1 : 0;
                    const class$3 = ((i - colgroup$3 | 0) % 2 | 0) === 0 ? "bg-gray-100" : "";
                    const cols$2 = rami3l$cmark$cmark$$Seq$to_array$23$(rami3l$cmark$cmark$$Seq$map$375$(_cols$2, (_param6) => {
                      const _inline$3 = _param6._0;
                      return Yoorkin$rabbit$45$tea$html$$td$362$(Yoorkin$rabbit$45$tea$html$$td$46$style$46$default$362$(), undefined, undefined, undefined, undefined, "border border-gray-300 p-2", inline2html(_inline$3));
                    }));
                    _tmp$2 = Yoorkin$rabbit$45$tea$html$$tr$362$(Yoorkin$rabbit$45$tea$html$$tr$46$style$46$default$362$(), undefined, class$3, cols$2);
                    break;
                  }
                  default: {
                    const _Sep = _x$15;
                    const _cols$3 = _Sep._0;
                    const _bind$3 = rami3l$cmark$cmark$$Seq$iter$220$(_cols$3);
                    _bind$3((_p$7) => {
                      const _x$16 = _p$7.v;
                      const _align = _x$16._0;
                      if (_align === undefined) {
                        moonbitlang$core$array$$Array$push$23$(colgroup, Yoorkin$rabbit$45$tea$html$$col$362$(Yoorkin$rabbit$45$tea$html$$col$46$style$46$default$362$(), undefined, undefined, "", []));
                      } else {
                        const _Some = _align;
                        const _x$17 = _Some;
                        switch (_x$17) {
                          case 0: {
                            moonbitlang$core$array$$Array$push$23$(colgroup, Yoorkin$rabbit$45$tea$html$$col$362$(Yoorkin$rabbit$45$tea$html$$col$46$style$46$default$362$(), undefined, undefined, "text-left", []));
                            break;
                          }
                          case 1: {
                            moonbitlang$core$array$$Array$push$23$(colgroup, Yoorkin$rabbit$45$tea$html$$col$362$(Yoorkin$rabbit$45$tea$html$$col$46$style$46$default$362$(), undefined, undefined, "text-center", []));
                            break;
                          }
                          default: {
                            moonbitlang$core$array$$Array$push$23$(colgroup, Yoorkin$rabbit$45$tea$html$$col$362$(Yoorkin$rabbit$45$tea$html$$col$46$style$46$default$362$(), undefined, undefined, "text-right", []));
                          }
                        }
                      }
                      return 1;
                    });
                    _tmp$2 = Yoorkin$rabbit$45$tea$html$$nothing$362$();
                  }
                }
                _p$3[_p$5] = _tmp$2;
                _tmp = _p$5 + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            body = _p$3;
            break _L$2;
          }
          body = _p$2;
        }
        return Yoorkin$rabbit$45$tea$html$$table$362$(Yoorkin$rabbit$45$tea$html$$table$46$style$46$default$362$(), undefined, "w-full table-auto my-6 border-2 border-collapse border-gray-300", [Yoorkin$rabbit$45$tea$html$$colgroup$362$(Yoorkin$rabbit$45$tea$html$$colgroup$46$style$46$default$362$(), undefined, undefined, undefined, colgroup), Yoorkin$rabbit$45$tea$html$$tbody$362$(Yoorkin$rabbit$45$tea$html$$tbody$46$style$46$default$362$(), undefined, undefined, body)]);
      }
      case 6: {
        return Yoorkin$rabbit$45$tea$html$$nothing$362$();
      }
      case 10: {
        const _ExtMathBlock = _param3;
        const _x$14 = _ExtMathBlock._0;
        const _math = _x$14.v;
        return moonbitlang$mooncakes$view$$unsupported$362$("ExtMathBlock", moonbitlang$core$builtin$$Show$to_string$320$(_math));
      }
      case 5: {
        const _HtmlBlock = _param3;
        const _x$15 = _HtmlBlock._0;
        const _html = _x$15.v;
        return moonbitlang$mooncakes$view$$unsupported$362$("HtmlBlock", moonbitlang$core$builtin$$Show$to_string$321$(_html));
      }
      default: {
        const _ExtFootnoteDefinition = _param3;
        const _x$16 = _ExtFootnoteDefinition._0;
        const _footnote = _x$16.v;
        return moonbitlang$mooncakes$view$$unsupported$362$("ExtFootnoteDefinition", moonbitlang$core$builtin$$Show$to_string$322$(_footnote));
      }
    }
  };
  const folder = { inline_ext_default: (_discard_, acc, _discard_$2) => new Result$Ok$79$(acc), block_ext_default: (_discard_, acc, _discard_$2) => new Result$Ok$79$(acc), inline: (_discard_, acc, inline) => {
    const _self = [];
    moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(acc));
    moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(inline2html(inline)));
    return new $64$rami3l$47$cmark$47$cmark$46$FolderResult$Fold$82$(_self);
  }, block: (_discard_, acc, block) => {
    const _self = [];
    moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(acc));
    moonbitlang$core$array$$Array$push$23$(_self, block2html(block));
    return new $64$rami3l$47$cmark$47$cmark$46$FolderResult$Fold$82$(_self);
  } };
  let _try_err;
  _L: {
    const _bind$2 = rami3l$cmark$cmark$$Folder$fold_doc$376$(folder, [], doc);
    let _bind$3;
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _bind$3 = _ok._0;
    } else {
      const _err = _bind$2;
      const _tmp = _err._0;
      _try_err = _tmp;
      break _L;
    }
    return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "w-full text-base text-[#3c3c43]", undefined, _bind$3);
  }
  const _FolderError = _try_err;
  const _msg = _FolderError._0;
  return Yoorkin$rabbit$45$tea$html$$text$362$(`Failed to render markdown: ${moonbitlang$core$builtin$$Show$to_string$9$(_msg)}`);
}
function moonbitlang$mooncakes$view$$markdown$46$small_heading$46$default$362$() {
  return false;
}
function moonbitlang$mooncakes$view$$footer$363$() {
  return Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "px-6 min-h-28 lg:mx-10 mt-5 py-10 border-t text-gray-600 flex flex-col md:flex-row justify-center gap-4 md:gap-8", undefined, [Yoorkin$rabbit$45$tea$html$$p$363$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$363$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$363$("Powered by MoonBit")]), Yoorkin$rabbit$45$tea$html$$a$363$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$363$(), undefined, moonbitlang$mooncakes$view$$footer$46$class$124$44, "https://github.com/moonbitlang/mooncakes.io", Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$363$(), [Yoorkin$rabbit$45$tea$html$$text$363$("Site source")], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$363$()), Yoorkin$rabbit$45$tea$html$$a$363$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$363$(), undefined, moonbitlang$mooncakes$view$$footer$46$class$124$44, "https://github.com/moonbitlang/mooncakes.io/issues/new", Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$363$(), [Yoorkin$rabbit$45$tea$html$$text$363$("Report issue")], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$363$()), Yoorkin$rabbit$45$tea$html$$p$363$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$363$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$363$("© 2025 mooncakes.io (Community Edition)")])]);
}
function moonbitlang$mooncakes$view$$accordion$362$(class_, click, showing, items) {
  const _tmp = Yoorkin$rabbit$45$tea$html$$ul$46$style$46$default$362$();
  const _p = new Array(items.length);
  const _p$2 = items.length;
  let _tmp$2 = 0;
  while (true) {
    const _p$3 = _tmp$2;
    if (_p$3 < _p$2) {
      const _p$4 = items[_p$3];
      const _param9 = _p$4;
      const _title = _param9._0;
      const _childs = _param9._1;
      const folded = moonbitlang$core$builtin$$op_notequal$9$(_title, showing);
      const folded_style = folded ? "" : "bg-gray-100";
      const click$2 = moonbitlang$core$option$$Option$map$56$(click, (f) => _title === showing ? f("") : f(_title));
      const childs = folded ? Yoorkin$rabbit$45$tea$html$$nothing$362$() : _childs;
      _p[_p$3] = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "w-full", undefined, [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, `w-full px-2 py-1 select-none font-semibold text-gray-700 hover:bg-gray-200 ${moonbitlang$core$builtin$$Show$to_string$9$(folded_style)}`, click$2, [Yoorkin$rabbit$45$tea$html$$text$362$(_title)]), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "ml-2", undefined, [childs])]);
      _tmp$2 = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return Yoorkin$rabbit$45$tea$html$$ul$362$(_tmp, undefined, class_, undefined, _p);
}
function moonbitlang$mooncakes$view$$not_found$361$() {
  return Yoorkin$rabbit$45$tea$html$$div$361$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$361$(), undefined, "flex flex-col items-center justify-center h-screen", undefined, [Yoorkin$rabbit$45$tea$html$$h1$361$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$361$(), undefined, "text-4xl font-bold", [Yoorkin$rabbit$45$tea$html$$text$361$("404")]), Yoorkin$rabbit$45$tea$html$$p$361$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$361$(), undefined, "text-lg", [Yoorkin$rabbit$45$tea$html$$text$361$("Page not found")]), Yoorkin$rabbit$45$tea$html$$a$361$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$361$(), undefined, "text-blue-500", "/", Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$361$(), [Yoorkin$rabbit$45$tea$html$$text$361$("Go back to home")], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$361$())]);
}
function moonbitlang$mooncakes$view$$loading$361$() {
  return Yoorkin$rabbit$45$tea$html$$div$361$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$361$(), undefined, "flex flex-col items-center justify-center h-full w-full", undefined, [Yoorkin$rabbit$45$tea$html$$h1$361$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$361$(), undefined, "text-2xl font-bold m-10", [Yoorkin$rabbit$45$tea$html$$text$361$("Loading...")])]);
}
function moonbitlang$mooncakes$view$$loading$363$() {
  return Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "flex flex-col items-center justify-center h-full w-full", undefined, [Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "text-2xl font-bold m-10", [Yoorkin$rabbit$45$tea$html$$text$363$("Loading...")])]);
}
function moonbitlang$mooncakes$view$$loading$362$() {
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "flex flex-col items-center justify-center h-full w-full", undefined, [Yoorkin$rabbit$45$tea$html$$h1$362$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$362$(), undefined, "text-2xl font-bold m-10", [Yoorkin$rabbit$45$tea$html$$text$362$("Loading...")])]);
}
function moonbitlang$mooncakes$view$$load_failed$363$(resource) {
  return Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "flex flex-col items-center justify-center h-full w-full", undefined, [Yoorkin$rabbit$45$tea$html$$pre$363$(Yoorkin$rabbit$45$tea$html$$pre$46$style$46$default$363$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$code$363$(Yoorkin$rabbit$45$tea$html$$code$46$style$46$default$363$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$363$(moonbitlang$mooncakes$config$$dead_rabbit)])]), Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "text-2xl font-bold text-gray-700 m-10", [Yoorkin$rabbit$45$tea$html$$text$363$(`Failed to load ${moonbitlang$core$builtin$$Show$to_string$9$(resource)}`)])]);
}
function moonbitlang$mooncakes$view$$document_not_available$362$(path) {
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "flex flex-col items-center justify-center h-full w-full", undefined, [Yoorkin$rabbit$45$tea$html$$pre$362$(Yoorkin$rabbit$45$tea$html$$pre$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$code$362$(Yoorkin$rabbit$45$tea$html$$code$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(moonbitlang$mooncakes$config$$dead_rabbit)])]), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "text-gray-900 m-10", undefined, [Yoorkin$rabbit$45$tea$html$$h1$362$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$362$(), undefined, "text-lg mb-2 font-semibold text-center", [Yoorkin$rabbit$45$tea$html$$text$362$(`Document for ${moonbitlang$core$builtin$$Show$to_string$9$(path)} is not available`)]), Yoorkin$rabbit$45$tea$html$$ul$362$(Yoorkin$rabbit$45$tea$html$$ul$46$style$46$default$362$(), undefined, "list-disc text-gray-600", undefined, [Yoorkin$rabbit$45$tea$html$$li$362$(Yoorkin$rabbit$45$tea$html$$li$46$style$46$default$362$(), undefined, undefined, undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$("The package may be outdated and we cannot build document for it.")]), Yoorkin$rabbit$45$tea$html$$li$362$(Yoorkin$rabbit$45$tea$html$$li$46$style$46$default$362$(), undefined, undefined, undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$("It also could be an error in mooncakes.io, please report it to us.")])])])]);
}
function Yoorkin$rabbit$45$tea$http$$Body$content_type(self) {
  switch (self.$tag) {
    case 0: {
      return "application/json";
    }
    case 1: {
      return "text/plain";
    }
    default: {
      return "text/plain";
    }
  }
}
function Yoorkin$rabbit$45$tea$http$$Body$stringfiy(self) {
  switch (self.$tag) {
    case 0: {
      const _Json = self;
      const _json = _Json._0;
      return moonbitlang$core$json$$Json$stringify(_json, moonbitlang$core$json$$Json$stringify$46$escape_slash$46$default(), moonbitlang$core$json$$Json$stringify$46$indent$46$default());
    }
    case 1: {
      const _Text = self;
      const _text = _Text._0;
      return _text;
    }
    default: {
      return "";
    }
  }
}
function Yoorkin$rabbit$45$tea$http$$request$377$(url, http_method, expect, body) {
  const launch = (events) => {
    let has_body;
    if (body.$tag === 2) {
      has_body = false;
    } else {
      has_body = true;
    }
    const content_type = Yoorkin$rabbit$45$tea$http$$Body$content_type(body);
    const body$2 = Yoorkin$rabbit$45$tea$http$$Body$stringfiy(body);
    if (expect.$tag === 0) {
      const _Json = expect;
      const _f = _Json._0;
      const _decoder = _Json._1;
      Yoorkin$rabbit$45$tea$http$$js_request(url, http_method, content_type, body$2, has_body, (str) => {
        let result;
        let _try_err;
        _L: {
          _L$2: {
            const _bind = moonbitlang$core$json$$parse(str);
            let _tmp;
            if (_bind.$tag === 1) {
              const _ok = _bind;
              _tmp = _ok._0;
            } else {
              const _err = _bind;
              const _tmp$2 = _err._0;
              _try_err = _tmp$2;
              break _L$2;
            }
            result = new Result$Ok$83$(_tmp);
            break _L;
          }
          result = new Result$Err$83$("Json parse error");
        }
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(moonbitlang$core$result$$Result$bind$342$(result, _decoder)));
      }, (msg) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(new Result$Err$43$(`Http request failed:${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`)));
      });
      return;
    } else {
      const _Text = expect;
      const _f = _Text._0;
      Yoorkin$rabbit$45$tea$http$$js_request(url, http_method, content_type, body$2, has_body, (str) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(new Result$Ok$84$(str)));
      }, (msg) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(new Result$Err$84$(`Http request failed:${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`)));
      });
      return;
    }
  };
  return launch;
}
function Yoorkin$rabbit$45$tea$http$$request$378$(url, http_method, expect, body) {
  const launch = (events) => {
    let has_body;
    if (body.$tag === 2) {
      has_body = false;
    } else {
      has_body = true;
    }
    const content_type = Yoorkin$rabbit$45$tea$http$$Body$content_type(body);
    const body$2 = Yoorkin$rabbit$45$tea$http$$Body$stringfiy(body);
    if (expect.$tag === 0) {
      const _Json = expect;
      const _f = _Json._0;
      const _decoder = _Json._1;
      Yoorkin$rabbit$45$tea$http$$js_request(url, http_method, content_type, body$2, has_body, (str) => {
        let result;
        let _try_err;
        _L: {
          _L$2: {
            const _bind = moonbitlang$core$json$$parse(str);
            let _tmp;
            if (_bind.$tag === 1) {
              const _ok = _bind;
              _tmp = _ok._0;
            } else {
              const _err = _bind;
              const _tmp$2 = _err._0;
              _try_err = _tmp$2;
              break _L$2;
            }
            result = new Result$Ok$83$(_tmp);
            break _L;
          }
          result = new Result$Err$83$("Json parse error");
        }
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$363$(events, _f(moonbitlang$core$result$$Result$bind$343$(result, _decoder)));
      }, (msg) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$363$(events, _f(new Result$Err$44$(`Http request failed:${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`)));
      });
      return;
    } else {
      const _Text = expect;
      const _f = _Text._0;
      Yoorkin$rabbit$45$tea$http$$js_request(url, http_method, content_type, body$2, has_body, (str) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$363$(events, _f(new Result$Ok$84$(str)));
      }, (msg) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$363$(events, _f(new Result$Err$84$(`Http request failed:${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`)));
      });
      return;
    }
  };
  return launch;
}
function Yoorkin$rabbit$45$tea$http$$request$379$(url, http_method, expect, body) {
  const launch = (events) => {
    let has_body;
    if (body.$tag === 2) {
      has_body = false;
    } else {
      has_body = true;
    }
    const content_type = Yoorkin$rabbit$45$tea$http$$Body$content_type(body);
    const body$2 = Yoorkin$rabbit$45$tea$http$$Body$stringfiy(body);
    if (expect.$tag === 0) {
      const _Json = expect;
      const _f = _Json._0;
      const _decoder = _Json._1;
      Yoorkin$rabbit$45$tea$http$$js_request(url, http_method, content_type, body$2, has_body, (str) => {
        let result;
        let _try_err;
        _L: {
          _L$2: {
            const _bind = moonbitlang$core$json$$parse(str);
            let _tmp;
            if (_bind.$tag === 1) {
              const _ok = _bind;
              _tmp = _ok._0;
            } else {
              const _err = _bind;
              const _tmp$2 = _err._0;
              _try_err = _tmp$2;
              break _L$2;
            }
            result = new Result$Ok$83$(_tmp);
            break _L;
          }
          result = new Result$Err$83$("Json parse error");
        }
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(moonbitlang$core$result$$Result$bind$344$(result, _decoder)));
      }, (msg) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(new Result$Err$45$(`Http request failed:${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`)));
      });
      return;
    } else {
      const _Text = expect;
      const _f = _Text._0;
      Yoorkin$rabbit$45$tea$http$$js_request(url, http_method, content_type, body$2, has_body, (str) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(new Result$Ok$84$(str)));
      }, (msg) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(new Result$Err$84$(`Http request failed:${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`)));
      });
      return;
    }
  };
  return launch;
}
function Yoorkin$rabbit$45$tea$http$$request$380$(url, http_method, expect, body) {
  const launch = (events) => {
    let has_body;
    if (body.$tag === 2) {
      has_body = false;
    } else {
      has_body = true;
    }
    const content_type = Yoorkin$rabbit$45$tea$http$$Body$content_type(body);
    const body$2 = Yoorkin$rabbit$45$tea$http$$Body$stringfiy(body);
    if (expect.$tag === 0) {
      const _Json = expect;
      const _f = _Json._0;
      const _decoder = _Json._1;
      Yoorkin$rabbit$45$tea$http$$js_request(url, http_method, content_type, body$2, has_body, (str) => {
        let result;
        let _try_err;
        _L: {
          _L$2: {
            const _bind = moonbitlang$core$json$$parse(str);
            let _tmp;
            if (_bind.$tag === 1) {
              const _ok = _bind;
              _tmp = _ok._0;
            } else {
              const _err = _bind;
              const _tmp$2 = _err._0;
              _try_err = _tmp$2;
              break _L$2;
            }
            result = new Result$Ok$83$(_tmp);
            break _L;
          }
          result = new Result$Err$83$("Json parse error");
        }
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(moonbitlang$core$result$$Result$bind$345$(result, _decoder)));
      }, (msg) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(new Result$Err$42$(`Http request failed:${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`)));
      });
      return;
    } else {
      const _Text = expect;
      const _f = _Text._0;
      Yoorkin$rabbit$45$tea$http$$js_request(url, http_method, content_type, body$2, has_body, (str) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(new Result$Ok$84$(str)));
      }, (msg) => {
        Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(events, _f(new Result$Err$84$(`Http request failed:${moonbitlang$core$builtin$$Show$to_string$9$(msg)}`)));
      });
      return;
    }
  };
  return launch;
}
function Yoorkin$rabbit$45$tea$http$$get$377$(url, expect) {
  return Yoorkin$rabbit$45$tea$http$$request$377$(url, "GET", expect, $64$Yoorkin$47$rabbit$45$tea$47$http$46$Body$Empty);
}
function Yoorkin$rabbit$45$tea$http$$get$378$(url, expect) {
  return Yoorkin$rabbit$45$tea$http$$request$378$(url, "GET", expect, $64$Yoorkin$47$rabbit$45$tea$47$http$46$Body$Empty);
}
function Yoorkin$rabbit$45$tea$http$$get$379$(url, expect) {
  return Yoorkin$rabbit$45$tea$http$$request$379$(url, "GET", expect, $64$Yoorkin$47$rabbit$45$tea$47$http$46$Body$Empty);
}
function Yoorkin$rabbit$45$tea$http$$get$380$(url, expect) {
  return Yoorkin$rabbit$45$tea$http$$request$380$(url, "GET", expect, $64$Yoorkin$47$rabbit$45$tea$47$http$46$Body$Empty);
}
function moonbitlang$mooncakes$page$home$$decode_module_indices(modules_json) {
  const _bind = moonbitlang$core$result$$Result$unwrap$346$(moonbitlang$core$json$$parse(moonbitlang$mooncakes$page$home$$resource));
  if (_bind.$tag === 5) {
    const _Array = _bind;
    const _blacklist = _Array._0;
    const _bind$2 = moonbitlang$core$array$$Array$iter$17$(_blacklist);
    const blacklist = moonbitlang$core$hashset$$from_array$9$(moonbitlang$core$builtin$$Iter$collect$9$((_p) => _bind$2((_p$2) => {
      const metadata = moonbitlang$core$option$$Option$unwrap$269$(moonbitlang$core$json$$Json$as_object(moonbitlang$core$option$$Option$unwrap$17$(moonbitlang$core$builtin$$Map$get$8$(moonbitlang$core$option$$Option$unwrap$269$(moonbitlang$core$json$$Json$as_object(_p$2)), "metadata"))));
      const package_name = moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$json$$Json$as_string(moonbitlang$core$option$$Option$unwrap$17$(moonbitlang$core$builtin$$Map$get$8$(metadata, "name"))));
      const author = moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$json$$Json$as_string(moonbitlang$core$option$$Option$unwrap$17$(moonbitlang$core$builtin$$Map$get$8$(metadata, "author"))));
      return _p(`${author}/${package_name}`);
    })));
    _L: {
      if (modules_json.$tag === 6) {
        const _Object = modules_json;
        const _x = _Object._0;
        const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "modules");
        if (_x$2 === undefined) {
          break _L;
        } else {
          const _Some = _x$2;
          const _x$3 = _Some;
          if (_x$3.$tag === 5) {
            const _Array$2 = _x$3;
            const _modules = _Array$2._0;
            const indices = [];
            const _len = _modules.length;
            let _tmp = 0;
            while (true) {
              const _i = _tmp;
              if (_i < _len) {
                const mod = _modules[_i];
                let _bind$3;
                _L$2: {
                  _L$3: {
                    if (mod.$tag === 6) {
                      const _Object$2 = mod;
                      const _x$4 = _Object$2._0;
                      const _x$5 = moonbitlang$core$builtin$$Map$get$8$(_x$4, "name");
                      if (_x$5 === undefined) {
                        break _L$3;
                      } else {
                        const _Some$2 = _x$5;
                        const _x$6 = _Some$2;
                        if (_x$6.$tag === 4) {
                          const _String = _x$6;
                          const _path = _String._0;
                          const _x$7 = moonbitlang$core$builtin$$Map$get$8$(_x$4, "version");
                          if (_x$7 === undefined) {
                            break _L$3;
                          } else {
                            const _Some$3 = _x$7;
                            const _x$8 = _Some$3;
                            if (_x$8.$tag === 4) {
                              const _String$2 = _x$8;
                              const _version = _String$2._0;
                              const _description = moonbitlang$core$builtin$$Map$get$8$(_x$4, "description");
                              const _keywords = moonbitlang$core$builtin$$Map$get$8$(_x$4, "keywords");
                              const _created_at = moonbitlang$core$builtin$$Map$get$8$(_x$4, "created_at");
                              let keywords;
                              _L$4: {
                                _L$5: {
                                  if (_keywords === undefined) {
                                    break _L$5;
                                  } else {
                                    const _Some$4 = _keywords;
                                    const _x$9 = _Some$4;
                                    if (_x$9.$tag === 5) {
                                      const _Array$3 = _x$9;
                                      const _keywords$2 = _Array$3._0;
                                      const _p = new Array(_keywords$2.length);
                                      const _p$2 = _keywords$2.length;
                                      let _tmp$2 = 0;
                                      while (true) {
                                        const _p$3 = _tmp$2;
                                        if (_p$3 < _p$2) {
                                          const _p$4 = _keywords$2[_p$3];
                                          const x = _p$4;
                                          _p[_p$3] = moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$json$$Json$as_string(x));
                                          _tmp$2 = _p$3 + 1 | 0;
                                          continue;
                                        } else {
                                          break;
                                        }
                                      }
                                      keywords = new Option$Some$85$(_p);
                                    } else {
                                      break _L$5;
                                    }
                                  }
                                  break _L$4;
                                }
                                keywords = Option$None$85$;
                              }
                              const created_at = moonbitlang$core$option$$Option$map$53$(_created_at, (x) => moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$json$$Json$as_string(x)));
                              const description = moonbitlang$core$option$$Option$map$53$(_description, (x) => moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$json$$Json$as_string(x)));
                              const _bind$4 = moonbitlang$core$builtin$$Iter$collect$16$(moonbitlang$core$string$$String$split(_path, { str: moonbitlang$mooncakes$page$home$$decode_module_indices$46$42$bind$124$111, start: 0, end: moonbitlang$mooncakes$page$home$$decode_module_indices$46$42$bind$124$111.length }));
                              if (_bind$4.length >= 1) {
                                const _author = _bind$4[0];
                                const _x$9 = moonbitlang$core$array$$Array$op_as_view$16$(_bind$4, 1, _bind$4.length);
                                const _bind$5 = moonbitlang$core$array$$ArrayView$iter$16$(_x$9);
                                const name = moonbitlang$core$builtin$$Iter$join((_p) => _bind$5((_p$2) => _p(moonbitlang$core$builtin$$Show$to_string$16$(_p$2))), "/");
                                const _bind$6 = moonbitlang$core$builtin$$Show$to_string$16$(_author);
                                _bind$3 = new Result$Ok$86$({ author: _bind$6, name: name, path: _path, version: _version, keywords: keywords, description: description, created_at: created_at });
                              } else {
                                _bind$3 = $panic();
                              }
                            } else {
                              break _L$3;
                            }
                          }
                        } else {
                          break _L$3;
                        }
                      }
                    } else {
                      break _L$3;
                    }
                    break _L$2;
                  }
                  _bind$3 = new Result$Err$86$("Error when parsing metadata.");
                }
                if (_bind$3.$tag === 1) {
                  const _Ok = _bind$3;
                  const _index = _Ok._0;
                  _L$3: {
                    _L$4: {
                      const _bind$4 = _index.keywords;
                      if (_bind$4.$tag === 1) {
                        const _Some$2 = _bind$4;
                        const _keywords = _Some$2._0;
                        if (moonbitlang$core$array$$Array$contains$9$(_keywords, "mooncakes-test")) {
                        } else {
                          if (moonbitlang$core$hashset$$T$contains$9$(blacklist, _index.path)) {
                          } else {
                            break _L$4;
                          }
                        }
                      } else {
                        if (moonbitlang$core$hashset$$T$contains$9$(blacklist, _index.path)) {
                        } else {
                          break _L$4;
                        }
                      }
                      break _L$3;
                    }
                    moonbitlang$core$array$$Array$push$24$(indices, _index);
                  }
                } else {
                  const _Err = _bind$3;
                  const _msg = _Err._0;
                  return new Result$Err$44$(_msg);
                }
                _tmp = _i + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            moonbitlang$core$array$$Array$sort_by$24$(indices, (a, b) => moonbitlang$core$builtin$$Compare$compare$9$(a.name, b.name));
            const all_modules = moonbitlang$core$builtin$$Map$from_array$292$([]);
            const _len$2 = indices.length;
            let _tmp$2 = 0;
            while (true) {
              const _i = _tmp$2;
              if (_i < _len$2) {
                const index = indices[_i];
                const _tmp$3 = index.name;
                $bound_check(_tmp$3, 0);
                const c = _tmp$3.charCodeAt(0);
                const first_letter = c >= 97 && c <= 122 ? moonbitlang$core$option$$Option$unwrap$10$(moonbitlang$core$int$$Int$to_char((c - 97 | 0) + 65 | 0)) : c;
                const _bind$3 = moonbitlang$core$builtin$$Map$get$292$(all_modules, first_letter);
                if (_bind$3.$tag === 0) {
                  moonbitlang$core$builtin$$Map$op_set$292$(all_modules, first_letter, [index]);
                } else {
                  const _Some$2 = _bind$3;
                  const _indices = _Some$2._0;
                  moonbitlang$core$array$$Array$push$24$(_indices, index);
                }
                _tmp$2 = _i + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            moonbitlang$core$array$$Array$sort_by$24$(indices, (_param2, _param3) => {
              const _x$4 = _param2.created_at;
              if (_x$4 === undefined) {
                const _x$5 = _param3.created_at;
                if (_x$5 === undefined) {
                  const _n1 = _param2.name;
                  const _n2 = _param3.name;
                  return -moonbitlang$core$builtin$$Compare$compare$9$(_n1, _n2);
                } else {
                  return 1;
                }
              } else {
                const _Some$2 = _x$4;
                const _v1 = _Some$2;
                const _n1 = _param2.name;
                const _x$5 = _param3.created_at;
                if (_x$5 === undefined) {
                  return -1;
                } else {
                  const _Some$3 = _x$5;
                  const _v2 = _Some$3;
                  const _n2 = _param3.name;
                  const _bind$3 = moonbitlang$mooncakes$page$home$$compare_date(_v1, _v2);
                  if (_bind$3 === 0) {
                    return -moonbitlang$core$builtin$$Compare$compare$9$(_n1, _n2);
                  } else {
                    return _bind$3;
                  }
                }
              }
            });
            const _bind$3 = moonbitlang$core$array$$Array$iter$24$(indices);
            const recently_updated = moonbitlang$core$builtin$$Iter$collect$24$((_p) => {
              const _i = { val: 0 };
              return _bind$3((_p$2) => {
                if (_i.val < 12 && _p(_p$2) === 1) {
                  _i.val = _i.val + 1 | 0;
                  return 1;
                } else {
                  return 0;
                }
              }) === 1 || _i.val === 12 ? 1 : 0;
            });
            return new Result$Ok$44$({ recently_updated: recently_updated, all_modules: all_modules });
          } else {
            break _L;
          }
        }
      } else {
        break _L;
      }
    }
    return $panic();
  } else {
    return $panic();
  }
}
function moonbitlang$mooncakes$page$home$$load() {
  return { _0: Yoorkin$rabbit$45$tea$http$$get$378$("https://mooncakes.me-56d.workers.dev/?url=https://mooncakes.io/assets/modules.json", new $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$87$((_hole105) => new $64$moonbitlang$47$mooncakes$47$page$47$home$46$Msg$GotModuleIndices(_hole105), moonbitlang$mooncakes$page$home$$decode_module_indices)), _1: { indices: $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$88$, filter: "", filtered_modules: [] } };
}
function moonbitlang$mooncakes$page$home$$filter_indices(filter, indices) {
  const _bind = moonbitlang$core$builtin$$Map$values$292$(indices.all_modules);
  return moonbitlang$core$builtin$$Iter$collect$24$((_p) => {
    const _p$2 = (_p$3) => {
      const is_matched = (s1) => {
        const _tmp = moonbitlang$core$string$$String$to_upper(s1);
        const _bind$2 = moonbitlang$core$string$$String$to_upper(filter);
        return moonbitlang$core$string$$String$contains(_tmp, { str: _bind$2, start: 0, end: _bind$2.length });
      };
      if (is_matched(_p$3.path) || (moonbitlang$core$option$$Option$map_or$63$(_p$3.keywords, false, (keywords) => moonbitlang$core$builtin$$Iter$any$9$(moonbitlang$core$array$$Array$iter$9$(keywords), is_matched)) || moonbitlang$core$option$$Option$map_or$64$(_p$3.description, false, is_matched))) {
        return _p(_p$3);
      } else {
        return 1;
      }
    };
    return _bind((_p$3) => {
      const _func = moonbitlang$core$array$$Array$iter$24$(_p$3);
      return _func(_p$2);
    });
  });
}
function moonbitlang$mooncakes$page$home$$update(msg, model) {
  if (msg.$tag === 0) {
    const _GotModuleIndices = msg;
    const _result = _GotModuleIndices._0;
    const _tmp = Yoorkin$rabbit$45$tea$cmd$$none$363$();
    let _tmp$2;
    if (_result.$tag === 1) {
      const _Ok = _result;
      const _modules = _Ok._0;
      _tmp$2 = { indices: new $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$88$(_modules), filter: model.filter, filtered_modules: model.filtered_modules };
    } else {
      _tmp$2 = { indices: $64$moonbitlang$47$mooncakes$47$util$46$Status$Failed$88$, filter: model.filter, filtered_modules: model.filtered_modules };
    }
    return { _0: _tmp, _1: _tmp$2 };
  } else {
    const _FilterChanged = msg;
    const _filter = _FilterChanged._0;
    const _bind = model.indices;
    let filtered_modules;
    if (_bind.$tag === 2) {
      const _Success = _bind;
      const _indices = _Success._0;
      filtered_modules = moonbitlang$mooncakes$page$home$$filter_indices(_filter, _indices);
    } else {
      filtered_modules = [];
    }
    return { _0: Yoorkin$rabbit$45$tea$cmd$$none$363$(), _1: { indices: model.indices, filter: _filter, filtered_modules: filtered_modules } };
  }
}
function moonbitlang$mooncakes$page$home$$banner$46$button$124$88(value, target, color) {
  return Yoorkin$rabbit$45$tea$html$$a$363$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$363$(), undefined, `py-2 px-6 select-none text-md rounded-full hover:opacity-80 transition-all ${moonbitlang$core$builtin$$Show$to_string$9$(color)}`, target, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$363$(), [Yoorkin$rabbit$45$tea$html$$text$363$(value)], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$363$());
}
function moonbitlang$mooncakes$page$home$$banner() {
  return Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "container lg:w-3/5 flex flex-col-reverse lg:flex-row items-center justify-between", undefined, [Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "text-center lg:text-left mx-4 bg-bottom rounded-xl flex-col", undefined, [Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "text-slate-700", undefined, [Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "font-semibold text-4xl lg:text-5xl", [Yoorkin$rabbit$45$tea$html$$text$363$("The Package Registry")]), Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "font-semibold text-4xl lg:text-5xl mt-2", [Yoorkin$rabbit$45$tea$html$$text$363$("for"), Yoorkin$rabbit$45$tea$html$$span$363$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$363$(), undefined, "text-moonbit font-extrabold", [Yoorkin$rabbit$45$tea$html$$text$363$(" MoonBit ")]), Yoorkin$rabbit$45$tea$html$$text$363$("Community")]), Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "font-semibold text-4xl lg:text-5xl mt-2", [Yoorkin$rabbit$45$tea$html$$text$363$("with"), Yoorkin$rabbit$45$tea$html$$span$363$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$363$(), undefined, "text-moonbit font-extrabold", [Yoorkin$rabbit$45$tea$html$$text$363$(" Mooncakes.io ")])]), Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "font-semibold text-4xl lg:text-5xl mt-2", [Yoorkin$rabbit$45$tea$html$$text$363$("LLM Filter (Community Edition)")]), Yoorkin$rabbit$45$tea$html$$h2$363$(Yoorkin$rabbit$45$tea$html$$h2$46$style$46$default$363$(), undefined, "text-lg lg:text-2xl mt-4 text-zinc-500 flex gap-1", [Yoorkin$rabbit$45$tea$html$$text$363$("Browse, search and share package and documentation")])]), Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "flex mt-4 gap-4 justify-center lg:justify-start", undefined, [moonbitlang$mooncakes$page$home$$banner$46$button$124$88("Getting Started", "https://docs.moonbitlang.com/en/latest/toolchain/moon/package-manage-tour.html", "bg-yellow-600 text-white"), moonbitlang$mooncakes$page$home$$banner$46$button$124$88("Install Moon", "https://www.moonbitlang.com/download/", "bg-gray-200 text-gray-800")])]), Yoorkin$rabbit$45$tea$html$$img$363$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$363$(), undefined, "w-[340px] h-[340px]", "mooncake-pic.png", undefined, undefined, undefined, undefined, undefined, [])]);
}
function moonbitlang$mooncakes$page$home$$simple_module_card(mod) {
  return Yoorkin$rabbit$45$tea$html$$a$363$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$363$(), undefined, "select-none p-4 h-50 flex bg-white outline outline-transparent flex-col border-gray-200 border-b lg:hover:outline-mooncake2 lg:hover:border-transparent lg:hover:shadow-md lg:border lg:rounded-md lg:min-h-28 lg:overflow-ellipsis transition-all", `/docs/${moonbitlang$core$builtin$$Show$to_string$9$(mod.path)}`, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$363$(), [Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "flex flex-row text-lg font-semibold", undefined, [Yoorkin$rabbit$45$tea$html$$span$363$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$363$(), undefined, "text-gray-500", [Yoorkin$rabbit$45$tea$html$$text$363$(mod.author)]), Yoorkin$rabbit$45$tea$html$$span$363$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$363$(), undefined, "px-1 text-gray-300", [Yoorkin$rabbit$45$tea$html$$text$363$("/")]), Yoorkin$rabbit$45$tea$html$$span$363$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$363$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$363$(mod.name)])]), Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "pt-2 text-gray-500 flex-grow flex flex-col justify-between gap-2", undefined, [Yoorkin$rabbit$45$tea$html$$p$363$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$363$(), undefined, "text-sm", [Yoorkin$rabbit$45$tea$html$$text$363$(moonbitlang$core$option$$Option$or$9$(mod.description, ""))]), Yoorkin$rabbit$45$tea$html$$p$363$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$363$(), undefined, "text-[0.8rem] w-full text-right", [Yoorkin$rabbit$45$tea$html$$text$363$(moonbitlang$core$option$$Option$or$9$(moonbitlang$core$option$$Option$map$11$(mod.created_at, moonbitlang$mooncakes$page$home$$get_relative_time), ""))])])], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$363$());
}
function moonbitlang$mooncakes$page$home$$all_modules(modules) {
  const _self = moonbitlang$core$builtin$$Iter2$to_array$292$(moonbitlang$core$builtin$$Map$iter2$292$(modules));
  moonbitlang$core$array$$Array$sort_by$40$(_self, (a, b) => a._0 - b._0 | 0);
  const _p = _self;
  const _p$2 = new Array(_p.length);
  const _p$3 = _p.length;
  let _tmp = 0;
  while (true) {
    const _p$4 = _tmp;
    if (_p$4 < _p$3) {
      const _p$5 = _p[_p$4];
      const x = _p$5;
      const _key = x._0;
      const _value = x._1;
      const _p$6 = new Array(_value.length);
      const _p$7 = _value.length;
      let _tmp$2 = 0;
      while (true) {
        const _p$8 = _tmp$2;
        if (_p$8 < _p$7) {
          const _p$9 = _value[_p$8];
          _p$6[_p$8] = moonbitlang$mooncakes$page$home$$simple_module_card(_p$9);
          _tmp$2 = _p$8 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const modules$2 = _p$6;
      _p$2[_p$4] = Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "pt-2", undefined, [Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "container lg:w-2/3 px-4", undefined, [Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "border-b p-4 text-sm font-bold text-gray-400 lg:border-0", [Yoorkin$rabbit$45$tea$html$$text$363$(moonbitlang$core$builtin$$Show$to_string$10$(_key))]), Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-4", undefined, modules$2)])]);
      _tmp = _p$4 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const all_modules = _p$2;
  return Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "pt-10", undefined, [Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "container lg:w-2/3 px-4", undefined, [Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "border-b p-4 text-sm font-bold text-gray-400 lg:border-0", [Yoorkin$rabbit$45$tea$html$$text$363$("ALL MODULES")])]), Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, undefined, undefined, all_modules)]);
}
function moonbitlang$mooncakes$page$home$$navbar() {
  return Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "w-full flex justify-center", undefined, [Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "min-h-14 w-4/5 flex flex-col sm:flex-row justify-between items-center", undefined, [Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "font-title select-none p-4", undefined, [Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "whitespace-nowrap text-gray-700 font-semibold", [Yoorkin$rabbit$45$tea$html$$text$363$("🥮 mooncakes.io (Community Edition)")])]), Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "justify-center my-2 w-full max-w-72 shadow-sm", undefined, [Yoorkin$rabbit$45$tea$html$$input$363$(18, undefined, undefined, -1, -1, -1, undefined, "Search modules ...", undefined, Yoorkin$rabbit$45$tea$html$$input$46$style$46$default$363$(), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, "border rounded-full px-4 w-full py-2 bg-zinc-50 focus:border-mooncake2 outline-none transition-colors", Yoorkin$rabbit$45$tea$html$$input$46$childrens$46$default$363$(), undefined, (_hole4) => new $64$moonbitlang$47$mooncakes$47$page$47$home$46$Msg$FilterChanged(_hole4))]), Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "text-gray-700 font-semibold invisible", undefined, [Yoorkin$rabbit$45$tea$html$$a$363$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$363$(), undefined, undefined, "", Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$363$(), [Yoorkin$rabbit$45$tea$html$$text$363$("Browse All Module")], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$363$())])])]);
}
function moonbitlang$mooncakes$page$home$$recently_updated(recently) {
  const _p = new Array(recently.length);
  const _p$2 = recently.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = recently[_p$3];
      _p[_p$3] = moonbitlang$mooncakes$page$home$$simple_module_card(_p$4);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const recently_updated = _p;
  return Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, undefined, undefined, [Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "container lg:w-2/3 px-4", undefined, [Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "border-b p-4 text-sm font-bold text-gray-400 lg:border-0", [Yoorkin$rabbit$45$tea$html$$text$363$("RECENTLY UPDATED")]), Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-4", undefined, recently_updated)])]);
}
function moonbitlang$mooncakes$page$home$$module_card(mod) {
  const _bind = mod.keywords;
  let keywords;
  if (_bind.$tag === 0) {
    keywords = Yoorkin$rabbit$45$tea$html$$nothing$363$();
  } else {
    const _Some = _bind;
    const _keywords = _Some._0;
    const _tmp = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$();
    const _p = new Array(_keywords.length);
    const _p$2 = _keywords.length;
    let _tmp$2 = 0;
    while (true) {
      const _p$3 = _tmp$2;
      if (_p$3 < _p$2) {
        const _p$4 = _keywords[_p$3];
        const keyword = _p$4;
        _p[_p$3] = Yoorkin$rabbit$45$tea$html$$span$363$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$363$(), undefined, "text-sm/4 h-5 bg-gray-50 text-gray-600 px-2 my-2 border-gray-200  border rounded", [Yoorkin$rabbit$45$tea$html$$text$363$(keyword)]);
        _tmp$2 = _p$3 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    keywords = Yoorkin$rabbit$45$tea$html$$div$363$(_tmp, undefined, "flex gap-2 h-8 flex-wrap overflow-y-hidden shrink-0", undefined, _p);
  }
  const _bind$2 = mod.description;
  let description;
  if (_bind$2 === undefined) {
    description = Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "flex-grow", undefined, []);
  } else {
    const _Some = _bind$2;
    const _description = _Some;
    description = Yoorkin$rabbit$45$tea$html$$p$363$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$363$(), undefined, "text-gray-700 py-3 overflow-ellipsis grow text-sm", [Yoorkin$rabbit$45$tea$html$$text$363$(_description)]);
  }
  const _bind$3 = mod.created_at;
  let time;
  if (_bind$3 === undefined) {
    time = Yoorkin$rabbit$45$tea$html$$nothing$363$();
  } else {
    const _Some = _bind$3;
    const _t = _Some;
    time = Yoorkin$rabbit$45$tea$html$$p$363$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$363$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$363$(moonbitlang$mooncakes$page$home$$get_relative_time(_t))]);
  }
  return Yoorkin$rabbit$45$tea$html$$a$363$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$363$(), undefined, "select-none p-4 min-h-32 flex flex-col border-t bg-white hover:bg-gray-100 transition-all", `/docs/${moonbitlang$core$builtin$$Show$to_string$9$(mod.path)}`, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$363$(), [Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "flex flex-row text-lg font-semibold", undefined, [Yoorkin$rabbit$45$tea$html$$h2$363$(Yoorkin$rabbit$45$tea$html$$h2$46$style$46$default$363$(), undefined, "text-gray-500", [Yoorkin$rabbit$45$tea$html$$text$363$(mod.author)]), Yoorkin$rabbit$45$tea$html$$h2$363$(Yoorkin$rabbit$45$tea$html$$h2$46$style$46$default$363$(), undefined, "px-1 text-gray-300", [Yoorkin$rabbit$45$tea$html$$text$363$("/")]), Yoorkin$rabbit$45$tea$html$$h2$363$(Yoorkin$rabbit$45$tea$html$$h2$46$style$46$default$363$(), undefined, "", [Yoorkin$rabbit$45$tea$html$$text$363$(mod.name)])]), description, Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "flex justify-between items-center text-gray-600 text-sm", undefined, [keywords, time])], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$363$());
}
function moonbitlang$mooncakes$page$home$$search_result(mods) {
  const _p = new Array(mods.length);
  const _p$2 = mods.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = mods[_p$3];
      _p[_p$3] = moonbitlang$mooncakes$page$home$$module_card(_p$4);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const module_cards = _p;
  return Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, undefined, undefined, [Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "container lg:w-3/5 px-4", undefined, [Yoorkin$rabbit$45$tea$html$$h1$363$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$363$(), undefined, "p-4 text-sm font-bold text-gray-400 lg:border-0", [Yoorkin$rabbit$45$tea$html$$text$363$("SEARCH RESULT")]), Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "grid grid-cols-1", undefined, module_cards)])]);
}
function moonbitlang$mooncakes$page$home$$view(model) {
  const _bind = model.indices;
  let module_list;
  switch (_bind.$tag) {
    case 0: {
      module_list = moonbitlang$mooncakes$view$$loading$363$();
      break;
    }
    case 1: {
      module_list = moonbitlang$mooncakes$view$$load_failed$363$("module indices");
      break;
    }
    default: {
      const _Success = _bind;
      const _indices = _Success._0;
      module_list = model.filter === "" ? Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, undefined, undefined, [moonbitlang$mooncakes$page$home$$recently_updated(_indices.recently_updated), moonbitlang$mooncakes$page$home$$all_modules(_indices.all_modules)]) : moonbitlang$mooncakes$page$home$$search_result(model.filtered_modules);
    }
  }
  const banner = model.filter === "" ? moonbitlang$mooncakes$page$home$$banner() : Yoorkin$rabbit$45$tea$html$$nothing$363$();
  return Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "flex flex-col min-h-screen", undefined, [moonbitlang$mooncakes$page$home$$navbar(), banner, Yoorkin$rabbit$45$tea$html$$hr$363$(Yoorkin$rabbit$45$tea$html$$hr$46$style$46$default$363$(), undefined, "m-4 border-gray-200", Yoorkin$rabbit$45$tea$html$$hr$46$childrens$46$default$363$()), module_list, Yoorkin$rabbit$45$tea$html$$div$363$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$363$(), undefined, "mt-auto", undefined, [moonbitlang$mooncakes$view$$footer$363$()])]);
}
function Yoorkin$rabbit$45$tea$dialog$$show$362$(id, modal) {
  return (_discard_) => {
    const dialog = moonbitlang$core$option$$Option$unwrap$267$(rami3l$js$45$ffi$js$$Nullable$to_option$267$(Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_dialog_element(moonbitlang$core$option$$Option$unwrap$268$(rami3l$js$45$ffi$js$$Nullable$to_option$268$(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(moonbitlang$core$option$$Option$unwrap$266$(rami3l$js$45$ffi$js$$Nullable$to_option$266$(Yoorkin$rabbit$45$tea$dom$$Document$get_element_by_id(Yoorkin$rabbit$45$tea$dom$$document(), id)))))))));
    if (modal) {
      Yoorkin$rabbit$45$tea$dom$$HTMLDialogElement$show_modal(dialog);
      return;
    } else {
      Yoorkin$rabbit$45$tea$dom$$HTMLDialogElement$show(dialog);
      return;
    }
  };
}
function Yoorkin$rabbit$45$tea$dialog$$show$46$modal$46$default$362$() {
  return true;
}
function Yoorkin$rabbit$45$tea$dialog$$close$362$(id, return_value) {
  return (_discard_) => {
    const dialog = moonbitlang$core$option$$Option$unwrap$267$(rami3l$js$45$ffi$js$$Nullable$to_option$267$(Yoorkin$rabbit$45$tea$dom$$HTMLElement$to_html_dialog_element(moonbitlang$core$option$$Option$unwrap$268$(rami3l$js$45$ffi$js$$Nullable$to_option$268$(Yoorkin$rabbit$45$tea$dom$$Element$to_html_element(moonbitlang$core$option$$Option$unwrap$266$(rami3l$js$45$ffi$js$$Nullable$to_option$266$(Yoorkin$rabbit$45$tea$dom$$Document$get_element_by_id(Yoorkin$rabbit$45$tea$dom$$document(), id)))))))));
    Yoorkin$rabbit$45$tea$dom$$HTMLDialogElement$close(dialog, rami3l$js$45$ffi$js$$Optional$from_option$9$(return_value));
  };
}
function moonbitlang$mooncakes$view$tree$$Tree$get_name$22$(self) {
  if (self.$tag === 0) {
    const _Item = self;
    const _name = _Item._1;
    return _name;
  } else {
    const _Node = self;
    const _name = _Node._1;
    return _name;
  }
}
function moonbitlang$mooncakes$view$tree$$view$381$(toggle, click, state, indicator, items) {
  const aux = (_param1) => {
    if (_param1.$tag === 0) {
      const _Item = _param1;
      const _id = _Item._0;
      const _str = _Item._1;
      const indicator$2 = moonbitlang$core$builtin$$Eq$op_equal$22$(indicator, _id) ? Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "bg-yellow-500 w-[0.2em] h-5 rounded mr-2", undefined, []) : Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "w-1 h-5 mr-2", undefined, []);
      return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "hover:bg-gray-100 px-2 py-1 rounded text-sm flex", click(_id), [indicator$2, Yoorkin$rabbit$45$tea$html$$text$362$(_str)]);
    } else {
      const _Node = _param1;
      const _id = _Node._0;
      const _str = _Node._1;
      const _children = _Node._2;
      const expanded = `${moonbitlang$mooncakes$view$tree$$view$46$collapsed$124$15} rotate-90 `;
      let body_style;
      let icon;
      _L: {
        if (moonbitlang$core$immut$sorted_set$$T$contains$22$(state, _id)) {
          body_style = "max-h-[9999px]";
          icon = expanded;
          break _L;
        } else {
          body_style = "max-h-0";
          icon = moonbitlang$mooncakes$view$tree$$view$46$collapsed$124$15;
          break _L;
        }
      }
      const _tmp = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$();
      const _tmp$2 = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "relative transition hover:bg-gray-100 px-2 py-1 rounded text-sm flex", toggle(_id), [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, `absolute w-0 h-0 self-center mr-1 transition-transform ${moonbitlang$core$builtin$$Show$to_string$9$(icon)}`, undefined, []), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "pl-3", undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(_str)])]);
      const _tmp$3 = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$();
      const _tmp$4 = `pl-2 overflow-hidden duration-400 transition-[max-height] ${moonbitlang$core$builtin$$Show$to_string$9$(body_style)}`;
      const _tmp$5 = Yoorkin$rabbit$45$tea$html$$ul$46$style$46$default$362$();
      const _p = new Array(_children.length);
      const _p$2 = _children.length;
      let _tmp$6 = 0;
      while (true) {
        const _p$3 = _tmp$6;
        if (_p$3 < _p$2) {
          const _p$4 = _children[_p$3];
          _p[_p$3] = aux(_p$4);
          _tmp$6 = _p$3 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return Yoorkin$rabbit$45$tea$html$$div$362$(_tmp, undefined, undefined, undefined, [_tmp$2, Yoorkin$rabbit$45$tea$html$$div$362$(_tmp$3, undefined, _tmp$4, undefined, [Yoorkin$rabbit$45$tea$html$$ul$362$(_tmp$5, undefined, undefined, undefined, _p)])]);
    }
  };
  const _tmp = Yoorkin$rabbit$45$tea$html$$ul$46$style$46$default$362$();
  const _p = new Array(items.length);
  const _p$2 = items.length;
  let _tmp$2 = 0;
  while (true) {
    const _p$3 = _tmp$2;
    if (_p$3 < _p$2) {
      const _p$4 = items[_p$3];
      _p[_p$3] = aux(_p$4);
      _tmp$2 = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return Yoorkin$rabbit$45$tea$html$$ul$362$(_tmp, undefined, "select-none", undefined, _p);
}
function illusory0x0$fuzzy_match$$StringLike$length$9$(self) {
  const _arg = moonbitlang$core$string$$String$char_length$46$start_offset$46$default();
  const _arg$2 = moonbitlang$core$string$$String$char_length$46$end_offset$46$default(self);
  return moonbitlang$core$string$$String$char_length(self, _arg, _arg$2);
}
function illusory0x0$fuzzy_match$$StringLike$op_get$9$(self, index) {
  return moonbitlang$core$string$$String$char_at(self, index);
}
function illusory0x0$fuzzy_match$$StringLike$is_empty$74$(self) {
  return illusory0x0$fuzzy_match$$StringLike$length$9$(self) === 0;
}
function illusory0x0$fuzzy_match$$StringLike$view$9$(self, start, end) {
  return moonbitlang$core$string$$String$view(self, start, end);
}
function illusory0x0$fuzzy_match$$CharClass$from_char(ch) {
  return ch >= 65 && ch <= 65 ? 0 : ch >= 97 && ch <= 122 ? 1 : ch >= 48 && ch <= 57 ? 2 : 3;
}
function illusory0x0$fuzzy_match$$lowercase(ch) {
  return ch >= 65 && ch <= 90 ? ch + 32 | 0 : ch;
}
function illusory0x0$fuzzy_match$$equal_ignore_case(ch1, ch2) {
  return illusory0x0$fuzzy_match$$lowercase(ch1) === illusory0x0$fuzzy_match$$lowercase(ch2);
}
function illusory0x0$fuzzy_match$$max(a, b) {
  return a > b ? a : b;
}
function illusory0x0$fuzzy_match$$find_start_end_indices$11$(query, item) {
  let item_idx = 0;
  let query_idx = 0;
  while (true) {
    if (item_idx < illusory0x0$fuzzy_match$$StringLike$length$9$(item) && query_idx < illusory0x0$fuzzy_match$$StringLike$length$9$(query)) {
      if (illusory0x0$fuzzy_match$$equal_ignore_case(illusory0x0$fuzzy_match$$StringLike$op_get$9$(item, item_idx), illusory0x0$fuzzy_match$$StringLike$op_get$9$(query, query_idx))) {
        query_idx = query_idx + 1 | 0;
      }
      item_idx = item_idx + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (query_idx < illusory0x0$fuzzy_match$$StringLike$length$9$(query)) {
    illusory0x0$fuzzy_match$$the_one_and_only.found = false;
  } else {
    const end_idx = item_idx;
    let item_idx$2 = end_idx - 1 | 0;
    let query_idx$2 = illusory0x0$fuzzy_match$$StringLike$length$9$(query) - 1 | 0;
    while (true) {
      if (query_idx$2 >= 0) {
        if (illusory0x0$fuzzy_match$$equal_ignore_case(illusory0x0$fuzzy_match$$StringLike$op_get$9$(item, item_idx$2), illusory0x0$fuzzy_match$$StringLike$op_get$9$(query, query_idx$2))) {
          query_idx$2 = query_idx$2 - 1 | 0;
        }
        item_idx$2 = item_idx$2 - 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const start_idx = item_idx$2 + 1 | 0;
    illusory0x0$fuzzy_match$$the_one_and_only.found = true;
    illusory0x0$fuzzy_match$$the_one_and_only.start_idx = start_idx;
    illusory0x0$fuzzy_match$$the_one_and_only.end_idx = end_idx;
  }
  return illusory0x0$fuzzy_match$$the_one_and_only;
}
function illusory0x0$fuzzy_match$$fold_matching_indices_single_query$382$(query, item, init, f) {
  const _bind = illusory0x0$fuzzy_match$$find_start_end_indices$11$(query, item);
  const _start_idx = _bind.start_idx;
  const _end_idx = _bind.end_idx;
  const _found = _bind.found;
  let acc = init;
  if (_found) {
    let query_idx = 0;
    let _tmp = _start_idx;
    while (true) {
      const item_idx = _tmp;
      if (item_idx < _end_idx) {
        if (illusory0x0$fuzzy_match$$equal_ignore_case(illusory0x0$fuzzy_match$$StringLike$op_get$9$(item, item_idx), illusory0x0$fuzzy_match$$StringLike$op_get$9$(query, query_idx))) {
          acc = f(acc, item_idx);
          query_idx = query_idx + 1 | 0;
        }
        _tmp = item_idx + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  }
  return acc;
}
function illusory0x0$fuzzy_match$$score_single_query$11$(query, item, case_sensitive) {
  const _bind = illusory0x0$fuzzy_match$$find_start_end_indices$11$(query, item);
  const _found = _bind.found;
  const _start_idx = _bind.start_idx;
  const _end_idx = _bind.end_idx;
  if (!_found) {
    return 0;
  } else {
    const start_char_class = _start_idx === 0 ? 3 : illusory0x0$fuzzy_match$$CharClass$from_char(illusory0x0$fuzzy_match$$StringLike$op_get$9$(item, _start_idx - 1 | 0));
    let query_idx = 0;
    let score = 0;
    let in_gap = false;
    let prev_char_class = start_char_class;
    let prev_char_score = 0;
    let _tmp = _start_idx;
    while (true) {
      const item_idx = _tmp;
      if (item_idx < _end_idx) {
        const item_char = illusory0x0$fuzzy_match$$StringLike$op_get$9$(item, item_idx);
        const query_char = illusory0x0$fuzzy_match$$StringLike$op_get$9$(query, query_idx);
        if (illusory0x0$fuzzy_match$$equal_ignore_case(item_char, query_char)) {
          const char_class = illusory0x0$fuzzy_match$$CharClass$from_char(item_char);
          let base_score;
          _L: {
            _L$2: {
              _L$3: {
                _L$4: {
                  _L$5: {
                    _L$6: {
                      _L$7: {
                        const _bind$2 = prev_char_class;
                        switch (_bind$2) {
                          case 3: {
                            switch (char_class) {
                              case 0: {
                                break _L$7;
                              }
                              case 1: {
                                break _L$7;
                              }
                              case 2: {
                                break _L$7;
                              }
                              default: {
                                break _L$4;
                              }
                            }
                          }
                          case 1: {
                            switch (char_class) {
                              case 0: {
                                break _L$6;
                              }
                              case 2: {
                                break _L$6;
                              }
                              case 3: {
                                break _L$4;
                              }
                              default: {
                                break _L$2;
                              }
                            }
                          }
                          default: {
                            switch (char_class) {
                              case 2: {
                                break _L$6;
                              }
                              case 3: {
                                break _L$4;
                              }
                              default: {
                                break _L$2;
                              }
                            }
                          }
                        }
                      }
                      base_score = 480;
                      break _L$5;
                    }
                    base_score = 360;
                  }
                  break _L$3;
                }
                base_score = 480;
              }
              break _L;
            }
            base_score = 320;
          }
          const with_start_of_item_bonus = item_idx === 0 ? base_score + 1 | 0 : base_score;
          const with_consecutive_bonus = in_gap ? with_start_of_item_bonus : illusory0x0$fuzzy_match$$max(with_start_of_item_bonus, prev_char_score);
          const with_wrong_case_penalty = item_char === query_char || !case_sensitive ? with_consecutive_bonus : with_consecutive_bonus - 120 | 0;
          const this_char_score = query_idx === 0 ? Math.imul(2, with_wrong_case_penalty) | 0 : with_wrong_case_penalty;
          query_idx = query_idx + 1 | 0;
          score = score + this_char_score | 0;
          prev_char_class = char_class;
          prev_char_score = this_char_score;
          in_gap = false;
        } else {
          const this_char_score = !in_gap ? -20 : -60;
          score = score + this_char_score | 0;
          in_gap = true;
        }
        _tmp = item_idx + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return score;
  }
}
function illusory0x0$fuzzy_match$$Query$new(query) {
  const queries = moonbitlang$core$builtin$$Iter$collect$9$(moonbitlang$core$builtin$$Iter$filter_map$334$(moonbitlang$core$string$$String$split(query, { str: illusory0x0$fuzzy_match$$new$46$42$bind$124$264, start: 0, end: illusory0x0$fuzzy_match$$new$46$42$bind$124$264.length }), (s) => !moonbitlang$core$string$$StringView$is_empty(s) ? moonbitlang$core$builtin$$Show$to_string$16$(s) : undefined));
  const case_sensitive = moonbitlang$core$builtin$$Iter$any$10$(moonbitlang$core$string$$String$iter(query), moonbitlang$core$char$$Char$is_ascii_uppercase);
  return { queries: queries, raw: query, case_sensitive: case_sensitive };
}
function illusory0x0$fuzzy_match$$score_upper_bound(query_length) {
  return (Math.imul(962, query_length) | 0) + 1 | 0;
}
function illusory0x0$fuzzy_match$$Query$is_empty(self) {
  return moonbitlang$core$string$$String$is_empty(self.raw);
}
function illusory0x0$fuzzy_match$$Query$score$9$(self, item) {
  const _bind = illusory0x0$fuzzy_match$$StringLike$is_empty$74$(item);
  const _bind$2 = illusory0x0$fuzzy_match$$Query$is_empty(self);
  if (_bind === true) {
    return 0;
  } else {
    if (_bind$2 === true) {
      return 1;
    } else {
      const _queries = self.queries;
      const _raw = self.raw;
      const _case_sensitive = self.case_sensitive;
      let raw_score = 0;
      let any_mismatch = false;
      const _len = _queries.length;
      let _tmp = 0;
      while (true) {
        const _i = _tmp;
        if (_i < _len) {
          const query = _queries[_i];
          const score = illusory0x0$fuzzy_match$$score_single_query$11$(query, item, _case_sensitive);
          if (score === 0) {
            any_mismatch = true;
          }
          raw_score = raw_score + score | 0;
          _tmp = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return raw_score === 0 || any_mismatch ? 0 : illusory0x0$fuzzy_match$$score_upper_bound(_raw.length) - raw_score | 0;
    }
  }
}
function illusory0x0$fuzzy_match$$Query$matching_indices$9$(self, item) {
  if (illusory0x0$fuzzy_match$$Query$is_empty(self)) {
    return new Option$Some$89$([]);
  } else {
    const _p = self.queries;
    const _p$2 = moonbitlang$core$set$$Set$new$7$(moonbitlang$core$set$$Set$new$46$capacity$46$default$7$());
    let indices;
    let _tmp = 0;
    let _tmp$2 = _p$2;
    while (true) {
      const _p$3 = _tmp;
      const _p$4 = _tmp$2;
      if (_p$3 < _p.length) {
        const _tmp$3 = _p$3 + 1 | 0;
        const set = _p$4;
        const query = moonbitlang$core$array$$Array$op_get$9$(_p, _p$3);
        const _tmp$4 = illusory0x0$fuzzy_match$$fold_matching_indices_single_query$382$(query, item, set, (set$2, query$2) => {
          moonbitlang$core$set$$Set$add$7$(set$2, query$2);
          return set$2;
        });
        _tmp = _tmp$3;
        _tmp$2 = _tmp$4;
        continue;
      } else {
        indices = _p$4;
        break;
      }
    }
    return moonbitlang$core$set$$Set$is_empty$7$(indices) ? Option$None$89$ : new Option$Some$89$(moonbitlang$core$set$$Set$to_array$7$(indices));
  }
}
function illusory0x0$fuzzy_match$$split_by_matching_sections$46$add_section$47$11688(_env, matching, start, end_inclusive) {
  const item = _env._1;
  const sections = _env._0;
  moonbitlang$core$deque$$T$push_back$283$(sections, { _0: matching, _1: illusory0x0$fuzzy_match$$StringLike$view$9$(item, start, end_inclusive + 1 | 0) });
}
function illusory0x0$fuzzy_match$$Query$split_by_matching_sections$9$(self, item) {
  const _bind = illusory0x0$fuzzy_match$$Query$matching_indices$9$(self, item);
  if (_bind.$tag === 0) {
    return Option$None$90$;
  } else {
    const _Some = _bind;
    const _x = _Some._0;
    if (_x.length === 0) {
      return new Option$Some$90$([{ _0: false, _1: illusory0x0$fuzzy_match$$StringLike$view$9$(item, 0, illusory0x0$fuzzy_match$$StringLike$length$9$(item)) }]);
    } else {
      const sections = moonbitlang$core$deque$$new$283$(moonbitlang$core$deque$$new$46$capacity$46$default$283$());
      const _env = { _0: sections, _1: item };
      const first = moonbitlang$core$array$$Array$op_get$7$(_x, 0);
      if (first > 0) {
        illusory0x0$fuzzy_match$$split_by_matching_sections$46$add_section$47$11688(_env, false, 0, first - 1 | 0);
      }
      const matching_range_start = { val: first };
      const matching_range_end = { val: first };
      const _p = _x.length;
      let _tmp = 0;
      while (true) {
        const _p$2 = _tmp;
        if (_p$2 < _p) {
          const _p$3 = _x[_p$2];
          const idx = _p$3;
          if (idx > (matching_range_end.val + 1 | 0)) {
            illusory0x0$fuzzy_match$$split_by_matching_sections$46$add_section$47$11688(_env, true, matching_range_start.val, matching_range_end.val);
            illusory0x0$fuzzy_match$$split_by_matching_sections$46$add_section$47$11688(_env, false, matching_range_end.val + 1 | 0, idx - 1 | 0);
            matching_range_start.val = idx;
          }
          matching_range_end.val = idx;
          _tmp = _p$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      illusory0x0$fuzzy_match$$split_by_matching_sections$46$add_section$47$11688(_env, true, matching_range_start.val, matching_range_end.val);
      if (matching_range_end.val < (illusory0x0$fuzzy_match$$StringLike$length$9$(item) - 1 | 0)) {
        illusory0x0$fuzzy_match$$split_by_matching_sections$46$add_section$47$11688(_env, false, matching_range_end.val + 1 | 0, illusory0x0$fuzzy_match$$StringLike$length$9$(item) - 1 | 0);
      }
      return new Option$Some$90$(moonbitlang$core$deque$$T$to_array$283$(sections));
    }
  }
}
function CAIMEOX$lazy$$Lazy$from_thunk$383$(f) {
  return { body: new $64$CAIMEOX$47$lazy$46$LazyPrim$Thunk$91$(f) };
}
function CAIMEOX$lazy$$Lazy$new$383$(f) {
  return CAIMEOX$lazy$$Lazy$from_thunk$383$(f);
}
function CAIMEOX$lazy$$Lazy$force$383$(self) {
  const _bind = self.body;
  if (_bind.$tag === 1) {
    const _Value = _bind;
    const _v = _Value._0;
    return _v;
  } else {
    const _Thunk = _bind;
    const _f = _Thunk._0;
    const v = _f();
    self.body = new $64$CAIMEOX$47$lazy$46$LazyPrim$Value$91$(v);
    return v;
  }
}
function Yoorkin$rabbit$45$tea$clipboard$$copy$46$42$cont$47$11715(_param) {}
function Yoorkin$rabbit$45$tea$clipboard$$copy$46$42$async_driver$47$11716(_state) {
  if (_state.$tag === 0) {
    const _$42$try$47$15 = _state;
    const _cont = _$42$try$47$15._3;
    const dispatcher = _$42$try$47$15._2;
    const failed = _$42$try$47$15._1;
    const _try_err = _$42$try$47$15._0;
    if (failed === undefined) {
      _cont(undefined);
      return;
    } else {
      const _Some = failed;
      const _to_msg = _Some;
      _cont(Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(dispatcher, _to_msg(moonbitlang$core$builtin$$Show$to_string$313$(_try_err))));
      return;
    }
  } else {
    const _State_1 = _state;
    const _cont = _State_1._3;
    const dispatcher = _State_1._2;
    const copied = _State_1._1;
    _State_1._0;
    if (copied === undefined) {
      _cont(undefined);
      return;
    } else {
      const _Some = copied;
      const _msg = _Some;
      _cont(Yoorkin$rabbit$45$tea$cmd$$Events$trigger_update$362$(dispatcher, _msg));
      return;
    }
  }
}
function Yoorkin$rabbit$45$tea$clipboard$$copy$362$(item, copied, failed) {
  return (dispatcher) => {
    const _Text = item;
    const _text = _Text._0;
    rami3l$js$45$ffi$js$$Promise$wait(Yoorkin$rabbit$45$tea$dom$$Clipboard$write_text(Yoorkin$rabbit$45$tea$dom$$Navigator$clipboard(Yoorkin$rabbit$45$tea$dom$$Window$navigator(Yoorkin$rabbit$45$tea$dom$$window())), _text), (_cont_param) => {
      Yoorkin$rabbit$45$tea$clipboard$$copy$46$42$async_driver$47$11716(new $36$Yoorkin$47$rabbit$45$tea$47$clipboard$46$copy$46$lambda$46$lambda$47$37$46$State$State_1$72$(_cont_param, copied, dispatcher, Yoorkin$rabbit$45$tea$clipboard$$copy$46$42$cont$47$11715));
    }, (_cont_param) => {
      Yoorkin$rabbit$45$tea$clipboard$$copy$46$42$async_driver$47$11716(new $36$Yoorkin$47$rabbit$45$tea$47$clipboard$46$copy$46$lambda$46$lambda$47$37$46$State$_try$47$15$72$(_cont_param, failed, dispatcher, Yoorkin$rabbit$45$tea$clipboard$$copy$46$42$cont$47$11715));
    });
  };
}
function moonbitlang$core$builtin$$Show$output$76$(_x_703, _x_704) {
  _x_704.method_0(_x_704.self, "{");
  _x_704.method_0(_x_704.self, "path: ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_704, _x_703.path);
  _x_704.method_0(_x_704.self, ", ");
  _x_704.method_0(_x_704.self, "name: ");
  moonbitlang$core$builtin$$Logger$write_object$9$(_x_704, _x_703.name);
  _x_704.method_0(_x_704.self, "}");
}
function moonbitlang$core$builtin$$Show$output$79$(_x_671, _x_672) {
  switch (_x_671.$tag) {
    case 0: {
      const _Constr = _x_671;
      const _$42$arg_673 = _Constr._0;
      const _$42$arg_674 = _Constr._1;
      _x_672.method_0(_x_672.self, "Constr(");
      _x_672.method_0(_x_672.self, "constr=");
      moonbitlang$core$builtin$$Logger$write_object$76$(_x_672, _$42$arg_673);
      _x_672.method_0(_x_672.self, ", ");
      _x_672.method_0(_x_672.self, "arguments=");
      moonbitlang$core$builtin$$Logger$write_object$77$(_x_672, _$42$arg_674);
      _x_672.method_0(_x_672.self, ")");
      return;
    }
    case 1: {
      const _Arrow = _x_671;
      const _$42$arg_675 = _Arrow._0;
      const _$42$arg_676 = _Arrow._1;
      const _$42$arg_677 = _Arrow._2;
      const _$42$arg_678 = _Arrow._3;
      _x_672.method_0(_x_672.self, "Arrow(");
      _x_672.method_0(_x_672.self, "parameters=");
      moonbitlang$core$builtin$$Logger$write_object$77$(_x_672, _$42$arg_675);
      _x_672.method_0(_x_672.self, ", ");
      _x_672.method_0(_x_672.self, "return_type=");
      moonbitlang$core$builtin$$Logger$write_object$79$(_x_672, _$42$arg_676);
      _x_672.method_0(_x_672.self, ", ");
      _x_672.method_0(_x_672.self, "error_type=");
      moonbitlang$core$builtin$$Logger$write_object$80$(_x_672, _$42$arg_677);
      _x_672.method_0(_x_672.self, ", ");
      _x_672.method_0(_x_672.self, "is_async=");
      moonbitlang$core$builtin$$Logger$write_object$82$(_x_672, _$42$arg_678);
      _x_672.method_0(_x_672.self, ")");
      return;
    }
    case 2: {
      const _Param = _x_671;
      const _$42$arg_679 = _Param._0;
      _x_672.method_0(_x_672.self, "Param(");
      _x_672.method_0(_x_672.self, "name=");
      moonbitlang$core$builtin$$Logger$write_object$9$(_x_672, _$42$arg_679);
      _x_672.method_0(_x_672.self, ")");
      return;
    }
    default: {
      const _TypePath = _x_671;
      const _$42$arg_680 = _TypePath._0;
      _x_672.method_0(_x_672.self, "TypePath(");
      moonbitlang$core$builtin$$Logger$write_object$76$(_x_672, _$42$arg_680);
      _x_672.method_0(_x_672.self, ")");
      return;
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$22$(_x_635, _x_636) {
  switch (_x_635.$tag) {
    case 0: {
      const _Package = _x_635;
      const _$42$x0_637 = _Package._0;
      if (_x_636.$tag === 0) {
        const _Package$2 = _x_636;
        const _$42$y0_638 = _Package$2._0;
        return moonbitlang$core$builtin$$Compare$compare$9$(_$42$x0_637, _$42$y0_638);
      } else {
        return -1;
      }
    }
    case 1: {
      const _Symbol = _x_635;
      const _$42$x0_639 = _Symbol._0;
      switch (_x_636.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          const _Symbol$2 = _x_636;
          const _$42$y0_640 = _Symbol$2._0;
          return moonbitlang$core$builtin$$Compare$compare$9$(_$42$x0_639, _$42$y0_640);
        }
        default: {
          return -1;
        }
      }
    }
    default: {
      const _Section = _x_635;
      const _$42$x0_641 = _Section._0;
      switch (_x_636.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        default: {
          const _Section$2 = _x_636;
          const _$42$y0_642 = _Section$2._0;
          return moonbitlang$core$builtin$$Compare$compare$9$(_$42$x0_641, _$42$y0_642);
        }
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$22$(_x_619, _x_620) {
  switch (_x_619.$tag) {
    case 0: {
      const _Package = _x_619;
      const _$42$x0_621 = _Package._0;
      if (_x_620.$tag === 0) {
        const _Package$2 = _x_620;
        const _$42$y0_622 = _Package$2._0;
        return _$42$x0_621 === _$42$y0_622;
      } else {
        return false;
      }
    }
    case 1: {
      const _Symbol = _x_619;
      const _$42$x0_623 = _Symbol._0;
      if (_x_620.$tag === 1) {
        const _Symbol$2 = _x_620;
        const _$42$y0_624 = _Symbol$2._0;
        return _$42$x0_623 === _$42$y0_624;
      } else {
        return false;
      }
    }
    default: {
      const _Section = _x_619;
      const _$42$x0_625 = _Section._0;
      if (_x_620.$tag === 2) {
        const _Section$2 = _x_620;
        const _$42$y0_626 = _Section$2._0;
        return _$42$x0_625 === _$42$y0_626;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$mooncakes$page$docs$$map_with_error$384$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$26$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$92$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$385$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$28$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$93$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$386$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$30$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$94$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$387$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$32$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$95$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$388$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$34$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$96$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$389$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$253$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$97$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$390$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$255$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$98$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$391$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$222$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$99$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$392$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$257$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$100$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$393$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$258$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$101$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$394$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$259$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$102$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$395$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$260$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$103$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$396$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$261$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$104$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$397$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$262$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$105$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$398$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$9$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$106$(xs);
}
function moonbitlang$mooncakes$page$docs$$map_with_error$399$(arr, f) {
  const xs = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = arr[_i];
      const _bind = f(x);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$79$(xs, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$107$(xs);
}
function moonbitlang$mooncakes$page$docs$$decode_meta_info(json) {
  let _return_err_value;
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _name = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
      const _repository = moonbitlang$core$builtin$$Map$get$8$(_x, "repository");
      const _version = moonbitlang$core$builtin$$Map$get$8$(_x, "version");
      const _license = moonbitlang$core$builtin$$Map$get$8$(_x, "license");
      const _description = moonbitlang$core$builtin$$Map$get$8$(_x, "description");
      const _keywords = moonbitlang$core$builtin$$Map$get$8$(_x, "keywords");
      const _deps = moonbitlang$core$builtin$$Map$get$8$(_x, "deps");
      const _p = [_name, _version];
      const _p$2 = new Array(_p.length);
      const _p$3 = _p.length;
      let _tmp = 0;
      while (true) {
        const _p$4 = _tmp;
        if (_p$4 < _p$3) {
          const _p$5 = _p[_p$4];
          const _param1 = _p$5;
          let _tmp$2;
          _L$2: {
            _L$3: {
              if (_param1 === undefined) {
                break _L$3;
              } else {
                const _Some = _param1;
                const _x$2 = _Some;
                if (_x$2.$tag === 4) {
                  const _String = _x$2;
                  const _str = _String._0;
                  _tmp$2 = _str;
                } else {
                  break _L$3;
                }
              }
              break _L$2;
            }
            _tmp$2 = moonbitlang$core$abort$$abort$9$("Error when parsing name and version.");
          }
          _p$2[_p$4] = _tmp$2;
          _tmp = _p$4 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const _bind = _p$2;
      if (_bind.length === 2) {
        const _name$2 = _bind[0];
        const _version$2 = _bind[1];
        const _p$4 = [_repository, _license, _description];
        const _p$5 = new Array(_p$4.length);
        const _p$6 = _p$4.length;
        let _tmp$2 = 0;
        while (true) {
          const _p$7 = _tmp$2;
          if (_p$7 < _p$6) {
            const _p$8 = _p$4[_p$7];
            const _param2 = _p$8;
            let _tmp$3;
            if (_param2 === undefined) {
              _tmp$3 = undefined;
            } else {
              const _Some = _param2;
              const _x$2 = _Some;
              _tmp$3 = moonbitlang$core$json$$Json$as_string(_x$2);
            }
            _p$5[_p$7] = _tmp$3;
            _tmp$2 = _p$7 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _bind$2 = _p$5;
        if (_bind$2.length === 3) {
          const _repository$2 = _bind$2[0];
          const _license$2 = _bind$2[1];
          const _description$2 = _bind$2[2];
          let keywords;
          if (_keywords === undefined) {
            keywords = [];
          } else {
            const _Some = _keywords;
            const _x$2 = _Some;
            if (_x$2.$tag === 5) {
              const _Array = _x$2;
              const _keywords$2 = _Array._0;
              const _p$7 = new Array(_keywords$2.length);
              const _p$8 = _keywords$2.length;
              let _tmp$3 = 0;
              while (true) {
                const _p$9 = _tmp$3;
                if (_p$9 < _p$8) {
                  const _p$10 = _keywords$2[_p$9];
                  const x = _p$10;
                  _p$7[_p$9] = moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$json$$Json$as_string(x));
                  _tmp$3 = _p$9 + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              keywords = _p$7;
            } else {
              keywords = moonbitlang$core$abort$$abort$19$("Error when parsing keywords.");
            }
          }
          const iter = moonbitlang$core$string$$String$iter(_name$2);
          const author = moonbitlang$core$string$$String$from_array(moonbitlang$core$builtin$$Iter$collect$10$(moonbitlang$core$builtin$$Iter$take_while$10$(iter, (_hole593) => 47 !== _hole593)));
          let deps;
          if (_deps === undefined) {
            deps = [];
          } else {
            const _Some = _deps;
            const _x$2 = _Some;
            if (_x$2.$tag === 6) {
              const _Object$2 = _x$2;
              const _xs = _Object$2._0;
              const _bind$3 = moonbitlang$mooncakes$page$docs$$map_with_error$391$(moonbitlang$core$builtin$$Iter2$to_array$8$(moonbitlang$core$builtin$$Map$iter2$8$(_xs)), (_param3) => {
                const _name$3 = _param3._0;
                const _x$3 = _param3._1;
                if (_x$3.$tag === 4) {
                  const _String = _x$3;
                  const _version$3 = _String._0;
                  return new Result$Ok$19$({ _0: _name$3, _1: _version$3 });
                } else {
                  return moonbitlang$core$builtin$$fail$222$("Error when parsing deps.", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/resource.mbt:104:16-104:49");
                }
              });
              if (_bind$3.$tag === 1) {
                const _ok = _bind$3;
                deps = _ok._0;
              } else {
                const _err = _bind$3;
                const _tmp$3 = _err._0;
                _return_err_value = _tmp$3;
                break _L;
              }
            } else {
              deps = moonbitlang$core$abort$$abort$20$("Error when parsing deps.");
            }
          }
          return new Result$Ok$108$({ name: _name$2, author: author, version: _version$2, license: _license$2, keywords: keywords, description: _description$2, repository: _repository$2, deps: deps });
        } else {
          return moonbitlang$core$builtin$$fail$254$("Error when parsing repository, license, description, readme.", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/resource.mbt:89:7-89:76");
        }
      } else {
        return moonbitlang$core$builtin$$fail$254$("Error when parsing name and version.", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/resource.mbt:82:7-82:52");
      }
    } else {
      return moonbitlang$core$builtin$$fail$254$("Error when parsing metadata.", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/resource.mbt:75:7-75:44");
    }
  }
  return new Result$Err$108$(_return_err_value);
}
function moonbitlang$mooncakes$page$docs$$decode_module_resources(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "module_index");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _module_index_path = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "meta_info");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _meta_info = _Some$2;
            const _bind = moonbitlang$mooncakes$page$docs$$decode_meta_info(_meta_info);
            let _bind$2;
            if (_bind.$tag === 1) {
              const _ok = _bind;
              _bind$2 = _ok._0;
            } else {
              return _bind;
            }
            return new Result$Ok$109$({ meta_info: _bind$2, module_index_path: _module_index_path });
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$250$("missing field module_index or source_files", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/resource.mbt:120:10-120:61");
}
function moonbitlang$mooncakes$page$docs$$decode_package_resources(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "package_data");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _package_data_path = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "source_files");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 5) {
              const _Array = _x$5;
              const _source_files = _Array._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "module_path");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 4) {
                  const _String$2 = _x$7;
                  const _module_path = _String$2._0;
                  const ls = [];
                  const _len = _source_files.length;
                  let _tmp = 0;
                  while (true) {
                    const _i = _tmp;
                    if (_i < _len) {
                      const x = _source_files[_i];
                      if (x.$tag === 4) {
                        const _String$3 = x;
                        const _s = _String$3._0;
                        moonbitlang$core$array$$Array$push$9$(ls, _s);
                      } else {
                        const _bind = moonbitlang$core$builtin$$fail$12$("invalid source_files", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/resource.mbt:137:16-137:45");
                        if (_bind.$tag === 1) {
                          const _ok = _bind;
                          _ok._0;
                        } else {
                          return _bind;
                        }
                      }
                      _tmp = _i + 1 | 0;
                      continue;
                    } else {
                      break;
                    }
                  }
                  return new Result$Ok$110$({ package_data_path: _package_data_path, source_files: ls, module_path: _module_path });
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$251$(`missing field package_data or source_files: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/resource.mbt:142:10-142:70");
}
function moonbitlang$mooncakes$page$docs$$decode_root_package_resources(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "package_data");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _package_data_path = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "source_files");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 5) {
              const _Array = _x$5;
              const _source_files = _Array._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "module_index");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 4) {
                  const _String$2 = _x$7;
                  const _module_index_path = _String$2._0;
                  const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "meta_info");
                  if (_x$8 === undefined) {
                    break _L;
                  } else {
                    const _Some$4 = _x$8;
                    const _meta_info = _Some$4;
                    const ls = [];
                    const _len = _source_files.length;
                    let _tmp = 0;
                    while (true) {
                      const _i = _tmp;
                      if (_i < _len) {
                        const x = _source_files[_i];
                        if (x.$tag === 4) {
                          const _String$3 = x;
                          const _s = _String$3._0;
                          moonbitlang$core$array$$Array$push$9$(ls, _s);
                        } else {
                          const _bind = moonbitlang$core$builtin$$fail$12$("invalid source_files", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/resource.mbt:160:16-160:45");
                          if (_bind.$tag === 1) {
                            const _ok = _bind;
                            _ok._0;
                          } else {
                            return _bind;
                          }
                        }
                        _tmp = _i + 1 | 0;
                        continue;
                      } else {
                        break;
                      }
                    }
                    const _bind = moonbitlang$mooncakes$page$docs$$decode_meta_info(_meta_info);
                    let _bind$2;
                    if (_bind.$tag === 1) {
                      const _ok = _bind;
                      _bind$2 = _ok._0;
                    } else {
                      return _bind;
                    }
                    return new Result$Ok$111$({ meta_info: _bind$2, module_index_path: _module_index_path, package_data_path: _package_data_path, source_files: ls });
                  }
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$252$(`missing field package_data or source_files: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/resource.mbt:170:10-170:70");
}
function moonbitlang$mooncakes$page$docs$$decode_resource(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "kind");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _kind = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "readme_content");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 4) {
              const _String$2 = _x$5;
              const _readme_content = _String$2._0;
              let _try_err;
              _L$2: {
                let kind;
                switch (_kind) {
                  case "module": {
                    const _bind = moonbitlang$mooncakes$page$docs$$decode_module_resources(json);
                    let _tmp;
                    if (_bind.$tag === 1) {
                      const _ok = _bind;
                      _tmp = _ok._0;
                    } else {
                      const _err = _bind;
                      const _tmp$2 = _err._0;
                      _try_err = _tmp$2;
                      break _L$2;
                    }
                    kind = new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ResourceKind$Module(_tmp);
                    break;
                  }
                  case "package": {
                    const _bind$2 = moonbitlang$mooncakes$page$docs$$decode_package_resources(json);
                    let _tmp$2;
                    if (_bind$2.$tag === 1) {
                      const _ok = _bind$2;
                      _tmp$2 = _ok._0;
                    } else {
                      const _err = _bind$2;
                      const _tmp$3 = _err._0;
                      _try_err = _tmp$3;
                      break _L$2;
                    }
                    kind = new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ResourceKind$Package(_tmp$2);
                    break;
                  }
                  case "module_and_package": {
                    const _bind$3 = moonbitlang$mooncakes$page$docs$$decode_root_package_resources(json);
                    let _tmp$3;
                    if (_bind$3.$tag === 1) {
                      const _ok = _bind$3;
                      _tmp$3 = _ok._0;
                    } else {
                      const _err = _bind$3;
                      const _tmp$4 = _err._0;
                      _try_err = _tmp$4;
                      break _L$2;
                    }
                    kind = new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ResourceKind$RootPackage(_tmp$3);
                    break;
                  }
                  default: {
                    kind = $panic();
                  }
                }
                return new Result$Ok$43$({ readme_content: _readme_content, kind: kind });
              }
              return new Result$Err$43$(moonbitlang$core$builtin$$Show$to_string$313$(_try_err));
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return new Result$Err$43$("invalid resource.json");
}
function moonbitlang$mooncakes$page$docs$$FoldedState$new() {
  return { set: moonbitlang$core$immut$sorted_set$$new$9$(), card_mode: 0 };
}
function moonbitlang$mooncakes$page$docs$$load(path, fragment) {
  const _tmp = Yoorkin$rabbit$45$tea$cmd$$batch$362$([Yoorkin$rabbit$45$tea$http$$get$377$(`https://mooncakes.me-56d.workers.dev/?url=https://mooncakes.io/assets/${moonbitlang$core$builtin$$Show$to_string$16$(moonbitlang$core$string$$String$trim(path, { str: moonbitlang$mooncakes$page$docs$$load$46$42$bind$124$948, start: 0, end: moonbitlang$mooncakes$page$docs$$load$46$42$bind$124$948.length }))}/resource.json`, new $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$112$((_hole539) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotResource(_hole539), moonbitlang$mooncakes$page$docs$$decode_resource)), Yoorkin$rabbit$45$tea$dialog$$close$362$("search-panel", undefined)]);
  const _bind = $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$113$;
  const _bind$2 = moonbitlang$core$option$$Option$or$9$(fragment, "");
  const _bind$3 = [];
  const _bind$4 = moonbitlang$core$immut$sorted_set$$new$22$();
  const _bind$5 = $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$114$;
  const _bind$6 = moonbitlang$mooncakes$page$docs$$FoldedState$new();
  const _bind$7 = $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$115$;
  const _bind$8 = { filter: "", results: $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$116$ };
  const _bind$9 = $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$117$;
  return { _0: _tmp, _1: { fragment: _bind$2, path: path, resource: _bind$7, module_index: _bind, package_data: _bind$5, search_entries: _bind$9, collapsed_docs: _bind$6, sidebar_document: _bind$3, sidebar_collapsed: _bind$4, sidebar_tab: moonbitlang$mooncakes$page$docs$$load$46$42$bind$124$957, sidebar_fab: false, search: _bind$8, install_copied: false } };
}
function moonbitlang$mooncakes$page$docs$$decode_type_path(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _path = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 4) {
              const _String$2 = _x$5;
              const _name = _String$2._0;
              return new Result$Ok$118$({ path: _path, name: _name });
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$76$("invalid json in type path", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:129:10-129:44");
}
function moonbitlang$mooncakes$page$docs$$decode_stype(json) {
  _L: {
    _L$2: {
      if (json.$tag === 6) {
        const _Object = json;
        const _x = _Object._0;
        const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "kind");
        if (_x$2 === undefined) {
          const _x$3 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
          if (_x$3 === undefined) {
            break _L;
          } else {
            const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
            if (_x$4 === undefined) {
              break _L;
            } else {
              break _L$2;
            }
          }
        } else {
          const _Some = _x$2;
          const _x$3 = _Some;
          if (_x$3.$tag === 4) {
            const _String = _x$3;
            const _x$4 = _String._0;
            switch (_x$4) {
              case "constr": {
                const _x$5 = moonbitlang$core$builtin$$Map$get$8$(_x, "constructor");
                if (_x$5 === undefined) {
                  const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
                  if (_x$6 === undefined) {
                    break _L;
                  } else {
                    const _x$7 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
                    if (_x$7 === undefined) {
                      break _L;
                    } else {
                      break _L$2;
                    }
                  }
                } else {
                  const _Some$2 = _x$5;
                  const _type_path = _Some$2;
                  const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "arguments");
                  if (_x$6 === undefined) {
                    const _x$7 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
                    if (_x$7 === undefined) {
                      break _L;
                    } else {
                      const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
                      if (_x$8 === undefined) {
                        break _L;
                      } else {
                        break _L$2;
                      }
                    }
                  } else {
                    const _Some$3 = _x$6;
                    const _x$7 = _Some$3;
                    if (_x$7.$tag === 5) {
                      const _Array = _x$7;
                      const _stypes = _Array._0;
                      const _bind = moonbitlang$mooncakes$page$docs$$decode_type_path(_type_path);
                      let _tmp;
                      if (_bind.$tag === 1) {
                        const _ok = _bind;
                        _tmp = _ok._0;
                      } else {
                        return _bind;
                      }
                      const _bind$2 = moonbitlang$mooncakes$page$docs$$map_with_error$399$(_stypes, moonbitlang$mooncakes$page$docs$$decode_stype);
                      let _tmp$2;
                      if (_bind$2.$tag === 1) {
                        const _ok = _bind$2;
                        _tmp$2 = _ok._0;
                      } else {
                        return _bind$2;
                      }
                      return new Result$Ok$119$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$Constr(_tmp, _tmp$2));
                    } else {
                      const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
                      if (_x$8 === undefined) {
                        break _L;
                      } else {
                        const _x$9 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
                        if (_x$9 === undefined) {
                          break _L;
                        } else {
                          break _L$2;
                        }
                      }
                    }
                  }
                }
              }
              case "arrow": {
                const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "parameters");
                if (_x$6 === undefined) {
                  const _x$7 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
                  if (_x$7 === undefined) {
                    break _L;
                  } else {
                    const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
                    if (_x$8 === undefined) {
                      break _L;
                    } else {
                      break _L$2;
                    }
                  }
                } else {
                  const _Some$2 = _x$6;
                  const _x$7 = _Some$2;
                  if (_x$7.$tag === 5) {
                    const _Array = _x$7;
                    const _parameters = _Array._0;
                    const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "return_type");
                    if (_x$8 === undefined) {
                      const _x$9 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
                      if (_x$9 === undefined) {
                        break _L;
                      } else {
                        const _x$10 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
                        if (_x$10 === undefined) {
                          break _L;
                        } else {
                          break _L$2;
                        }
                      }
                    } else {
                      const _Some$3 = _x$8;
                      const _return_type = _Some$3;
                      const _error_type = moonbitlang$core$builtin$$Map$get$8$(_x, "error_type");
                      const _x$9 = moonbitlang$core$builtin$$Map$get$8$(_x, "is_async");
                      if (_x$9 === undefined) {
                        const _x$10 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
                        if (_x$10 === undefined) {
                          break _L;
                        } else {
                          const _x$11 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
                          if (_x$11 === undefined) {
                            break _L;
                          } else {
                            break _L$2;
                          }
                        }
                      } else {
                        const _Some$4 = _x$9;
                        const _is_async = _Some$4;
                        let error_type;
                        if (_error_type === undefined) {
                          error_type = undefined;
                        } else {
                          const _Some$5 = _error_type;
                          const _x$10 = _Some$5;
                          const _bind = moonbitlang$mooncakes$page$docs$$decode_stype(_x$10);
                          if (_bind.$tag === 1) {
                            const _ok = _bind;
                            error_type = _ok._0;
                          } else {
                            return _bind;
                          }
                        }
                        const _bind = moonbitlang$core$json$$from_json$82$(_is_async, moonbitlang$core$json$$from_json$46$path$46$default$82$());
                        let is_async;
                        if (_bind.$tag === 1) {
                          const _ok = _bind;
                          is_async = _ok._0;
                        } else {
                          return _bind;
                        }
                        const _bind$2 = moonbitlang$mooncakes$page$docs$$map_with_error$399$(_parameters, moonbitlang$mooncakes$page$docs$$decode_stype);
                        let _tmp;
                        if (_bind$2.$tag === 1) {
                          const _ok = _bind$2;
                          _tmp = _ok._0;
                        } else {
                          return _bind$2;
                        }
                        const _bind$3 = moonbitlang$mooncakes$page$docs$$decode_stype(_return_type);
                        let _tmp$2;
                        if (_bind$3.$tag === 1) {
                          const _ok = _bind$3;
                          _tmp$2 = _ok._0;
                        } else {
                          return _bind$3;
                        }
                        return new Result$Ok$119$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$Arrow(_tmp, _tmp$2, error_type, is_async));
                      }
                    }
                  } else {
                    const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
                    if (_x$8 === undefined) {
                      break _L;
                    } else {
                      const _x$9 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
                      if (_x$9 === undefined) {
                        break _L;
                      } else {
                        break _L$2;
                      }
                    }
                  }
                }
              }
              case "param": {
                const _x$7 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
                if (_x$7 === undefined) {
                  break _L;
                } else {
                  const _Some$2 = _x$7;
                  const _x$8 = _Some$2;
                  if (_x$8.$tag === 4) {
                    const _String$2 = _x$8;
                    const _name = _String$2._0;
                    return new Result$Ok$119$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$Param(_name));
                  } else {
                    const _x$9 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
                    if (_x$9 === undefined) {
                      break _L;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
              default: {
                const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
                if (_x$8 === undefined) {
                  break _L;
                } else {
                  const _x$9 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
                  if (_x$9 === undefined) {
                    break _L;
                  } else {
                    break _L$2;
                  }
                }
              }
            }
          } else {
            const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
            if (_x$4 === undefined) {
              break _L;
            } else {
              const _x$5 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
              if (_x$5 === undefined) {
                break _L;
              } else {
                break _L$2;
              }
            }
          }
        }
      } else {
        break _L;
      }
    }
    const _bind = moonbitlang$mooncakes$page$docs$$decode_type_path(json);
    let _tmp;
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _tmp = _ok._0;
    } else {
      return _bind;
    }
    return new Result$Ok$119$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Stype$TypePath(_tmp));
  }
  return moonbitlang$core$builtin$$fail$79$(`invalid json in stype: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:168:10-168:49");
}
function moonbitlang$mooncakes$page$docs$$decode_impl_index(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "self");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _self_type = _Some;
        const _x$3 = moonbitlang$core$builtin$$Map$get$8$(_x, "trait");
        if (_x$3 === undefined) {
          break _L;
        } else {
          const _Some$2 = _x$3;
          const _trait_type = _Some$2;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "methods");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$3 = _x$4;
            const _x$5 = _Some$3;
            if (_x$5.$tag === 5) {
              const _Array = _x$5;
              const _methods = _Array._0;
              const _bind = moonbitlang$mooncakes$page$docs$$decode_stype(_self_type);
              let self_type;
              if (_bind.$tag === 1) {
                const _ok = _bind;
                self_type = _ok._0;
              } else {
                return _bind;
              }
              const _bind$2 = moonbitlang$mooncakes$page$docs$$decode_type_path(_trait_type);
              let trait_type;
              if (_bind$2.$tag === 1) {
                const _ok = _bind$2;
                trait_type = _ok._0;
              } else {
                return _bind$2;
              }
              const _bind$3 = moonbitlang$mooncakes$page$docs$$map_with_error$398$(_methods, (_param7) => {
                if (_param7.$tag === 4) {
                  const _String = _param7;
                  const _x$6 = _String._0;
                  return new Result$Ok$26$(_x$6);
                } else {
                  return moonbitlang$core$builtin$$fail$9$("invalid methods in impl index", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:247:14-247:52");
                }
              });
              let methods;
              if (_bind$3.$tag === 1) {
                const _ok = _bind$3;
                methods = _ok._0;
              } else {
                return _bind$3;
              }
              return new Result$Ok$120$({ self: self_type, trait_: trait_type, methods: methods });
            } else {
              break _L;
            }
          }
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$262$("invalid json in impl index", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:251:10-251:45");
}
function moonbitlang$mooncakes$page$docs$$decode_misc_index(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _name = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "impls");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 5) {
              const _Array = _x$5;
              const _impls = _Array._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "methods");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 5) {
                  const _Array$2 = _x$7;
                  const _methods = _Array$2._0;
                  const _bind = moonbitlang$mooncakes$page$docs$$map_with_error$397$(_impls, moonbitlang$mooncakes$page$docs$$decode_impl_index);
                  let impls;
                  if (_bind.$tag === 1) {
                    const _ok = _bind;
                    impls = _ok._0;
                  } else {
                    return _bind;
                  }
                  const _bind$2 = moonbitlang$mooncakes$page$docs$$map_with_error$398$(_methods, (_param6) => {
                    if (_param6.$tag === 4) {
                      const _String$2 = _param6;
                      const _x$8 = _String$2._0;
                      return new Result$Ok$26$(_x$8);
                    } else {
                      return moonbitlang$core$builtin$$fail$9$("invalid json in misc index", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:231:14-231:49");
                    }
                  });
                  let methods;
                  if (_bind$2.$tag === 1) {
                    const _ok = _bind$2;
                    methods = _ok._0;
                  } else {
                    return _bind$2;
                  }
                  return new Result$Ok$121$({ name: _name, impls: impls, methods: methods });
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$261$("invalid json in misc index", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:235:10-235:45");
}
function moonbitlang$mooncakes$page$docs$$decode_trait_index(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _name = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "impls");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 5) {
              const _Array = _x$5;
              const _impls = _Array._0;
              const _bind = moonbitlang$mooncakes$page$docs$$map_with_error$397$(_impls, moonbitlang$mooncakes$page$docs$$decode_impl_index);
              let impls;
              if (_bind.$tag === 1) {
                const _ok = _bind;
                impls = _ok._0;
              } else {
                return _bind;
              }
              return new Result$Ok$122$({ name: _name, impls: impls });
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$257$("invalid json in trait index", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:179:10-179:46");
}
function moonbitlang$mooncakes$page$docs$$decode_type_index(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _name = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "impls");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 5) {
              const _Array = _x$5;
              const _impls = _Array._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "methods");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 5) {
                  const _Array$2 = _x$7;
                  const _methods = _Array$2._0;
                  const _bind = moonbitlang$mooncakes$page$docs$$map_with_error$397$(_impls, moonbitlang$mooncakes$page$docs$$decode_impl_index);
                  let impls;
                  if (_bind.$tag === 1) {
                    const _ok = _bind;
                    impls = _ok._0;
                  } else {
                    return _bind;
                  }
                  const _bind$2 = moonbitlang$mooncakes$page$docs$$map_with_error$398$(_methods, (_param5) => {
                    if (_param5.$tag === 4) {
                      const _String$2 = _param5;
                      const _x$8 = _String$2._0;
                      return new Result$Ok$26$(_x$8);
                    } else {
                      return moonbitlang$core$builtin$$fail$9$("invalid json in type index", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:195:14-195:49");
                    }
                  });
                  let methods;
                  if (_bind$2.$tag === 1) {
                    const _ok = _bind$2;
                    methods = _ok._0;
                  } else {
                    return _bind$2;
                  }
                  return new Result$Ok$123$({ name: _name, impls: impls, methods: methods });
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$258$("invalid json in type index", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:199:10-199:45");
}
function moonbitlang$mooncakes$page$docs$$decode_typealias_index(json) {
  if (json.$tag === 4) {
    const _String = json;
    const _x = _String._0;
    return new Result$Ok$124$({ name: _x });
  } else {
    return moonbitlang$core$builtin$$fail$259$("invalid json in typealias index", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:207:10-207:50");
  }
}
function moonbitlang$mooncakes$page$docs$$decode_value_index(json) {
  if (json.$tag === 4) {
    const _String = json;
    const _x = _String._0;
    return new Result$Ok$125$({ name: _x });
  } else {
    return moonbitlang$core$builtin$$fail$260$("invalid json in value index", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:215:10-215:46");
  }
}
function moonbitlang$mooncakes$page$docs$$decode_package_index(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "traits");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 5) {
          const _Array = _x$3;
          const _traits = _Array._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "types");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 5) {
              const _Array$2 = _x$5;
              const _types = _Array$2._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "typealias");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 5) {
                  const _Array$3 = _x$7;
                  const _typealias_ = _Array$3._0;
                  const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "values");
                  if (_x$8 === undefined) {
                    break _L;
                  } else {
                    const _Some$4 = _x$8;
                    const _x$9 = _Some$4;
                    if (_x$9.$tag === 5) {
                      const _Array$4 = _x$9;
                      const _values = _Array$4._0;
                      const _x$10 = moonbitlang$core$builtin$$Map$get$8$(_x, "misc");
                      if (_x$10 === undefined) {
                        break _L;
                      } else {
                        const _Some$5 = _x$10;
                        const _x$11 = _Some$5;
                        if (_x$11.$tag === 5) {
                          const _Array$5 = _x$11;
                          const _miscs = _Array$5._0;
                          const _x$12 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
                          if (_x$12 === undefined) {
                            break _L;
                          } else {
                            const _Some$6 = _x$12;
                            const _x$13 = _Some$6;
                            if (_x$13.$tag === 4) {
                              const _String = _x$13;
                              const _path = _String._0;
                              const _bind = moonbitlang$mooncakes$page$docs$$map_with_error$392$(_traits, moonbitlang$mooncakes$page$docs$$decode_trait_index);
                              let traits;
                              if (_bind.$tag === 1) {
                                const _ok = _bind;
                                traits = _ok._0;
                              } else {
                                return _bind;
                              }
                              const _bind$2 = moonbitlang$mooncakes$page$docs$$map_with_error$393$(_types, moonbitlang$mooncakes$page$docs$$decode_type_index);
                              let types;
                              if (_bind$2.$tag === 1) {
                                const _ok = _bind$2;
                                types = _ok._0;
                              } else {
                                return _bind$2;
                              }
                              const _bind$3 = moonbitlang$mooncakes$page$docs$$map_with_error$394$(_typealias_, moonbitlang$mooncakes$page$docs$$decode_typealias_index);
                              let typealias_;
                              if (_bind$3.$tag === 1) {
                                const _ok = _bind$3;
                                typealias_ = _ok._0;
                              } else {
                                return _bind$3;
                              }
                              const _bind$4 = moonbitlang$mooncakes$page$docs$$map_with_error$395$(_values, moonbitlang$mooncakes$page$docs$$decode_value_index);
                              let values;
                              if (_bind$4.$tag === 1) {
                                const _ok = _bind$4;
                                values = _ok._0;
                              } else {
                                return _bind$4;
                              }
                              const _bind$5 = moonbitlang$mooncakes$page$docs$$map_with_error$396$(_miscs, moonbitlang$mooncakes$page$docs$$decode_misc_index);
                              let misc;
                              if (_bind$5.$tag === 1) {
                                const _ok = _bind$5;
                                misc = _ok._0;
                              } else {
                                return _bind$5;
                              }
                              return new Result$Ok$126$({ path: _path, traits: traits, types: types, typealias_: typealias_, values: values, misc: misc });
                            } else {
                              break _L;
                            }
                          }
                        } else {
                          break _L;
                        }
                      }
                    } else {
                      break _L;
                    }
                  }
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$66$("invalid json in package index", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:286:10-286:48");
}
function moonbitlang$mooncakes$page$docs$$decode_index_node(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _name = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "package");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _pkg = _Some$2;
            const _x$5 = moonbitlang$core$builtin$$Map$get$8$(_x, "childs");
            if (_x$5 === undefined) {
              break _L;
            } else {
              const _Some$3 = _x$5;
              const _x$6 = _Some$3;
              if (_x$6.$tag === 5) {
                const _Array = _x$6;
                const _childs = _Array._0;
                const _bind = moonbitlang$mooncakes$page$docs$$map_with_error$389$(_childs, moonbitlang$mooncakes$page$docs$$decode_index_node);
                let _p;
                if (_bind.$tag === 1) {
                  const _ok = _bind;
                  _p = _ok._0;
                } else {
                  return _bind;
                }
                const _p$2 = new Array(_p.length);
                const _p$3 = _p.length;
                let _tmp = 0;
                while (true) {
                  const _p$4 = _tmp;
                  if (_p$4 < _p$3) {
                    const _p$5 = _p[_p$4];
                    const x = _p$5;
                    _p$2[_p$4] = { _0: x.name, _1: x };
                    _tmp = _p$4 + 1 | 0;
                    continue;
                  } else {
                    break;
                  }
                }
                const childs = moonbitlang$core$immut$sorted_map$$from_array$291$(_p$2);
                let pkg;
                if (_pkg.$tag === 0) {
                  pkg = undefined;
                } else {
                  const _bind$2 = moonbitlang$mooncakes$page$docs$$decode_package_index(_pkg);
                  if (_bind$2.$tag === 1) {
                    const _ok = _bind$2;
                    pkg = _ok._0;
                  } else {
                    return _bind$2;
                  }
                }
                return new Result$Ok$127$({ name: _name, pkg: pkg, childs: childs });
              } else {
                break _L;
              }
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$253$("invalid json in index node", "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/module_index.mbt:304:10-304:45");
}
function moonbitlang$mooncakes$page$docs$$decode_module_index(json) {
  let _try_err;
  _L: {
    const _bind = moonbitlang$mooncakes$page$docs$$decode_index_node(json);
    let _bind$2;
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _bind$2 = _ok._0;
    } else {
      const _err = _bind;
      const _tmp = _err._0;
      _try_err = _tmp;
      break _L;
    }
    return new Result$Ok$45$(_bind$2);
  }
  return new Result$Err$45$(moonbitlang$core$builtin$$Show$to_string$313$(_try_err));
}
function moonbitlang$mooncakes$page$docs$$compare_strings(a, b) {
  const len_a = a.length;
  const len_b = b.length;
  const min_len = len_a < len_b ? len_a : len_b;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < min_len) {
      $bound_check(a, i);
      const char_a = a.charCodeAt(i);
      $bound_check(b, i);
      const char_b = b.charCodeAt(i);
      if (char_a !== char_b) {
        return char_a - char_b | 0;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return len_a - len_b | 0;
}
function moonbitlang$mooncakes$page$docs$$decode_loc(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "path");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _path = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "file");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 4) {
              const _String$2 = _x$5;
              const _file = _String$2._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "line");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 3) {
                  const _Number = _x$7;
                  const _line = _Number._0;
                  const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "column");
                  if (_x$8 === undefined) {
                    break _L;
                  } else {
                    const _Some$4 = _x$8;
                    const _x$9 = _Some$4;
                    if (_x$9.$tag === 3) {
                      const _Number$2 = _x$9;
                      const _column = _Number$2._0;
                      return new Result$Ok$128$({ path: _path, file: _file, line: moonbitlang$core$double$$Double$to_int(_line), column: moonbitlang$core$double$$Double$to_int(_column) });
                    } else {
                      break _L;
                    }
                  }
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$256$(`fail to decode loc: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/package_data.mbt:98:10-98:46");
}
function moonbitlang$mooncakes$page$docs$$decode_value_doc(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _name = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "docstring");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 4) {
              const _String$2 = _x$5;
              const _docstring = _String$2._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "signature");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 4) {
                  const _String$3 = _x$7;
                  const _signature = _String$3._0;
                  const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "loc");
                  if (_x$8 === undefined) {
                    break _L;
                  } else {
                    const _Some$4 = _x$8;
                    const _loc = _Some$4;
                    const _bind = moonbitlang$mooncakes$page$docs$$decode_loc(_loc);
                    let _tmp;
                    if (_bind.$tag === 1) {
                      const _ok = _bind;
                      _tmp = _ok._0;
                    } else {
                      return _bind;
                    }
                    return new Result$Ok$129$({ name: _name, docstring: _docstring, signature: _signature, loc: _tmp });
                  }
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$32$(`fail to decode value doc: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/package_data.mbt:182:10-182:52");
}
function moonbitlang$mooncakes$page$docs$$decode_impl_doc(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "self");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _self_type = _Some;
        const _x$3 = moonbitlang$core$builtin$$Map$get$8$(_x, "trait");
        if (_x$3 === undefined) {
          break _L;
        } else {
          const _Some$2 = _x$3;
          const _trait_type = _Some$2;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "methods");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$3 = _x$4;
            const _x$5 = _Some$3;
            if (_x$5.$tag === 5) {
              const _Array = _x$5;
              const _methods = _Array._0;
              const _bind = moonbitlang$mooncakes$page$docs$$decode_stype(_self_type);
              let self_type;
              if (_bind.$tag === 1) {
                const _ok = _bind;
                self_type = _ok._0;
              } else {
                return _bind;
              }
              const _bind$2 = moonbitlang$mooncakes$page$docs$$decode_type_path(_trait_type);
              let trait_type;
              if (_bind$2.$tag === 1) {
                const _ok = _bind$2;
                trait_type = _ok._0;
              } else {
                return _bind$2;
              }
              const _bind$3 = moonbitlang$mooncakes$page$docs$$map_with_error$387$(_methods, moonbitlang$mooncakes$page$docs$$decode_value_doc);
              let methods;
              if (_bind$3.$tag === 1) {
                const _ok = _bind$3;
                methods = _ok._0;
              } else {
                return _bind$3;
              }
              return new Result$Ok$130$({ self_type: self_type, trait_type: trait_type, methods: methods });
            } else {
              break _L;
            }
          }
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$255$(`fail to decode impl doc: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/package_data.mbt:111:10-111:51");
}
function moonbitlang$mooncakes$page$docs$$decode_misc_doc(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _name = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "impls");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 5) {
              const _Array = _x$5;
              const _impls = _Array._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "methods");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 5) {
                  const _Array$2 = _x$7;
                  const _methods = _Array$2._0;
                  const _bind = moonbitlang$mooncakes$page$docs$$map_with_error$387$(_methods, moonbitlang$mooncakes$page$docs$$decode_value_doc);
                  let methods;
                  if (_bind.$tag === 1) {
                    const _ok = _bind;
                    methods = _ok._0;
                  } else {
                    return _bind;
                  }
                  const _bind$2 = moonbitlang$mooncakes$page$docs$$map_with_error$390$(_impls, moonbitlang$mooncakes$page$docs$$decode_impl_doc);
                  let impls;
                  if (_bind$2.$tag === 1) {
                    const _ok = _bind$2;
                    impls = _ok._0;
                  } else {
                    return _bind$2;
                  }
                  return new Result$Ok$131$({ name: _name, impls: impls, methods: methods });
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$34$(`fail to decode misc doc: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/package_data.mbt:199:10-199:51");
}
function moonbitlang$mooncakes$page$docs$$decode_trait_doc(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _name = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "docstring");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 4) {
              const _String$2 = _x$5;
              const _docstring = _String$2._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "signature");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 4) {
                  const _String$3 = _x$7;
                  const _signature = _String$3._0;
                  const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "impls");
                  if (_x$8 === undefined) {
                    break _L;
                  } else {
                    const _Some$4 = _x$8;
                    const _x$9 = _Some$4;
                    if (_x$9.$tag === 5) {
                      const _Array = _x$9;
                      const _impls = _Array._0;
                      const _x$10 = moonbitlang$core$builtin$$Map$get$8$(_x, "loc");
                      if (_x$10 === undefined) {
                        break _L;
                      } else {
                        const _Some$5 = _x$10;
                        const _loc = _Some$5;
                        const _bind = moonbitlang$mooncakes$page$docs$$map_with_error$390$(_impls, moonbitlang$mooncakes$page$docs$$decode_impl_doc);
                        let impls;
                        if (_bind.$tag === 1) {
                          const _ok = _bind;
                          impls = _ok._0;
                        } else {
                          return _bind;
                        }
                        const _bind$2 = moonbitlang$mooncakes$page$docs$$decode_loc(_loc);
                        let loc;
                        if (_bind$2.$tag === 1) {
                          const _ok = _bind$2;
                          loc = _ok._0;
                        } else {
                          return _bind$2;
                        }
                        return new Result$Ok$132$({ name: _name, docstring: _docstring, signature: _signature, loc: loc, impls: impls });
                      }
                    } else {
                      break _L;
                    }
                  }
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$28$(`fail to decode trait doc: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/package_data.mbt:151:10-151:52");
}
function moonbitlang$mooncakes$page$docs$$decode_type_doc(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _name = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "docstring");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 4) {
              const _String$2 = _x$5;
              const _docstring = _String$2._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "signature");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 4) {
                  const _String$3 = _x$7;
                  const _signature = _String$3._0;
                  const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "methods");
                  if (_x$8 === undefined) {
                    break _L;
                  } else {
                    const _Some$4 = _x$8;
                    const _x$9 = _Some$4;
                    if (_x$9.$tag === 5) {
                      const _Array = _x$9;
                      const _methods = _Array._0;
                      const _x$10 = moonbitlang$core$builtin$$Map$get$8$(_x, "impls");
                      if (_x$10 === undefined) {
                        break _L;
                      } else {
                        const _Some$5 = _x$10;
                        const _x$11 = _Some$5;
                        if (_x$11.$tag === 5) {
                          const _Array$2 = _x$11;
                          const _impls = _Array$2._0;
                          const _x$12 = moonbitlang$core$builtin$$Map$get$8$(_x, "loc");
                          if (_x$12 === undefined) {
                            break _L;
                          } else {
                            const _Some$6 = _x$12;
                            const _loc = _Some$6;
                            const _bind = moonbitlang$mooncakes$page$docs$$map_with_error$387$(_methods, moonbitlang$mooncakes$page$docs$$decode_value_doc);
                            let methods;
                            if (_bind.$tag === 1) {
                              const _ok = _bind;
                              methods = _ok._0;
                            } else {
                              return _bind;
                            }
                            const _bind$2 = moonbitlang$mooncakes$page$docs$$map_with_error$390$(_impls, moonbitlang$mooncakes$page$docs$$decode_impl_doc);
                            let impls;
                            if (_bind$2.$tag === 1) {
                              const _ok = _bind$2;
                              impls = _ok._0;
                            } else {
                              return _bind$2;
                            }
                            const _bind$3 = moonbitlang$mooncakes$page$docs$$decode_loc(_loc);
                            let loc;
                            if (_bind$3.$tag === 1) {
                              const _ok = _bind$3;
                              loc = _ok._0;
                            } else {
                              return _bind$3;
                            }
                            return new Result$Ok$133$({ name: _name, docstring: _docstring, signature: _signature, loc: loc, methods: methods, impls: impls });
                          }
                        } else {
                          break _L;
                        }
                      }
                    } else {
                      break _L;
                    }
                  }
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$26$(`fail to decode type doc: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/package_data.mbt:132:10-132:51");
}
function moonbitlang$mooncakes$page$docs$$decode_typealias_doc(json) {
  _L: {
    if (json.$tag === 6) {
      const _Object = json;
      const _x = _Object._0;
      const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
      if (_x$2 === undefined) {
        break _L;
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3.$tag === 4) {
          const _String = _x$3;
          const _name = _String._0;
          const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "docstring");
          if (_x$4 === undefined) {
            break _L;
          } else {
            const _Some$2 = _x$4;
            const _x$5 = _Some$2;
            if (_x$5.$tag === 4) {
              const _String$2 = _x$5;
              const _docstring = _String$2._0;
              const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "signature");
              if (_x$6 === undefined) {
                break _L;
              } else {
                const _Some$3 = _x$6;
                const _x$7 = _Some$3;
                if (_x$7.$tag === 4) {
                  const _String$3 = _x$7;
                  const _signature = _String$3._0;
                  const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "loc");
                  if (_x$8 === undefined) {
                    break _L;
                  } else {
                    const _Some$4 = _x$8;
                    const _loc = _Some$4;
                    const _bind = moonbitlang$mooncakes$page$docs$$decode_loc(_loc);
                    let loc;
                    if (_bind.$tag === 1) {
                      const _ok = _bind;
                      loc = _ok._0;
                    } else {
                      return _bind;
                    }
                    return new Result$Ok$134$({ name: _name, docstring: _docstring, signature: _signature, loc: loc });
                  }
                } else {
                  break _L;
                }
              }
            } else {
              break _L;
            }
          }
        } else {
          break _L;
        }
      }
    } else {
      break _L;
    }
  }
  return moonbitlang$core$builtin$$fail$30$(`fail to decode type alias doc: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/package_data.mbt:168:10-168:57");
}
function moonbitlang$mooncakes$page$docs$$decode_package_data(json) {
  let _tmp;
  let _return_err_value;
  _L: {
    _L$2: {
      _L$3: {
        _L$4: {
          if (json.$tag === 6) {
            const _Object = json;
            const _x = _Object._0;
            const _x$2 = moonbitlang$core$builtin$$Map$get$8$(_x, "name");
            if (_x$2 === undefined) {
              break _L$4;
            } else {
              const _Some = _x$2;
              const _x$3 = _Some;
              if (_x$3.$tag === 4) {
                const _String = _x$3;
                const _name = _String._0;
                const _x$4 = moonbitlang$core$builtin$$Map$get$8$(_x, "types");
                if (_x$4 === undefined) {
                  break _L$4;
                } else {
                  const _Some$2 = _x$4;
                  const _x$5 = _Some$2;
                  if (_x$5.$tag === 5) {
                    const _Array = _x$5;
                    const _types = _Array._0;
                    const _x$6 = moonbitlang$core$builtin$$Map$get$8$(_x, "traits");
                    if (_x$6 === undefined) {
                      break _L$4;
                    } else {
                      const _Some$3 = _x$6;
                      const _x$7 = _Some$3;
                      if (_x$7.$tag === 5) {
                        const _Array$2 = _x$7;
                        const _traits = _Array$2._0;
                        const _x$8 = moonbitlang$core$builtin$$Map$get$8$(_x, "typealias");
                        if (_x$8 === undefined) {
                          break _L$4;
                        } else {
                          const _Some$4 = _x$8;
                          const _x$9 = _Some$4;
                          if (_x$9.$tag === 5) {
                            const _Array$3 = _x$9;
                            const _aliases = _Array$3._0;
                            const _x$10 = moonbitlang$core$builtin$$Map$get$8$(_x, "values");
                            if (_x$10 === undefined) {
                              break _L$4;
                            } else {
                              const _Some$5 = _x$10;
                              const _x$11 = _Some$5;
                              if (_x$11.$tag === 5) {
                                const _Array$4 = _x$11;
                                const _values = _Array$4._0;
                                const _x$12 = moonbitlang$core$builtin$$Map$get$8$(_x, "misc");
                                if (_x$12 === undefined) {
                                  break _L$4;
                                } else {
                                  const _Some$6 = _x$12;
                                  const _x$13 = _Some$6;
                                  if (_x$13.$tag === 5) {
                                    const _Array$5 = _x$13;
                                    const _misc = _Array$5._0;
                                    const _bind = moonbitlang$mooncakes$page$docs$$map_with_error$384$(_types, moonbitlang$mooncakes$page$docs$$decode_type_doc);
                                    let types;
                                    if (_bind.$tag === 1) {
                                      const _ok = _bind;
                                      types = _ok._0;
                                    } else {
                                      const _err = _bind;
                                      const _tmp$2 = _err._0;
                                      _return_err_value = _tmp$2;
                                      break _L$2;
                                    }
                                    const _bind$2 = moonbitlang$mooncakes$page$docs$$map_with_error$385$(_traits, moonbitlang$mooncakes$page$docs$$decode_trait_doc);
                                    let traits;
                                    if (_bind$2.$tag === 1) {
                                      const _ok = _bind$2;
                                      traits = _ok._0;
                                    } else {
                                      const _err = _bind$2;
                                      const _tmp$2 = _err._0;
                                      _return_err_value = _tmp$2;
                                      break _L$2;
                                    }
                                    const _bind$3 = moonbitlang$mooncakes$page$docs$$map_with_error$386$(_aliases, moonbitlang$mooncakes$page$docs$$decode_typealias_doc);
                                    let aliases;
                                    if (_bind$3.$tag === 1) {
                                      const _ok = _bind$3;
                                      aliases = _ok._0;
                                    } else {
                                      const _err = _bind$3;
                                      const _tmp$2 = _err._0;
                                      _return_err_value = _tmp$2;
                                      break _L$2;
                                    }
                                    const _bind$4 = moonbitlang$mooncakes$page$docs$$map_with_error$387$(_values, moonbitlang$mooncakes$page$docs$$decode_value_doc);
                                    let values;
                                    if (_bind$4.$tag === 1) {
                                      const _ok = _bind$4;
                                      values = _ok._0;
                                    } else {
                                      const _err = _bind$4;
                                      const _tmp$2 = _err._0;
                                      _return_err_value = _tmp$2;
                                      break _L$2;
                                    }
                                    const _bind$5 = moonbitlang$mooncakes$page$docs$$map_with_error$388$(_misc, moonbitlang$mooncakes$page$docs$$decode_misc_doc);
                                    let misc;
                                    if (_bind$5.$tag === 1) {
                                      const _ok = _bind$5;
                                      misc = _ok._0;
                                    } else {
                                      const _err = _bind$5;
                                      const _tmp$2 = _err._0;
                                      _return_err_value = _tmp$2;
                                      break _L$2;
                                    }
                                    moonbitlang$core$array$$Array$sort_by$26$(types, (x, y) => moonbitlang$mooncakes$page$docs$$compare_strings(x.name, y.name));
                                    moonbitlang$core$array$$Array$sort_by$28$(traits, (x, y) => moonbitlang$mooncakes$page$docs$$compare_strings(x.name, y.name));
                                    moonbitlang$core$array$$Array$sort_by$30$(aliases, (x, y) => moonbitlang$mooncakes$page$docs$$compare_strings(x.name, y.name));
                                    moonbitlang$core$array$$Array$sort_by$32$(values, (x, y) => moonbitlang$mooncakes$page$docs$$compare_strings(x.name, y.name));
                                    moonbitlang$core$array$$Array$sort_by$34$(misc, (x, y) => moonbitlang$mooncakes$page$docs$$compare_strings(x.name, y.name));
                                    _tmp = new Result$Ok$135$({ name: _name, types: types, traits: traits, typealiases: aliases, values: values, misc: misc });
                                  } else {
                                    break _L$4;
                                  }
                                }
                              } else {
                                break _L$4;
                              }
                            }
                          } else {
                            break _L$4;
                          }
                        }
                      } else {
                        break _L$4;
                      }
                    }
                  } else {
                    break _L$4;
                  }
                }
              } else {
                break _L$4;
              }
            }
          } else {
            break _L$4;
          }
          break _L$3;
        }
        _tmp = moonbitlang$core$builtin$$fail$249$(`fail to decode package data: ${moonbitlang$core$builtin$$Show$to_string$314$(json)}`, "/home/runner/work/clean-mooncakes.io/clean-mooncakes.io/src/page/docs/package_data.mbt:231:10-231:55");
      }
      break _L;
    }
    _tmp = new Result$Err$135$(_return_err_value);
  }
  return moonbitlang$core$result$$Result$map_err$341$(_tmp, moonbitlang$core$builtin$$Show$to_string$313$);
}
function moonbitlang$mooncakes$page$docs$$IndexNode$iter(self) {
  return moonbitlang$core$builtin$$Iter$new$253$((yield_) => {
    const _bind = self.pkg;
    if (_bind === undefined) {
    } else {
      if (moonbitlang$core$builtin$$Eq$op_equal$75$(yield_(self), 0)) {
        return 0;
      }
    }
    const _foreach_result = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$136$ };
    const _bind$2 = moonbitlang$core$immut$sorted_map$$T$iter2$291$(self.childs);
    _bind$2((__, node) => {
      if (moonbitlang$core$builtin$$Eq$op_equal$75$(moonbitlang$core$builtin$$Iter$run$253$(moonbitlang$mooncakes$page$docs$$IndexNode$iter(node), yield_), 0)) {
        _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$136$(0);
        return 0;
      }
      return 1;
    });
    const _tmp = _foreach_result.val;
    switch (_tmp.$tag) {
      case 0: {
        break;
      }
      case 1: {
        const _break = _tmp;
        _break._0;
        break;
      }
      case 2: {
        const _return = _tmp;
        return _return._0;
      }
      case 3: {
        $panic();
        break;
      }
      default: {
        $panic();
      }
    }
    return 1;
  });
}
function moonbitlang$mooncakes$page$docs$$ModuleIndex$iter(self) {
  return moonbitlang$mooncakes$page$docs$$IndexNode$iter(self);
}
function moonbitlang$mooncakes$page$docs$$load_search_entries(indices) {
  return () => {
    const results = [];
    const _bind = moonbitlang$mooncakes$page$docs$$ModuleIndex$iter(indices);
    _bind((_p) => {
      const _x = _p.pkg;
      if (_x === undefined) {
      } else {
        const _Some = _x;
        const _x$2 = _Some;
        const _path = _x$2.path;
        const _traits = _x$2.traits;
        const _types = _x$2.types;
        const _typealias_ = _x$2.typealias_;
        const _values = _x$2.values;
        const _misc = _x$2.misc;
        const _bind$2 = `@${_path}`;
        const _bind$3 = `/docs/${_path}`;
        moonbitlang$core$array$$Array$push$296$(results, { kind: moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1467, href: _bind$3, fullname: _bind$2 });
        const _p$2 = _traits.length;
        let _tmp = 0;
        while (true) {
          const _p$3 = _tmp;
          if (_p$3 < _p$2) {
            const _p$4 = _traits[_p$3];
            const x = _p$4;
            const _bind$4 = `@${_path}.${x.name}`;
            const _bind$5 = `/docs/${_path}#${x.name}`;
            moonbitlang$core$array$$Array$push$296$(results, { kind: moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1470, href: _bind$5, fullname: _bind$4 });
            _tmp = _p$3 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _p$3 = _types.length;
        let _tmp$2 = 0;
        while (true) {
          const _p$4 = _tmp$2;
          if (_p$4 < _p$3) {
            const _p$5 = _types[_p$4];
            const x = _p$5;
            const _bind$4 = `@${_path}.${x.name}`;
            const _bind$5 = `/docs/${_path}#${x.name}`;
            moonbitlang$core$array$$Array$push$296$(results, { kind: moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1473, href: _bind$5, fullname: _bind$4 });
            const _p$6 = x.methods;
            const _p$7 = _p$6.length;
            let _tmp$3 = 0;
            while (true) {
              const _p$8 = _tmp$3;
              if (_p$8 < _p$7) {
                const _p$9 = _p$6[_p$8];
                const meth = _p$9;
                const _bind$6 = `@${_path}.${x.name}::${meth}`;
                const _bind$7 = `/docs/${_path}#${x.name}::${meth}`;
                moonbitlang$core$array$$Array$push$296$(results, { kind: moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1476, href: _bind$7, fullname: _bind$6 });
                _tmp$3 = _p$8 + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            _tmp$2 = _p$4 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _p$4 = _typealias_.length;
        let _tmp$3 = 0;
        while (true) {
          const _p$5 = _tmp$3;
          if (_p$5 < _p$4) {
            const _p$6 = _typealias_[_p$5];
            const x = _p$6;
            const _bind$4 = `@${_path}.${x.name}`;
            const _bind$5 = `/docs/${_path}#${x.name}`;
            moonbitlang$core$array$$Array$push$296$(results, { kind: moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1479, href: _bind$5, fullname: _bind$4 });
            _tmp$3 = _p$5 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _p$5 = _values.length;
        let _tmp$4 = 0;
        while (true) {
          const _p$6 = _tmp$4;
          if (_p$6 < _p$5) {
            const _p$7 = _values[_p$6];
            const x = _p$7;
            const _bind$4 = `@${_path}.${x.name}`;
            const _bind$5 = `/docs/${_path}#${x.name}`;
            moonbitlang$core$array$$Array$push$296$(results, { kind: moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1482, href: _bind$5, fullname: _bind$4 });
            _tmp$4 = _p$6 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _p$6 = _misc.length;
        let _tmp$5 = 0;
        while (true) {
          const _p$7 = _tmp$5;
          if (_p$7 < _p$6) {
            const _p$8 = _misc[_p$7];
            const x = _p$8;
            const _bind$4 = `@${_path}.${x.name}`;
            const _bind$5 = `/docs/${_path}#${x.name}`;
            moonbitlang$core$array$$Array$push$296$(results, { kind: moonbitlang$mooncakes$page$docs$$load_search_entries$46$42$bind$124$1485, href: _bind$5, fullname: _bind$4 });
            _tmp$5 = _p$7 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      }
      return 1;
    });
    return results;
  };
}
function moonbitlang$mooncakes$page$docs$$search(entries, filter) {
  if (moonbitlang$core$string$$String$is_empty(filter)) {
    return [];
  }
  const results = CAIMEOX$lazy$$Lazy$force$383$(entries);
  const query = illusory0x0$fuzzy_match$$Query$new(filter);
  const _self = moonbitlang$core$array$$Array$filter_map$352$(results, (entry) => {
    const score = illusory0x0$fuzzy_match$$Query$score$9$(query, entry.fullname);
    const _bind = illusory0x0$fuzzy_match$$Query$split_by_matching_sections$9$(query, entry.fullname);
    if (_bind.$tag === 0) {
      return undefined;
    } else {
      const _Some = _bind;
      const _matching = _Some._0;
      return { matching: _matching, score: score, entry: entry };
    }
  });
  moonbitlang$core$array$$Array$sort_by$38$(_self, (a, b) => a.score - b.score | 0);
  return _self;
}
function moonbitlang$mooncakes$page$docs$$FoldedState$add(self, id) {
  return { set: moonbitlang$core$immut$sorted_set$$T$add$9$(self.set, id), card_mode: self.card_mode };
}
function moonbitlang$mooncakes$page$docs$$FoldedState$contains(self, id) {
  const _bind = self.card_mode;
  if (_bind === 0) {
    return moonbitlang$core$immut$sorted_set$$T$contains$9$(self.set, id);
  } else {
    return true;
  }
}
function moonbitlang$mooncakes$page$docs$$FoldedState$remove(self, id) {
  return { set: moonbitlang$core$immut$sorted_set$$T$remove$9$(self.set, id), card_mode: self.card_mode };
}
function moonbitlang$mooncakes$page$docs$$FoldedState$set_mode(self, mode) {
  return { set: self.set, card_mode: mode };
}
function moonbitlang$mooncakes$page$docs$$ImplDoc$get_id(self) {
  return `${moonbitlang$core$builtin$$Show$to_string$315$(self.self_type)}-for-${moonbitlang$core$builtin$$Show$to_string$316$(self.trait_type)}`;
}
function moonbitlang$mooncakes$page$docs$$IndexNode$find_node(self, path) {
  const _bind = moonbitlang$core$builtin$$Iter$to_array$16$(moonbitlang$core$string$$StringView$split(moonbitlang$core$string$$String$trim(path, { str: moonbitlang$mooncakes$page$docs$$find_node$46$42$bind$124$1534, start: 0, end: moonbitlang$mooncakes$page$docs$$find_node$46$42$bind$124$1534.length }), { str: moonbitlang$mooncakes$page$docs$$find_node$46$42$bind$124$1535, start: 0, end: moonbitlang$mooncakes$page$docs$$find_node$46$42$bind$124$1535.length }));
  const paths_len = _bind.length;
  _L: {
    if (paths_len >= 1) {
      const _root_path = _bind[0];
      const _some = paths_len;
      const _x = { buf: _bind, start: 1, len: _some - 1 | 0 };
      const _bind$2 = self.name;
      if (moonbitlang$core$builtin$$Eq$op_equal$16$(_root_path, { str: _bind$2, start: 0, end: _bind$2.length })) {
        let _tmp = self;
        let _tmp$2 = _x;
        while (true) {
          const _param = _tmp;
          const _param$2 = _tmp$2;
          if (_param === undefined) {
            return _param;
          } else {
            const _Some = _param;
            const _node = _Some;
            if (_param$2.len >= 1) {
              const _path = _param$2.buf[_param$2.start];
              const _tmp$3 = _param$2.buf;
              const _tmp$4 = 1 + _param$2.start | 0;
              const _some$2 = _param$2.len;
              const _x$2 = { buf: _tmp$3, start: _tmp$4, len: _some$2 - 1 | 0 };
              const _tmp$5 = moonbitlang$core$immut$sorted_map$$T$get$291$(_node.childs, moonbitlang$core$builtin$$Show$to_string$16$(_path));
              _tmp = _tmp$5;
              _tmp$2 = _x$2;
              continue;
            } else {
              return _param;
            }
          }
        }
      } else {
        break _L;
      }
    } else {
      break _L;
    }
  }
  return undefined;
}
function moonbitlang$mooncakes$page$docs$$compare_items$22$(a, b) {
  return moonbitlang$mooncakes$page$docs$$compare_strings(moonbitlang$mooncakes$view$tree$$Tree$get_name$22$(a), moonbitlang$mooncakes$view$tree$$Tree$get_name$22$(b));
}
function moonbitlang$mooncakes$page$docs$$PkgIndex$to_document_items(self) {
  const _traits = self.traits;
  const _types = self.types;
  const _typealias_ = self.typealias_;
  const _values = self.values;
  const _misc = self.misc;
  const _p = new Array(_values.length);
  const _p$2 = _values.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = _values[_p$3];
      const x = _p$4;
      _p[_p$3] = new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Item$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(x.name), x.name);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _p$3 = new Array(_misc.length);
  const _p$4 = _misc.length;
  let _tmp$2 = 0;
  while (true) {
    const _p$5 = _tmp$2;
    if (_p$5 < _p$4) {
      const _p$6 = _misc[_p$5];
      const misc = _p$6;
      let _tmp$3;
      if (moonbitlang$core$array$$Array$is_empty$9$(misc.methods)) {
        _tmp$3 = new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Item$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(misc.name), misc.name);
      } else {
        const _p$7 = misc.methods;
        const _p$8 = new Array(_p$7.length);
        const _p$9 = _p$7.length;
        let _tmp$4 = 0;
        while (true) {
          const _p$10 = _tmp$4;
          if (_p$10 < _p$9) {
            const _p$11 = _p$7[_p$10];
            const meth = _p$11;
            _p$8[_p$10] = new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Item$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(`${misc.name}::${meth}`), meth);
            _tmp$4 = _p$10 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        _tmp$3 = new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Node$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(misc.name), misc.name, _p$8);
      }
      _p$3[_p$5] = _tmp$3;
      _tmp$2 = _p$5 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const values = moonbitlang$core$builtin$$Add$op_add$335$(_p, _p$3);
  const _p$5 = new Array(_traits.length);
  const _p$6 = _traits.length;
  let _tmp$3 = 0;
  while (true) {
    const _p$7 = _tmp$3;
    if (_p$7 < _p$6) {
      const _p$8 = _traits[_p$7];
      const x = _p$8;
      _p$5[_p$7] = new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Item$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(x.name), x.name);
      _tmp$3 = _p$7 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const traits = _p$5;
  const _p$7 = new Array(_types.length);
  const _p$8 = _types.length;
  let _tmp$4 = 0;
  while (true) {
    const _p$9 = _tmp$4;
    if (_p$9 < _p$8) {
      const _p$10 = _types[_p$9];
      const ty = _p$10;
      let _tmp$5;
      if (moonbitlang$core$array$$Array$is_empty$9$(ty.methods)) {
        _tmp$5 = new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Item$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(ty.name), ty.name);
      } else {
        const _p$11 = ty.methods;
        const _p$12 = new Array(_p$11.length);
        const _p$13 = _p$11.length;
        let _tmp$6 = 0;
        while (true) {
          const _p$14 = _tmp$6;
          if (_p$14 < _p$13) {
            const _p$15 = _p$11[_p$14];
            const meth = _p$15;
            _p$12[_p$14] = new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Item$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(`${ty.name}::${meth}`), meth);
            _tmp$6 = _p$14 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        _tmp$5 = new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Node$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(ty.name), ty.name, _p$12);
      }
      _p$7[_p$9] = _tmp$5;
      _tmp$4 = _p$9 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _p$9 = new Array(_typealias_.length);
  const _p$10 = _typealias_.length;
  let _tmp$5 = 0;
  while (true) {
    const _p$11 = _tmp$5;
    if (_p$11 < _p$10) {
      const _p$12 = _typealias_[_p$11];
      const x = _p$12;
      _p$9[_p$11] = new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Item$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(x.name), x.name);
      _tmp$5 = _p$11 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const types = moonbitlang$core$builtin$$Add$op_add$335$(_p$7, _p$9);
  const result = [];
  if (!moonbitlang$core$array$$Array$is_empty$36$(traits)) {
    moonbitlang$core$array$$Array$sort_by$36$(traits, moonbitlang$mooncakes$page$docs$$compare_items$22$);
    moonbitlang$core$array$$Array$push$36$(result, new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Node$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Section("trait-section"), "Traits", traits));
  }
  if (!moonbitlang$core$array$$Array$is_empty$36$(types)) {
    moonbitlang$core$array$$Array$sort_by$36$(types, moonbitlang$mooncakes$page$docs$$compare_items$22$);
    moonbitlang$core$array$$Array$push$36$(result, new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Node$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Section("type-section"), "Types", types));
  }
  if (!moonbitlang$core$array$$Array$is_empty$36$(values)) {
    moonbitlang$core$array$$Array$sort_by$36$(values, moonbitlang$mooncakes$page$docs$$compare_items$22$);
    moonbitlang$core$array$$Array$push$36$(result, new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Node$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Section("value-section"), "Values", values));
  }
  return result;
}
function moonbitlang$mooncakes$page$docs$$to_document_items$46$collect_packages$124$388(node) {
  const _bind = node.pkg;
  if (_bind === undefined) {
    if (!moonbitlang$core$immut$sorted_map$$T$is_empty$291$(node.childs)) {
      const _self = moonbitlang$core$array$$Array$filter_map$351$(moonbitlang$core$immut$sorted_map$$T$elems$291$(node.childs), moonbitlang$mooncakes$page$docs$$to_document_items$46$collect_packages$124$388);
      moonbitlang$core$array$$Array$sort_by$36$(_self, moonbitlang$mooncakes$page$docs$$compare_items$22$);
      const childs = _self;
      return new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Node$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Package(node.name), node.name, childs);
    } else {
      return undefined;
    }
  } else {
    const _Some = _bind;
    const _pkg = _Some;
    return new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Item$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Package(_pkg.path), node.name);
  }
}
function moonbitlang$mooncakes$page$docs$$IndexNode$to_document_items(self) {
  const _self = moonbitlang$core$array$$Array$filter_map$351$(moonbitlang$core$immut$sorted_map$$T$elems$291$(self.childs), moonbitlang$mooncakes$page$docs$$to_document_items$46$collect_packages$124$388);
  moonbitlang$core$array$$Array$sort_by$36$(_self, moonbitlang$mooncakes$page$docs$$compare_items$22$);
  const packages = _self;
  const package_section = packages.length === 0 ? [] : [new $64$moonbitlang$47$mooncakes$47$view$47$tree$46$Tree$Node$55$(new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Section("packages-section"), "Sub Packages", packages)];
  const _bind = self.pkg;
  let symbols;
  if (_bind === undefined) {
    symbols = [];
  } else {
    const _Some = _bind;
    const _pkg = _Some;
    symbols = moonbitlang$mooncakes$page$docs$$PkgIndex$to_document_items(_pkg);
  }
  const _self$2 = [];
  moonbitlang$core$array$$Array$push_iter$36$(_self$2, moonbitlang$core$array$$Array$iter$36$(symbols));
  moonbitlang$core$array$$Array$push_iter$36$(_self$2, moonbitlang$core$array$$Array$iter$36$(package_section));
  return _self$2;
}
function moonbitlang$mooncakes$page$docs$$update(msg, model) {
  switch (msg.$tag) {
    case 2: {
      const _GotResource = msg;
      const _result = _GotResource._0;
      if (_result.$tag === 1) {
        const _Ok = _result;
        const _x = _Ok._0;
        const _kind = _x.kind;
        let cmd;
        switch (_kind.$tag) {
          case 1: {
            const _Module = _kind;
            const _x$2 = _Module._0;
            const _module_index_path = _x$2.module_index_path;
            cmd = Yoorkin$rabbit$45$tea$http$$get$379$(`https://mooncakes.me-56d.workers.dev/?url=https://mooncakes.io/assets/${_module_index_path}`, new $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$137$((_hole484) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotModuleIndex(_hole484), moonbitlang$mooncakes$page$docs$$decode_module_index));
            break;
          }
          case 0: {
            const _Package = _kind;
            const _x$3 = _Package._0;
            const _package_data_path = _x$3.package_data_path;
            const _module_path = _x$3.module_path;
            cmd = Yoorkin$rabbit$45$tea$cmd$$batch$362$([Yoorkin$rabbit$45$tea$http$$get$380$(`https://mooncakes.me-56d.workers.dev/?url=https://mooncakes.io/assets/${_package_data_path}`, new $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$138$((_hole488) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotPackageData(_hole488), moonbitlang$mooncakes$page$docs$$decode_package_data)), Yoorkin$rabbit$45$tea$http$$get$379$(`https://mooncakes.me-56d.workers.dev/?url=https://mooncakes.io/assets/${_module_path}/module_index.json`, new $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$137$((_hole490) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotModuleIndex(_hole490), moonbitlang$mooncakes$page$docs$$decode_module_index))]);
            break;
          }
          default: {
            const _RootPackage = _kind;
            const _x$4 = _RootPackage._0;
            const _module_index_path$2 = _x$4.module_index_path;
            const _package_data_path$2 = _x$4.package_data_path;
            cmd = Yoorkin$rabbit$45$tea$cmd$$batch$362$([Yoorkin$rabbit$45$tea$http$$get$379$(`https://mooncakes.me-56d.workers.dev/?url=https://mooncakes.io/assets/${_module_index_path$2}`, new $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$137$((_hole494) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotModuleIndex(_hole494), moonbitlang$mooncakes$page$docs$$decode_module_index)), Yoorkin$rabbit$45$tea$http$$get$380$(`https://mooncakes.me-56d.workers.dev/?url=https://mooncakes.io/assets/${_package_data_path$2}`, new $64$Yoorkin$47$rabbit$45$tea$47$http$46$Expecting$Json$138$((_hole496) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$GotPackageData(_hole496), moonbitlang$mooncakes$page$docs$$decode_package_data))]);
          }
        }
        return { _0: cmd, _1: { ...model, resource: new $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$115$(_x) } };
      } else {
        const _Err = _result;
        const _msg = _Err._0;
        moonbitlang$core$builtin$$println$9$(_msg);
        return { _0: Yoorkin$rabbit$45$tea$cmd$$none$362$(), _1: { ...model, resource: $64$moonbitlang$47$mooncakes$47$util$46$Status$Failed$115$ } };
      }
    }
    case 3: {
      const _GotModuleIndex = msg;
      const _result$2 = _GotModuleIndex._0;
      const _tmp = Yoorkin$rabbit$45$tea$cmd$$none$362$();
      let _tmp$2;
      if (_result$2.$tag === 1) {
        const _Ok = _result$2;
        const _module_index = _Ok._0;
        const sidebar_document = moonbitlang$mooncakes$page$docs$$IndexNode$to_document_items(moonbitlang$core$option$$Option$unwrap$253$(moonbitlang$mooncakes$page$docs$$IndexNode$find_node(_module_index, model.path)));
        _tmp$2 = { ...model, sidebar_document: sidebar_document, module_index: new $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$113$(_module_index), search_entries: new $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$117$(CAIMEOX$lazy$$Lazy$new$383$(moonbitlang$mooncakes$page$docs$$load_search_entries(_module_index))) };
      } else {
        const _Err = _result$2;
        const _msg = _Err._0;
        moonbitlang$core$builtin$$println$9$(_msg);
        _tmp$2 = { ...model, module_index: $64$moonbitlang$47$mooncakes$47$util$46$Status$Failed$113$ };
      }
      return { _0: _tmp, _1: _tmp$2 };
    }
    case 4: {
      const _GotPackageData = msg;
      const _result$3 = _GotPackageData._0;
      let model$2;
      if (_result$3.$tag === 1) {
        const _Ok = _result$3;
        const _x = _Ok._0;
        const _types = _x.types;
        const _traits = _x.traits;
        const _misc = _x.misc;
        const _bind = moonbitlang$core$array$$Array$iter$26$(_types);
        const _bind$2 = moonbitlang$core$array$$Array$iter$28$(_traits);
        const _bind$3 = moonbitlang$core$array$$Array$iter$34$(_misc);
        const _bind$4 = model.collapsed_docs;
        const _acc = { val: _bind$4 };
        const _p = (_p$2) => {
          const _p$3 = moonbitlang$mooncakes$page$docs$$ImplDoc$get_id(_p$2);
          _acc.val = moonbitlang$mooncakes$page$docs$$FoldedState$add(_acc.val, _p$3);
          return 1;
        };
        (_bind((_p$2) => {
          const _func = moonbitlang$core$array$$Array$iter$255$(_p$2.impls);
          return _func(_p);
        }) === 1 && _bind$2((_p$2) => {
          const _func = moonbitlang$core$array$$Array$iter$255$(_p$2.impls);
          return _func(_p);
        }) === 1 ? 1 : 0) === 1 && _bind$3((_p$2) => {
          const _func = moonbitlang$core$array$$Array$iter$255$(_p$2.impls);
          return _func(_p);
        }) === 1 ? 1 : 0;
        const collapsed_docs = _acc.val;
        model$2 = { ...model, collapsed_docs: collapsed_docs, package_data: new $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$114$(_x) };
      } else {
        const _Err = _result$3;
        const _msg = _Err._0;
        moonbitlang$core$builtin$$println$9$(_msg);
        model$2 = { ...model, package_data: $64$moonbitlang$47$mooncakes$47$util$46$Status$Failed$114$ };
      }
      return { _0: Yoorkin$rabbit$45$tea$nav$$scroll_to$362$(model$2.fragment), _1: model$2 };
    }
    case 0: {
      const _ToggleDocDetail = msg;
      const _id = _ToggleDocDetail._0;
      const folded_items = moonbitlang$mooncakes$page$docs$$FoldedState$contains(model.collapsed_docs, _id) ? moonbitlang$mooncakes$page$docs$$FoldedState$remove(model.collapsed_docs, _id) : moonbitlang$mooncakes$page$docs$$FoldedState$add(model.collapsed_docs, _id);
      return { _0: Yoorkin$rabbit$45$tea$cmd$$none$362$(), _1: { ...model, collapsed_docs: folded_items } };
    }
    case 1: {
      const _DocModeChanged = msg;
      const _card_mode = _DocModeChanged._0;
      return { _0: Yoorkin$rabbit$45$tea$cmd$$none$362$(), _1: { ...model, collapsed_docs: moonbitlang$mooncakes$page$docs$$FoldedState$set_mode(model.collapsed_docs, _card_mode) } };
    }
    case 5: {
      const _SidebarTabClicked = msg;
      const _sidebar_tab = _SidebarTabClicked._0;
      return { _0: Yoorkin$rabbit$45$tea$cmd$$none$362$(), _1: { ...model, sidebar_tab: _sidebar_tab } };
    }
    case 6: {
      const _ToggleSidebarItem = msg;
      const _id$2 = _ToggleSidebarItem._0;
      const sidebar_collapsed = moonbitlang$core$immut$sorted_set$$T$contains$22$(model.sidebar_collapsed, _id$2) ? moonbitlang$core$immut$sorted_set$$T$remove$22$(model.sidebar_collapsed, _id$2) : moonbitlang$core$immut$sorted_set$$T$add$22$(model.sidebar_collapsed, _id$2);
      return { _0: Yoorkin$rabbit$45$tea$cmd$$none$362$(), _1: { ...model, sidebar_collapsed: sidebar_collapsed } };
    }
    case 7: {
      const _ClickSidebarItem = msg;
      const _id$3 = _ClickSidebarItem._0;
      const model$3 = { ...model, sidebar_fab: false };
      let id;
      _L: {
        switch (_id$3.$tag) {
          case 0: {
            const _Package = _id$3;
            const _path = _Package._0;
            return { _0: Yoorkin$rabbit$45$tea$nav$$push_url$362$(`/docs/${_path}`), _1: { ...model$3, path: _path } };
          }
          case 1: {
            const _Symbol = _id$3;
            const _id$4 = _Symbol._0;
            id = _id$4;
            break _L;
          }
          default: {
            const _Section = _id$3;
            const _id$5 = _Section._0;
            id = _id$5;
            break _L;
          }
        }
      }
      return { _0: Yoorkin$rabbit$45$tea$nav$$scroll_to$362$(id), _1: model$3 };
    }
    case 8: {
      const _ToggleSearchPanel = msg;
      const _open = _ToggleSearchPanel._0;
      const cmd = _open ? Yoorkin$rabbit$45$tea$dialog$$show$362$("search-panel", Yoorkin$rabbit$45$tea$dialog$$show$46$modal$46$default$362$()) : Yoorkin$rabbit$45$tea$dialog$$close$362$("search-panel", undefined);
      return { _0: cmd, _1: model };
    }
    case 9: {
      const _SearchFilterChanged = msg;
      const _filter = _SearchFilterChanged._0;
      const _bind = model.search_entries;
      let results;
      switch (_bind.$tag) {
        case 1: {
          results = $64$moonbitlang$47$mooncakes$47$util$46$Status$Failed$116$;
          break;
        }
        case 0: {
          results = $64$moonbitlang$47$mooncakes$47$util$46$Status$Loading$116$;
          break;
        }
        default: {
          const _Success = _bind;
          const _indices = _Success._0;
          results = new $64$moonbitlang$47$mooncakes$47$util$46$Status$Success$116$(moonbitlang$mooncakes$page$docs$$search(_indices, _filter));
        }
      }
      const search = { filter: _filter, results: results };
      return { _0: Yoorkin$rabbit$45$tea$cmd$$none$362$(), _1: { ...model, search: search } };
    }
    case 10: {
      const sidebar_fab = !model.sidebar_fab;
      return { _0: Yoorkin$rabbit$45$tea$cmd$$none$362$(), _1: { ...model, sidebar_fab: sidebar_fab } };
    }
    case 11: {
      const _CopyInstallCommand = msg;
      const _command = _CopyInstallCommand._0;
      return { _0: Yoorkin$rabbit$45$tea$clipboard$$copy$362$(new $64$Yoorkin$47$rabbit$45$tea$47$clipboard$46$Item$Text(_command), $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$CopyInstallSuccess, undefined), _1: model };
    }
    default: {
      return { _0: Yoorkin$rabbit$45$tea$cmd$$none$362$(), _1: { ...model, install_copied: true } };
    }
  }
}
function moonbitlang$mooncakes$page$docs$$breadcrumbs(path, module_path, module_index) {
  const module_path$2 = moonbitlang$core$builtin$$Show$to_string$16$(moonbitlang$core$string$$String$trim(module_path, { str: moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1767, start: 0, end: moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1767.length }));
  const path$2 = moonbitlang$core$string$$String$trim(path, { str: moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1766, start: 0, end: moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1766.length });
  const paths = moonbitlang$core$builtin$$Iter$collect$16$(moonbitlang$core$string$$StringView$split(moonbitlang$core$string$$StringView$trim_start(path$2, { str: moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1764, start: 0, end: moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1764.length }), { str: moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1765, start: 0, end: moonbitlang$mooncakes$page$docs$$breadcrumbs$46$42$bind$124$1765.length }));
  const acc_path = { val: "" };
  const elems = [];
  const _len = paths.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const path$3 = paths[_i];
      const path$4 = moonbitlang$core$builtin$$Show$to_string$16$(path$3);
      acc_path.val = `${acc_path.val}${acc_path.val === "" ? path$4 : `/${path$4}`}`;
      let elem;
      _L: {
        _L$2: {
          if (moonbitlang$core$string$$String$has_prefix(acc_path.val, { str: module_path$2, start: 0, end: module_path$2.length })) {
            const _bind = moonbitlang$mooncakes$page$docs$$IndexNode$find_node(module_index, acc_path.val);
            if (_bind === undefined) {
              break _L$2;
            } else {
              const _Some = _bind;
              const _node = _Some;
              _L$3: {
                if (acc_path.val === module_path$2) {
                  break _L$3;
                } else {
                  if (!moonbitlang$core$option$$Option$is_empty$66$(_node.pkg)) {
                    break _L$3;
                  } else {
                    break _L$2;
                  }
                }
              }
              elem = Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, "hover:underline", `/docs/${acc_path.val}`, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [Yoorkin$rabbit$45$tea$html$$text$362$(path$4)], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$());
            }
          } else {
            break _L$2;
          }
          break _L;
        }
        elem = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "text-gray-700 font-normal", undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(path$4)]);
      }
      moonbitlang$core$array$$Array$push$23$(elems, elem);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const separator = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "text-gray-300 text-base", undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(" / ")]);
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "text-base text-gray-800 font-semibold flex gap-2", undefined, moonbitlang$core$builtin$$Iter$collect$23$(moonbitlang$core$builtin$$Iter$intersperse$23$(moonbitlang$core$array$$Array$iter$23$(elems), separator)));
}
function moonbitlang$mooncakes$page$docs$$logo() {
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "w-full h-full flex justify-end border-b top-0 z-20", undefined, [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "h-full flex items-center w-full 2xl:w-2/3", undefined, [Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, "border-gray-300 w-full", "/", Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [Yoorkin$rabbit$45$tea$html$$h1$362$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$362$(), undefined, "font-title text-gray-700 font-semibold mx-12", [Yoorkin$rabbit$45$tea$html$$text$362$("🥮 mooncakes.io (Community Edition)")])], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$())])]);
}
function moonbitlang$mooncakes$page$docs$$card_mode_toggle$362$(mode, click) {
  let l;
  let r;
  _L: {
    if (mode === 0) {
      l = moonbitlang$mooncakes$page$docs$$card_mode_toggle$46$btn_focused$124$421;
      r = moonbitlang$mooncakes$page$docs$$card_mode_toggle$46$rbtn_normal$124$423;
      break _L;
    } else {
      l = moonbitlang$mooncakes$page$docs$$card_mode_toggle$46$lbtn_normal$124$422;
      r = moonbitlang$mooncakes$page$docs$$card_mode_toggle$46$btn_focused$124$421;
      break _L;
    }
  }
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "flex", undefined, [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, `py-2 px-3 rounded-l ${moonbitlang$core$builtin$$Show$to_string$9$(l)}`, click(0), [Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, moonbitlang$mooncakes$page$docs$$card_mode_toggle$46$img_class$124$420, "/expansion.svg", undefined, undefined, undefined, undefined, undefined, [])]), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, `py-2 px-3 rounded-r ${moonbitlang$core$builtin$$Show$to_string$9$(r)}`, click(1), [Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, moonbitlang$mooncakes$page$docs$$card_mode_toggle$46$img_class$124$420, "/reduction.svg", undefined, undefined, undefined, undefined, undefined, [])])]);
}
function moonbitlang$mooncakes$page$docs$$navbar(path, module_path, module_index, card_mode) {
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "bg-white w-full h-full border-b select-none flex items-center gap-4 pl-12 top-0 z-10", undefined, [module_path === path ? Yoorkin$rabbit$45$tea$html$$nothing$362$() : moonbitlang$mooncakes$page$docs$$breadcrumbs(path, module_path, module_index), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "flex-grow", undefined, []), moonbitlang$mooncakes$page$docs$$card_mode_toggle$362$(card_mode, (_hole460) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$DocModeChanged(_hole460)), Yoorkin$rabbit$45$tea$html$$button$362$(Yoorkin$rabbit$45$tea$html$$button$46$style$46$default$362$(), undefined, "bg-gray-100 border hover:border-mooncake2 border-opacity-0 transition-all rounded mx-2 py-1 px-2 lg:w-1/5 lg:shadow-sm text-gray-500 flex items-center gap-2", new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleSearchPanel(true), [Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, "w-5 h-5", "/search.svg", undefined, undefined, undefined, undefined, undefined, []), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "hidden lg:block text-nowrap", undefined, [Yoorkin$rabbit$45$tea$html$$text$362$("search")])])]);
}
function moonbitlang$mooncakes$page$docs$$document_item(signature, content, collapsed, id, tight, loc) {
  let content_style;
  let icon;
  _L: {
    if (moonbitlang$mooncakes$page$docs$$FoldedState$contains(collapsed, id)) {
      content_style = "hidden";
      icon = "/section-close.svg";
      break _L;
    } else {
      content_style = "";
      icon = "/section-open.svg";
      break _L;
    }
  }
  const header_style = tight ? "py-1" : "py-2";
  let source_btn;
  if (loc === undefined) {
    source_btn = Yoorkin$rabbit$45$tea$html$$nothing$362$();
  } else {
    const _Some = loc;
    const _loc = _Some;
    source_btn = Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, "text-xs text-gray-500 hover:text-gray-700 transition-colors", `/assets/${moonbitlang$core$builtin$$Show$to_string$9$(_loc.path)}/${moonbitlang$core$builtin$$Show$to_string$9$(_loc.file)}.html#${moonbitlang$core$builtin$$Show$to_string$7$(_loc.line)}`, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [Yoorkin$rabbit$45$tea$html$$text$362$("source")], true);
  }
  const collapse_btn = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "w-8 h-8 hover:bg-gray-200 rounded-lg flex items-center justify-center", new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleDocDetail(id), [Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, "size-4", icon, undefined, undefined, undefined, undefined, undefined, [])]);
  const buttons = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "absolute right-1 top-1/2 transform -translate-y-1/2 select-none flex gap-1 items-center justify-center group-hover:visible invisible", undefined, [source_btn, collapse_btn]);
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "border-t border-gray-300 py-2 group", undefined, [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), id, `pl-4 py-2 pr-2 bg-gray-100 rounded-lg relative w-full ${moonbitlang$core$builtin$$Show$to_string$9$(header_style)}`, undefined, [signature, buttons]), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, `pl-4 pt-2 ${moonbitlang$core$builtin$$Show$to_string$9$(content_style)}`, undefined, [content])]);
}
function moonbitlang$mooncakes$page$docs$$document_item$46$tight$46$default() {
  return false;
}
function moonbitlang$mooncakes$page$docs$$type_path(ty) {
  return Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, "hover:text-gray-700 transition-colors underline underline-offset-4 text-gray-300", `/docs/${moonbitlang$core$builtin$$Show$to_string$9$(ty.path)}#${moonbitlang$core$builtin$$Show$to_string$9$(ty.name)}`, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-gray-700", [Yoorkin$rabbit$45$tea$html$$text$362$(ty.name)])], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$());
}
function moonbitlang$mooncakes$page$docs$$stype(ty) {
  switch (ty.$tag) {
    case 2: {
      const _Param = ty;
      const _name = _Param._0;
      return Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(_name)]);
    }
    case 1: {
      const _Arrow = ty;
      const _parameters = _Arrow._0;
      const _return_type = _Arrow._1;
      const _error_type = _Arrow._2;
      const _is_async = _Arrow._3;
      const async_indicator = _is_async ? Yoorkin$rabbit$45$tea$html$$text$362$("async ") : Yoorkin$rabbit$45$tea$html$$nothing$362$();
      let error_type_indicator;
      if (_error_type === undefined) {
        error_type_indicator = Yoorkin$rabbit$45$tea$html$$nothing$362$();
      } else {
        const _Some = _error_type;
        const _ty = _Some;
        error_type_indicator = Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "flex", [Yoorkin$rabbit$45$tea$html$$text$362$("!"), moonbitlang$mooncakes$page$docs$$stype(_ty)]);
      }
      const _tmp = Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$();
      const _self = [];
      moonbitlang$core$array$$Array$push$23$(_self, async_indicator);
      moonbitlang$core$array$$Array$push$23$(_self, Yoorkin$rabbit$45$tea$html$$text$362$("("));
      const _p = new Array(_parameters.length);
      const _p$2 = _parameters.length;
      let _tmp$2 = 0;
      while (true) {
        const _p$3 = _tmp$2;
        if (_p$3 < _p$2) {
          const _p$4 = _parameters[_p$3];
          _p[_p$3] = moonbitlang$mooncakes$page$docs$$stype(_p$4);
          _tmp$2 = _p$3 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$builtin$$Iter$iter$23$(moonbitlang$core$builtin$$Iter$intersperse$23$(moonbitlang$core$array$$Array$iter$23$(_p), Yoorkin$rabbit$45$tea$html$$text$362$(", "))));
      moonbitlang$core$array$$Array$push$23$(_self, Yoorkin$rabbit$45$tea$html$$text$362$(")"));
      moonbitlang$core$array$$Array$push$23$(_self, Yoorkin$rabbit$45$tea$html$$text$362$(" -> "));
      moonbitlang$core$array$$Array$push$23$(_self, moonbitlang$mooncakes$page$docs$$stype(_return_type));
      moonbitlang$core$array$$Array$push$23$(_self, error_type_indicator);
      return Yoorkin$rabbit$45$tea$html$$span$362$(_tmp, undefined, undefined, _self);
    }
    case 0: {
      const _Constr = ty;
      const _constr = _Constr._0;
      const _x = _Constr._1;
      if (_x.length === 0) {
        return moonbitlang$mooncakes$page$docs$$type_path(_constr);
      } else {
        const _tmp$3 = Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$();
        const _self$2 = [];
        moonbitlang$core$array$$Array$push$23$(_self$2, moonbitlang$mooncakes$page$docs$$type_path(_constr));
        moonbitlang$core$array$$Array$push$23$(_self$2, Yoorkin$rabbit$45$tea$html$$text$362$("["));
        const _p$3 = new Array(_x.length);
        const _p$4 = _x.length;
        let _tmp$4 = 0;
        while (true) {
          const _p$5 = _tmp$4;
          if (_p$5 < _p$4) {
            const _p$6 = _x[_p$5];
            _p$3[_p$5] = moonbitlang$mooncakes$page$docs$$stype(_p$6);
            _tmp$4 = _p$5 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        moonbitlang$core$array$$Array$push_iter$23$(_self$2, moonbitlang$core$builtin$$Iter$iter$23$(moonbitlang$core$builtin$$Iter$intersperse$23$(moonbitlang$core$array$$Array$iter$23$(_p$3), Yoorkin$rabbit$45$tea$html$$text$362$(", "))));
        moonbitlang$core$array$$Array$push$23$(_self$2, Yoorkin$rabbit$45$tea$html$$text$362$("]"));
        return Yoorkin$rabbit$45$tea$html$$span$362$(_tmp$3, undefined, undefined, _self$2);
      }
    }
    default: {
      const _TypePath = ty;
      const _path = _TypePath._0;
      return moonbitlang$mooncakes$page$docs$$type_path(_path);
    }
  }
}
function moonbitlang$mooncakes$page$docs$$signature_view(content) {
  return Yoorkin$rabbit$45$tea$html$$pre$362$(Yoorkin$rabbit$45$tea$html$$pre$46$style$46$default$362$(), undefined, "text-wrap flex items-center", [Yoorkin$rabbit$45$tea$html$$code$362$(Yoorkin$rabbit$45$tea$html$$code$46$style$46$default$362$(), undefined, "font-mono text-[0.95em] text-blue-800", [moonbitlang$mooncakes$view$$code_block$362$(content, true)])]);
}
function moonbitlang$mooncakes$page$docs$$ValueDoc$get_id(self) {
  return self.name;
}
function moonbitlang$mooncakes$page$docs$$value_doc(doc, folded, type_id) {
  const _docstring = doc.docstring;
  const _signature = doc.signature;
  const _loc = doc.loc;
  const id = moonbitlang$core$option$$Option$or$9$(moonbitlang$core$option$$Option$map$11$(type_id, (x) => `${moonbitlang$core$builtin$$Show$to_string$9$(x)}::${moonbitlang$core$builtin$$Show$to_string$9$(moonbitlang$mooncakes$page$docs$$ValueDoc$get_id(doc))}`), moonbitlang$mooncakes$page$docs$$ValueDoc$get_id(doc));
  const signature = moonbitlang$mooncakes$page$docs$$signature_view(_signature);
  const content = moonbitlang$mooncakes$view$$markdown$362$(_docstring, true);
  return moonbitlang$mooncakes$page$docs$$document_item(signature, content, folded, id, moonbitlang$mooncakes$page$docs$$document_item$46$tight$46$default(), _loc);
}
function moonbitlang$mooncakes$page$docs$$impl_doc(doc, folded) {
  const _self_type = doc.self_type;
  const _trait_type = doc.trait_type;
  const _methods = doc.methods;
  const id = moonbitlang$mooncakes$page$docs$$ImplDoc$get_id(doc);
  const signature = Yoorkin$rabbit$45$tea$html$$pre$362$(Yoorkin$rabbit$45$tea$html$$pre$46$style$46$default$362$(), undefined, "bg-gray-100 text-wrap pr-4", [Yoorkin$rabbit$45$tea$html$$code$362$(Yoorkin$rabbit$45$tea$html$$code$46$style$46$default$362$(), undefined, "font-mono text-[0.9em] text-[#0033b3]", [Yoorkin$rabbit$45$tea$html$$text$362$("impl "), moonbitlang$mooncakes$page$docs$$type_path(_trait_type), Yoorkin$rabbit$45$tea$html$$text$362$(" for "), Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-gray-700", [moonbitlang$mooncakes$page$docs$$stype(_self_type)])])]);
  const _tmp = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$();
  const _p = new Array(_methods.length);
  const _p$2 = _methods.length;
  let _tmp$2 = 0;
  while (true) {
    const _p$3 = _tmp$2;
    if (_p$3 < _p$2) {
      const _p$4 = _methods[_p$3];
      const _hole195 = _p$4;
      _p[_p$3] = moonbitlang$mooncakes$page$docs$$value_doc(_hole195, folded, undefined);
      _tmp$2 = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const content = Yoorkin$rabbit$45$tea$html$$div$362$(_tmp, undefined, "pl-4", undefined, _p);
  return moonbitlang$mooncakes$page$docs$$document_item(signature, content, folded, id, true, undefined);
}
function moonbitlang$mooncakes$page$docs$$MiscDoc$get_id(self) {
  return self.name;
}
function moonbitlang$mooncakes$page$docs$$misc_doc(doc, folded) {
  const _name = doc.name;
  const _methods = doc.methods;
  const _impls = doc.impls;
  const id = moonbitlang$mooncakes$page$docs$$MiscDoc$get_id(doc);
  const signature = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), _name, "py-1 w-full", undefined, [Yoorkin$rabbit$45$tea$html$$h3$362$(Yoorkin$rabbit$45$tea$html$$h3$46$style$46$default$362$(), undefined, "text-lg text-gray-800", [Yoorkin$rabbit$45$tea$html$$text$362$(_name)])]);
  const _bind = moonbitlang$core$builtin$$Map$get$11$(moonbitlang$mooncakes$config$$builtins_package_path, _name);
  let tips;
  if (_bind === undefined) {
    tips = Yoorkin$rabbit$45$tea$html$$nothing$362$();
  } else {
    const _Some = _bind;
    const _pkg_path = _Some;
    tips = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "bg-mooncake border-mooncake2 border-opacity-50 text-yellow-800 border rounded px-6 py-4 my-2", undefined, [Yoorkin$rabbit$45$tea$html$$h3$362$(Yoorkin$rabbit$45$tea$html$$h3$46$style$46$default$362$(), undefined, "text-base font-semibold", [Yoorkin$rabbit$45$tea$html$$text$362$("Note")]), Yoorkin$rabbit$45$tea$html$$p$362$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$(), undefined, "mt-2", [Yoorkin$rabbit$45$tea$html$$text$362$(`${moonbitlang$core$builtin$$Show$to_string$9$(_name)} is a built-in type. The documentation may not be complete here. You can find all methods and implementations in the `), Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, moonbitlang$mooncakes$page$docs$$misc_doc$46$package_link_class$124$124, `/docs/moonbitlang/core/builtin#${moonbitlang$core$builtin$$Show$to_string$9$(_name)}`, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [Yoorkin$rabbit$45$tea$html$$text$362$("core/builtin")], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$()), Yoorkin$rabbit$45$tea$html$$text$362$(" and "), Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, moonbitlang$mooncakes$page$docs$$misc_doc$46$package_link_class$124$124, `/docs/moonbitlang/${moonbitlang$core$builtin$$Show$to_string$9$(_pkg_path)}#${moonbitlang$core$builtin$$Show$to_string$9$(_name)}`, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [Yoorkin$rabbit$45$tea$html$$text$362$(`core/${moonbitlang$core$builtin$$Show$to_string$9$(moonbitlang$core$string$$String$to_lower(_name))}`)], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$()), Yoorkin$rabbit$45$tea$html$$text$362$(" package.")])]);
  }
  const _tmp = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$();
  const _self = [];
  moonbitlang$core$array$$Array$push$23$(_self, tips);
  const _p = new Array(_methods.length);
  const _p$2 = _methods.length;
  let _tmp$2 = 0;
  while (true) {
    const _p$3 = _tmp$2;
    if (_p$3 < _p$2) {
      const _p$4 = _methods[_p$3];
      const _hole127 = _p$4;
      _p[_p$3] = moonbitlang$mooncakes$page$docs$$value_doc(_hole127, folded, id);
      _tmp$2 = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(_p));
  const _p$3 = new Array(_impls.length);
  const _p$4 = _impls.length;
  let _tmp$3 = 0;
  while (true) {
    const _p$5 = _tmp$3;
    if (_p$5 < _p$4) {
      const _p$6 = _impls[_p$5];
      const _hole129 = _p$6;
      _p$3[_p$5] = moonbitlang$mooncakes$page$docs$$impl_doc(_hole129, folded);
      _tmp$3 = _p$5 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(_p$3));
  const content = Yoorkin$rabbit$45$tea$html$$div$362$(_tmp, undefined, "ml-3 my-2", undefined, _self);
  return moonbitlang$mooncakes$page$docs$$document_item(signature, content, folded, id, moonbitlang$mooncakes$page$docs$$document_item$46$tight$46$default(), undefined);
}
function moonbitlang$mooncakes$page$docs$$sub_section_title(title, item_count) {
  return item_count === 0 ? Yoorkin$rabbit$45$tea$html$$nothing$362$() : Yoorkin$rabbit$45$tea$html$$h1$362$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$362$(), undefined, "text-xs font-bold py-2 text-blue-900", [Yoorkin$rabbit$45$tea$html$$text$362$(title)]);
}
function moonbitlang$mooncakes$page$docs$$TraitDoc$get_id(self) {
  return self.name;
}
function moonbitlang$mooncakes$page$docs$$trait_doc(doc, folded) {
  const _docstring = doc.docstring;
  const _signature = doc.signature;
  const _impls = doc.impls;
  const _loc = doc.loc;
  const id = moonbitlang$mooncakes$page$docs$$TraitDoc$get_id(doc);
  const signature = moonbitlang$mooncakes$page$docs$$signature_view(_signature);
  const _tmp = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$();
  const _self = [];
  moonbitlang$core$array$$Array$push$23$(_self, moonbitlang$mooncakes$view$$markdown$362$(_docstring, true));
  moonbitlang$core$array$$Array$push$23$(_self, moonbitlang$mooncakes$page$docs$$sub_section_title("Implementation", _impls.length));
  const _p = new Array(_impls.length);
  const _p$2 = _impls.length;
  let _tmp$2 = 0;
  while (true) {
    const _p$3 = _tmp$2;
    if (_p$3 < _p$2) {
      const _p$4 = _impls[_p$3];
      const _hole171 = _p$4;
      _p[_p$3] = moonbitlang$mooncakes$page$docs$$impl_doc(_hole171, folded);
      _tmp$2 = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(_p));
  const content = Yoorkin$rabbit$45$tea$html$$div$362$(_tmp, undefined, undefined, undefined, _self);
  return moonbitlang$mooncakes$page$docs$$document_item(signature, content, folded, id, moonbitlang$mooncakes$page$docs$$document_item$46$tight$46$default(), _loc);
}
function moonbitlang$mooncakes$page$docs$$TypeAliasDoc$get_id(self) {
  return self.name;
}
function moonbitlang$mooncakes$page$docs$$type_alias_doc(doc, folded) {
  const _docstring = doc.docstring;
  const _signature = doc.signature;
  const _loc = doc.loc;
  const signature = moonbitlang$mooncakes$page$docs$$signature_view(_signature);
  const content = moonbitlang$mooncakes$view$$markdown$362$(_docstring, true);
  const id = moonbitlang$mooncakes$page$docs$$TypeAliasDoc$get_id(doc);
  return moonbitlang$mooncakes$page$docs$$document_item(signature, content, folded, id, moonbitlang$mooncakes$page$docs$$document_item$46$tight$46$default(), _loc);
}
function moonbitlang$mooncakes$page$docs$$TypeDoc$get_id(self) {
  return self.name;
}
function moonbitlang$mooncakes$page$docs$$type_doc(doc, folded) {
  const _docstring = doc.docstring;
  const _signature = doc.signature;
  const _methods = doc.methods;
  const _impls = doc.impls;
  const _loc = doc.loc;
  const id = moonbitlang$mooncakes$page$docs$$TypeDoc$get_id(doc);
  const signature = moonbitlang$mooncakes$page$docs$$signature_view(_signature);
  const _tmp = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$();
  const _self = [];
  moonbitlang$core$array$$Array$push$23$(_self, moonbitlang$mooncakes$view$$markdown$362$(_docstring, true));
  const _p = new Array(_methods.length);
  const _p$2 = _methods.length;
  let _tmp$2 = 0;
  while (true) {
    const _p$3 = _tmp$2;
    if (_p$3 < _p$2) {
      const _p$4 = _methods[_p$3];
      const _hole183 = _p$4;
      _p[_p$3] = moonbitlang$mooncakes$page$docs$$value_doc(_hole183, folded, id);
      _tmp$2 = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(_p));
  const _p$3 = new Array(_impls.length);
  const _p$4 = _impls.length;
  let _tmp$3 = 0;
  while (true) {
    const _p$5 = _tmp$3;
    if (_p$5 < _p$4) {
      const _p$6 = _impls[_p$5];
      const _hole185 = _p$6;
      _p$3[_p$5] = moonbitlang$mooncakes$page$docs$$impl_doc(_hole185, folded);
      _tmp$3 = _p$5 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(_p$3));
  const content = Yoorkin$rabbit$45$tea$html$$div$362$(_tmp, undefined, undefined, undefined, _self);
  return moonbitlang$mooncakes$page$docs$$document_item(signature, content, folded, id, moonbitlang$mooncakes$page$docs$$document_item$46$tight$46$default(), _loc);
}
function moonbitlang$mooncakes$page$docs$$document$46$section_title$124$100(id, title, item_count) {
  return item_count === 0 ? Yoorkin$rabbit$45$tea$html$$nothing$362$() : Yoorkin$rabbit$45$tea$html$$h1$362$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$362$(), id, "text-sm font-semibold pb-2 pt-4 text-gray-800", [Yoorkin$rabbit$45$tea$html$$text$362$(title)]);
}
function moonbitlang$mooncakes$page$docs$$document(readme_content, package_data, folded) {
  let readme;
  _L: {
    _L$2: {
      if (readme_content === undefined) {
        break _L$2;
      } else {
        const _Some = readme_content;
        const _x = _Some;
        if (_x === "") {
          break _L$2;
        } else {
          const content = moonbitlang$mooncakes$view$$markdown$362$(_x, moonbitlang$mooncakes$view$$markdown$46$small_heading$46$default$362$());
          readme = moonbitlang$mooncakes$view$$collapse$362$(Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "py-2 pl-6 text-sm font-bold text-gray-700", undefined, [Yoorkin$rabbit$45$tea$html$$p$362$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$("README")])]), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "pl-6", undefined, [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "mr-4 mb-6", undefined, [content])]), moonbitlang$mooncakes$page$docs$$FoldedState$contains(folded, "readme"), new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleDocDetail("readme"), 0);
        }
      }
      break _L;
    }
    readme = Yoorkin$rabbit$45$tea$html$$nothing$362$();
  }
  let doc_list;
  _L$2: {
    _L$3: {
      if (package_data === undefined) {
        break _L$3;
      } else {
        const _Some = package_data;
        const _x = _Some;
        if (_x.$tag === 2) {
          const _Success = _x;
          const _x$2 = _Success._0;
          const _traits = _x$2.traits;
          const _types = _x$2.types;
          const _typealiases = _x$2.typealiases;
          const _values = _x$2.values;
          const _misc = _x$2.misc;
          const _self = [];
          moonbitlang$core$array$$Array$push$23$(_self, moonbitlang$mooncakes$page$docs$$document$46$section_title$124$100("trait-section", "Traits", _traits.length));
          const _p = new Array(_traits.length);
          const _p$2 = _traits.length;
          let _tmp = 0;
          while (true) {
            const _p$3 = _tmp;
            if (_p$3 < _p$2) {
              const _p$4 = _traits[_p$3];
              const _hole104 = _p$4;
              _p[_p$3] = moonbitlang$mooncakes$page$docs$$trait_doc(_hole104, folded);
              _tmp = _p$3 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(_p));
          moonbitlang$core$array$$Array$push$23$(_self, moonbitlang$mooncakes$page$docs$$document$46$section_title$124$100("type-section", "Types", _types.length));
          const _p$3 = new Array(_types.length);
          const _p$4 = _types.length;
          let _tmp$2 = 0;
          while (true) {
            const _p$5 = _tmp$2;
            if (_p$5 < _p$4) {
              const _p$6 = _types[_p$5];
              const _hole106 = _p$6;
              _p$3[_p$5] = moonbitlang$mooncakes$page$docs$$type_doc(_hole106, folded);
              _tmp$2 = _p$5 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(_p$3));
          const _p$5 = new Array(_typealiases.length);
          const _p$6 = _typealiases.length;
          let _tmp$3 = 0;
          while (true) {
            const _p$7 = _tmp$3;
            if (_p$7 < _p$6) {
              const _p$8 = _typealiases[_p$7];
              const _hole108 = _p$8;
              _p$5[_p$7] = moonbitlang$mooncakes$page$docs$$type_alias_doc(_hole108, folded);
              _tmp$3 = _p$7 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(_p$5));
          moonbitlang$core$array$$Array$push$23$(_self, moonbitlang$mooncakes$page$docs$$document$46$section_title$124$100("value-section", "Values & Functions", _values.length + _misc.length | 0));
          const _p$7 = new Array(_values.length);
          const _p$8 = _values.length;
          let _tmp$4 = 0;
          while (true) {
            const _p$9 = _tmp$4;
            if (_p$9 < _p$8) {
              const _p$10 = _values[_p$9];
              const _hole110 = _p$10;
              _p$7[_p$9] = moonbitlang$mooncakes$page$docs$$value_doc(_hole110, folded, undefined);
              _tmp$4 = _p$9 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(_p$7));
          const _p$9 = new Array(_misc.length);
          const _p$10 = _misc.length;
          let _tmp$5 = 0;
          while (true) {
            const _p$11 = _tmp$5;
            if (_p$11 < _p$10) {
              const _p$12 = _misc[_p$11];
              const _hole112 = _p$12;
              _p$9[_p$11] = moonbitlang$mooncakes$page$docs$$misc_doc(_hole112, folded);
              _tmp$5 = _p$11 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          moonbitlang$core$array$$Array$push_iter$23$(_self, moonbitlang$core$array$$Array$iter$23$(_p$9));
          doc_list = _self;
        } else {
          break _L$3;
        }
      }
      break _L$2;
    }
    doc_list = [];
  }
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "contents-center flex flex-col pl-2 sm:pl-6 p-4 pr-2 sm:pr-16 pb-20 w-full", undefined, [readme, Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "pl-6", undefined, doc_list)]);
}
function moonbitlang$mooncakes$page$docs$$install_view(command, copied) {
  const icon = copied ? moonbitlang$mooncakes$config$$ok : moonbitlang$mooncakes$config$$clipboard;
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "hover:bg-gray-100 active:bg-gray-200 bg-white shadow-sm transition-colors text-black text-sm px-3 p-2 font-roboto border rounded outline-none flex justify-between items-center gap-2", new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$CopyInstallCommand(command), [Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "overflow-x-auto text-nowrap", [Yoorkin$rabbit$45$tea$html$$text$362$(command)]), Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, "size-4", icon, undefined, undefined, undefined, undefined, undefined, [])]);
}
function moonbitlang$mooncakes$page$docs$$meta_info_item_view(title, elem, icon) {
  let title_content;
  if (icon === undefined) {
    title_content = Yoorkin$rabbit$45$tea$html$$text$362$(title);
  } else {
    const _Some = icon;
    const _icon_src = _Some;
    title_content = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "flex items-center gap-2", undefined, [Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, "w-[14px] h-[14px]", _icon_src, undefined, undefined, undefined, undefined, undefined, []), Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-gray-700", [Yoorkin$rabbit$45$tea$html$$text$362$(title)])]);
  }
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "flex border-t flex-col gap-2 text-gray-800 px-8 py-4 grow", undefined, [Yoorkin$rabbit$45$tea$html$$p$362$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$(), undefined, "font-bold text-sm", [title_content]), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "grow", undefined, [elem])]);
}
function moonbitlang$mooncakes$page$docs$$tag_view(value) {
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "self-center border rounded bg-zinc-50 px-2 text-[12px] text-gray-600 overflow-hidden", undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(value)]);
}
function moonbitlang$mooncakes$page$docs$$meta_info(model, install_copied) {
  const _bind = model.license;
  let model_license;
  if (_bind === undefined) {
    model_license = Yoorkin$rabbit$45$tea$html$$nothing$362$();
  } else {
    const _Some = _bind;
    const _l = _Some;
    model_license = moonbitlang$mooncakes$page$docs$$meta_info_item_view("License", Yoorkin$rabbit$45$tea$html$$p$362$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(_l)]), moonbitlang$mooncakes$config$$license);
  }
  const _bind$2 = model.repository;
  let model_repo;
  if (_bind$2 === undefined) {
    model_repo = Yoorkin$rabbit$45$tea$html$$nothing$362$();
  } else {
    const _Some = _bind$2;
    const _repo = _Some;
    model_repo = moonbitlang$mooncakes$page$docs$$meta_info_item_view("Repository", Yoorkin$rabbit$45$tea$html$$p$362$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, "hover:underline", _repo, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [Yoorkin$rabbit$45$tea$html$$text$362$(_repo)], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$())]), moonbitlang$mooncakes$config$$repo);
  }
  const _tmp = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$();
  const _tmp$2 = Yoorkin$rabbit$45$tea$html$$h1$362$(Yoorkin$rabbit$45$tea$html$$h1$46$style$46$default$362$(), undefined, "text-2xl font-bold mb-4", [Yoorkin$rabbit$45$tea$html$$text$362$(moonbitlang$core$builtin$$Show$to_string$16$(moonbitlang$core$option$$Option$unwrap$16$(moonbitlang$core$builtin$$Iter$last$16$(moonbitlang$core$string$$String$split(model.name, { str: moonbitlang$mooncakes$page$docs$$meta_info$46$42$bind$124$2339, start: 0, end: moonbitlang$mooncakes$page$docs$$meta_info$46$42$bind$124$2339.length })))))]);
  const _bind$3 = model.description;
  let _tmp$3;
  if (_bind$3 === undefined) {
    _tmp$3 = Yoorkin$rabbit$45$tea$html$$nothing$362$();
  } else {
    const _Some = _bind$3;
    const _d = _Some;
    _tmp$3 = Yoorkin$rabbit$45$tea$html$$p$362$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$(), undefined, "text-gray-600 flex items-center text-sm", [Yoorkin$rabbit$45$tea$html$$text$362$(_d)]);
  }
  const _tmp$4 = _tmp$3;
  const _tmp$5 = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$();
  const _p = model.keywords;
  const _p$2 = new Array(_p.length);
  const _p$3 = _p.length;
  let _tmp$6 = 0;
  while (true) {
    const _p$4 = _tmp$6;
    if (_p$4 < _p$3) {
      const _p$5 = _p[_p$4];
      _p$2[_p$4] = moonbitlang$mooncakes$page$docs$$tag_view(_p$5);
      _tmp$6 = _p$4 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const model_description = Yoorkin$rabbit$45$tea$html$$div$362$(_tmp, undefined, "pl-7 py-4", undefined, [_tmp$2, _tmp$4, Yoorkin$rabbit$45$tea$html$$div$362$(_tmp$5, undefined, "flex gap-2 my-2", undefined, _p$2)]);
  const _tmp$7 = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$();
  const _tmp$8 = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "flex flex-wrap content-stretch", undefined, moonbitlang$core$builtin$$Iter$collect$23$(moonbitlang$core$builtin$$Iter$intersperse$23$(moonbitlang$core$array$$Array$iter$23$([moonbitlang$mooncakes$page$docs$$meta_info_item_view("Author", Yoorkin$rabbit$45$tea$html$$p$362$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(model.author)]), moonbitlang$mooncakes$config$$user), moonbitlang$mooncakes$page$docs$$meta_info_item_view("Version", Yoorkin$rabbit$45$tea$html$$p$362$(Yoorkin$rabbit$45$tea$html$$p$46$style$46$default$362$(), undefined, undefined, [Yoorkin$rabbit$45$tea$html$$text$362$(model.version)]), moonbitlang$mooncakes$config$$tag), model_license, model_repo]), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "", undefined, []))));
  let _tmp$9;
  if (moonbitlang$core$array$$Array$is_empty$222$(model.deps)) {
    _tmp$9 = Yoorkin$rabbit$45$tea$html$$nothing$362$();
  } else {
    const _tmp$10 = Yoorkin$rabbit$45$tea$html$$ul$46$style$46$default$362$();
    const _p$4 = model.deps;
    const _p$5 = new Array(_p$4.length);
    const _p$6 = _p$4.length;
    let _tmp$11 = 0;
    while (true) {
      const _p$7 = _tmp$11;
      if (_p$7 < _p$6) {
        const _p$8 = _p$4[_p$7];
        const _param9 = _p$8;
        const _name = _param9._0;
        const _version = _param9._1;
        _p$5[_p$7] = Yoorkin$rabbit$45$tea$html$$li$362$(Yoorkin$rabbit$45$tea$html$$li$46$style$46$default$362$(), undefined, undefined, "font-roboto text-sm text-gray-300", undefined, [Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, "hover:underline text-gray-900", `/docs/${moonbitlang$core$builtin$$Show$to_string$9$(_name)}`, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [Yoorkin$rabbit$45$tea$html$$text$362$(_name)], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$()), Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-gray-500", [Yoorkin$rabbit$45$tea$html$$text$362$(` ${_version}`)])]);
        _tmp$11 = _p$7 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    _tmp$9 = moonbitlang$mooncakes$page$docs$$meta_info_item_view("Dependencies", Yoorkin$rabbit$45$tea$html$$ul$362$(_tmp$10, undefined, "", undefined, _p$5), moonbitlang$mooncakes$config$$deps);
  }
  return Yoorkin$rabbit$45$tea$html$$div$362$(_tmp$7, undefined, "mx-7 my-4 py-2 bg-gray-50 rounded overflow-clip", undefined, [model_description, _tmp$8, _tmp$9, moonbitlang$mooncakes$page$docs$$meta_info_item_view("Install", model.name === "moonbitlang/core" ? Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "text-gray-600", undefined, [Yoorkin$rabbit$45$tea$html$$text$362$("This module is installed by default.")]) : moonbitlang$mooncakes$page$docs$$install_view(`moon add ${moonbitlang$core$builtin$$Show$to_string$9$(model.name)}@${moonbitlang$core$builtin$$Show$to_string$9$(model.version)}`, install_copied), moonbitlang$mooncakes$config$$terminal)]);
}
function moonbitlang$mooncakes$page$docs$$item_button$362$(childrens, icon, click) {
  let icon$2;
  if (icon === undefined) {
    icon$2 = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, undefined, undefined, []);
  } else {
    const _Some = icon;
    const _src = _Some;
    icon$2 = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "size-[12px] self-center mr-1", undefined, [Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, undefined, _src, undefined, undefined, undefined, undefined, undefined, [])]);
  }
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "hover:bg-gray-100 px-2 py-1 rounded text-sm flex", click, [icon$2, childrens]);
}
function moonbitlang$mooncakes$page$docs$$source_list(files, package_path) {
  if (moonbitlang$core$array$$Array$is_empty$9$(files)) {
    return Yoorkin$rabbit$45$tea$html$$text$362$("No source files.");
  }
  const package_path$2 = moonbitlang$core$string$$String$trim(package_path, { str: moonbitlang$mooncakes$page$docs$$source_list$46$42$bind$124$2436, start: 0, end: moonbitlang$mooncakes$page$docs$$source_list$46$42$bind$124$2436.length });
  const _tmp = Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$();
  const _tmp$2 = Yoorkin$rabbit$45$tea$html$$ul$46$style$46$default$362$();
  const _p = new Array(files.length);
  const _p$2 = files.length;
  let _tmp$3 = 0;
  while (true) {
    const _p$3 = _tmp$3;
    if (_p$3 < _p$2) {
      const _p$4 = files[_p$3];
      const x = _p$4;
      _p[_p$3] = moonbitlang$mooncakes$page$docs$$item_button$362$(Yoorkin$rabbit$45$tea$html$$a$362$(Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$(), undefined, "w-full", `/assets/${moonbitlang$core$builtin$$Show$to_string$16$(package_path$2)}/${moonbitlang$core$builtin$$Show$to_string$9$(x)}.html`, Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$(), [Yoorkin$rabbit$45$tea$html$$text$362$(x)], true), undefined, undefined);
      _tmp$3 = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return Yoorkin$rabbit$45$tea$html$$div$362$(_tmp, undefined, "", undefined, [Yoorkin$rabbit$45$tea$html$$ul$362$(_tmp$2, undefined, undefined, undefined, _p)]);
}
function moonbitlang$mooncakes$page$docs$$sidebar(document_index, source_files, showing, package_path, sidebar_state) {
  return moonbitlang$mooncakes$view$$accordion$362$("text-gray-700 flex flex-col", (_hole362) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$SidebarTabClicked(_hole362), showing, [{ _0: "Documentation", _1: moonbitlang$mooncakes$view$tree$$view$381$((_hole364) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleSidebarItem(_hole364), (_hole366) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ClickSidebarItem(_hole366), sidebar_state, new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$ItemTarget$Symbol(""), document_index) }, { _0: "Source files", _1: moonbitlang$mooncakes$page$docs$$source_list(source_files, package_path) }]);
}
function moonbitlang$mooncakes$page$docs$$view(model) {
  let navbar;
  _L: {
    _L$2: {
      const _bind = model.module_index;
      const _bind$2 = model.resource;
      if (_bind.$tag === 2) {
        const _Success = _bind;
        const _module_index = _Success._0;
        if (_bind$2.$tag === 2) {
          const _Success$2 = _bind$2;
          const _resource = _Success$2._0;
          const _bind$3 = _resource.kind;
          let module_path;
          switch (_bind$3.$tag) {
            case 1: {
              const _Module = _bind$3;
              const _x = _Module._0;
              const _meta_info = _x.meta_info;
              module_path = _meta_info.name;
              break;
            }
            case 0: {
              const _Package = _bind$3;
              const _x$2 = _Package._0;
              const _module_path = _x$2.module_path;
              module_path = _module_path;
              break;
            }
            default: {
              module_path = model.path;
            }
          }
          navbar = moonbitlang$mooncakes$page$docs$$navbar(model.path, moonbitlang$core$option$$Option$or$9$(module_path, ""), _module_index, model.collapsed_docs.card_mode);
        } else {
          break _L$2;
        }
      } else {
        break _L$2;
      }
      break _L;
    }
    navbar = Yoorkin$rabbit$45$tea$html$$nothing$362$();
  }
  let source_files;
  _L$2: {
    _L$3: {
      const _bind = model.resource;
      if (_bind.$tag === 2) {
        const _Success = _bind;
        const _x = _Success._0;
        const _x$2 = _x.kind;
        switch (_x$2.$tag) {
          case 0: {
            const _Package = _x$2;
            const _x$3 = _Package._0;
            const _source_files = _x$3.source_files;
            source_files = _source_files;
            break;
          }
          case 2: {
            const _RootPackage = _x$2;
            const _x$4 = _RootPackage._0;
            const _source_files$2 = _x$4.source_files;
            source_files = _source_files$2;
            break;
          }
          default: {
            break _L$3;
          }
        }
      } else {
        break _L$3;
      }
      break _L$2;
    }
    source_files = [];
  }
  const sidebar_ele = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "w-full h-full flex justify-end", undefined, [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "pl-6 pr-3 py-3 overflow-y-scroll w-full 2xl:w-2/3", undefined, [moonbitlang$mooncakes$page$docs$$sidebar(model.sidebar_document, source_files, model.sidebar_tab, model.path, model.sidebar_collapsed)])]);
  const _bind = model.resource;
  let main;
  switch (_bind.$tag) {
    case 2: {
      const _Success = _bind;
      const _x = _Success._0;
      const _readme_content = _x.readme_content;
      const _kind = _x.kind;
      let meta;
      let meta$2;
      _L$3: {
        _L$4: {
          switch (_kind.$tag) {
            case 1: {
              const _Module = _kind;
              const _x$2 = _Module._0;
              const _meta = _x$2.meta_info;
              meta$2 = _meta;
              break _L$4;
            }
            case 2: {
              const _RootPackage = _kind;
              const _x$3 = _RootPackage._0;
              const _meta$2 = _x$3.meta_info;
              meta$2 = _meta$2;
              break _L$4;
            }
            default: {
              meta = Yoorkin$rabbit$45$tea$html$$nothing$362$();
            }
          }
          break _L$3;
        }
        meta = moonbitlang$mooncakes$page$docs$$meta_info(meta$2, model.install_copied);
      }
      main = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "flex w-full min-h-full justify-begin", undefined, [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "overflow-y-auto 2xl:w-4/5", undefined, [meta, moonbitlang$mooncakes$page$docs$$document(_readme_content, model.package_data, model.collapsed_docs)])]);
      break;
    }
    case 1: {
      main = moonbitlang$mooncakes$view$$document_not_available$362$(model.path);
      break;
    }
    default: {
      main = moonbitlang$mooncakes$view$$loading$362$();
    }
  }
  const search = model.search;
  const _tmp = Yoorkin$rabbit$45$tea$html$$dialog$46$style$46$default$362$();
  const _tmp$2 = Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "h-12 border-b bg-white rounded-none sticky top-0 text-base w-full flex", undefined, [Yoorkin$rabbit$45$tea$html$$input$362$(18, undefined, search.filter, -1, -1, -1, undefined, "search...", undefined, Yoorkin$rabbit$45$tea$html$$input$46$style$46$default$362$(), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, "outline-none m-0 flex-grow px-4 p-2", Yoorkin$rabbit$45$tea$html$$input$46$childrens$46$default$362$(), undefined, (_hole444) => new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$SearchFilterChanged(_hole444)), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "size-12 container hover:bg-gray-200 flex justify-center items-center", new $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleSearchPanel(false), [Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, undefined, moonbitlang$mooncakes$config$$icon_close, undefined, undefined, undefined, undefined, undefined, [])])]);
  const _bind$2 = search.results;
  let _tmp$3;
  switch (_bind$2.$tag) {
    case 0: {
      _tmp$3 = Yoorkin$rabbit$45$tea$html$$nothing$362$();
      break;
    }
    case 1: {
      _tmp$3 = Yoorkin$rabbit$45$tea$html$$text$362$("load indices failed");
      break;
    }
    default: {
      const _Success$2 = _bind$2;
      const _results = _Success$2._0;
      const _tmp$4 = Yoorkin$rabbit$45$tea$html$$ul$46$style$46$default$362$();
      const _p = new Array(_results.length);
      const _p$2 = _results.length;
      let _tmp$5 = 0;
      while (true) {
        const _p$3 = _tmp$5;
        if (_p$3 < _p$2) {
          const _p$4 = _results[_p$3];
          const x = _p$4;
          const _bind$3 = x.entry.kind;
          let color;
          switch (_bind$3) {
            case "Package": {
              color = "text-yellow-700";
              break;
            }
            case "Trait": {
              color = "text-blue-700";
              break;
            }
            case "Type": {
              color = "text-green-700";
              break;
            }
            case "Method": {
              color = "text-moonbit";
              break;
            }
            case "Value": {
              color = "text-purple-700";
              break;
            }
            default: {
              color = "text-gray-700";
            }
          }
          const _tmp$6 = Yoorkin$rabbit$45$tea$html$$li$46$style$46$default$362$();
          const _tmp$7 = Yoorkin$rabbit$45$tea$html$$a$46$style$46$default$362$();
          const _tmp$8 = x.entry.href;
          const _tmp$9 = Yoorkin$rabbit$45$tea$html$$a$46$target$46$default$362$();
          const _tmp$10 = Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$();
          const _p$5 = x.matching;
          const _p$6 = new Array(_p$5.length);
          const _p$7 = _p$5.length;
          let _tmp$11 = 0;
          while (true) {
            const _p$8 = _tmp$11;
            if (_p$8 < _p$7) {
              const _p$9 = _p$5[_p$8];
              const _param4 = _p$9;
              const _x$2 = _param4._0;
              let _tmp$12;
              if (_x$2 === true) {
                const _str = _param4._1;
                _tmp$12 = Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-moonbit font-semibold", [Yoorkin$rabbit$45$tea$html$$text$362$(moonbitlang$core$builtin$$Show$to_string$16$(_str))]);
              } else {
                const _str = _param4._1;
                _tmp$12 = Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, "text-gray-600", [Yoorkin$rabbit$45$tea$html$$text$362$(moonbitlang$core$builtin$$Show$to_string$16$(_str))]);
              }
              _p$6[_p$8] = _tmp$12;
              _tmp$11 = _p$8 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          _p[_p$3] = Yoorkin$rabbit$45$tea$html$$li$362$(_tmp$6, undefined, undefined, "border-b px-4 py-2 bg-white hover:bg-gray-100", undefined, [Yoorkin$rabbit$45$tea$html$$a$362$(_tmp$7, undefined, "grid grid-cols-[1fr_auto] ", _tmp$8, _tmp$9, [Yoorkin$rabbit$45$tea$html$$span$362$(_tmp$10, undefined, "", _p$6), Yoorkin$rabbit$45$tea$html$$span$362$(Yoorkin$rabbit$45$tea$html$$span$46$style$46$default$362$(), undefined, `font-thin text-tiny lg:text-base ${moonbitlang$core$builtin$$Show$to_string$9$(color)}`, [Yoorkin$rabbit$45$tea$html$$text$362$(x.entry.kind)])], Yoorkin$rabbit$45$tea$html$$a$46$escape$46$default$362$())]);
          _tmp$5 = _p$3 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp$3 = Yoorkin$rabbit$45$tea$html$$ul$362$(_tmp$4, undefined, "overflow-y-scroll flex-grow", undefined, _p);
    }
  }
  const search_panel = Yoorkin$rabbit$45$tea$html$$dialog$362$(_tmp, "search-panel", "lg:backdrop:bg-black/30 lg:backdrop:backdrop-blur lg:rounded lg:shadow-lg absolute max-w-none max-h-none w-full h-screen m-0 lg:m-auto lg:w-2/5 lg:h-[80%]", -1, undefined, undefined, [_tmp$2, _tmp$3]);
  const show_sidebar_dialog = model.sidebar_fab ? "flex" : "none";
  const sidebar_dialog = Yoorkin$rabbit$45$tea$html$$div$362$([`display: ${show_sidebar_dialog}`], undefined, "fixed inset-0 justify-center items-center", undefined, [Yoorkin$rabbit$45$tea$html$$div$362$([`display: ${show_sidebar_dialog}`], undefined, "fixed inset-0 bg-black bg-opacity-40 z-10", $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleSidebarFab, []), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "bg-white w-3/4 h-3/4 overflow-y-auto rounded p-4 shadow-lg z-20", undefined, [moonbitlang$mooncakes$page$docs$$sidebar(model.sidebar_document, source_files, model.sidebar_tab, model.path, model.sidebar_collapsed)])]);
  const fab = Yoorkin$rabbit$45$tea$html$$button$362$(Yoorkin$rabbit$45$tea$html$$button$46$style$46$default$362$(), undefined, "flex lg:hidden fixed bottom-4 right-4 bg-mooncake2 text-white rounded-full shadow-lg w-12 h-12 items-center justify-center cursor-pointer hover:bg-moonbit-dark transition-all select-none", $64$moonbitlang$47$mooncakes$47$page$47$docs$46$Msg$ToggleSidebarFab, [Yoorkin$rabbit$45$tea$html$$img$362$(Yoorkin$rabbit$45$tea$html$$img$46$style$46$default$362$(), undefined, "size-5", "/hamburger-button.svg", undefined, undefined, undefined, undefined, undefined, [])]);
  return Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "grid grid-rows-[3em_0_auto] grid-cols-1 lg:grid-rows-[3em_auto] lg:grid-cols-4 h-screen", undefined, [Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "bg-[#f7f7f7] col-start-1 row-start-1 hidden lg:block lg:col-start-1 col-span-1 lg:row-start-1 row-span-1", undefined, [moonbitlang$mooncakes$page$docs$$logo()]), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "col-start-1 row-start-1 lg:col-start-2 col-span-3 lg:row-start-1 row-span-1", undefined, [navbar]), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "bg-[#f7f7f7] col-start-1 row-start-2 lg:col-start-1 col-span-1 lg:row-start-2 lg:row-span-2 overflow-y-scroll scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-transparent", undefined, [sidebar_ele]), Yoorkin$rabbit$45$tea$html$$div$362$(Yoorkin$rabbit$45$tea$html$$div$46$style$46$default$362$(), undefined, "col-start-1 row-start-3 lg:col-start-2 lg:col-span-3 lg:row-start-2 lg:row-span-2 overflow-y-scroll scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-transparent", undefined, [main]), search_panel, sidebar_dialog, fab]);
}
function moonbitlang$mooncakes$main$$update_with$400$(pair, to_model, to_msg) {
  const _cmd = pair._0;
  const _model = pair._1;
  return { _0: Yoorkin$rabbit$45$tea$cmd$$Cmd$map$364$(_cmd, to_msg), _1: to_model(_model) };
}
function moonbitlang$mooncakes$main$$update_with$401$(pair, to_model, to_msg) {
  const _cmd = pair._0;
  const _model = pair._1;
  return { _0: Yoorkin$rabbit$45$tea$cmd$$Cmd$map$365$(_cmd, to_msg), _1: to_model(_model) };
}
function moonbitlang$mooncakes$main$$route(url) {
  const paths = moonbitlang$core$builtin$$Iter$collect$16$(moonbitlang$core$string$$String$split(url.path, { str: moonbitlang$mooncakes$main$$route$46$42$bind$124$82, start: 0, end: moonbitlang$mooncakes$main$$route$46$42$bind$124$82.length }));
  _L: {
    let module_path;
    _L$2: {
      _L$3: {
        _L$4: {
          if (paths.length === 1) {
            const _x = paths[0];
            if (moonbitlang$core$string$$String$char_length_eq(_x.str, 1, _x.start, _x.end)) {
              const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 0, _x.start, _x.end));
              if (_x$2 === 47) {
                break _L$4;
              } else {
                break _L;
              }
            } else {
              if (moonbitlang$core$string$$String$char_length_eq(_x.str, 0, _x.start, _x.end)) {
                break _L$4;
              } else {
                if (moonbitlang$core$string$$String$char_length_eq(_x.str, 6, _x.start, _x.end)) {
                  const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 0, _x.start, _x.end));
                  if (_x$2 === 97) {
                    const _x$3 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 1, _x.start, _x.end));
                    if (_x$3 === 115) {
                      const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 2, _x.start, _x.end));
                      if (_x$4 === 115) {
                        const _x$5 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 3, _x.start, _x.end));
                        if (_x$5 === 101) {
                          const _x$6 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 4, _x.start, _x.end));
                          if (_x$6 === 116) {
                            const _x$7 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 5, _x.start, _x.end));
                            if (_x$7 === 115) {
                              break _L$3;
                            } else {
                              break _L;
                            }
                          } else {
                            break _L;
                          }
                        } else {
                          break _L;
                        }
                      } else {
                        break _L;
                      }
                    } else {
                      break _L;
                    }
                  } else {
                    break _L;
                  }
                } else {
                  if (moonbitlang$core$string$$String$char_length_eq(_x.str, 4, _x.start, _x.end)) {
                    const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 0, _x.start, _x.end));
                    if (_x$2 === 100) {
                      const _x$3 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 1, _x.start, _x.end));
                      if (_x$3 === 111) {
                        const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 2, _x.start, _x.end));
                        if (_x$4 === 99) {
                          const _x$5 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 3, _x.start, _x.end));
                          if (_x$5 === 115) {
                            const _x$6 = moonbitlang$core$array$$Array$op_as_view$16$(paths, 1, paths.length);
                            module_path = _x$6;
                            break _L$2;
                          } else {
                            break _L;
                          }
                        } else {
                          break _L;
                        }
                      } else {
                        break _L;
                      }
                    } else {
                      break _L;
                    }
                  } else {
                    break _L;
                  }
                }
              }
            }
          } else {
            if (paths.length === 0) {
              break _L$4;
            } else {
              const _x = paths[0];
              if (moonbitlang$core$string$$String$char_length_eq(_x.str, 6, _x.start, _x.end)) {
                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 0, _x.start, _x.end));
                if (_x$2 === 97) {
                  const _x$3 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 1, _x.start, _x.end));
                  if (_x$3 === 115) {
                    const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 2, _x.start, _x.end));
                    if (_x$4 === 115) {
                      const _x$5 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 3, _x.start, _x.end));
                      if (_x$5 === 101) {
                        const _x$6 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 4, _x.start, _x.end));
                        if (_x$6 === 116) {
                          const _x$7 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 5, _x.start, _x.end));
                          if (_x$7 === 115) {
                            break _L$3;
                          } else {
                            break _L;
                          }
                        } else {
                          break _L;
                        }
                      } else {
                        break _L;
                      }
                    } else {
                      break _L;
                    }
                  } else {
                    break _L;
                  }
                } else {
                  break _L;
                }
              } else {
                if (moonbitlang$core$string$$String$char_length_eq(_x.str, 4, _x.start, _x.end)) {
                  const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 0, _x.start, _x.end));
                  if (_x$2 === 100) {
                    const _x$3 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 1, _x.start, _x.end));
                    if (_x$3 === 111) {
                      const _x$4 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 2, _x.start, _x.end));
                      if (_x$4 === 99) {
                        const _x$5 = moonbitlang$core$string$$String$unsafe_char_at(_x.str, moonbitlang$core$string$$String$offset_of_nth_char(_x.str, 3, _x.start, _x.end));
                        if (_x$5 === 115) {
                          const _x$6 = moonbitlang$core$array$$Array$op_as_view$16$(paths, 1, paths.length);
                          module_path = _x$6;
                          break _L$2;
                        } else {
                          break _L;
                        }
                      } else {
                        break _L;
                      }
                    } else {
                      break _L;
                    }
                  } else {
                    break _L;
                  }
                } else {
                  break _L;
                }
              }
            }
          }
        }
        return moonbitlang$mooncakes$main$$update_with$401$(moonbitlang$mooncakes$page$home$$load(), (_hole14) => new Model$Home(_hole14), (_hole16) => new Msg$GotHomeMsg(_hole16));
      }
      return { _0: Yoorkin$rabbit$45$tea$nav$$load$361$(Yoorkin$rabbit$45$tea$url$$Url$to_string(url)), _1: Model$Redirect };
    }
    const _bind = moonbitlang$core$array$$ArrayView$iter$16$(module_path);
    const _tmp = moonbitlang$core$builtin$$Iter$join((_p) => _bind((_p$2) => _p(moonbitlang$core$builtin$$Show$to_string$16$(_p$2))), "/");
    return moonbitlang$mooncakes$main$$update_with$400$(moonbitlang$mooncakes$page$docs$$load(_tmp, url.fragment), (_hole19) => new Model$Docs(_hole19), (_hole21) => new Msg$GotDocsMsg(_hole21));
  }
  return { _0: Yoorkin$rabbit$45$tea$cmd$$none$361$(), _1: Model$NotFound };
}
function moonbitlang$mooncakes$main$$update(msg, model) {
  _L: {
    switch (msg.$tag) {
      case 0: {
        const _GotHomeMsg = msg;
        const _msg = _GotHomeMsg._0;
        if (model.$tag === 0) {
          const _Home = model;
          const _model = _Home._0;
          return moonbitlang$mooncakes$main$$update_with$401$(moonbitlang$mooncakes$page$home$$update(_msg, _model), (_hole27) => new Model$Home(_hole27), (_hole29) => new Msg$GotHomeMsg(_hole29));
        } else {
          break _L;
        }
      }
      case 1: {
        const _GotDocsMsg = msg;
        const _msg$2 = _GotDocsMsg._0;
        if (model.$tag === 1) {
          const _Docs = model;
          const _model = _Docs._0;
          return moonbitlang$mooncakes$main$$update_with$400$(moonbitlang$mooncakes$page$docs$$update(_msg$2, _model), (_hole33) => new Model$Docs(_hole33), (_hole35) => new Msg$GotDocsMsg(_hole35));
        } else {
          break _L;
        }
      }
      case 2: {
        const _LinkClicked = msg;
        const _request = _LinkClicked._0;
        if (_request.$tag === 0) {
          const _Internal = _request;
          const _url = _Internal._0;
          return { _0: Yoorkin$rabbit$45$tea$nav$$push_url$361$(Yoorkin$rabbit$45$tea$url$$Url$to_string(_url)), _1: model };
        } else {
          const _External = _request;
          const _url = _External._0;
          return { _0: Yoorkin$rabbit$45$tea$nav$$load$361$(_url), _1: model };
        }
      }
      default: {
        const _UrlChanged = msg;
        const _url = _UrlChanged._0;
        return moonbitlang$mooncakes$main$$route(_url);
      }
    }
  }
  return { _0: Yoorkin$rabbit$45$tea$cmd$$none$361$(), _1: model };
}
function moonbitlang$mooncakes$main$$view(model) {
  switch (model.$tag) {
    case 0: {
      const _Home = model;
      const _model = _Home._0;
      return Yoorkin$rabbit$45$tea$html$$T$map$365$(moonbitlang$mooncakes$page$home$$view(_model), (_hole7) => new Msg$GotHomeMsg(_hole7));
    }
    case 1: {
      const _Docs = model;
      const _model$2 = _Docs._0;
      return Yoorkin$rabbit$45$tea$html$$T$map$364$(moonbitlang$mooncakes$page$docs$$view(_model$2), (_hole10) => new Msg$GotDocsMsg(_hole10));
    }
    case 2: {
      return moonbitlang$mooncakes$view$$not_found$361$();
    }
    default: {
      return moonbitlang$mooncakes$view$$loading$361$();
    }
  }
}
(() => {
  Yoorkin$rabbit$45$tea$$application$368$(moonbitlang$mooncakes$main$$route, moonbitlang$mooncakes$main$$update, moonbitlang$mooncakes$main$$view, (_hole1) => new Msg$UrlChanged(_hole1), (_hole3) => new Msg$LinkClicked(_hole3), Yoorkin$rabbit$45$tea$$application$46$mount$46$default$368$());
})();
